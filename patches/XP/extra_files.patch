diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.html b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.html
new file mode 100644
index 0000000000000..4a81cedbda7cb
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.html
@@ -0,0 +1,219 @@
+<style include="mwb-element-shared-style">
+  :host {
+    --row-height: 40px;
+    display: block;
+    user-select: none;
+    white-space: nowrap;
+  }
+
+  .row {
+    --row-padding-inline-start: calc(var(--node-depth) * 17px);
+    --row-icon-width: 20px;
+    align-items: center;
+    appearance: none;
+    background: transparent;
+    border: none;
+    box-sizing: border-box;
+    color: currentColor;
+    display: grid;
+    font-size: var(--mwb-primary-text-font-size);
+    grid-template-areas: 'arrow icon title';
+    grid-template-columns: var(--row-icon-width) var(--row-icon-width) auto;
+    height: var(--row-height);
+    line-height: var(--row-height);
+    padding-block-end: 0;
+    padding-block-start: 0;
+    padding-inline-start: var(--row-padding-inline-start);
+    text-align: start;
+    width: 100%;
+  }
+
+  :host-context([hover-visible]) .row:not([empty]):hover {
+    background-color: var(--mwb-list-item-hover-background-color);
+  }
+
+  :host-context(.focus-outline-visible) .row:focus,
+  :host-context(.focus-outline-visible) .row:focus:hover {
+    background-color: var(--mwb-list-item-selected-background-color);
+    outline: none;
+  }
+
+  .row:focus-visible:focus {
+    outline: none;
+  }
+
+  :host-context([hover-visible]) .row:not([empty]):active,
+  :host-context(.focus-outline-visible) .row:not([empty]):active {
+    background-color: var(--cr-active-background-color);
+  }
+
+  .arrow,
+  .icon,
+  .title {
+    /**
+     * Keep content-visibility on inner children of .row instead of on .row
+     * as the CSS property seems to have bugs with rendering elements outside
+     * of .row when dragging elements around.
+     */
+    content-visibility: auto;
+  }
+
+  #arrow {
+    grid-area: arrow;
+    justify-self: center;
+  }
+
+  #arrowIcon {
+    --cr-icon-button-hover-background-color: transparent;
+    --cr-icon-button-active-background-color: transparent;
+    margin: 0;
+    transform: rotate(-90deg);
+    transition: transform 100ms cubic-bezier(0.4, 0, 0.2, 1);
+  }
+
+  #arrowIcon[open] {
+    transform: rotate(0);
+  }
+
+  #arrowIcon:focus,
+  #arrowIcon:hover {
+    background: none;
+    box-shadow: none;
+  }
+
+  :host-context([dir='rtl']) #arrowIcon:not([open]) {
+    transform: rotate(90deg);
+  }
+
+  .icon {
+    background-position: left center;
+    background-repeat: no-repeat;
+    grid-area: icon;
+    height: 16px;
+    justify-self: center;
+    width: 16px;
+  }
+
+  #folderIcon {
+    background-image: url(chrome://theme/IDR_FOLDER_CLOSED);
+  }
+
+  /**
+   * Folder icons are OS-specific. On Mac, there is a separate folder icon
+   * for dark mode; on non-Mac, there is a separate folder icon for open states
+   * and the icon for that is slightly larger. This is mirroring the icons
+   * used in chrome://bookmarks.
+   */
+<if expr="is_macosx">
+  @media (prefers-color-scheme: dark) {
+    #folderIcon {
+      background-image: url(chrome://theme/IDR_FOLDER_CLOSED_WHITE);
+    }
+  }
+</if>
+
+<if expr="not is_macosx">
+    #folderIcon {
+      height: 20px;
+      width: 20px;
+    }
+
+    #folderIcon[open] {
+      background-image: url(chrome://theme/IDR_FOLDER_OPEN);
+    }
+</if>
+
+  .title {
+    grid-area: title;
+    overflow: hidden;
+    padding: 0 10px;
+    text-overflow: ellipsis;
+  }
+
+  .bookmark {
+    color: currentColor;
+    text-decoration: none;
+  }
+
+  #children {
+    --node-depth: var(--child-depth);
+    min-height: calc(var(--child-count, 0) * var(--row-height));
+  }
+
+  [drop-position='into'] {
+    background: var(--mwb-list-item-selected-background-color);
+  }
+
+  [drop-position='above'],
+  [drop-position='below'] {
+    position: relative;
+  }
+
+  [drop-position='above']::after,
+  [drop-position='below']::after {
+    background: var(--google-blue-500);
+    content: '';
+    display: block;
+    height: 2px;
+    left: calc(
+        var(--row-padding-inline-start) + var(--row-icon-width));
+    position: absolute;
+    right: 0;
+    top: -1px;
+  }
+
+  [drop-position='below']::after {
+    bottom: -1px;
+    top: auto;
+  }
+</style>
+<div id="container" role="treeitem" aria-expanded="[[getAriaExpanded_(open_)]]">
+  <button id="folder" class="row"
+      title="[[folder.title]]"
+      draggable="true"
+      data-bookmark="[[folder]]"
+      empty$="[[!folder.children.length]]"
+      on-click="onFolderClick_" on-contextmenu="onFolderContextMenu_">
+    <div id="arrow" hidden$="[[!folder.children.length]]">
+      <cr-icon-button
+          id="arrowIcon"
+          iron-icon="cr:arrow-drop-down"
+          open$="[[open_]]"
+          tabindex="-1">
+      </cr-icon-button>
+    </div>
+    <div id="folderIcon" class="icon" open$="[[open_]]"></div>
+    <div class="title">[[folder.title]]</div>
+  </button>
+
+  <template is="dom-if" if="[[open_]]" restamp>
+    <div id="children" role="group">
+      <template is="dom-repeat" items="[[folder.children]]" initial-count="20">
+        <template is="dom-if" if="[[!item.url]]" restamp>
+          <bookmark-folder
+              id="bookmark-[[item.id]]"
+              folder="[[item]]"
+              depth="[[childDepth_]]"
+              open-folders="[[openFolders]]">
+          </bookmark-folder>
+        </template>
+
+        <template is="dom-if" if="[[item.url]]" restamp>
+          <button
+              id="bookmark-[[item.id]]" role="treeitem" class="bookmark row"
+              title="[[item.title]]"
+              draggable="true" data-bookmark="[[item]]"
+              on-click="onBookmarkClick_"
+              on-auxclick="onBookmarkAuxClick_"
+              on-contextmenu="onBookmarkContextMenu_">
+            <div
+                class="icon"
+                style="background-image: [[getBookmarkIcon_(item.url)]]">
+            </div>
+            <div class="title">[[item.title]]</div>
+          </button>
+        </template>
+      </template>
+    </div>
+  </template>
+</div>
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.ts b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.ts
new file mode 100644
index 0000000000000..34ace377a0ebc
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.ts
@@ -0,0 +1,274 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://resources/cr_elements/cr_icon_button/cr_icon_button.js';
+import 'chrome://resources/cr_elements/icons.html.js';
+import 'chrome://resources/cr_elements/cr_shared_vars.css.js';
+import 'chrome://resources/cr_elements/mwb_element_shared_style.css.js';
+
+import {getFaviconForPageURL} from 'chrome://resources/js/icon.js';
+import {DomRepeatEvent, PolymerElement} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+
+import {getTemplate} from './bookmark_folder.html.js';
+import {ActionSource} from './bookmarks.mojom-webui.js';
+import {BookmarksApiProxy, BookmarksApiProxyImpl} from './bookmarks_api_proxy.js';
+
+export interface BookmarkFolderElement {
+  $: {
+    children: HTMLElement,
+  };
+}
+
+// Event name for open state of a folder being changed.
+export const FOLDER_OPEN_CHANGED_EVENT = 'bookmark-folder-open-changed';
+
+export class BookmarkFolderElement extends PolymerElement {
+  static get is() {
+    return 'bookmark-folder';
+  }
+
+  static get template() {
+    return getTemplate();
+  }
+
+  static get properties() {
+    return {
+      childDepth_: {
+        type: Number,
+        value: 1,
+      },
+
+      depth: {
+        type: Number,
+        observer: 'onDepthChanged_',
+        value: 0,
+      },
+
+      folder: Object,
+
+      open_: {
+        type: Boolean,
+        value: false,
+        computed:
+            'computeIsOpen_(openFolders, folder.id, folder.children.length)',
+      },
+
+      openFolders: Array,
+    };
+  }
+
+  private childDepth_: number;
+  depth: number;
+  folder: chrome.bookmarks.BookmarkTreeNode;
+  private open_: boolean;
+  openFolders: string[];
+  private bookmarksApi_: BookmarksApiProxy =
+      BookmarksApiProxyImpl.getInstance();
+
+  static get observers() {
+    return [
+      'onChildrenLengthChanged_(folder.children.length)',
+    ];
+  }
+
+  private getAriaExpanded_(): string|undefined {
+    if (!this.folder.children || this.folder.children.length === 0) {
+      // Remove the attribute for empty folders that cannot be expanded.
+      return undefined;
+    }
+
+    return this.open_ ? 'true' : 'false';
+  }
+
+  private onBookmarkAuxClick_(
+      event: DomRepeatEvent<chrome.bookmarks.BookmarkTreeNode, MouseEvent>) {
+    if (event.button !== 1) {
+      // Not a middle click.
+      return;
+    }
+
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.openBookmark(
+        event.model.item.id!, this.depth, {
+          middleButton: true,
+          altKey: event.altKey,
+          ctrlKey: event.ctrlKey,
+          metaKey: event.metaKey,
+          shiftKey: event.shiftKey,
+        },
+        ActionSource.kBookmark);
+  }
+
+  private onBookmarkClick_(
+      event: DomRepeatEvent<chrome.bookmarks.BookmarkTreeNode, MouseEvent>) {
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.openBookmark(
+        event.model.item.id!, this.depth, {
+          middleButton: false,
+          altKey: event.altKey,
+          ctrlKey: event.ctrlKey,
+          metaKey: event.metaKey,
+          shiftKey: event.shiftKey,
+        },
+        ActionSource.kBookmark);
+  }
+
+  private onBookmarkContextMenu_(
+      event: DomRepeatEvent<chrome.bookmarks.BookmarkTreeNode, MouseEvent>) {
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.showContextMenu(
+        event.model.item.id, event.clientX, event.clientY,
+        ActionSource.kBookmark);
+  }
+
+  private onFolderContextMenu_(event: MouseEvent) {
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.showContextMenu(
+        this.folder.id, event.clientX, event.clientY, ActionSource.kBookmark);
+  }
+
+  private getBookmarkIcon_(url: string): string {
+    return getFaviconForPageURL(url, false);
+  }
+
+  private onChildrenLengthChanged_() {
+    if (this.folder.children) {
+      this.style.setProperty(
+          '--child-count', this.folder.children!.length.toString());
+    } else {
+      this.style.setProperty('--child-count', '0');
+    }
+  }
+
+  private onDepthChanged_() {
+    this.childDepth_ = this.depth + 1;
+    this.style.setProperty('--node-depth', `${this.depth}`);
+    this.style.setProperty('--child-depth', `${this.childDepth_}`);
+  }
+
+  private onFolderClick_(event: Event) {
+    event.preventDefault();
+    event.stopPropagation();
+
+    if (!this.folder.children || this.folder.children.length === 0) {
+      // No reason to open if there are no children to show.
+      return;
+    }
+
+    this.dispatchEvent(new CustomEvent(FOLDER_OPEN_CHANGED_EVENT, {
+      bubbles: true,
+      composed: true,
+      detail: {
+        id: this.folder.id,
+        open: !this.open_,
+      },
+    }));
+
+    chrome.metricsPrivate.recordUserAction(
+        this.open_ ? 'SidePanel.Bookmarks.FolderOpen' :
+                     'SidePanel.Bookmarks.FolderClose');
+  }
+
+  private computeIsOpen_() {
+    return Boolean(this.openFolders) &&
+        this.openFolders.includes(this.folder.id) && this.folder.children &&
+        this.folder.children.length > 0;
+  }
+
+  private getFocusableRows_(): HTMLElement[] {
+    return Array.from(
+        this.shadowRoot!.querySelectorAll('.row, bookmark-folder'));
+  }
+
+  getFocusableElement(path: chrome.bookmarks.BookmarkTreeNode[]): (HTMLElement|
+                                                                   null) {
+    const currentNode = path.shift();
+    if (currentNode) {
+      const currentNodeId = currentNode.id;
+      const currentNodeElement =
+          this.shadowRoot!.querySelector(`#bookmark-${currentNodeId}`) as (
+              HTMLElement | null);
+      if (currentNodeElement &&
+          currentNodeElement.classList.contains('bookmark')) {
+        // Found a bookmark item.
+        return currentNodeElement;
+      }
+
+      if (currentNodeElement &&
+          currentNodeElement instanceof BookmarkFolderElement) {
+        // Bookmark item may be a grandchild or be deeper. Iterate through
+        // child BookmarkFolderElements until the bookmark item is found.
+        const nestedElement = currentNodeElement.getFocusableElement(path);
+        if (nestedElement) {
+          return nestedElement;
+        }
+      }
+    }
+
+    // If all else fails, return the focusable folder row.
+    return this.shadowRoot!.querySelector('#folder');
+  }
+
+  moveFocus(delta: -1|1): boolean {
+    const currentFocus = this.shadowRoot!.activeElement;
+    if (currentFocus instanceof BookmarkFolderElement &&
+        currentFocus.moveFocus(delta)) {
+      // If focus is already inside a nested folder, delegate the focus to the
+      // nested folder and return early if successful.
+      return true;
+    }
+
+    let moveFocusTo = null;
+    const focusableRows = this.getFocusableRows_();
+    if (currentFocus) {
+      // If focus is in this folder, move focus to the next or previous
+      // focusable row.
+      const currentFocusIndex =
+          focusableRows.indexOf(currentFocus as HTMLElement);
+      moveFocusTo = focusableRows[currentFocusIndex + delta];
+    } else {
+      // If focus is not in this folder yet, move focus to either end.
+      moveFocusTo = delta === 1 ? focusableRows[0] :
+                                  focusableRows[focusableRows.length - 1];
+    }
+
+    if (moveFocusTo instanceof BookmarkFolderElement) {
+      return moveFocusTo.moveFocus(delta);
+    } else if (moveFocusTo) {
+      moveFocusTo.focus();
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
+
+declare global {
+  interface HTMLElementTagNameMap {
+    'bookmark-folder': BookmarkFolderElement;
+  }
+}
+
+customElements.define(BookmarkFolderElement.is, BookmarkFolderElement);
+
+interface DraggableElement extends HTMLElement {
+  dataBookmark: chrome.bookmarks.BookmarkTreeNode;
+}
+
+export function getBookmarkFromElement(element: HTMLElement):
+    chrome.bookmarks.BookmarkTreeNode {
+  return (element as DraggableElement).dataBookmark;
+}
+
+export function isValidDropTarget(element: HTMLElement) {
+  return element.id === 'folder' || element.classList.contains('bookmark');
+}
+
+export function isBookmarkFolderElement(element: HTMLElement): boolean {
+  return element.id === 'folder';
+}
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks.html b/chrome/browser/resources/side_panel/bookmarks/bookmarks.html
new file mode 100644
index 0000000000000..c6128dc9d8e8b
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks.html
@@ -0,0 +1,35 @@
+<!doctype html>
+<html dir="$i18n{textdirection}" lang="$i18n{language}">
+<head>
+  <meta charset="utf-8">
+  <title>$i18n{bookmarksTabTitle}</title>
+  <meta name="color-scheme" content="light dark">
+  <link rel="stylesheet" href="chrome://resources/css/text_defaults_md.css">
+  <link rel="stylesheet" href="chrome://resources/css/md_colors.css">
+  <style>
+    html,
+    body {
+      height: 100%;
+      margin: 0;
+      padding: 0;
+      width: 100%;
+    }
+
+    body {
+      background: white;
+      overflow-x: hidden;
+      overflow-y: auto;
+    }
+
+    @media (prefers-color-scheme: dark) {
+      body {
+        background: var(--google-grey-900);
+      }
+    }
+  </style>
+</head>
+<body>
+  <bookmarks-list></bookmarks-list>
+  <script type="module" src="bookmarks_list.js"></script>
+</body>
+</html>
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks_drag_manager.ts b/chrome/browser/resources/side_panel/bookmarks/bookmarks_drag_manager.ts
new file mode 100644
index 0000000000000..8131a048c8887
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks_drag_manager.ts
@@ -0,0 +1,270 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import '../strings.m.js';
+
+import {EventTracker} from 'chrome://resources/js/event_tracker.js';
+import {loadTimeData} from 'chrome://resources/js/load_time_data.js';
+
+import {getBookmarkFromElement, isBookmarkFolderElement, isValidDropTarget} from './bookmark_folder.js';
+
+export const DROP_POSITION_ATTR = 'drop-position';
+
+const ROOT_FOLDER_ID = '0';
+
+// Ms to wait during a dragover to open closed folder.
+let folderOpenerTimeoutDelay = 1000;
+export function overrideFolderOpenerTimeoutDelay(ms: number) {
+  folderOpenerTimeoutDelay = ms;
+}
+
+export enum DropPosition {
+  ABOVE = 'above',
+  INTO = 'into',
+  BELOW = 'below',
+}
+
+interface BookmarksDragDelegate extends HTMLElement {
+  getAscendants(bookmarkId: string): string[];
+  getIndex(bookmark: chrome.bookmarks.BookmarkTreeNode): number;
+  isFolderOpen(bookmark: chrome.bookmarks.BookmarkTreeNode): boolean;
+  onFinishDrop(bookmarks: chrome.bookmarks.BookmarkTreeNode[]): void;
+  openFolder(folderId: string): void;
+}
+
+class DragSession {
+  private delegate_: BookmarksDragDelegate;
+  private dragData_: chrome.bookmarkManagerPrivate.DragData;
+  private lastDragOverElement_: HTMLElement|null = null;
+  private lastPointerWasTouch_ = false;
+  private folderOpenerTimeout_: number|null = null;
+
+  constructor(
+      delegate: BookmarksDragDelegate,
+      dragData: chrome.bookmarkManagerPrivate.DragData) {
+    this.delegate_ = delegate;
+    this.dragData_ = dragData;
+  }
+
+  start(e: DragEvent) {
+    chrome.bookmarkManagerPrivate.startDrag(
+        this.dragData_.elements!.map(bookmark => bookmark.id), 0,
+        this.lastPointerWasTouch_, e.clientX, e.clientY);
+  }
+
+  update(e: DragEvent) {
+    const dragOverElement = e.composedPath().find(target => {
+      return target instanceof HTMLElement && isValidDropTarget(target);
+    }) as HTMLElement;
+    if (!dragOverElement) {
+      return;
+    }
+
+    if (dragOverElement !== this.lastDragOverElement_) {
+      this.resetState_();
+    }
+
+    const dragOverBookmark = getBookmarkFromElement(dragOverElement);
+    const ascendants = this.delegate_.getAscendants(dragOverBookmark.id);
+    const isInvalidDragOverTarget = dragOverBookmark.unmodifiable ||
+        this.dragData_.elements &&
+            this.dragData_.elements.some(
+                element => ascendants.indexOf(element.id) !== -1);
+    if (isInvalidDragOverTarget) {
+      this.lastDragOverElement_ = null;
+      return;
+    }
+
+    const isDraggingOverFolder = isBookmarkFolderElement(dragOverElement);
+    const dragOverElRect = dragOverElement.getBoundingClientRect();
+    const dragOverYRatio =
+        (e.clientY - dragOverElRect.top) / dragOverElRect.height;
+
+    let dropPosition;
+    if (isDraggingOverFolder) {
+      const folderIsOpen = this.delegate_.isFolderOpen(dragOverBookmark);
+      if (dragOverBookmark.parentId === ROOT_FOLDER_ID) {
+        // Cannot drag above or below children of root folder.
+        dropPosition = DropPosition.INTO;
+      } else if (dragOverYRatio <= .25) {
+        dropPosition = DropPosition.ABOVE;
+      } else if (dragOverYRatio <= .75) {
+        dropPosition = DropPosition.INTO;
+      } else if (folderIsOpen) {
+        // If a folder is open, its child bookmarks appear immediately below it
+        // so it should not be possible to drop a bookmark right below an open
+        // folder.
+        dropPosition = DropPosition.INTO;
+      } else {
+        dropPosition = DropPosition.BELOW;
+      }
+    } else {
+      dropPosition =
+          dragOverYRatio <= .5 ? DropPosition.ABOVE : DropPosition.BELOW;
+    }
+    dragOverElement.setAttribute(DROP_POSITION_ATTR, dropPosition);
+
+    if (dropPosition === DropPosition.INTO &&
+        !this.delegate_.isFolderOpen(dragOverBookmark) &&
+        !this.folderOpenerTimeout_) {
+      // Queue a timeout to auto-open the dragged over folder.
+      this.folderOpenerTimeout_ = setTimeout(() => {
+        this.delegate_.openFolder(dragOverBookmark.id);
+        this.folderOpenerTimeout_ = null;
+      }, folderOpenerTimeoutDelay);
+    }
+
+    this.lastDragOverElement_ = dragOverElement;
+  }
+
+  cancel() {
+    this.resetState_();
+    this.lastDragOverElement_ = null;
+  }
+
+  finish() {
+    if (!this.lastDragOverElement_) {
+      return;
+    }
+
+    const dropTargetBookmark =
+        getBookmarkFromElement(this.lastDragOverElement_);
+    const dropPosition = this.lastDragOverElement_.getAttribute(
+                             DROP_POSITION_ATTR) as DropPosition;
+    this.resetState_();
+
+    if (isBookmarkFolderElement(this.lastDragOverElement_) &&
+        dropPosition === DropPosition.INTO) {
+      chrome.bookmarkManagerPrivate
+          .drop(dropTargetBookmark.id, /* index */ undefined)
+          .then(() => this.delegate_.onFinishDrop(this.dragData_.elements!));
+      return;
+    }
+
+    let toIndex = this.delegate_.getIndex(dropTargetBookmark);
+    toIndex += dropPosition === DropPosition.BELOW ? 1 : 0;
+    chrome.bookmarkManagerPrivate.drop(dropTargetBookmark.parentId!, toIndex)
+        .then(() => this.delegate_.onFinishDrop(this.dragData_.elements!));
+  }
+
+  private resetState_() {
+    if (this.lastDragOverElement_) {
+      this.lastDragOverElement_.removeAttribute(DROP_POSITION_ATTR);
+    }
+
+    if (this.folderOpenerTimeout_ !== null) {
+      clearTimeout(this.folderOpenerTimeout_);
+      this.folderOpenerTimeout_ = null;
+    }
+  }
+
+  static createFromBookmark(
+      delegate: BookmarksDragDelegate,
+      bookmark: chrome.bookmarks.BookmarkTreeNode) {
+    return new DragSession(delegate, {
+      elements: [bookmark],
+      sameProfile: true,
+    });
+  }
+}
+
+export class BookmarksDragManager {
+  private delegate_: BookmarksDragDelegate;
+  private dragSession_: DragSession|null;
+  private eventTracker_: EventTracker = new EventTracker();
+
+  constructor(delegate: BookmarksDragDelegate) {
+    this.delegate_ = delegate;
+  }
+
+  startObserving() {
+    this.eventTracker_.add(
+        this.delegate_, 'dragstart',
+        (e: Event) => this.onDragStart_(e as DragEvent));
+    this.eventTracker_.add(
+        this.delegate_, 'dragover',
+        (e: Event) => this.onDragOver_(e as DragEvent));
+    this.eventTracker_.add(
+        this.delegate_, 'dragleave', () => this.onDragLeave_());
+    this.eventTracker_.add(this.delegate_, 'dragend', () => this.cancelDrag_());
+    this.eventTracker_.add(
+        this.delegate_, 'drop', (e: Event) => this.onDrop_(e as DragEvent));
+
+    if (loadTimeData.getBoolean('editBookmarksEnabled')) {
+      chrome.bookmarkManagerPrivate.onDragEnter.addListener(
+          (dragData: chrome.bookmarkManagerPrivate.DragData) =>
+              this.onChromeDragEnter_(dragData));
+      chrome.bookmarkManagerPrivate.onDragLeave.addListener(
+          () => this.cancelDrag_());
+    }
+  }
+
+  stopObserving() {
+    this.eventTracker_.removeAll();
+  }
+
+  private cancelDrag_() {
+    if (!this.dragSession_) {
+      return;
+    }
+    this.dragSession_.cancel();
+    this.dragSession_ = null;
+  }
+
+  private onChromeDragEnter_(dragData: chrome.bookmarkManagerPrivate.DragData) {
+    if (this.dragSession_) {
+      // A drag session is already in flight.
+      return;
+    }
+
+    this.dragSession_ = new DragSession(this.delegate_, dragData);
+  }
+
+  private onDragStart_(e: DragEvent) {
+    e.preventDefault();
+    if (!loadTimeData.getBoolean('editBookmarksEnabled')) {
+      return;
+    }
+
+    const bookmark = getBookmarkFromElement(
+        e.composedPath().find(target => (target as HTMLElement).draggable) as
+        HTMLElement);
+    if (!bookmark ||
+        /* Cannot drag root's children. */ bookmark.parentId ===
+            ROOT_FOLDER_ID ||
+        bookmark.unmodifiable) {
+      return;
+    }
+
+    this.dragSession_ =
+        DragSession.createFromBookmark(this.delegate_, bookmark);
+    this.dragSession_.start(e);
+  }
+
+  private onDragOver_(e: DragEvent) {
+    e.preventDefault();
+    if (!this.dragSession_) {
+      return;
+    }
+    this.dragSession_.update(e);
+  }
+
+  private onDragLeave_() {
+    if (!this.dragSession_) {
+      return;
+    }
+
+    this.dragSession_.cancel();
+  }
+
+  private onDrop_(e: DragEvent) {
+    if (!this.dragSession_) {
+      return;
+    }
+
+    e.preventDefault();
+    this.dragSession_.finish();
+    this.dragSession_ = null;
+  }
+}
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.html b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.html
new file mode 100644
index 0000000000000..74c2236c80cba
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.html
@@ -0,0 +1,20 @@
+<style include="cr-icons cr-hidden-style">
+  .divider {
+    border-top: 1px solid var(--cr-separator-color);
+    margin: 0 22px;
+  }
+</style>
+
+<div id="bookmarksContainer">
+  <template is="dom-repeat" items="[[folders_]]">
+    <bookmark-folder id="bookmark-[[item.id]]" folder="[[item]]"
+        open-folders="[[openFolders_]]">
+    </bookmark-folder>
+  </template>
+  <template is="dom-if" if="[[productInfos_.length]]" restamp>
+    <div class="divider"></div>
+    <shopping-list
+        id="shoppingList" product-infos="[[productInfos_]]">
+    </shopping-list>
+  </template>
+</div>
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.ts b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.ts
new file mode 100644
index 0000000000000..9a360fba45cdc
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.ts
@@ -0,0 +1,460 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import './commerce/shopping_list.js';
+
+import {ShoppingServiceApiProxy, ShoppingServiceApiProxyImpl} from '//bookmarks-side-panel.top-chrome/shared/commerce/shopping_service_api_proxy.js';
+import {BookmarkProductInfo} from '//bookmarks-side-panel.top-chrome/shared/shopping_list.mojom-webui.js';
+import {getInstance as getAnnouncerInstance} from 'chrome://resources/cr_elements/cr_a11y_announcer/cr_a11y_announcer.js';
+import {FocusOutlineManager} from 'chrome://resources/js/focus_outline_manager.js';
+import {loadTimeData} from 'chrome://resources/js/load_time_data.js';
+import {listenOnce} from 'chrome://resources/js/util.js';
+import {afterNextRender, PolymerElement} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+
+import {BookmarkFolderElement, FOLDER_OPEN_CHANGED_EVENT, getBookmarkFromElement, isBookmarkFolderElement} from './bookmark_folder.js';
+import {BookmarksApiProxy, BookmarksApiProxyImpl} from './bookmarks_api_proxy.js';
+import {BookmarksDragManager} from './bookmarks_drag_manager.js';
+import {getTemplate} from './bookmarks_list.html.js';
+
+// Key for localStorage object that refers to all the open folders.
+export const LOCAL_STORAGE_OPEN_FOLDERS_KEY = 'openFolders';
+
+function getBookmarkName(bookmark: chrome.bookmarks.BookmarkTreeNode): string {
+  return bookmark.title || bookmark.url || '';
+}
+
+export interface BookmarksListElement {
+  $: {
+    bookmarksContainer: HTMLElement,
+  };
+}
+
+export class BookmarksListElement extends PolymerElement {
+  static get is() {
+    return 'bookmarks-list';
+  }
+
+  static get template() {
+    return getTemplate();
+  }
+
+  static get properties() {
+    return {
+      folders_: {
+        type: Array,
+        value: () => [],
+      },
+
+      hoverVisible: {
+        reflectToAttribute: true,
+        value: false,
+      },
+
+      openFolders_: {
+        type: Array,
+        value: () => [],
+      },
+    };
+  }
+
+  private bookmarksApi_: BookmarksApiProxy =
+      BookmarksApiProxyImpl.getInstance();
+  private shoppingServiceApi_: ShoppingServiceApiProxy =
+      ShoppingServiceApiProxyImpl.getInstance();
+  private bookmarksDragManager_: BookmarksDragManager =
+      new BookmarksDragManager(this);
+  private focusOutlineManager_: FocusOutlineManager;
+  private listeners_ = new Map<string, Function>();
+  private folders_: chrome.bookmarks.BookmarkTreeNode[];
+  private productInfos_: BookmarkProductInfo[];
+  hoverVisible: boolean;
+  private openFolders_: string[];
+  private shoppingListenerIds_: number[] = [];
+
+  override ready() {
+    super.ready();
+    this.addEventListener(
+        FOLDER_OPEN_CHANGED_EVENT,
+        e => this.onFolderOpenChanged_(
+            e as CustomEvent<{id: string, open: boolean}>));
+    this.addEventListener('keydown', e => this.onKeydown_(e));
+    this.addEventListener('pointermove', () => this.hoverVisible = true);
+    this.addEventListener('pointerleave', () => this.hoverVisible = false);
+  }
+
+  override connectedCallback() {
+    super.connectedCallback();
+    this.setAttribute('role', 'tree');
+
+    listenOnce(this.$.bookmarksContainer, 'dom-change', () => {
+      setTimeout(() => this.bookmarksApi_.showUi(), 0);
+    });
+
+    this.focusOutlineManager_ = FocusOutlineManager.forDocument(document);
+    this.bookmarksApi_.getFolders().then(folders => {
+      this.folders_ = folders;
+
+      this.addListener_(
+          'onChildrenReordered',
+          (id: string, reorderedInfo: chrome.bookmarks.ReorderInfo) =>
+              this.onChildrenReordered_(id, reorderedInfo));
+      this.addListener_(
+          'onChanged',
+          (id: string, changedInfo: chrome.bookmarks.ChangeInfo) =>
+              this.onChanged_(id, changedInfo));
+      this.addListener_(
+          'onCreated',
+          (_id: string, node: chrome.bookmarks.BookmarkTreeNode) =>
+              this.onCreated_(node));
+      this.addListener_(
+          'onMoved',
+          (_id: string, movedInfo: chrome.bookmarks.MoveInfo) =>
+              this.onMoved_(movedInfo));
+      this.addListener_('onRemoved', (id: string) => this.onRemoved_(id));
+
+      try {
+        const openFolders = window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY];
+        this.openFolders_ = JSON.parse(openFolders);
+      } catch (error) {
+        this.openFolders_ = [this.folders_[0]!.id];
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] =
+            JSON.stringify(this.openFolders_);
+      }
+
+      this.bookmarksDragManager_.startObserving();
+    });
+
+    this.shoppingServiceApi_.getAllPriceTrackedBookmarkProductInfo().then(res => {
+      this.productInfos_ = res.productInfos;
+      if (this.productInfos_.length > 0) {
+        chrome.metricsPrivate.recordUserAction(
+            'Commerce.PriceTracking.SidePanel.TrackedProductsShown');
+      }
+    });
+    const callbackRouter = this.shoppingServiceApi_.getCallbackRouter();
+    this.shoppingListenerIds_.push(
+        callbackRouter.priceTrackedForBookmark.addListener(
+            (product: BookmarkProductInfo) =>
+                this.onBookmarkPriceTracked(product)),
+        callbackRouter.priceUntrackedForBookmark.addListener(
+            (product: BookmarkProductInfo) =>
+                this.onBookmarkPriceUntracked(product)),
+    );
+  }
+
+  override disconnectedCallback() {
+    for (const [eventName, callback] of this.listeners_.entries()) {
+      this.bookmarksApi_.callbackRouter[eventName]!.removeListener(callback);
+    }
+    this.bookmarksDragManager_.stopObserving();
+    this.shoppingListenerIds_.forEach(
+        id => this.shoppingServiceApi_.getCallbackRouter().removeListener(id));
+  }
+
+  /** BookmarksDragDelegate */
+  getAscendants(bookmarkId: string): string[] {
+    const path = this.findPathToId_(bookmarkId);
+    return path.map(bookmark => bookmark.id);
+  }
+
+  /** BookmarksDragDelegate */
+  getIndex(bookmark: chrome.bookmarks.BookmarkTreeNode): number {
+    const path = this.findPathToId_(bookmark.id);
+    const parent = path[path.length - 2];
+    if (!parent || !parent.children) {
+      return -1;
+    }
+    return parent.children.findIndex((child) => child.id === bookmark.id);
+  }
+
+  /** BookmarksDragDelegate */
+  isFolderOpen(bookmark: chrome.bookmarks.BookmarkTreeNode): boolean {
+    return this.openFolders_.some(id => bookmark.id === id);
+  }
+
+  /** BookmarksDragDelegate */
+  onFinishDrop(bookmarks: chrome.bookmarks.BookmarkTreeNode[]): void {
+    if (bookmarks.length === 0 || bookmarks[0]!.id === undefined) {
+      return;
+    }
+
+    this.focusBookmark_(bookmarks[0]!.id);
+    this.hoverVisible = false;
+
+    // Show the focus state immediately after dropping a bookmark to indicate
+    // where the bookmark was moved to, and remove the state immediately after
+    // the next mouse event.
+    this.focusOutlineManager_.visible = true;
+    document.addEventListener('mousedown', () => {
+      this.focusOutlineManager_.visible = false;
+    }, {once: true});
+  }
+
+  /** BookmarksDragDelegate */
+  openFolder(folderId: string) {
+    this.changeFolderOpenStatus_(folderId, true);
+  }
+
+  private addListener_(eventName: string, callback: Function): void {
+    this.bookmarksApi_.callbackRouter[eventName]!.addListener(callback);
+    this.listeners_.set(eventName, callback);
+  }
+
+  /**
+   * Finds the node within the nested array of folders and returns the path to
+   * the node in the tree.
+   */
+  private findPathToId_(id: string): chrome.bookmarks.BookmarkTreeNode[] {
+    const path: chrome.bookmarks.BookmarkTreeNode[] = [];
+
+    function findPathByIdInternal(
+        id: string, node: chrome.bookmarks.BookmarkTreeNode) {
+      if (node.id === id) {
+        path.push(node);
+        return true;
+      }
+
+      if (!node.children) {
+        return false;
+      }
+
+      path.push(node);
+      const foundInChildren =
+          node.children.some(child => findPathByIdInternal(id, child));
+      if (!foundInChildren) {
+        path.pop();
+      }
+
+      return foundInChildren;
+    }
+
+    this.folders_.some(folder => findPathByIdInternal(id, folder));
+    return path;
+  }
+
+  /**
+   * Reduces an array of nodes to a string to notify Polymer of changes to the
+   * nested array.
+   */
+  private getPathString_(path: chrome.bookmarks.BookmarkTreeNode[]): string {
+    return path.reduce((reducedString, pathItem, index) => {
+      if (index === 0) {
+        return `folders_.${this.folders_.indexOf(pathItem)}`;
+      }
+
+      const parent = path[index - 1];
+      return `${reducedString}.children.${parent!.children!.indexOf(pathItem)}`;
+    }, '');
+  }
+
+  private onChanged_(id: string, changedInfo: chrome.bookmarks.ChangeInfo) {
+    const path = this.findPathToId_(id);
+    Object.assign(path[path.length - 1], changedInfo);
+
+    const pathString = this.getPathString_(path);
+    Object.keys(changedInfo)
+        .forEach(key => this.notifyPath(`${pathString}.${key}`));
+  }
+
+  private onChildrenReordered_(
+      id: string, reorderedInfo: chrome.bookmarks.ReorderInfo) {
+    const path = this.findPathToId_(id);
+    const parent = path[path.length - 1];
+    const childById = parent!.children!.reduce((map, node) => {
+      map.set(node.id, node);
+      return map;
+    }, new Map());
+    parent!.children = reorderedInfo.childIds.map(id => childById.get(id));
+    const pathString = this.getPathString_(path);
+    this.notifyPath(`${pathString}.children`);
+  }
+
+  private onCreated_(node: chrome.bookmarks.BookmarkTreeNode) {
+    const pathToParent = this.findPathToId_(node.parentId as string);
+    const pathToParentString = this.getPathString_(pathToParent);
+    const parent = pathToParent[pathToParent.length - 1];
+    if (parent && !parent.children) {
+      // Newly created folders in this session may not have an array of
+      // children yet, so create an empty one.
+      parent.children = [];
+    }
+    this.splice(`${pathToParentString}.children`, node.index!, 0, node);
+    afterNextRender(this, () => {
+      this.focusBookmark_(node.id);
+      if (node.url) {
+        getAnnouncerInstance().announce(
+            loadTimeData.getStringF('bookmarkCreated', getBookmarkName(node)));
+      } else {
+        getAnnouncerInstance().announce(loadTimeData.getStringF(
+            'bookmarkFolderCreated', getBookmarkName(node)));
+      }
+    });
+  }
+
+  private changeFolderOpenStatus_(id: string, open: boolean) {
+    const alreadyOpenIndex = this.openFolders_.indexOf(id);
+    if (open && alreadyOpenIndex === -1) {
+      this.openFolders_.push(id);
+    } else if (!open) {
+      this.openFolders_.splice(alreadyOpenIndex, 1);
+    }
+
+    // Assign to a new array so that listeners are triggered.
+    this.openFolders_ = [...this.openFolders_];
+    window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] =
+        JSON.stringify(this.openFolders_);
+  }
+
+  private onFolderOpenChanged_(event: CustomEvent) {
+    const {id, open} = event.detail;
+    this.changeFolderOpenStatus_(id, open);
+  }
+
+  private onKeydown_(event: KeyboardEvent) {
+    if (['ArrowDown', 'ArrowUp'].includes(event.key)) {
+      this.handleArrowKeyNavigation_(event);
+      return;
+    }
+
+    if (!event.ctrlKey && !event.metaKey) {
+      return;
+    }
+    event.preventDefault();
+    const eventTarget = event.composedPath()[0] as HTMLElement;
+    const bookmarkData = getBookmarkFromElement(eventTarget);
+    if (!bookmarkData || !this.focusOutlineManager_.visible) {
+      return;
+    }
+
+    if (event.key === 'x') {
+      this.bookmarksApi_.cutBookmark(bookmarkData.id);
+    } else if (event.key === 'c') {
+      this.bookmarksApi_.copyBookmark(bookmarkData.id);
+      getAnnouncerInstance().announce(loadTimeData.getStringF(
+          'bookmarkCopied', getBookmarkName(bookmarkData)));
+    } else if (event.key === 'v') {
+      if (isBookmarkFolderElement(eventTarget)) {
+        this.bookmarksApi_.pasteToBookmark(bookmarkData.id);
+      } else {
+        this.bookmarksApi_.pasteToBookmark(
+            bookmarkData.parentId!, bookmarkData.id);
+      }
+    }
+  }
+
+  private handleArrowKeyNavigation_(event: KeyboardEvent) {
+    if (!(this.shadowRoot!.activeElement instanceof BookmarkFolderElement)) {
+      // If the key event did not happen within a BookmarkFolderElement, do
+      // not do anything.
+      return;
+    }
+
+    // Prevent arrow keys from causing scroll.
+    event.preventDefault();
+
+    const allFolderElements: BookmarkFolderElement[] =
+        Array.from(this.shadowRoot!.querySelectorAll('bookmark-folder'));
+
+    const delta = event.key === 'ArrowUp' ? -1 : 1;
+    let currentIndex =
+        allFolderElements.indexOf(this.shadowRoot!.activeElement);
+    let focusHasMoved = false;
+    while (!focusHasMoved) {
+      focusHasMoved = allFolderElements[currentIndex]!.moveFocus(delta);
+      currentIndex = (currentIndex + delta + allFolderElements.length) %
+          allFolderElements.length;
+    }
+  }
+
+  private onMoved_(movedInfo: chrome.bookmarks.MoveInfo) {
+    // Get old path and remove node from oldParent at oldIndex.
+    const oldParentPath = this.findPathToId_(movedInfo.oldParentId);
+    const oldParentPathString = this.getPathString_(oldParentPath);
+    const oldParent = oldParentPath[oldParentPath.length - 1];
+    const movedNode = oldParent!.children![movedInfo.oldIndex]!;
+    Object.assign(
+        movedNode, {index: movedInfo.index, parentId: movedInfo.parentId});
+    this.splice(`${oldParentPathString}.children`, movedInfo.oldIndex, 1);
+
+    // Get new parent's path and add the node to the new parent at index.
+    const newParentPath = this.findPathToId_(movedInfo.parentId);
+    const newParentPathString = this.getPathString_(newParentPath);
+    const newParent = newParentPath[newParentPath.length - 1];
+    if (newParent && !newParent.children) {
+      newParent.children = [];
+    }
+    this.splice(
+        `${newParentPathString}.children`, movedInfo.index, 0, movedNode);
+
+    if (movedInfo.oldParentId === movedInfo.parentId) {
+      getAnnouncerInstance().announce(loadTimeData.getStringF(
+          'bookmarkReordered', getBookmarkName(movedNode)));
+    } else {
+      getAnnouncerInstance().announce(loadTimeData.getStringF(
+          'bookmarkMoved', getBookmarkName(movedNode),
+          getBookmarkName(newParent!)));
+    }
+  }
+
+  private onRemoved_(id: string) {
+    const oldPath = this.findPathToId_(id);
+    const removedNode = oldPath.pop()!;
+    const oldParent = oldPath[oldPath.length - 1]!;
+    const oldParentPathString = this.getPathString_(oldPath);
+    this.splice(
+        `${oldParentPathString}.children`,
+        oldParent.children!.indexOf(removedNode), 1);
+
+    getAnnouncerInstance().announce(loadTimeData.getStringF(
+        'bookmarkDeleted', getBookmarkName(removedNode)));
+    this.productInfos_ =
+        this.productInfos_.filter(item => item.bookmarkId !== BigInt(id));
+  }
+
+  private focusBookmark_(id: string) {
+    const path = this.findPathToId_(id);
+    if (path.length === 0) {
+      // Could not find bookmark.
+      return;
+    }
+
+    const rootBookmark = path.shift();
+    const rootBookmarkElement =
+        this.shadowRoot!.querySelector(`#bookmark-${rootBookmark!.id}`) as
+        BookmarkFolderElement;
+    if (!rootBookmarkElement) {
+      return;
+    }
+
+    const bookmarkElement = rootBookmarkElement.getFocusableElement(path);
+    if (bookmarkElement) {
+      bookmarkElement.focus();
+    }
+  }
+
+  private onBookmarkPriceTracked(product: BookmarkProductInfo) {
+    // Here we only control the visibility of ShoppingListElement. The same
+    // signal will also be handled in ShoppingListElement to update shopping
+    // list.
+    if (this.productInfos_.length > 0) {
+      return;
+    }
+    this.push('productInfos_', product);
+    chrome.metricsPrivate.recordUserAction(
+        'Commerce.PriceTracking.SidePanel.TrackedProductsShown');
+  }
+
+  private onBookmarkPriceUntracked(product: BookmarkProductInfo) {
+    this.productInfos_ = this.productInfos_.filter(
+        item => item.bookmarkId !== product.bookmarkId);
+  }
+}
+
+declare global {
+  interface HTMLElementTagNameMap {
+    'bookmarks-list': BookmarksListElement;
+  }
+}
+
+customElements.define(BookmarksListElement.is, BookmarksListElement);
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmark_folder_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmark_folder_test.ts
new file mode 100644
index 0000000000000..b994bc25787d8
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmark_folder_test.ts
@@ -0,0 +1,353 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+
+import {BookmarkFolderElement, FOLDER_OPEN_CHANGED_EVENT, getBookmarkFromElement} from 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+import {ActionSource} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks.mojom-webui.js';
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {getFaviconForPageURL} from 'chrome://resources/js/icon.js';
+import {assertEquals, assertFalse, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {flushTasks, waitAfterNextRender} from 'chrome://webui-test/polymer_test_util.js';
+import {eventToPromise} from 'chrome://webui-test/test_util.js';
+
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarkFolderTest', () => {
+  let bookmarkFolder: BookmarkFolderElement;
+  let bookmarksApi: TestBookmarksApiProxy;
+
+  const folder: chrome.bookmarks.BookmarkTreeNode = {
+    id: '0',
+    title: 'Bookmarks bar',
+    children: [
+      {
+        id: '1',
+        title: 'Shopping list',
+        children: [
+          {
+            id: '4',
+            title: 'New shoes',
+            url: 'http://shoes/',
+          },
+        ],
+      },
+      {
+        id: '2',
+        title: 'Foo website',
+        url: 'http://foo/',
+      },
+      {
+        id: '3',
+        title: 'Bar website',
+        url: 'http://bar/',
+      },
+    ],
+  };
+
+  function getChildElements(): Array<HTMLElement|BookmarkFolderElement> {
+    return Array.from(bookmarkFolder.shadowRoot!.querySelectorAll(
+        'bookmark-folder, .bookmark'));
+  }
+
+  setup(async () => {
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    bookmarksApi = new TestBookmarksApiProxy();
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    bookmarkFolder = document.createElement('bookmark-folder');
+    bookmarkFolder.folder = folder;
+    bookmarkFolder.openFolders = ['0'];
+    document.body.appendChild(bookmarkFolder);
+
+    await flushTasks();
+  });
+
+  test('UpdatesDepthVariables', () => {
+    bookmarkFolder.depth = 3;
+    assertEquals('3', bookmarkFolder.style.getPropertyValue('--node-depth'));
+    assertEquals('4', bookmarkFolder.style.getPropertyValue('--child-depth'));
+  });
+
+  test('RendersChildren', () => {
+    const childElements = getChildElements();
+    assertEquals(3, childElements.length);
+
+    assertTrue(childElements[0] instanceof BookmarkFolderElement);
+    assertEquals(
+        folder.children![0],
+        (childElements[0]! as BookmarkFolderElement).folder);
+
+    assertEquals(
+        folder.children![1]!.title,
+        childElements[1]!.querySelector('.title')!.textContent);
+    assertEquals(
+        folder.children![2]!.title,
+        childElements[2]!.querySelector('.title')!.textContent);
+  });
+
+  test('UpdatesChildCountVariable', () => {
+    assertEquals('3', bookmarkFolder.style.getPropertyValue('--child-count'));
+
+    bookmarkFolder.folder = Object.assign({}, folder, {
+      children: [
+        {
+          id: '1',
+          title: 'Shopping list',
+          children: [],
+        },
+      ],
+    });
+    assertEquals('1', bookmarkFolder.style.getPropertyValue('--child-count'));
+
+    bookmarkFolder.folder = Object.assign({}, folder, {children: undefined});
+    assertEquals('0', bookmarkFolder.style.getPropertyValue('--child-count'));
+  });
+
+  test('ShowsFaviconForBookmarks', () => {
+    const fooWebsiteElement = getChildElements()[1]!;
+    assertEquals(
+        getFaviconForPageURL(folder.children![1]!.url!, false),
+        fooWebsiteElement.querySelector<HTMLElement>('.icon')!.style
+            .getPropertyValue('background-image'));
+  });
+
+  test('OpensAndClosesFolder', async () => {
+    const arrowIcon =
+        bookmarkFolder.shadowRoot!.querySelector<HTMLElement>('#arrowIcon')!;
+    assertTrue(arrowIcon.hasAttribute('open'));
+    assertEquals(3, getChildElements().length);
+
+    const eventPromise =
+        eventToPromise(FOLDER_OPEN_CHANGED_EVENT, document.body);
+    bookmarkFolder.shadowRoot!.querySelector<HTMLElement>('.row')!.click();
+    await eventPromise;
+
+    // Normally, the event listener for FOLDER_OPEN_CHANGED_EVENT will update
+    // the openFolders property.
+    bookmarkFolder.openFolders = [];
+    await waitAfterNextRender(bookmarkFolder);
+    assertFalse(arrowIcon.hasAttribute('open'));
+    assertEquals(0, getChildElements().length);
+  });
+
+  test('UpdatesOpenStateBasedOnOpenFolders', async () => {
+    bookmarkFolder.openFolders = [];
+    await waitAfterNextRender(bookmarkFolder);
+    getChildElements().forEach(
+        child => assertEquals('none', child.style.display));
+  });
+
+  test('OpensBookmark', async () => {
+    getChildElements()[1]!.click();
+    const [id, parentFolderDepth, , source] =
+        await bookmarksApi.whenCalled('openBookmark');
+    assertEquals(folder.children![1]!.id, id);
+    assertEquals(0, parentFolderDepth);
+    assertEquals(ActionSource.kBookmark, source);
+  });
+
+  test('OpensBookmarkContextMenu', async () => {
+    getChildElements()[1]!.dispatchEvent(new MouseEvent('contextmenu'));
+    const [id, , , source] = await bookmarksApi.whenCalled('showContextMenu');
+    assertEquals(folder.children![1]!.id, id);
+    assertEquals(ActionSource.kBookmark, source);
+  });
+
+  test('MovesFocusDown', () => {
+    // No focus yet, should focus folder row.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('.row'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus down one, should focus first child which is a folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('#children bookmark-folder'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    const bookmarkElements =
+        bookmarkFolder.shadowRoot!.querySelectorAll('#children .row');
+    // Move focus down one, should focus second child, the first bookmark.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(bookmarkElements[0], bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus down one, should focus second child, the second bookmark.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(bookmarkElements[1], bookmarkFolder.shadowRoot!.activeElement);
+
+    // No more room.
+    assertFalse(bookmarkFolder.moveFocus(1));
+  });
+
+  test('MovesFocusUp', () => {
+    // No focus yet, should focus last bookmark.
+    const bookmarkElements =
+        bookmarkFolder.shadowRoot!.querySelectorAll('#children .row');
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkElements[bookmarkElements.length - 1],
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus up one, should focus the first bookmark.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(bookmarkElements[0], bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus up one, should focus the child folder.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('#children bookmark-folder'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus up one, should focus the folder itself.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('.row'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // No more room.
+    assertFalse(bookmarkFolder.moveFocus(-1));
+  });
+
+  test('DoesNotFocusHiddenChildren', async () => {
+    bookmarkFolder.openFolders = [];
+    await waitAfterNextRender(bookmarkFolder);
+    assertTrue(bookmarkFolder.moveFocus(1));   // Moves focus to folder.
+    assertFalse(bookmarkFolder.moveFocus(1));  // No children to move focus to.
+  });
+
+  test('MovesFocusWithinNestedFolders', async () => {
+    bookmarkFolder.folder = {
+      id: '0',
+      title: 'Bookmarks bar',
+      children: [{
+        id: '1',
+        title: 'Nested folder 1',
+        children: [{
+          id: '2',
+          title: 'Nested folder 2',
+          children: [{
+            id: '3',
+            title: 'Nested folder 3',
+            children: [],
+          }],
+        }],
+      }],
+    };
+    bookmarkFolder.openFolders = ['0', '1', '2', '3'];
+    await waitAfterNextRender(bookmarkFolder);
+
+    // Move focus down 1, should focus root folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('.row'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus down 1, should focus first nested folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.folder.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement! as BookmarkFolderElement)
+            .folder);
+
+    // Move focus down 1, should focus grandchild folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.folder.children![0]!.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement!.shadowRoot!.activeElement! as
+         BookmarkFolderElement)
+            .folder);
+
+    // Move focus down 1, should focus great grandchild folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.folder.children![0]!.children![0]!.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement!.shadowRoot!.activeElement!
+             .shadowRoot!.activeElement! as BookmarkFolderElement)
+            .folder);
+
+    // Move focus up 1, should focus grandchild folder.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkFolder.folder.children![0]!.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement!.shadowRoot!.activeElement! as
+         BookmarkFolderElement)
+            .folder);
+  });
+
+  test('SendsClickModifiers', async () => {
+    const item = getChildElements()[1]!;
+    item.dispatchEvent(new MouseEvent('click'));
+    const [, , click] = await bookmarksApi.whenCalled('openBookmark');
+    assertFalse(
+        click.middleButton || click.altKey || click.ctrlKey || click.metaKey ||
+        click.shiftKey);
+    bookmarksApi.resetResolver('openBookmark');
+
+    // Middle mouse button click.
+    item.dispatchEvent(new MouseEvent('auxclick', {button: 1}));
+    const [, , auxClick] = await bookmarksApi.whenCalled('openBookmark');
+    assertTrue(auxClick.middleButton);
+    assertFalse(
+        auxClick.altKey || auxClick.ctrlKey || auxClick.metaKey ||
+        auxClick.shiftKey);
+    bookmarksApi.resetResolver('openBookmark');
+
+    // Non-middle mouse aux clicks.
+    item.dispatchEvent(new MouseEvent('auxclick', {button: 2}));
+    assertEquals(0, bookmarksApi.getCallCount('openBookmark'));
+
+    // Modifier keys.
+    item.dispatchEvent(new MouseEvent('click', {
+      altKey: true,
+      ctrlKey: true,
+      metaKey: true,
+      shiftKey: true,
+    }));
+    const [, , modifiedClick] = await bookmarksApi.whenCalled('openBookmark');
+    assertFalse(modifiedClick.middleButton);
+    assertTrue(
+        modifiedClick.altKey && modifiedClick.ctrlKey &&
+        modifiedClick.metaKey && modifiedClick.shiftKey);
+  });
+
+  test('GetsFocusableElements', async () => {
+    let focusableElement = bookmarkFolder.getFocusableElement([folder]);
+    assertTrue(!!focusableElement);
+    assertEquals('folder', focusableElement!.id);
+
+    const childBookmark = folder.children![1]!;
+    focusableElement = bookmarkFolder.getFocusableElement([childBookmark]);
+    assertTrue(!!focusableElement);
+    assertTrue(focusableElement!.classList.contains('bookmark'));
+    assertEquals(childBookmark, getBookmarkFromElement(focusableElement!));
+
+    const childFolder = folder.children![0]!;
+    focusableElement = bookmarkFolder.getFocusableElement([childFolder]);
+    assertTrue(!!focusableElement);
+    assertEquals('folder', focusableElement!.id);
+    assertEquals(childFolder.id, getBookmarkFromElement(focusableElement!).id);
+
+    // Grandchild bookmark is in a closed folder, so the focusable element
+    // should still be the child folder.
+    const grandchildBookmark = childFolder.children![0]!;
+    focusableElement =
+        bookmarkFolder.getFocusableElement([childFolder, grandchildBookmark]);
+    assertTrue(!!focusableElement);
+    assertEquals('folder', focusableElement!.id);
+    assertEquals(childFolder.id, getBookmarkFromElement(focusableElement!).id);
+
+    // Once the child folder is opened, the grandchild bookmark element should
+    // be focusable.
+    bookmarkFolder.openFolders = ['0', '1'];
+    await waitAfterNextRender(bookmarkFolder);
+    focusableElement =
+        bookmarkFolder.getFocusableElement([childFolder, grandchildBookmark]);
+    assertTrue(!!focusableElement);
+    assertTrue(focusableElement!.classList.contains('bookmark'));
+    assertEquals(grandchildBookmark, getBookmarkFromElement(focusableElement!));
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmarks_drag_manager_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_drag_manager_test.ts
new file mode 100644
index 0000000000000..6d7cb7204b67a
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_drag_manager_test.ts
@@ -0,0 +1,313 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {BookmarksDragManager, DROP_POSITION_ATTR, DropPosition, overrideFolderOpenerTimeoutDelay} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_drag_manager.js';
+import {BookmarksListElement, LOCAL_STORAGE_OPEN_FOLDERS_KEY} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+import {ShoppingListApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/shared/commerce/shopping_list_api_proxy.js';
+import {loadTimeData} from 'chrome://resources/js/load_time_data.js';
+import {assertDeepEquals, assertEquals, assertFalse, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {flushTasks} from 'chrome://webui-test/polymer_test_util.js';
+
+import {TestShoppingListApiProxy} from './commerce/test_shopping_list_api_proxy.js';
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarkDragManagerTest', () => {
+  let delegate: BookmarksListElement;
+
+  const folders: chrome.bookmarks.BookmarkTreeNode[] = [{
+    id: '1',
+    title: 'Bookmarks bar',
+    parentId: '0',
+    children: [
+      {
+        id: '2',
+        title: 'Google',
+        parentId: '1',
+        url: 'http://google.com',
+      },
+      {
+        id: '3',
+        title: 'Google Docs',
+        parentId: '1',
+        url: 'http://docs.google.com',
+      },
+      {
+        id: '4',
+        title: 'My folder',
+        parentId: '1',
+        children: [{
+          id: '5',
+          title: 'My folder\'s child',
+          url: 'http://google.com',
+          parentId: '4',
+        }],
+      },
+      {
+        id: '5',
+        title: 'Closed folder',
+        parentId: '1',
+        children: [{
+          id: '6',
+          title: 'Closed folder\'s child',
+          url: 'http://google.com',
+          parentId: '5',
+        }],
+      },
+    ],
+  }];
+
+  function getDraggableElements(): HTMLElement[] {
+    function getDraggableElementsInner(root: HTMLElement) {
+      const draggableElements: HTMLElement[] = [];
+      const children = root.shadowRoot!.querySelectorAll<HTMLElement>(
+          'bookmark-folder, .bookmark');
+      children.forEach(child => {
+        if (child.tagName === 'BOOKMARK-FOLDER') {
+          draggableElements.push(child.shadowRoot!.querySelector('#folder')!);
+          draggableElements.push(...getDraggableElementsInner(child));
+        } else {
+          draggableElements.push(child);
+        }
+      });
+      return draggableElements;
+    }
+
+    const rootFolder = delegate.shadowRoot!.querySelector('bookmark-folder')!;
+    return getDraggableElementsInner(rootFolder);
+  }
+
+  setup(async () => {
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    loadTimeData.overrideValues({
+      editBookmarksEnabled: true,
+    });
+
+    const bookmarksApi = new TestBookmarksApiProxy();
+    bookmarksApi.setFolders(JSON.parse(JSON.stringify(folders)));
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    const shoppingListApi = new TestShoppingListApiProxy();
+    ShoppingListApiProxyImpl.setInstance(shoppingListApi);
+
+    window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] =
+        JSON.stringify(['1', '4']);
+
+    delegate = new BookmarksListElement();
+    new BookmarksDragManager(delegate);
+    document.body.appendChild(delegate);
+
+    await flushTasks();
+  });
+
+  test('DragStartCallsAPI', () => {
+    let calledIds;
+    let calledIndex;
+    let calledX;
+    let calledY;
+    let calledTouch = false;
+    chrome.bookmarkManagerPrivate.startDrag =
+        (ids: string[], index: number, touch: boolean, x: number,
+         y: number) => {
+          calledIds = ids;
+          calledIndex = index;
+          calledTouch = touch;
+          calledX = x;
+          calledY = y;
+        };
+
+    const draggableBookmark = getDraggableElements()[0]!;
+    draggableBookmark.dispatchEvent(new DragEvent(
+        'dragstart',
+        {bubbles: true, composed: true, clientX: 100, clientY: 200}));
+
+    assertDeepEquals(['2'], calledIds);
+    assertEquals(0, calledIndex);
+    assertFalse(calledTouch);
+    assertEquals(100, calledX);
+    assertEquals(200, calledY);
+  });
+
+  test('DragOverUpdatesAttributes', () => {
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[0]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    function assertDropPosition(
+        dragOverElement: HTMLElement, yRatio: number,
+        dropPosition: DropPosition) {
+      const dragOverRect = dragOverElement.getBoundingClientRect();
+      dragOverElement.dispatchEvent(new DragEvent('dragover', {
+        bubbles: true,
+        composed: true,
+        clientX: dragOverRect.left,
+        clientY: dragOverRect.top + (dragOverRect.height * yRatio),
+      }));
+      assertEquals(
+          dropPosition, dragOverElement.getAttribute(DROP_POSITION_ATTR));
+    }
+
+    const dragOverBookmark = draggableElements[1]!;
+    assertDropPosition(dragOverBookmark, 0.2, DropPosition.ABOVE);
+    assertDropPosition(dragOverBookmark, 0.5, DropPosition.ABOVE);
+    assertDropPosition(dragOverBookmark, 0.8, DropPosition.BELOW);
+
+    const dragOverFolder = draggableElements[2]!;
+    assertDropPosition(dragOverFolder, 0.2, DropPosition.ABOVE);
+    assertDropPosition(dragOverFolder, 0.5, DropPosition.INTO);
+    delegate.isFolderOpen = () => false;
+    assertDropPosition(dragOverFolder, 0.8, DropPosition.BELOW);
+    delegate.isFolderOpen = () => true;
+    assertDropPosition(dragOverFolder, 0.8, DropPosition.INTO);
+  });
+
+  test('DragOverDescendant', async () => {
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    const draggableElements = getDraggableElements();
+    const draggedFolder = draggableElements[2]!;
+    draggedFolder.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    // Drag over self.
+    let dragOverRect = draggedFolder.getBoundingClientRect();
+    draggedFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top,
+    }));
+    assertEquals(null, draggedFolder.getAttribute(DROP_POSITION_ATTR));
+
+    const dragOverChild = draggableElements[3]!;
+    dragOverRect = dragOverChild.getBoundingClientRect();
+    dragOverChild.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top,
+    }));
+    assertEquals(null, dragOverChild.getAttribute(DROP_POSITION_ATTR));
+  });
+
+  test('DropsIntoFolder', () => {
+    let calledId;
+    let calledIndex;
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    chrome.bookmarkManagerPrivate.drop = (id, index) => {
+      calledId = id;
+      calledIndex = index;
+      return Promise.resolve();
+    };
+
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[0]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    const dropFolder = draggableElements[2]!;
+    const dragOverRect = dropFolder.getBoundingClientRect();
+    dropFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top + (dragOverRect.height * .5),
+    }));
+    dropFolder.dispatchEvent(
+        new DragEvent('drop', {bubbles: true, composed: true}));
+
+    assertEquals('4', calledId);
+    assertEquals(undefined, calledIndex);
+  });
+
+  test('DropsBookmarksToReorder', () => {
+    let calledId;
+    let calledIndex;
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    chrome.bookmarkManagerPrivate.drop = (id, index) => {
+      calledId = id;
+      calledIndex = index;
+      return Promise.resolve();
+    };
+
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[2]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    const dragAboveBookmark = draggableElements[0]!;
+    const dragAboveRect = dragAboveBookmark.getBoundingClientRect();
+    dragAboveBookmark.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragAboveRect.left,
+      clientY: dragAboveRect.top + (dragAboveRect.height * .1),
+    }));
+    dragAboveBookmark.dispatchEvent(
+        new DragEvent('drop', {bubbles: true, composed: true}));
+    assertEquals('1', calledId);
+    assertEquals(0, calledIndex);
+
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+    const dragBelowBookmark = draggableElements[1]!;
+    const dragBelowRect = dragBelowBookmark.getBoundingClientRect();
+    dragBelowBookmark.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragBelowRect.left,
+      clientY: dragBelowRect.top + (dragBelowRect.height * .9),
+    }));
+    dragBelowBookmark.dispatchEvent(
+        new DragEvent('drop', {bubbles: true, composed: true}));
+    assertEquals('1', calledId);
+    assertEquals(2, calledIndex);
+  });
+
+  test('DragOverFolderAutoOpens', async () => {
+    overrideFolderOpenerTimeoutDelay(0);
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[0]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    const folderNode = folders[0]!.children![3]!;
+    const dragOverFolder = draggableElements[4]!;
+    const dragOverRect = dragOverFolder.getBoundingClientRect();
+    dragOverFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top + (dragOverRect.height * .5),
+    }));
+    assertFalse(delegate.isFolderOpen(folderNode));
+
+    // Drag over a new bookmark before the timeout runs out to ensure the
+    // timeout is canceled.
+    const newDragOverBookmark = draggableElements[3]!;
+    const newDragOverBookmarkRect = newDragOverBookmark.getBoundingClientRect();
+    newDragOverBookmark.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: newDragOverBookmarkRect.left,
+      clientY:
+          newDragOverBookmarkRect.top + (newDragOverBookmarkRect.height * .5),
+    }));
+    await new Promise(resolve => setTimeout(resolve, 0));
+    assertFalse(delegate.isFolderOpen(folderNode));
+
+    // Drag back into closed folder and wait for the timeout to resolve.
+    dragOverFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top + (dragOverRect.height * .5),
+    }));
+    await new Promise(resolve => setTimeout(resolve, 0));
+    assertTrue(delegate.isFolderOpen(folderNode));
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_focus_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_focus_test.ts
new file mode 100644
index 0000000000000..3c4bc63a8accd
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_focus_test.ts
@@ -0,0 +1,172 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+
+import {BookmarkFolderElement} from 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {BookmarksListElement} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+import {ShoppingListApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/shared/commerce/shopping_list_api_proxy.js';
+import {FocusOutlineManager} from 'chrome://resources/js/focus_outline_manager.js';
+import {down, keyDownOn} from 'chrome://resources/polymer/v3_0/iron-test-helpers/mock-interactions.js';
+import {assertEquals, assertFalse, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {flushTasks} from 'chrome://webui-test/polymer_test_util.js';
+
+import {TestShoppingListApiProxy} from './commerce/test_shopping_list_api_proxy.js';
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarksListFocusTest', () => {
+  let bookmarksList: BookmarksListElement;
+  let bookmarksApi: TestBookmarksApiProxy;
+
+  const folders: chrome.bookmarks.BookmarkTreeNode[] = [
+    {
+      id: '0',
+      parentId: 'root',
+      title: 'Bookmarks bar',
+      children: [
+        {
+          id: '3',
+          parentId: '0',
+          title: 'Child bookmark',
+          url: 'http://child/bookmark/',
+        },
+        {
+          id: '4',
+          parentId: '0',
+          title: 'Child folder',
+          children: [
+            {
+              id: '5',
+              parentId: '4',
+              title: 'Nested bookmark',
+              url: 'http://nested/bookmark/',
+            },
+          ],
+        },
+      ],
+    },
+    {
+      id: '1',
+      parentId: 'root',
+      title: 'Other bookmarks',
+      children: [],
+    },
+    {
+      id: '2',
+      title: 'Mobile bookmarks',
+      children: [],
+    },
+  ];
+
+  function getFolderElements(root: HTMLElement):
+      NodeListOf<BookmarkFolderElement> {
+    return root.shadowRoot!.querySelectorAll('bookmark-folder');
+  }
+
+  function getBookmarkElements(root: HTMLElement): NodeListOf<HTMLElement> {
+    return root.shadowRoot!.querySelectorAll('.bookmark');
+  }
+
+  setup(async () => {
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    bookmarksApi = new TestBookmarksApiProxy();
+    bookmarksApi.setFolders(JSON.parse(JSON.stringify(folders)));
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    const shoppingListApi = new TestShoppingListApiProxy();
+    ShoppingListApiProxyImpl.setInstance(shoppingListApi);
+
+    bookmarksList = document.createElement('bookmarks-list');
+    document.body.appendChild(bookmarksList);
+    await flushTasks();
+  });
+
+  test('MovesFocusBetweenFolders', () => {
+    const folderElements = getFolderElements(bookmarksList);
+
+    function assertActiveElement(index: number) {
+      assertEquals(
+          folderElements[index], bookmarksList.shadowRoot!.activeElement);
+    }
+
+    // Move focus to the first folder.
+    folderElements[0]!.moveFocus(1);
+    assertActiveElement(0);
+
+    // One ArrowDown key should still keep focus in the first folder since the
+    // folder has children.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(0);
+
+    // Two ArrowsDown to eventually make it to the second folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(1);
+
+    // One ArrowsDown to eventually make it to the third folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(2);
+
+    // One ArrowsDown to loop back to the first folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(0);
+
+    // One ArrowUp to loop back to the last folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowUp');
+    assertActiveElement(2);
+
+    // One ArrowUp to loop back to the second folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowUp');
+    assertActiveElement(1);
+  });
+
+  test('CutsCopyPastesBookmark', async () => {
+    const folderElement = getFolderElements(bookmarksList)[0]!;
+    const bookmarkElement = getBookmarkElements(folderElement)[0]!;
+
+    // Hide focus states and focus.
+    FocusOutlineManager.forDocument(document).visible = false;
+    bookmarkElement.focus();
+    assertEquals(bookmarkElement, folderElement.shadowRoot!.activeElement);
+
+    // When focus is hidden, keyboard shortcuts should not be allowed.
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'x');
+    assertEquals(0, bookmarksApi.getCallCount('cutBookmark'));
+
+    // Show focus states, which should allow keyboard shortcuts.
+    FocusOutlineManager.forDocument(document).visible = true;
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'x');
+    const cutId = await bookmarksApi.whenCalled('cutBookmark');
+    assertEquals(1, bookmarksApi.getCallCount('cutBookmark'));
+    assertEquals('3', cutId);
+
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'c');
+    const copiedId = await bookmarksApi.whenCalled('copyBookmark');
+    assertEquals('3', copiedId);
+
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'v');
+    const [pastedId, pastedDestinationId] =
+        await bookmarksApi.whenCalled('pasteToBookmark');
+    assertEquals('0', pastedId);
+    assertEquals('3', pastedDestinationId);
+  });
+
+  test('ShowsFocusStateOnDrop', () => {
+    const focusOutlineManager = FocusOutlineManager.forDocument(document);
+
+    // Mousedown to hide focus state initially.
+    down(bookmarksList, {x: 0, y: 0});
+    assertFalse(focusOutlineManager.visible);
+
+    // Perform a drop and assert that focus state is visible.
+    bookmarksList.onFinishDrop([folders[0]!.children![0]!]);
+    assertTrue(focusOutlineManager.visible);
+
+    // Make sure on the next mouse event, the focus state gets rehidden.
+    down(bookmarksList, {x: 0, y: 0});
+    assertFalse(focusOutlineManager.visible);
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_test.ts
new file mode 100644
index 0000000000000..400ca60d35ed8
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_test.ts
@@ -0,0 +1,319 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+
+import {BookmarkFolderElement, FOLDER_OPEN_CHANGED_EVENT} from 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {BookmarksListElement, LOCAL_STORAGE_OPEN_FOLDERS_KEY} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+import {ShoppingListApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/shared/commerce/shopping_list_api_proxy.js';
+import {BookmarkProductInfo} from 'chrome://bookmarks-side-panel.top-chrome/shared/shopping_list.mojom-webui.js';
+import {flush} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+import {assertEquals, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {fakeMetricsPrivate, MetricsTracker} from 'chrome://webui-test/metrics_test_support.js';
+import {flushTasks} from 'chrome://webui-test/polymer_test_util.js';
+import {isVisible} from 'chrome://webui-test/test_util.js';
+
+import {TestShoppingListApiProxy} from './commerce/test_shopping_list_api_proxy.js';
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarksListTest', () => {
+  let bookmarksList: BookmarksListElement;
+  let bookmarksApi: TestBookmarksApiProxy;
+  let shoppingListApi: TestShoppingListApiProxy;
+  let metrics: MetricsTracker;
+
+  const folders: chrome.bookmarks.BookmarkTreeNode[] = [
+    {
+      id: '0',
+      parentId: 'root',
+      title: 'Bookmarks bar',
+      children: [
+        {
+          id: '3',
+          parentId: '0',
+          title: 'Child bookmark',
+          url: 'http://child/bookmark/',
+        },
+        {
+          id: '4',
+          parentId: '0',
+          title: 'Child folder',
+          children: [
+            {
+              id: '5',
+              parentId: '4',
+              title: 'Nested bookmark',
+              url: 'http://nested/bookmark/',
+            },
+          ],
+        },
+      ],
+    },
+    {
+      id: '1',
+      parentId: 'root',
+      title: 'Other bookmarks',
+      children: [],
+    },
+    {
+      id: '2',
+      title: 'Mobile bookmarks',
+      children: [],
+    },
+  ];
+
+  const products: BookmarkProductInfo[] = [{
+    bookmarkId: BigInt(3),
+    info: {
+      title: 'Product Foo',
+      clusterTitle: 'Product Cluster Foo',
+      domain: 'foo.com',
+      imageUrl: {url: 'https://foo.com/image'},
+      productUrl: {url: 'https://foo.com/product'},
+      currentPrice: '$12',
+      previousPrice: '$34',
+      clusterId: BigInt(12345),
+    },
+  }];
+
+  function getFolderElements(root: HTMLElement): BookmarkFolderElement[] {
+    return Array.from(root.shadowRoot!.querySelectorAll('bookmark-folder'));
+  }
+
+  function getBookmarkElements(root: HTMLElement): HTMLElement[] {
+    return Array.from(root.shadowRoot!.querySelectorAll('.bookmark'));
+  }
+
+  function checkShoppingListVisibility(
+      root: HTMLElement, visible: boolean): void {
+    const shoppingListElement = root.shadowRoot!.getElementById('shoppingList');
+    const dividerElement =
+        root.shadowRoot!.querySelector<HTMLElement>('.divider');
+
+    assertEquals(visible, isVisible(shoppingListElement));
+    assertEquals(visible, isVisible(dividerElement));
+  }
+
+  setup(async () => {
+    window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] = undefined;
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    metrics = fakeMetricsPrivate();
+
+    bookmarksApi = new TestBookmarksApiProxy();
+    bookmarksApi.setFolders(JSON.parse(JSON.stringify(folders)));
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    shoppingListApi = new TestShoppingListApiProxy();
+    shoppingListApi.setProducts(products);
+    ShoppingListApiProxyImpl.setInstance(shoppingListApi);
+
+    bookmarksList = document.createElement('bookmarks-list');
+    document.body.appendChild(bookmarksList);
+
+    await flushTasks();
+  });
+
+  test('GetsAndShowsFolders', () => {
+    assertEquals(1, bookmarksApi.getCallCount('getFolders'));
+    assertEquals(folders.length, getFolderElements(bookmarksList).length);
+  });
+
+  test('UpdatesChangedBookmarks', () => {
+    const rootFolderIndex = 0;
+    const bookmarkIndex = 0;
+
+    const changedBookmark = folders[rootFolderIndex]!.children![bookmarkIndex]!;
+    bookmarksApi.callbackRouter.onChanged.callListeners(changedBookmark.id, {
+      title: 'New title',
+      url: 'http://new/url',
+    });
+
+    const folderElement = getFolderElements(bookmarksList)[rootFolderIndex] as
+        BookmarkFolderElement;
+    const bookmarkElement = getBookmarkElements(folderElement)[bookmarkIndex]!;
+    assertEquals('New title', bookmarkElement.textContent);
+  });
+
+  test('UpdatesReorderedChildren', () => {
+    // Reverse the children of Bookmarks bar.
+    const children = folders[0]!.children!;
+    const reverseOrder = children.map(child => child.id).reverse();
+    bookmarksApi.callbackRouter.onChildrenReordered.callListeners(
+        folders[0]!.id, {childIds: reverseOrder});
+    flush();
+
+    const rootFolderElement = getFolderElements(bookmarksList)[0]!;
+    const childFolder = getFolderElements(rootFolderElement)[0]!;
+    const childBookmark = getBookmarkElements(rootFolderElement)[0]!;
+    assertTrue(
+        !!(childFolder.compareDocumentPosition(childBookmark) &
+           Node.DOCUMENT_POSITION_FOLLOWING));
+  });
+
+  test('AddsCreatedBookmark', async () => {
+    bookmarksApi.callbackRouter.onCreated.callListeners('999', {
+      id: '999',
+      title: 'New bookmark',
+      index: 0,
+      parentId: '4',
+      url: '//new/bookmark',
+    });
+    flush();
+
+    const rootFolderElement = getFolderElements(bookmarksList)[0]!;
+    const childFolder = getFolderElements(rootFolderElement)[0]!;
+    childFolder.shadowRoot!.querySelector<HTMLElement>(
+                               '.row')!.click();  // Open folder.
+    await flushTasks();
+    const childFolderBookmarks = getBookmarkElements(childFolder);
+    assertEquals(2, childFolderBookmarks.length);
+    assertEquals('New bookmark', childFolderBookmarks[0]!.textContent);
+  });
+
+  test('AddsCreatedBookmarkForNewFolder', () => {
+    // Create a new folder without a children array.
+    bookmarksApi.callbackRouter.onCreated.callListeners('1000', {
+      id: '1000',
+      title: 'New folder',
+      index: 0,
+      parentId: '0',
+    });
+    flush();
+
+    // Create a new bookmark within that folder.
+    bookmarksApi.callbackRouter.onCreated.callListeners('1001', {
+      id: '1001',
+      title: 'New bookmark in new folder',
+      index: 0,
+      parentId: '1000',
+      url: 'http://google.com',
+    });
+    flush();
+
+    const rootFolderElement = getFolderElements(bookmarksList)[0]!;
+    const newFolder = getFolderElements(rootFolderElement)[0]!;
+    assertEquals(1, newFolder.folder.children!.length);
+  });
+
+  test('MovesBookmarks', () => {
+    const movedBookmark = folders[0]!.children![1]!.children![0]!;
+    bookmarksApi.callbackRouter.onMoved.callListeners(movedBookmark.id, {
+      index: 0,
+      parentId: folders[0]!.id,                   // Moving to bookmarks bar.
+      oldParentId: folders[0]!.children![1]!.id,  // Moving from child folder.
+      oldIndex: 0,
+    });
+    flush();
+
+    const bookmarksBarFolder = getFolderElements(bookmarksList)[0]!;
+    const movedBookmarkElement = getBookmarkElements(bookmarksBarFolder)[0]!;
+    assertEquals('Nested bookmark', movedBookmarkElement.textContent);
+
+    const childFolder = getFolderElements(bookmarksBarFolder)[0]!;
+    const childFolderBookmarks = getBookmarkElements(childFolder);
+    assertEquals(0, childFolderBookmarks.length);
+  });
+
+  test('MovesBookmarksIntoNewFolder', () => {
+    // Create a new folder without a children array.
+    bookmarksApi.callbackRouter.onCreated.callListeners('1000', {
+      id: '1000',
+      title: 'New folder',
+      index: 0,
+      parentId: '0',
+    });
+    flush();
+
+    const movedBookmark = folders[0]!.children![1]!.children![0]!;
+    bookmarksApi.callbackRouter.onMoved.callListeners(movedBookmark.id, {
+      index: 0,
+      parentId: '1000',
+      oldParentId: folders[0]!.children![1]!.id,
+      oldIndex: 0,
+    });
+    flush();
+
+    const bookmarksBarFolder = getFolderElements(bookmarksList)[0]!;
+    const newFolder = getFolderElements(bookmarksBarFolder)[0]!;
+    assertEquals(1, newFolder.folder.children!.length);
+  });
+
+  test('DefaultsToFirstFolderBeingOpen', () => {
+    assertEquals(
+        JSON.stringify([folders[0]!.id]),
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY]);
+  });
+
+  test('UpdatesLocalStorageOnFolderOpenChanged', () => {
+    bookmarksList.dispatchEvent(new CustomEvent(FOLDER_OPEN_CHANGED_EVENT, {
+      bubbles: true,
+      composed: true,
+      detail: {
+        id: folders[0]!.id,
+        open: false,
+      },
+    }));
+    assertEquals(
+        JSON.stringify([]),
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY]);
+
+    bookmarksList.dispatchEvent(new CustomEvent(FOLDER_OPEN_CHANGED_EVENT, {
+      bubbles: true,
+      composed: true,
+      detail: {
+        id: '5001',
+        open: true,
+      },
+    }));
+    assertEquals(
+        JSON.stringify(['5001']),
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY]);
+  });
+
+  test('ShoppingListVisibility', async () => {
+    checkShoppingListVisibility(bookmarksList, true);
+    assertEquals(
+        1,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+
+    shoppingListApi.setProducts([]);
+    const newbookmarksList = document.createElement('bookmarks-list');
+    document.body.appendChild(newbookmarksList);
+
+    checkShoppingListVisibility(newbookmarksList, false);
+    assertEquals(
+        1,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+
+    shoppingListApi.getCallbackRouterRemote().priceTrackedForBookmark(
+        products[0]!);
+    await flushTasks();
+    checkShoppingListVisibility(newbookmarksList, true);
+    assertEquals(
+        2,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+
+    shoppingListApi.getCallbackRouterRemote().priceUntrackedForBookmark(
+        products[0]!);
+    await flushTasks();
+    checkShoppingListVisibility(newbookmarksList, false);
+    assertEquals(
+        2,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+  });
+
+  test('RemovesBookmarksInShoppingList', async () => {
+    checkShoppingListVisibility(bookmarksList, true);
+
+    bookmarksApi.callbackRouter.onRemoved.callListeners('4');
+    flush();
+    checkShoppingListVisibility(bookmarksList, true);
+
+    bookmarksApi.callbackRouter.onRemoved.callListeners('3');
+    flush();
+    checkShoppingListVisibility(bookmarksList, false);
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_focus_test.cc b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_focus_test.cc
new file mode 100644
index 0000000000000..deb0258397bf1
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_focus_test.cc
@@ -0,0 +1,13 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/common/webui_url_constants.h"
+#include "chrome/test/base/web_ui_mocha_browser_test.h"
+#include "content/public/test/browser_test.h"
+
+using SidePanelBookmarksFocusTest = WebUIMochaFocusTest;
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksFocusTest, List) {
+  set_test_loader_host(chrome::kChromeUIBookmarksSidePanelHost);
+  RunTest("side_panel/bookmarks/bookmarks_list_focus_test.js", "mocha.run()");
+}
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..2547e1d5e893b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,771 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  if (!collection_) {
+    return;
+  }
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (UNLIKELY(slow_down_mode_for_testing == SlowDownMode::kDelayEachTask)) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (UNLIKELY(slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask) &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..cee91dd4e059b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
\ No newline at end of file
diff --git a/media/audio/win/wavein_input_win.cc b/media/audio/win/wavein_input_win.cc
new file mode 100644
index 0000000000000..3c42508274554
--- /dev/null
+++ b/media/audio/win/wavein_input_win.cc
@@ -0,0 +1,332 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/win/wavein_input_win.h"
+
+#include "base/logging.h"
+#include "base/time/time.h"
+#include "media/audio/audio_device_description.h"
+#include "media/audio/audio_io.h"
+#include "media/audio/win/audio_manager_win.h"
+#include "media/audio/win/device_enumeration_win.h"
+#include "media/base/audio_bus.h"
+
+namespace media {
+
+// Our sound buffers are allocated once and kept in a linked list using the
+// the WAVEHDR::dwUser variable. The last buffer points to the first buffer.
+static WAVEHDR* GetNextBuffer(WAVEHDR* current) {
+  return reinterpret_cast<WAVEHDR*>(current->dwUser);
+}
+
+constexpr SampleFormat kSampleFormat = kSampleFormatS16;
+
+PCMWaveInAudioInputStream::PCMWaveInAudioInputStream(
+    AudioManagerWin* manager,
+    const AudioParameters& params,
+    int num_buffers,
+    const std::string& device_id)
+    : state_(kStateEmpty),
+      manager_(manager),
+      callback_(NULL),
+      num_buffers_(num_buffers),
+      channels_(params.channels()),
+      device_id_(device_id),
+      wavein_(NULL),
+      buffer_(NULL),
+      audio_bus_(media::AudioBus::Create(params)) {
+  DCHECK_GT(num_buffers_, 0);
+  format_.wFormatTag = WAVE_FORMAT_PCM;
+  format_.nChannels = params.channels() > 2 ? 2 : params.channels();
+  format_.nSamplesPerSec = params.sample_rate();
+  format_.wBitsPerSample = SampleFormatToBitsPerChannel(kSampleFormat);
+  format_.cbSize = 0;
+  format_.nBlockAlign = (format_.nChannels * format_.wBitsPerSample) / 8;
+  format_.nAvgBytesPerSec = format_.nBlockAlign * format_.nSamplesPerSec;
+  buffer_size_ = params.frames_per_buffer() * format_.nBlockAlign;
+  // If we don't have a packet size we use 100ms.
+  if (!buffer_size_)
+    buffer_size_ = format_.nAvgBytesPerSec / 10;
+  // The event is auto-reset.
+  stopped_event_.Set(::CreateEventW(NULL, FALSE, FALSE, NULL));
+}
+
+PCMWaveInAudioInputStream::~PCMWaveInAudioInputStream() {
+  DCHECK(NULL == wavein_);
+}
+
+AudioInputStream::OpenOutcome PCMWaveInAudioInputStream::Open() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateEmpty)
+    return AudioInputStream::OpenOutcome::kFailed;
+  if (num_buffers_ < 2 || num_buffers_ > 10)
+    return AudioInputStream::OpenOutcome::kFailed;
+
+  // Convert the stored device id string into an unsigned integer
+  // corresponding to the selected device.
+  UINT device_id = WAVE_MAPPER;
+  if (!GetDeviceId(&device_id)) {
+    return AudioInputStream::OpenOutcome::kFailed;
+  }
+
+  // Open the specified input device for recording.
+  MMRESULT result = MMSYSERR_NOERROR;
+  result = ::waveInOpen(&wavein_, device_id, &format_,
+                        reinterpret_cast<DWORD_PTR>(WaveCallback),
+                        reinterpret_cast<DWORD_PTR>(this),
+                        CALLBACK_FUNCTION);
+  if (result != MMSYSERR_NOERROR)
+    return AudioInputStream::OpenOutcome::kFailed;
+
+  SetupBuffers();
+  state_ = kStateReady;
+  return AudioInputStream::OpenOutcome::kSuccess;
+}
+
+void PCMWaveInAudioInputStream::SetupBuffers() {
+  WAVEHDR* last = NULL;
+  WAVEHDR* first = NULL;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    uint32_t sz = sizeof(WAVEHDR) + buffer_size_;
+    buffer_ =  reinterpret_cast<WAVEHDR*>(new char[sz]);
+    buffer_->lpData = reinterpret_cast<char*>(buffer_) + sizeof(WAVEHDR);
+    buffer_->dwBufferLength = buffer_size_;
+    buffer_->dwBytesRecorded = 0;
+    buffer_->dwUser = reinterpret_cast<DWORD_PTR>(last);
+    buffer_->dwFlags = WHDR_DONE;
+    buffer_->dwLoops = 0;
+    if (ix == 0)
+      first = buffer_;
+    last = buffer_;
+    ::waveInPrepareHeader(wavein_, buffer_, sizeof(WAVEHDR));
+  }
+  // Fix the first buffer to point to the last one.
+  first->dwUser = reinterpret_cast<DWORD_PTR>(last);
+}
+
+void PCMWaveInAudioInputStream::FreeBuffers() {
+  WAVEHDR* current = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    WAVEHDR* next = GetNextBuffer(current);
+    if (current->dwFlags & WHDR_PREPARED)
+      ::waveInUnprepareHeader(wavein_, current, sizeof(WAVEHDR));
+    delete[] reinterpret_cast<char*>(current);
+    current = next;
+  }
+  buffer_ = NULL;
+}
+
+void PCMWaveInAudioInputStream::Start(AudioInputCallback* callback) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateReady)
+    return;
+
+  DCHECK(!callback_);
+  callback_ = callback;
+  state_ = kStateRecording;
+
+  WAVEHDR* buffer = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    QueueNextPacket(buffer);
+    buffer = GetNextBuffer(buffer);
+  }
+  buffer = buffer_;
+
+  MMRESULT result = ::waveInStart(wavein_);
+  if (result != MMSYSERR_NOERROR) {
+    HandleError(result);
+    state_ = kStateReady;
+    callback_ = NULL;
+  }
+}
+
+// Stopping is tricky. First, no buffer should be locked by the audio driver
+// or else the waveInReset() will deadlock and secondly, the callback should
+// not be inside the AudioInputCallback's OnData because waveInReset()
+// forcefully kills the callback thread.
+void PCMWaveInAudioInputStream::Stop() {
+  DVLOG(1) << "PCMWaveInAudioInputStream::Stop()";
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateRecording)
+    return;
+
+  bool already_stopped = false;
+  {
+    // Tell the callback that we're stopping.
+    // As a result, |stopped_event_| will be signaled in callback method.
+    base::AutoLock auto_lock(lock_);
+    already_stopped = (callback_ == NULL);
+    callback_ = NULL;
+  }
+
+  if (already_stopped)
+    return;
+
+  // Wait for the callback to finish, it will signal us when ready to be reset.
+  DWORD wait = ::WaitForSingleObject(stopped_event_.Get(), INFINITE);
+  DCHECK_EQ(wait, WAIT_OBJECT_0);
+
+  // Stop input and reset the current position to zero for |wavein_|.
+  // All pending buffers are marked as done and returned to the application.
+  MMRESULT res = ::waveInReset(wavein_);
+  DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+
+  state_ = kStateReady;
+}
+
+void PCMWaveInAudioInputStream::Close() {
+  DVLOG(1) << "PCMWaveInAudioInputStream::Close()";
+  DCHECK(thread_checker_.CalledOnValidThread());
+
+  // We should not call Close() while recording. Catch it with DCHECK and
+  // implement auto-stop just in case.
+  DCHECK_NE(state_, kStateRecording);
+  Stop();
+
+  if (wavein_) {
+    FreeBuffers();
+
+    // waveInClose() generates a WIM_CLOSE callback.  In case Start() was never
+    // called, force a reset to ensure close succeeds.
+    MMRESULT res = ::waveInReset(wavein_);
+    DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+    res = ::waveInClose(wavein_);
+    DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+    state_ = kStateClosed;
+    wavein_ = NULL;
+  }
+
+  // Tell the audio manager that we have been released. This can result in
+  // the manager destroying us in-place so this needs to be the last thing
+  // we do on this function.
+  manager_->ReleaseInputStream(this);
+}
+
+double PCMWaveInAudioInputStream::GetMaxVolume() {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  return 0.0;
+}
+
+void PCMWaveInAudioInputStream::SetVolume(double volume) {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+}
+
+double PCMWaveInAudioInputStream::GetVolume() {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  return 0.0;
+}
+
+bool PCMWaveInAudioInputStream::SetAutomaticGainControl(bool enabled) {
+  // TODO(henrika): Add AGC support when volume control has been added.
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool PCMWaveInAudioInputStream::GetAutomaticGainControl() {
+  // TODO(henrika): Add AGC support when volume control has been added.
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool PCMWaveInAudioInputStream::IsMuted() {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void PCMWaveInAudioInputStream::HandleError(MMRESULT error) {
+  DLOG(WARNING) << "PCMWaveInAudio error " << error;
+  if (callback_)
+    callback_->OnError();
+}
+
+void PCMWaveInAudioInputStream::QueueNextPacket(WAVEHDR *buffer) {
+  MMRESULT res = ::waveInAddBuffer(wavein_, buffer, sizeof(WAVEHDR));
+  if (res != MMSYSERR_NOERROR)
+    HandleError(res);
+}
+
+bool PCMWaveInAudioInputStream::GetDeviceId(UINT* device_index) {
+  // Deliver the default input device id (WAVE_MAPPER) if the default
+  // device has been selected.
+  if (device_id_ == AudioDeviceDescription::kDefaultDeviceId) {
+    *device_index = WAVE_MAPPER;
+    return true;
+  }
+
+  // Get list of all available and active devices.
+  AudioDeviceNames device_names;
+  if (!media::GetInputDeviceNamesWinXP(&device_names))
+    return false;
+
+  if (device_names.empty())
+    return false;
+
+  // Search the full list of devices and compare with the specified
+  // device id which was specified in the constructor. Stop comparing
+  // when a match is found and return the corresponding index.
+  UINT index = 0;
+  bool found_device = false;
+  AudioDeviceNames::const_iterator it = device_names.begin();
+  while (it != device_names.end()) {
+    if (it->unique_id.compare(device_id_) == 0) {
+      *device_index = index;
+      found_device = true;
+      break;
+    }
+    ++index;
+    ++it;
+  }
+
+  return found_device;
+}
+
+// Windows calls us back in this function when some events happen. Most notably
+// when it has an audio buffer with recorded data.
+void PCMWaveInAudioInputStream::WaveCallback(HWAVEIN hwi, UINT msg,
+                                             DWORD_PTR instance,
+                                             DWORD_PTR param1, DWORD_PTR) {
+  PCMWaveInAudioInputStream* obj =
+      reinterpret_cast<PCMWaveInAudioInputStream*>(instance);
+
+  // The lock ensures that Stop() can't be called during a callback.
+  base::AutoLock auto_lock(obj->lock_);
+
+  if (msg == WIM_DATA) {
+    // The WIM_DATA message is sent when waveform-audio data is present in
+    // the input buffer and the buffer is being returned to the application.
+    // The message can be sent when the buffer is full or after the
+    // waveInReset function is called.
+    if (obj->callback_) {
+      // TODO(henrika): the |volume| parameter is always set to zero since
+      // there is currently no support for controlling the microphone volume
+      // level.
+      WAVEHDR* buffer = reinterpret_cast<WAVEHDR*>(param1);
+      obj->audio_bus_->FromInterleaved<SignedInt16SampleTypeTraits>(
+          reinterpret_cast<int16_t*>(buffer->lpData), obj->audio_bus_->frames());
+      obj->callback_->OnData(obj->audio_bus_.get(), base::TimeTicks::Now(), 0.0, {});
+
+      // Queue the finished buffer back with the audio driver. Since we are
+      // reusing the same buffers we can get away without calling
+      // waveInPrepareHeader.
+      obj->QueueNextPacket(buffer);
+    } else {
+      // Main thread has called Stop() and set |callback_| to NULL and is
+      // now waiting to issue waveInReset which will kill this thread.
+      // We should not call AudioSourceCallback code anymore.
+      ::SetEvent(obj->stopped_event_.Get());
+    }
+  } else if (msg == WIM_CLOSE) {
+    // Intentionaly no-op for now.
+  } else if (msg == WIM_OPEN) {
+    // Intentionaly no-op for now.
+  }
+}
+
+void PCMWaveInAudioInputStream::SetOutputDeviceForAec(
+    const std::string& output_device_id) {
+  // Not supported. Do nothing.
+}
+
+
+}  // namespace media
\ No newline at end of file
diff --git a/media/audio/win/wavein_input_win.h b/media/audio/win/wavein_input_win.h
new file mode 100644
index 0000000000000..8ec6aaad6725c
--- /dev/null
+++ b/media/audio/win/wavein_input_win.h
@@ -0,0 +1,141 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
+#define MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
+
+#include <windows.h>
+#include <mmsystem.h>
+#include <stdint.h>
+
+#include <memory>
+#include <string>
+
+#include "base/compiler_specific.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/thread_checker.h"
+#include "base/win/scoped_handle.h"
+#include "media/audio/audio_io.h"
+#include "media/audio/audio_manager_base.h"
+#include "media/base/audio_parameters.h"
+
+// Put this in the declarations for a class to be uncopyable and unassignable.
+
+
+namespace media {
+
+class AudioBus;
+class AudioManagerWin;
+
+class PCMWaveInAudioInputStream : public  AudioInputStream {
+ public:
+  // The ctor takes all the usual parameters, plus |manager| which is the
+  // the audio manager who is creating this object and |device_id| which
+  // is provided by the operating system.
+  PCMWaveInAudioInputStream(AudioManagerWin* manager,
+                            const AudioParameters& params,
+                            int num_buffers,
+                            const std::string& device_id);
+  ~PCMWaveInAudioInputStream() override;
+
+  // Implementation of AudioInputStream.
+  OpenOutcome Open() override;
+  void Start(AudioInputCallback* callback) override;
+  void Stop() override;
+  void Close() override;
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  double GetMaxVolume() override;
+  void SetVolume(double volume) override;
+  double GetVolume() override;
+  bool SetAutomaticGainControl(bool enabled) override;
+  bool GetAutomaticGainControl() override;
+  bool IsMuted() override;
+  void SetOutputDeviceForAec(const std::string& output_device_id) override;
+
+ private:
+  enum State {
+    kStateEmpty,      // Initial state.
+    kStateReady,      // Device obtained and ready to record.
+    kStateRecording,  // Recording audio.
+    kStateStopping,   // Trying to stop, waiting for callback to finish.
+    kStateStopped,    // Stopped. Device was reset.
+    kStateClosed      // Device has been released.
+  };
+
+  // Allow unit tests to query the device ID.
+  friend class AudioManagerTest;
+
+  // Windows calls us back with the recorded audio data here. See msdn
+  // documentation for 'waveInProc' for details about the parameters.
+  static void CALLBACK WaveCallback(HWAVEIN hwi, UINT msg, DWORD_PTR instance,
+                                    DWORD_PTR param1, DWORD_PTR param2);
+
+  // If windows reports an error this function handles it and passes it to
+  // the attached AudioInputCallback::OnError().
+  void HandleError(MMRESULT error);
+
+  // Allocates and prepares the memory that will be used for recording.
+  void SetupBuffers();
+
+  // Deallocates the memory allocated in SetupBuffers.
+  void FreeBuffers();
+
+  // Sends a buffer to the audio driver for recording.
+  void QueueNextPacket(WAVEHDR* buffer);
+
+  // Converts the stored device id string into an unsigned integer which
+  // can be used by waveInOpen() to open the specified capture device.
+  bool GetDeviceId(UINT* device_index);
+
+  base::ThreadChecker thread_checker_;
+
+  // Reader beware. Visual C has stronger guarantees on volatile vars than
+  // most people expect. In fact, it has release semantics on write and
+  // acquire semantics on reads. See the msdn documentation.
+  volatile State state_;
+
+  // The audio manager that created this input stream. We notify it when
+  // we close so it can release its own resources.
+  AudioManagerWin* manager_;
+
+  // We use the callback mostly to periodically give the recorded audio data.
+  AudioInputCallback* callback_;
+
+  // The number of buffers of size |buffer_size_| each to use.
+  const int num_buffers_;
+
+  // The size in bytes of each audio buffer.
+  uint32_t buffer_size_;
+
+  // Channels, 1 or 2.
+  const int channels_;
+
+  // Contains the unique name of the selected endpoint device.
+  // Note that AudioDeviceDescription::kDefaultDeviceId represents the default
+  // device role and is not a valid ID as such.
+  std::string device_id_;
+
+  // Windows native structure to encode the format parameters.
+  WAVEFORMATEX format_;
+
+  // Handle to the instance of the wave device.
+  HWAVEIN wavein_;
+
+  // Pointer to the first allocated audio buffer. This object owns it.
+  WAVEHDR* buffer_;
+
+  // An event that is signaled when the callback thread is ready to stop.
+  base::win::ScopedHandle stopped_event_;
+
+  // Lock used to avoid conflicts when Stop() is called during a callback.
+  base::Lock lock_;
+
+  // Extra audio bus used for storage of deinterleaved data for the OnData
+  // callback.
+  std::unique_ptr<media::AudioBus> audio_bus_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
\ No newline at end of file
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
new file mode 100644
index 0000000000000..b00c5670bb517
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
@@ -0,0 +1,43 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+WinHttpProxyResolverFunctions::WinHttpProxyResolverFunctions() {
+  HMODULE winhttp_module =
+      LoadLibraryEx(L"winhttp.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  if (winhttp_module) {
+    create_proxy_resolver = reinterpret_cast<WinHttpCreateProxyResolverFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpCreateProxyResolver"));
+    get_proxy_for_url_ex = reinterpret_cast<WinHttpGetProxyForUrlExFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyForUrlEx"));
+    get_proxy_result = reinterpret_cast<WinHttpGetProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyResult"));
+    free_proxy_result = reinterpret_cast<WinHttpFreeProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpFreeProxyResult"));
+  }
+}
+
+// Never called due to base::NoDestructor.
+WinHttpProxyResolverFunctions::~WinHttpProxyResolverFunctions() = default;
+
+bool WinHttpProxyResolverFunctions::are_all_functions_loaded() const {
+  return create_proxy_resolver && get_proxy_for_url_ex && get_proxy_result &&
+         free_proxy_result;
+}
+
+// static
+const WinHttpProxyResolverFunctions&
+WinHttpProxyResolverFunctions::GetInstance() {
+  // This is a singleton for performance reasons. This avoids having to load
+  // proxy resolver functions multiple times.
+  static base::NoDestructor<WinHttpProxyResolverFunctions> instance;
+  return *instance;
+}
+
+}  // namespace proxy_resolver_win
\ No newline at end of file
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
new file mode 100644
index 0000000000000..768269019cd0e
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
@@ -0,0 +1,47 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+#define SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+
+#include <windows.h>
+#include <winhttp.h>
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+// Not all WinHttp APIs we'll be using exist in all versions of Windows.
+// Several only exist in Windows 8+. Thus, each function entry point must be
+// loaded dynamically.
+struct WinHttpProxyResolverFunctions {
+ public:
+  WinHttpProxyResolverFunctions(const WinHttpProxyResolverFunctions&) = delete;
+  WinHttpProxyResolverFunctions& operator=(
+      const WinHttpProxyResolverFunctions&) = delete;
+
+  bool are_all_functions_loaded() const;
+
+  static const WinHttpProxyResolverFunctions& GetInstance();
+
+  using WinHttpCreateProxyResolverFunc = decltype(WinHttpCreateProxyResolver)*;
+  using WinHttpGetProxyForUrlExFunc = decltype(WinHttpGetProxyForUrlEx)*;
+  using WinHttpGetProxyResultFunc = decltype(WinHttpGetProxyResult)*;
+  using WinHttpFreeProxyResultFunc = decltype(WinHttpFreeProxyResult)*;
+
+  WinHttpCreateProxyResolverFunc create_proxy_resolver = nullptr;
+  WinHttpGetProxyForUrlExFunc get_proxy_for_url_ex = nullptr;
+  WinHttpGetProxyResultFunc get_proxy_result = nullptr;
+  WinHttpFreeProxyResultFunc free_proxy_result = nullptr;
+
+ private:
+  friend class base::NoDestructor<WinHttpProxyResolverFunctions>;
+
+  WinHttpProxyResolverFunctions();
+  ~WinHttpProxyResolverFunctions();
+};
+
+}  // namespace proxy_resolver_win
+
+#endif  // SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
\ No newline at end of file
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
new file mode 100644
index 0000000000000..2e8c855270541
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
@@ -0,0 +1,90 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+
+namespace blink {
+
+namespace {
+
+const wtf_size_t kMaxCacheSlots = 16;
+
+String makeCacheKey(FontDescription::GenericFamilyType generic_family,
+                    String bcp47_language_tag,
+                    FontFallbackPriority fallback_priority) {
+  StringBuilder cache_key;
+  cache_key.Append(bcp47_language_tag);
+  cache_key.AppendNumber(
+      static_cast<
+          std::underlying_type<FontDescription::GenericFamilyType>::type>(
+          generic_family));
+  cache_key.AppendNumber(
+      static_cast<std::underlying_type<FontFallbackPriority>::type>(
+          fallback_priority));
+  return cache_key.ToString();
+}
+
+void getFallbackFamilyAndStyle(SkTypeface* typeface,
+                               String* fallback_family,
+                               SkFontStyle* fallback_style) {
+  SkString family;
+  typeface->getFamilyName(&family);
+  *fallback_family = family.c_str();
+
+  *fallback_style = typeface->fontStyle();
+}
+}  // namespace
+
+FallbackFamilyStyleCache::FallbackFamilyStyleCache()
+    : recent_fallback_fonts_(kMaxCacheSlots) {}
+
+void FallbackFamilyStyleCache::Put(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    SkTypeface* typeface) {
+  String cache_key =
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority);
+
+  auto it = recent_fallback_fonts_.Get(cache_key);
+  if (it != recent_fallback_fonts_.end()) {
+    it->second.insert(0, sk_ref_sp(typeface));
+  } else {
+    TypefaceVector typefaces;
+    typefaces.push_back(sk_ref_sp(typeface));
+    recent_fallback_fonts_.Put(std::move(cache_key), std::move(typefaces));
+  }
+}
+
+void FallbackFamilyStyleCache::Get(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    UChar32 character,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  auto it = recent_fallback_fonts_.Get(
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority));
+  if (it == recent_fallback_fonts_.end())
+    return;
+  TypefaceVector& typefaces = it->second;
+  for (wtf_size_t i = 0; i < typefaces.size(); ++i) {
+    sk_sp<SkTypeface>& typeface = typefaces.at(i);
+    if (typeface->unicharToGlyph(character)) {
+      getFallbackFamilyAndStyle(typeface.get(), fallback_family,
+                                fallback_style);
+      sk_sp<SkTypeface> tmp_typeface(typeface);
+      // For the vector of typefaces for this specific language tag, since this
+      // SkTypeface had a glyph, move it to the beginning to accelerate
+      // subsequent lookups.
+      typefaces.EraseAt(i);
+      typefaces.insert(0, std::move(tmp_typeface));
+      return;
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
new file mode 100644
index 0000000000000..72e27fa69b27f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
@@ -0,0 +1,59 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+
+#include "base/containers/lru_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+using TypefaceVector = Vector<sk_sp<SkTypeface>>;
+using FallbackLruCache = base::HashingLRUCache<String, TypefaceVector>;
+
+class FallbackFamilyStyleCache {
+  USING_FAST_MALLOC(FallbackFamilyStyleCache);
+
+ public:
+  FallbackFamilyStyleCache();
+  FallbackFamilyStyleCache(const FallbackFamilyStyleCache&) = delete;
+  FallbackFamilyStyleCache& operator=(const FallbackFamilyStyleCache&) = delete;
+
+  // Places a SkTypeface object in the cache for specified language tag and
+  // fallback priority, taking a reference on SkTypeface. Adds the |SkTypeface|
+  // to the beginning of a list of typefaces if previous |SkTypefaces| objects
+  // where added for this set of parameters. Note, the internal list of
+  // typefaces for a language tag and fallback priority is not checked for
+  // duplicates when adding a |typeface| object.
+  void Put(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           SkTypeface* typeface);
+
+  // Fetches a |fallback_family| and |fallback_style| for a given language tag,
+  // fallback priority and codepoint. Checks the internal cache for whether a
+  // fallback font with glyph coverage for |character| is available for the
+  // given parameters, then returns its family name and style.
+  void Get(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           UChar32 character,
+           String* fallback_family,
+           SkFontStyle* fallback_style);
+
+  // Empties the internal cache, deleting keys and unrefing the typefaces that
+  // were placed in the cache.
+  void Clear();
+
+ private:
+  FallbackLruCache recent_fallback_fonts_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
new file mode 100644
index 0000000000000..0363fdca92dde
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
@@ -0,0 +1,99 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace {
+
+const char kHanSimplifiedLocale[] = "zh-Hans";
+const size_t kLruCacheTestSize = 5;
+const char kFontFamilyNameArial[] = "Arial";
+const UChar32 kFirstCJKIdeograph = 0x4E00;
+const UChar32 kSecondCJKIdeograph = kFirstCJKIdeograph + 1;
+
+sk_sp<SkTypeface> fallbackForLocale(String locale, UChar32 codepoint) {
+  sk_sp<SkFontMgr> font_mgr = SkFontMgr::RefDefault();
+  std::string locale_string(locale.Ascii());
+  const char* locale_char = locale_string.c_str();
+  return sk_sp<SkTypeface>(font_mgr->matchFamilyStyleCharacter(
+      kFontFamilyNameArial, SkFontStyle(), &locale_char, 1, codepoint));
+}
+
+void fillCacheWithDummies(blink::FallbackLruCache& lru_cache,
+                          const char* format_string,
+                          size_t count) {
+  for (size_t i = 0; i < count; ++i) {
+    blink::TypefaceVector dummy_typefaces;
+    dummy_typefaces.push_back(
+        SkTypeface::MakeFromName(kFontFamilyNameArial, SkFontStyle()));
+    lru_cache.Put(String::Format(format_string, i), std::move(dummy_typefaces));
+  }
+}
+
+}  // namespace
+
+namespace blink {
+
+TEST(FallbackLruCacheTest, KeepChineseWhenFetched) {
+  // Put a Chinese font in the cache, add size - 1 more dummy fallback fonts so
+  // that the cache is full. Get() and verify typeface for Chinese to move them
+  // up to the top of the cache. Then fill again with size - 1 items and verify
+  // that Chinese is still in the cache. Then fill with # size items to evict
+  // the Chinese font and ensure it's gone.
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  TypefaceVector fallback_typefaces_zh;
+  fallback_typefaces_zh.push_back(
+      fallbackForLocale(kHanSimplifiedLocale, kFirstCJKIdeograph));
+  lru_cache.Put(kHanSimplifiedLocale, std::move(fallback_typefaces_zh));
+
+  EXPECT_EQ(lru_cache.size(), 1u);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", kLruCacheTestSize - 1);
+  auto it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  TypefaceVector& chinese_typefaces = it->second;
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(0x4E01));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_2nd_%zu",
+                       kLruCacheTestSize - 1);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  chinese_typefaces = it->second;
+  EXPECT_EQ(chinese_typefaces.size(), 1u);
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(kSecondCJKIdeograph));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_3rd_%zu", kLruCacheTestSize);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it == lru_cache.end());
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+}
+
+TEST(FallbackLruCacheTest, LargeFillAndClear) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", 1000);
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+  lru_cache.Clear();
+  EXPECT_EQ(lru_cache.size(), 0u);
+}
+
+TEST(FallbackLruCacheTest, KeyOverride) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "same_locale", 10);
+  EXPECT_EQ(lru_cache.size(), 1u);
+}
+
+}  // namespace blink
diff --git a/ui/base/ime/win/imm32_manager.cc b/ui/base/ime/win/imm32_manager.cc
new file mode 100644
index 0000000000000..af0e4318d606e
--- /dev/null
+++ b/ui/base/ime/win/imm32_manager.cc
@@ -0,0 +1,487 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/ime/win/imm32_manager.h"
+
+#include <stdint.h>
+
+#include <memory>
+#include <string>
+
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "third_party/skia/include/core/SkColor.h"
+#include "ui/base/ime/composition_text.h"
+
+///////////////////////////////////////////////////////////////////////////////
+// IMM32Manager
+
+namespace {
+
+// Determines whether or not the given attribute represents a target
+// (a.k.a. a selection).
+bool IsTargetAttribute(char attribute) {
+  return (attribute == ATTR_TARGET_CONVERTED ||
+          attribute == ATTR_TARGET_NOTCONVERTED);
+}
+
+// Helper function for IMM32Manager::GetCompositionInfo() method, to get the
+// target range that's selected by the user in the current composition string.
+void GetCompositionTargetRange(HIMC imm_context, int* target_start,
+                               int* target_end) {
+  int attribute_size = ::ImmGetCompositionString(imm_context, GCS_COMPATTR,
+                                                 NULL, 0);
+  if (attribute_size > 0) {
+    int start = 0;
+    int end = 0;
+    std::unique_ptr<char[]> attribute_data(new char[attribute_size]);
+    if (attribute_data.get()) {
+      ::ImmGetCompositionString(imm_context, GCS_COMPATTR,
+                                attribute_data.get(), attribute_size);
+      for (start = 0; start < attribute_size; ++start) {
+        if (IsTargetAttribute(attribute_data[start]))
+          break;
+      }
+      for (end = start; end < attribute_size; ++end) {
+        if (!IsTargetAttribute(attribute_data[end]))
+          break;
+      }
+    }
+    *target_start = start;
+    *target_end = end;
+  }
+}
+
+// Helper function for IMM32Manager::GetCompositionInfo() method, to get
+// underlines information of the current composition string.
+void GetImeTextSpans(HIMC imm_context,
+                     int target_start,
+                     int target_end,
+                     ui::ImeTextSpans* ime_text_spans) {
+  int clause_size = ::ImmGetCompositionString(imm_context, GCS_COMPCLAUSE,
+                                              NULL, 0);
+  int clause_length = clause_size / sizeof(uint32_t);
+  if (clause_length) {
+    std::unique_ptr<uint32_t[]> clause_data(new uint32_t[clause_length]);
+    if (clause_data.get()) {
+      ::ImmGetCompositionString(imm_context, GCS_COMPCLAUSE,
+                                clause_data.get(), clause_size);
+      for (int i = 0; i < clause_length - 1; ++i) {
+        ui::ImeTextSpan ime_text_span;
+        ime_text_span.start_offset = clause_data[i];
+        ime_text_span.end_offset = clause_data[i + 1];
+        ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThin;
+        ime_text_span.background_color = SK_ColorTRANSPARENT;
+
+        // Use thick underline for the target clause.
+        if (ime_text_span.start_offset >= static_cast<uint32_t>(target_start) &&
+            ime_text_span.end_offset <= static_cast<uint32_t>(target_end)) {
+          ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThick;
+        }
+        ime_text_spans->push_back(ime_text_span);
+      }
+    }
+  }
+}
+
+}  // namespace
+
+namespace ui {
+
+IMM32Manager::IMM32Manager()
+    : is_composing_(false),
+      input_language_id_(LANG_USER_DEFAULT),
+      system_caret_(false),
+      caret_rect_(-1, -1, 0, 0),
+      use_composition_window_(false) {
+}
+
+IMM32Manager::~IMM32Manager() {
+}
+
+void IMM32Manager::SetInputLanguage() {
+  // Retrieve the current input language from the system's keyboard layout.
+  // Using GetKeyboardLayoutName instead of GetKeyboardLayout, because
+  // the language from GetKeyboardLayout is the language under where the
+  // keyboard layout is installed. And the language from GetKeyboardLayoutName
+  // indicates the language of the keyboard layout itself.
+  // See crbug.com/344834.
+  WCHAR keyboard_layout[KL_NAMELENGTH];
+  if (::GetKeyboardLayoutNameW(keyboard_layout)) {
+    input_language_id_ =
+        static_cast<LANGID>(
+            wcstol(&keyboard_layout[KL_NAMELENGTH >> 1], nullptr, 16));
+  } else {
+    input_language_id_ = 0x0409;  // Fallback to en-US.
+  }
+}
+
+void IMM32Manager::CreateImeWindow(HWND window_handle) {
+  // When a user disables TSF (Text Service Framework) and CUAS (Cicero
+  // Unaware Application Support), Chinese IMEs somehow ignore function calls
+  // to ::ImmSetCandidateWindow(), i.e. they do not move their candidate
+  // window to the position given as its parameters, and use the position
+  // of the current system caret instead, i.e. it uses ::GetCaretPos() to
+  // retrieve the position of their IME candidate window.
+  // Therefore, we create a temporary system caret for Chinese IMEs and use
+  // it during this input context.
+  // Since some third-party Japanese IME also uses ::GetCaretPos() to determine
+  // their window position, we also create a caret for Japanese IMEs.
+  if (PRIMARYLANGID(input_language_id_) == LANG_CHINESE ||
+      PRIMARYLANGID(input_language_id_) == LANG_JAPANESE) {
+    if (!system_caret_) {
+      if (::CreateCaret(window_handle, NULL, 1, 1)) {
+        system_caret_ = true;
+      }
+    }
+  }
+  // Restore the positions of the IME windows.
+  UpdateImeWindow(window_handle);
+}
+
+LRESULT IMM32Manager::SetImeWindowStyle(HWND window_handle, UINT message,
+                                    WPARAM wparam, LPARAM lparam,
+                                    BOOL* handled) {
+  // To prevent the IMM (Input Method Manager) from displaying the IME
+  // composition window, Update the styles of the IME windows and EXPLICITLY
+  // call ::DefWindowProc() here.
+  // NOTE(hbono): We can NEVER let WTL call ::DefWindowProc() when we update
+  // the styles of IME windows because the 'lparam' variable is a local one
+  // and all its updates disappear in returning from this function, i.e. WTL
+  // does not call ::DefWindowProc() with our updated 'lparam' value but call
+  // the function with its original value and over-writes our window styles.
+  *handled = TRUE;
+  lparam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
+  return ::DefWindowProc(window_handle, message, wparam, lparam);
+}
+
+void IMM32Manager::DestroyImeWindow(HWND window_handle) {
+  // Destroy the system caret if we have created for this IME input context.
+  if (system_caret_) {
+    ::DestroyCaret();
+    system_caret_ = false;
+  }
+}
+
+void IMM32Manager::MoveImeWindow(HWND window_handle, HIMC imm_context) {
+  // Does nothing when the target window has no input focus. This is important
+  // because the renderer may issue SelectionBoundsChanged event even when it
+  // has no input focus. (e.g. the page update caused by incremental search.)
+  // So this event should be ignored when the |window_handle| no longer has the
+  // input focus.
+  if (GetFocus() != window_handle)
+    return;
+
+  int x = caret_rect_.x();
+  int y = caret_rect_.y();
+
+  const int kCaretMargin = 1;
+  if (!use_composition_window_ &&
+      PRIMARYLANGID(input_language_id_) == LANG_CHINESE) {
+    // As written in a comment in IMM32Manager::CreateImeWindow(),
+    // Chinese IMEs ignore function calls to ::ImmSetCandidateWindow()
+    // when a user disables TSF (Text Service Framework) and CUAS (Cicero
+    // Unaware Application Support).
+    // On the other hand, when a user enables TSF and CUAS, Chinese IMEs
+    // ignore the position of the current system caret and uses the
+    // parameters given to ::ImmSetCandidateWindow() with its 'dwStyle'
+    // parameter CFS_CANDIDATEPOS.
+    // Therefore, we do not only call ::ImmSetCandidateWindow() but also
+    // set the positions of the temporary system caret if it exists.
+    CANDIDATEFORM candidate_position = {0, CFS_CANDIDATEPOS, {x, y},
+                                        {0, 0, 0, 0}};
+    ::ImmSetCandidateWindow(imm_context, &candidate_position);
+  }
+  if (system_caret_) {
+    switch (PRIMARYLANGID(input_language_id_)) {
+      case LANG_JAPANESE:
+        ::SetCaretPos(x, y + caret_rect_.height());
+        break;
+      default:
+        ::SetCaretPos(x, y);
+        break;
+    }
+  }
+  if (use_composition_window_) {
+    // Moves the composition text window.
+    COMPOSITIONFORM cf = {CFS_POINT, {x, y}};
+    ::ImmSetCompositionWindow(imm_context, &cf);
+    // Don't need to set the position of candidate window.
+    return;
+  }
+
+  if (PRIMARYLANGID(input_language_id_) == LANG_KOREAN) {
+    // Chinese IMEs and Japanese IMEs require the upper-left corner of
+    // the caret to move the position of their candidate windows.
+    // On the other hand, Korean IMEs require the lower-left corner of the
+    // caret to move their candidate windows.
+    y += kCaretMargin;
+  }
+  // Japanese IMEs and Korean IMEs also use the rectangle given to
+  // ::ImmSetCandidateWindow() with its 'dwStyle' parameter CFS_EXCLUDE
+  // to move their candidate windows when a user disables TSF and CUAS.
+  // Therefore, we also set this parameter here.
+  CANDIDATEFORM exclude_rectangle = {0, CFS_EXCLUDE, {x, y},
+      {x, y, x + caret_rect_.width(), y + caret_rect_.height()}};
+  ::ImmSetCandidateWindow(imm_context, &exclude_rectangle);
+}
+
+void IMM32Manager::UpdateImeWindow(HWND window_handle) {
+  // Just move the IME window attached to the given window.
+  if (caret_rect_.x() >= 0 && caret_rect_.y() >= 0) {
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      MoveImeWindow(window_handle, imm_context);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+  }
+}
+
+void IMM32Manager::CleanupComposition(HWND window_handle) {
+  // Notify the IMM attached to the given window to complete the ongoing
+  // composition, (this case happens when the given window is de-activated
+  // while composing a text and re-activated), and reset the omposition status.
+  if (is_composing_) {
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      ::ImmNotifyIME(imm_context, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+    ResetComposition(window_handle);
+  }
+}
+
+void IMM32Manager::ResetComposition(HWND window_handle) {
+  // Currently, just reset the composition status.
+  is_composing_ = false;
+}
+
+void IMM32Manager::CompleteComposition(HWND window_handle, HIMC imm_context) {
+  // We have to confirm there is an ongoing composition before completing it.
+  // This is for preventing some IMEs from getting confused while completing an
+  // ongoing composition even if they do not have any ongoing compositions.)
+  if (is_composing_) {
+    ::ImmNotifyIME(imm_context, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+    ResetComposition(window_handle);
+  }
+}
+
+void IMM32Manager::GetCompositionInfo(HIMC imm_context,
+                                      LPARAM lparam,
+                                      CompositionText* composition) {
+  // We only care about GCS_COMPATTR, GCS_COMPCLAUSE and GCS_CURSORPOS, and
+  // convert them into composition underlines and selection range respectively.
+  composition->ime_text_spans.clear();
+
+  int length = static_cast<int>(composition->text.length());
+
+  // Find out the range selected by the user.
+  int target_start = length;
+  int target_end = length;
+  if (lparam & GCS_COMPATTR)
+    GetCompositionTargetRange(imm_context, &target_start, &target_end);
+
+  // Retrieve the selection range information. If CS_NOMOVECARET is specified,
+  // that means the cursor should not be moved, then we just place the caret at
+  // the beginning of the composition string. Otherwise we should honour the
+  // GCS_CURSORPOS value if it's available.
+  // TODO(suzhe): due to a bug of webkit, we currently can't use selection range
+  // with composition string. See: https://bugs.webkit.org/show_bug.cgi?id=40805
+  if (!(lparam & CS_NOMOVECARET) && (lparam & GCS_CURSORPOS)) {
+    // IMM32 does not support non-zero-width selection in a composition. So
+    // always use the caret position as selection range.
+    int cursor = ::ImmGetCompositionString(imm_context, GCS_CURSORPOS, NULL, 0);
+    composition->selection = gfx::Range(cursor);
+  } else {
+    composition->selection = gfx::Range(0);
+  }
+
+  // Retrieve the clause segmentations and convert them to ime_text_spans.
+  if (lparam & GCS_COMPCLAUSE) {
+    GetImeTextSpans(imm_context, target_start, target_end,
+                    &composition->ime_text_spans);
+  }
+
+  // Set default composition underlines in case there is no clause information.
+  if (!composition->ime_text_spans.empty())
+    return;
+
+  ImeTextSpan ime_text_span;
+  ime_text_span.underline_color = SK_ColorTRANSPARENT;
+  ime_text_span.background_color = SK_ColorTRANSPARENT;
+  if (target_start > 0) {
+    ime_text_span.start_offset = 0U;
+    ime_text_span.end_offset = static_cast<uint32_t>(target_start);
+    ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThin;
+    composition->ime_text_spans.push_back(ime_text_span);
+  }
+  if (target_end > target_start) {
+    ime_text_span.start_offset = static_cast<uint32_t>(target_start);
+    ime_text_span.end_offset = static_cast<uint32_t>(target_end);
+    ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThick;
+    composition->ime_text_spans.push_back(ime_text_span);
+  }
+  if (target_end < length) {
+    ime_text_span.start_offset = static_cast<uint32_t>(target_end);
+    ime_text_span.end_offset = static_cast<uint32_t>(length);
+    ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThin;
+    composition->ime_text_spans.push_back(ime_text_span);
+  }
+}
+
+bool IMM32Manager::GetString(HIMC imm_context,
+                             WPARAM lparam,
+                             int type,
+                             std::u16string* result) {
+  if (!(lparam & type))
+    return false;
+  LONG string_size = ::ImmGetCompositionString(imm_context, type, NULL, 0);
+  if (string_size <= 0)
+    return false;
+  DCHECK_EQ(0u, string_size % sizeof(wchar_t));
+  ::ImmGetCompositionString(imm_context, type,
+                            base::as_writable_wcstr(base::WriteInto(
+                                result, (string_size / sizeof(wchar_t)) + 1)),
+                            string_size);
+  return true;
+}
+
+bool IMM32Manager::GetResult(HWND window_handle,
+                             LPARAM lparam,
+                             std::u16string* result) {
+  bool ret = false;
+  HIMC imm_context = ::ImmGetContext(window_handle);
+  if (imm_context) {
+    ret = GetString(imm_context, lparam, GCS_RESULTSTR, result);
+    ::ImmReleaseContext(window_handle, imm_context);
+  }
+  return ret;
+}
+
+bool IMM32Manager::GetComposition(HWND window_handle, LPARAM lparam,
+                              CompositionText* composition) {
+  bool ret = false;
+  HIMC imm_context = ::ImmGetContext(window_handle);
+  if (imm_context) {
+    // Copy the composition string to the CompositionText object.
+    ret = GetString(imm_context, lparam, GCS_COMPSTR, &composition->text);
+
+    if (ret) {
+      // This is a dirty workaround for facebook. Facebook deletes the
+      // placeholder character (U+3000) used by Traditional-Chinese IMEs at the
+      // beginning of composition text. This prevents WebKit from replacing this
+      // placeholder character with a Traditional-Chinese character, i.e. we
+      // cannot input any characters in a comment box of facebook with
+      // Traditional-Chinese IMEs. As a workaround, we replace U+3000 at the
+      // beginning of composition text with U+FF3F, a placeholder character used
+      // by Japanese IMEs.
+      if (input_language_id_ == MAKELANGID(LANG_CHINESE,
+                                           SUBLANG_CHINESE_TRADITIONAL) &&
+          composition->text[0] == 0x3000) {
+        composition->text[0] = 0xFF3F;
+      }
+
+      // Retrieve the IME text spans and selection range information.
+      GetCompositionInfo(imm_context, lparam, composition);
+
+      // Mark that there is an ongoing composition.
+      is_composing_ = true;
+    }
+
+    ::ImmReleaseContext(window_handle, imm_context);
+  }
+  return ret;
+}
+
+void IMM32Manager::DisableIME(HWND window_handle) {
+  // A renderer process have moved its input focus to a password input
+  // when there is an ongoing composition, e.g. a user has clicked a
+  // mouse button and selected a password input while composing a text.
+  // For this case, we have to complete the ongoing composition and
+  // clean up the resources attached to this object BEFORE DISABLING THE IME.
+  CleanupComposition(window_handle);
+  ::ImmAssociateContextEx(window_handle, NULL, 0);
+}
+
+void IMM32Manager::CancelIME(HWND window_handle) {
+  if (is_composing_) {
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      ::ImmNotifyIME(imm_context, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+    ResetComposition(window_handle);
+  }
+}
+
+void IMM32Manager::EnableIME(HWND window_handle) {
+  // Load the default IME context.
+  // NOTE(hbono)
+  //   IMM ignores this call if the IME context is loaded. Therefore, we do
+  //   not have to check whether or not the IME context is loaded.
+  ::ImmAssociateContextEx(window_handle, NULL, IACE_DEFAULT);
+}
+
+void IMM32Manager::UpdateCaretRect(HWND window_handle,
+                               const gfx::Rect& caret_rect) {
+  // Save the caret position, and Update the position of the IME window.
+  // This update is used for moving an IME window when a renderer process
+  // resize/moves the input caret.
+  if (caret_rect_ != caret_rect) {
+    caret_rect_ = caret_rect;
+    // Move the IME windows.
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      MoveImeWindow(window_handle, imm_context);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+  }
+}
+
+void IMM32Manager::SetUseCompositionWindow(bool use_composition_window) {
+  use_composition_window_ = use_composition_window;
+}
+
+bool IMM32Manager::IsInputLanguageCJK() const {
+  LANGID lang = PRIMARYLANGID(input_language_id_);
+  return lang == LANG_CHINESE || lang == LANG_JAPANESE ||
+      lang == LANG_KOREAN;
+}
+
+void IMM32Manager::SetTextInputMode(HWND window_handle,
+                                    TextInputMode input_mode) {
+  if (input_mode == ui::TEXT_INPUT_MODE_DEFAULT)
+    return;
+
+  const HIMC imm_context = ::ImmGetContext(window_handle);
+  if (!imm_context)
+    return;
+
+  DWORD conversion_mode = 0;
+  DWORD sentence_mode = 0;
+  if (::ImmGetConversionStatus(imm_context, &conversion_mode, &sentence_mode)
+      == FALSE) {
+    return;
+  }
+
+  BOOL open = FALSE;
+  ConvertInputModeToImmFlags(input_mode, conversion_mode, &open,
+                             &conversion_mode),
+
+  ::ImmSetOpenStatus(imm_context, open);
+  if (open)
+    ::ImmSetConversionStatus(imm_context, conversion_mode, sentence_mode);
+  ::ImmReleaseContext(window_handle, imm_context);
+}
+
+// static
+void IMM32Manager::ConvertInputModeToImmFlags(TextInputMode input_mode,
+                                              DWORD initial_conversion_mode,
+                                              BOOL* open,
+                                              DWORD* new_conversion_mode) {
+  *open = FALSE;
+  *new_conversion_mode = initial_conversion_mode;
+}
+
+}  // namespace ui
diff --git a/ui/base/ime/win/imm32_manager.h b/ui/base/ime/win/imm32_manager.h
new file mode 100644
index 0000000000000..e8271a992d4b1
--- /dev/null
+++ b/ui/base/ime/win/imm32_manager.h
@@ -0,0 +1,308 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_IME_WIN_IMM32_MANAGER_H_
+#define UI_BASE_IME_WIN_IMM32_MANAGER_H_
+
+#include <windows.h>
+
+#include <string>
+#include <vector>
+
+#include "base/component_export.h"
+#include "base/i18n/rtl.h"
+#include "ui/base/ime/text_input_mode.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace ui {
+
+struct CompositionText;
+
+// This header file defines a struct and a class used for encapsulating IMM32
+// APIs, controls IMEs attached to a window, and enables the 'on-the-spot'
+// input without deep knowledge about the APIs, i.e. knowledge about the
+// language-specific and IME-specific behaviors.
+// The following items enumerates the simplest steps for an (window)
+// application to control its IMEs with the struct and the class defined
+// this file.
+// 1. Add an instance of the IMM32Manager class to its window class.
+//    (The IMM32Manager class needs a window handle.)
+// 2. Add messages handlers listed in the following subsections, follow the
+//    instructions written in each subsection, and use the IMM32Manager class.
+// 2.1. WM_IME_SETCONTEXT (0x0281)
+//      Call the functions listed below:
+//      - IMM32Manager::CreateImeWindow();
+//      - IMM32Manager::CleanupComposition(), and;
+//      - IMM32Manager::SetImeWindowStyle().
+//      An application MUST prevent from calling ::DefWindowProc().
+// 2.2. WM_IME_STARTCOMPOSITION (0x010D)
+//      Call the functions listed below:
+//      - IMM32Manager::CreateImeWindow(), and;
+//      - IMM32Manager::ResetComposition().
+//      An application MUST prevent from calling ::DefWindowProc().
+// 2.3. WM_IME_COMPOSITION (0x010F)
+//      Call the functions listed below:
+//      - IMM32Manager::UpdateImeWindow();
+//      - IMM32Manager::GetResult();
+//      - IMM32Manager::GetComposition(), and;
+//      - IMM32Manager::ResetComposition() (optional).
+//      An application MUST prevent from calling ::DefWindowProc().
+// 2.4. WM_IME_ENDCOMPOSITION (0x010E)
+//      Call the functions listed below:
+//      - IMM32Manager::ResetComposition(), and;
+//      - IMM32Manager::DestroyImeWindow().
+//      An application CAN call ::DefWindowProc().
+// 2.5. WM_INPUTLANGCHANGE (0x0051)
+//      Call the functions listed below:
+//      - IMM32Manager::SetInputLanguage().
+//      An application CAN call ::DefWindowProc().
+
+// This class controls the IMM (Input Method Manager) through IMM32 APIs and
+// enables it to retrieve the string being controled by the IMM. (I wrote
+// a note to describe the reason why I do not use 'IME' but 'IMM' below.)
+// NOTE(hbono):
+//   Fortunately or unfortunately, TSF (Text Service Framework) and
+//   CUAS (Cicero Unaware Application Support) allows IMM32 APIs for
+//   retrieving not only the inputs from IMEs (Input Method Editors), used
+//   only for inputting East-Asian language texts, but also the ones from
+//   tablets (on Windows XP Tablet PC Edition and Windows Vista), voice
+//   recognizers (e.g. ViaVoice and Microsoft Office), etc.
+//   We can disable TSF and CUAS in Windows XP Tablet PC Edition. On the other
+//   hand, we can NEVER disable either TSF or CUAS in Windows Vista, i.e.
+//   THIS CLASS IS NOT ONLY USED ON THE INPUT CONTEXTS OF EAST-ASIAN
+//   LANGUAGES BUT ALSO USED ON THE INPUT CONTEXTS OF ALL LANGUAGES.
+class COMPONENT_EXPORT(UI_BASE_IME_WIN) IMM32Manager {
+ public:
+  IMM32Manager();
+
+  IMM32Manager(const IMM32Manager&) = delete;
+  IMM32Manager& operator=(const IMM32Manager&) = delete;
+
+  virtual ~IMM32Manager();
+
+  // Retrieves whether or not there is an ongoing composition.
+  bool is_composing() const { return is_composing_; }
+
+  // Retrieves the input language from Windows and update it.
+  void SetInputLanguage();
+
+  // Creates the IME windows, and allocate required resources for them.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void CreateImeWindow(HWND window_handle);
+
+  // Updates the style of the IME windows.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * message [in] (UINT)
+  //   * wparam [in] (WPARAM)
+  //   * lparam [in] (LPARAM)
+  //     Represent the windows message of the caller.
+  //     These parameters are used for verifying if this function is called
+  //     in a handler function for WM_IME_SETCONTEXT messages because this
+  //     function uses ::DefWindowProc() to update the style.
+  //     A caller just has to pass the input parameters for the handler
+  //     function without modifications.
+  //   * handled [out] (BOOL*)
+  //     Returns ::DefWindowProc() is really called in this function.
+  //     PLEASE DO NOT CALL ::DefWindowProc() IF THIS VALUE IS TRUE!
+  //     All the window styles set in this function are over-written when
+  //     calling ::DefWindowProc() after returning this function.
+  // Returns the value returned by DefWindowProc.
+  LRESULT SetImeWindowStyle(HWND window_handle, UINT message,
+                            WPARAM wparam, LPARAM lparam, BOOL* handled);
+
+  // Destroys the IME windows and all the resources attached to them.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void DestroyImeWindow(HWND window_handle);
+
+  // Updates the position of the IME windows.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void UpdateImeWindow(HWND window_handle);
+
+  // Cleans up the all resources attached to the given IMM32Manager object, and
+  // reset its composition status.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void CleanupComposition(HWND window_handle);
+
+  // Resets the composition status.
+  // Cancel the ongoing composition if it exists.
+  // NOTE(hbono): This method does not release the allocated resources.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void ResetComposition(HWND window_handle);
+
+  // Retrieves a composition result of the ongoing composition if it exists.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * lparam [in] (LPARAM)
+  //     Specifies the updated members of the ongoing composition, and must be
+  //     the same parameter of a WM_IME_COMPOSITION message handler.
+  //     This parameter is used for checking if the ongoing composition has
+  //     its result string,
+  //   * result [out] (std::u16string)
+  //     Represents the object contains the composition result.
+  // Return values
+  //   * true
+  //     The ongoing composition has a composition result.
+  //   * false
+  //     The ongoing composition does not have composition results.
+  // Remarks
+  //   This function is designed for being called from WM_IME_COMPOSITION
+  //   message handlers.
+  bool GetResult(HWND window_handle, LPARAM lparam, std::u16string* result);
+
+  // Retrieves the current composition status of the ongoing composition.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * lparam [in] (LPARAM)
+  //     Specifies the updated members of the ongoing composition, and must be
+  //     the same parameter of a WM_IME_COMPOSITION message handler.
+  //     This parameter is used for checking if the ongoing composition has
+  //     its result string,
+  //   * composition [out] (Composition)
+  //     Represents the struct contains the composition status.
+  // Return values
+  //   * true
+  //     The status of the ongoing composition is updated.
+  //   * false
+  //     The status of the ongoing composition is not updated.
+  // Remarks
+  //   This function is designed for being called from WM_IME_COMPOSITION
+  //   message handlers.
+  bool GetComposition(HWND window_handle, LPARAM lparam,
+                      CompositionText* composition);
+
+  // Enables the IME attached to the given window, i.e. allows user-input
+  // events to be dispatched to the IME.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * complete [in] (bool)
+  //     Represents whether or not to complete the ongoing composition.
+  //     + true
+  //       After finishing the ongoing composition and close its IME windows,
+  //       start another composition and display its IME windows to the given
+  //       position.
+  //     + false
+  //       Just move the IME windows of the ongoing composition to the given
+  //       position without finishing it.
+  void EnableIME(HWND window_handle);
+
+  // Disables the IME attached to the given window, i.e. prohibits any
+  // user-input events from being dispatched to the IME.
+  // In Chrome, this function is used when:
+  //   * a renreder process sets its input focus to a password input.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void DisableIME(HWND window_handle);
+
+  // Cancels an ongoing composition of the IME attached to the given window.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void CancelIME(HWND window_handle);
+
+  // Updates the caret position of the given window.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * caret_rect [in] (const gfx::Rect&)
+  //     Represent the rectangle of the input caret.
+  //     This rectangle is used for controlling the positions of IME windows.
+  void UpdateCaretRect(HWND window_handle, const gfx::Rect& caret_rect);
+
+  // Updates the setting whether we want IME to render composition text.
+  void SetUseCompositionWindow(bool use_composition_window);
+
+  // Returns the current input language id.
+  LANGID input_language_id() const { return input_language_id_; }
+
+  // Returns whether the system's input language is CJK.
+  bool IsInputLanguageCJK() const;
+
+  // Sets conversion status corresponding to |input_mode|.
+  virtual void SetTextInputMode(HWND window_handle, TextInputMode input_mode);
+
+  // Helper functions ----------------------------------------------------------
+
+  // Gets parameters for ::ImmSetOpenStatus and ::ImmSetConversionStatus from
+  // |input_mode|.
+  static void ConvertInputModeToImmFlags(TextInputMode input_mode,
+                                         DWORD initial_conversion_mode,
+                                         BOOL* open,
+                                         DWORD* new_conversion_mode);
+
+ protected:
+  // Retrieves the composition information.
+  void GetCompositionInfo(HIMC imm_context, LPARAM lparam,
+                          CompositionText* composition);
+
+  // Updates the position of the IME windows.
+  void MoveImeWindow(HWND window_handle, HIMC imm_context);
+
+  // Completes the ongoing composition if it exists.
+  void CompleteComposition(HWND window_handle, HIMC imm_context);
+
+  // Retrieves a string from the IMM.
+  bool GetString(HIMC imm_context,
+                 WPARAM lparam,
+                 int type,
+                 std::u16string* result);
+
+ private:
+  // Represents whether or not there is an ongoing composition in a browser
+  // process, i.e. whether or not a browser process is composing a text.
+  bool is_composing_;
+
+  // The current input Language ID retrieved from Windows, which consists of:
+  //   * Primary Language ID (bit 0 to bit 9), which shows a natunal language
+  //     (English, Korean, Chinese, Japanese, etc.) and;
+  //   * Sub-Language ID (bit 10 to bit 15), which shows a geometrical region
+  //     the language is spoken (For English, United States, United Kingdom,
+  //     Australia, Canada, etc.)
+  // The following list enumerates some examples for the Language ID:
+  //   * "en-US" (0x0409)
+  //     MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
+  //   * "ko-KR" (0x0412)
+  //     MAKELANGID(LANG_KOREAN,  SUBLANG_KOREAN);
+  //   * "zh-TW" (0x0404)
+  //     MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
+  //   * "zh-CN" (0x0804)
+  //     MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
+  //   * "ja-JP" (0x0411)
+  //     MAKELANGID(LANG_JAPANESE, SUBLANG_JAPANESE_JAPAN), etc.
+  //   (See <winnt.h> for other available values.)
+  // This Language ID is used for processing language-specific operations in
+  // IME functions.
+  LANGID input_language_id_;
+
+  // Represents whether or not the current input context has created a system
+  // caret to set the position of its IME candidate window.
+  //   * true: it creates a system caret.
+  //   * false: it does not create a system caret.
+  bool system_caret_;
+
+  // The rectangle of the input caret retrieved from a renderer process.
+  gfx::Rect caret_rect_;
+
+  // Indicates whether or not we want IME to render composition text.
+  bool use_composition_window_;
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_IME_WIN_IMM32_MANAGER_H_
diff --git a/ui/base/ime/win/imm32_manager_unittest.cc b/ui/base/ime/win/imm32_manager_unittest.cc
new file mode 100644
index 0000000000000..4d40973c626ec
--- /dev/null
+++ b/ui/base/ime/win/imm32_manager_unittest.cc
@@ -0,0 +1,69 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/ime/win/imm32_manager.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace ui {
+namespace {
+
+struct InputModeTestCase {
+  TextInputMode input_mode;
+  DWORD conversion_mode;
+  BOOL expected_open;
+  DWORD expected_conversion_mode;
+};
+
+// Google Test pretty-printer.
+void PrintTo(const InputModeTestCase& data, std::ostream* os) {
+  *os << " input_mode: " << testing::PrintToString(data.input_mode)
+      << "; conversion_mode: " << testing::PrintToString(data.conversion_mode);
+}
+
+class IMM32ManagerTest
+    : public ::testing::TestWithParam<InputModeTestCase> {
+};
+
+const InputModeTestCase kInputModeTestCases[] = {
+    {TEXT_INPUT_MODE_DEFAULT, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_DEFAULT, IME_CMODE_NATIVE, FALSE, IME_CMODE_NATIVE},
+    {TEXT_INPUT_MODE_TEXT, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_TEXT, IME_CMODE_NATIVE, FALSE, IME_CMODE_NATIVE},
+    {TEXT_INPUT_MODE_NUMERIC, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_NUMERIC, IME_CMODE_FULLSHAPE, FALSE, IME_CMODE_FULLSHAPE},
+    {TEXT_INPUT_MODE_DECIMAL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_DECIMAL, IME_CMODE_FULLSHAPE, FALSE, IME_CMODE_FULLSHAPE},
+    {TEXT_INPUT_MODE_TEL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_TEL, IME_CMODE_ROMAN, FALSE, IME_CMODE_ROMAN},
+    {TEXT_INPUT_MODE_EMAIL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_EMAIL, IME_CMODE_CHARCODE, FALSE, IME_CMODE_CHARCODE},
+    {TEXT_INPUT_MODE_URL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_URL, IME_CMODE_HANJACONVERT, FALSE,
+     IME_CMODE_HANJACONVERT},
+    {TEXT_INPUT_MODE_SEARCH, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_SEARCH, IME_CMODE_CHARCODE, FALSE, IME_CMODE_CHARCODE},
+};
+
+TEST_P(IMM32ManagerTest, ConvertInputModeToImmFlags) {
+  const InputModeTestCase& test_case = GetParam();
+
+  BOOL open;
+  DWORD conversion_mode;
+  // Call testee method.
+  IMM32Manager::ConvertInputModeToImmFlags(test_case.input_mode,
+                                           test_case.conversion_mode,
+                                           &open,
+                                           &conversion_mode);
+
+  EXPECT_EQ(test_case.expected_open, open);
+  EXPECT_EQ(test_case.expected_conversion_mode, conversion_mode);
+}
+
+INSTANTIATE_TEST_SUITE_P(All,
+                         IMM32ManagerTest,
+                         ::testing::ValuesIn(kInputModeTestCases));
+
+}  // namespace
+}  // namespace ui
diff --git a/ui/base/ime/win/input_method_win_imm32.cc b/ui/base/ime/win/input_method_win_imm32.cc
new file mode 100644
index 0000000000000..0aa096de50119
--- /dev/null
+++ b/ui/base/ime/win/input_method_win_imm32.cc
@@ -0,0 +1,349 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/ime/win/input_method_win_imm32.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "base/auto_reset.h"
+#include "base/command_line.h"
+#include "base/functional/bind.h"
+#include "ui/base/ime/text_input_client.h"
+#include "ui/base/ime/win/tsf_input_scope.h"
+#include "ui/display/win/screen_win.h"
+#include "ui/events/event.h"
+#include "ui/events/event_constants.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/keycodes/keyboard_codes.h"
+#include "ui/gfx/win/hwnd_util.h"
+
+namespace ui {
+
+InputMethodWinImm32::InputMethodWinImm32(
+    ImeKeyEventDispatcher* ime_key_event_dispatcher,
+    HWND attached_window_handle)
+    : InputMethodWinBase(ime_key_event_dispatcher, attached_window_handle),
+
+      enabled_(false),
+      is_candidate_popup_open_(false),
+      composing_window_handle_(NULL) {
+  imm32_manager_.SetInputLanguage();
+}
+
+InputMethodWinImm32::~InputMethodWinImm32() {}
+
+void InputMethodWinImm32::OnFocus() {
+  InputMethodBase::OnFocus();
+  RefreshInputLanguage();
+}
+
+bool InputMethodWinImm32::OnUntranslatedIMEMessage(
+    const CHROME_MSG event,
+    InputMethod::NativeEventResult* result) {
+  LRESULT original_result = 0;
+  BOOL handled = FALSE;
+
+  switch (event.message) {
+    case WM_IME_SETCONTEXT:
+      original_result = OnImeSetContext(event.hwnd, event.message, event.wParam,
+                                        event.lParam, &handled);
+      break;
+    case WM_IME_STARTCOMPOSITION:
+      original_result = OnImeStartComposition(
+          event.hwnd, event.message, event.wParam, event.lParam, &handled);
+      break;
+    case WM_IME_COMPOSITION:
+      original_result = OnImeComposition(event.hwnd, event.message,
+                                         event.wParam, event.lParam, &handled);
+      break;
+    case WM_IME_ENDCOMPOSITION:
+      original_result = OnImeEndComposition(
+          event.hwnd, event.message, event.wParam, event.lParam, &handled);
+      break;
+    case WM_IME_REQUEST:
+      original_result =
+          OnImeRequest(event.message, event.wParam, event.lParam, &handled);
+      break;
+    case WM_CHAR:
+    case WM_SYSCHAR:
+      original_result = OnChar(event.hwnd, event.message, event.wParam,
+                               event.lParam, event, &handled);
+      break;
+    case WM_IME_NOTIFY:
+      original_result =
+          OnImeNotify(event.message, event.wParam, event.lParam, &handled);
+      break;
+    default:
+      NOTREACHED() << "Unknown IME message:" << event.message;
+      break;
+  }
+  if (result)
+    *result = original_result;
+  return !!handled;
+}
+
+void InputMethodWinImm32::OnTextInputTypeChanged(TextInputClient* client) {
+  InputMethodBase::OnTextInputTypeChanged(client);
+  if (!IsTextInputClientFocused(client) || !IsWindowFocused(client))
+    return;
+  imm32_manager_.CancelIME(attached_window_handle_);
+  UpdateIMEState();
+}
+
+void InputMethodWinImm32::OnCaretBoundsChanged(const TextInputClient* client) {
+  if (!IsTextInputClientFocused(client) || !IsWindowFocused(client))
+    return;
+  NotifyTextInputCaretBoundsChanged(client);
+  if (!enabled_)
+    return;
+
+  // The current text input type should not be NONE if |client| is focused.
+  DCHECK(!IsTextInputTypeNone());
+  // Tentatively assume that the returned value is DIP (Density Independent
+  // Pixel). See the comment in text_input_client.h and http://crbug.com/360334.
+  const gfx::Rect dip_screen_bounds(GetTextInputClient()->GetCaretBounds());
+  const gfx::Rect screen_bounds = display::win::ScreenWin::DIPToScreenRect(
+      attached_window_handle_, dip_screen_bounds);
+
+  HWND attached_window = attached_window_handle_;
+  // TODO(ime): see comment in TextInputClient::GetCaretBounds(), this
+  // conversion shouldn't be necessary.
+  RECT r = {};
+  GetClientRect(attached_window, &r);
+  POINT window_point = {screen_bounds.x(), screen_bounds.y()};
+  ScreenToClient(attached_window, &window_point);
+  gfx::Rect caret_rect(gfx::Point(window_point.x, window_point.y),
+                       screen_bounds.size());
+  imm32_manager_.UpdateCaretRect(attached_window, caret_rect);
+}
+
+void InputMethodWinImm32::CancelComposition(const TextInputClient* client) {
+  if (IsTextInputClientFocused(client) && enabled_) {
+    imm32_manager_.CancelIME(attached_window_handle_);
+  }
+}
+
+void InputMethodWinImm32::OnInputLocaleChanged() {
+  // Note: OnInputLocaleChanged() is for capturing the input language which can
+  // be used to determine the appropriate TextInputType for Omnibox.
+  // See https://crbug.com/344834.
+  // Currently OnInputLocaleChanged() on Windows relies on WM_INPUTLANGCHANGED,
+  // which is known to be incompatible with TSF.
+  // TODO(shuchen): Use ITfLanguageProfileNotifySink instead.
+  OnInputMethodChanged();
+  RefreshInputLanguage();
+}
+
+bool InputMethodWinImm32::IsInputLocaleCJK() const {
+  return imm32_manager_.IsInputLanguageCJK();
+}
+
+bool InputMethodWinImm32::IsCandidatePopupOpen() const {
+  return is_candidate_popup_open_;
+}
+
+void InputMethodWinImm32::OnWillChangeFocusedClient(
+    TextInputClient* focused_before,
+    TextInputClient* focused) {
+  if (IsWindowFocused(focused_before))
+    ConfirmCompositionText();
+}
+
+void InputMethodWinImm32::OnDidChangeFocusedClient(
+    TextInputClient* focused_before,
+    TextInputClient* focused) {
+  if (IsWindowFocused(focused)) {
+    // Force to update the input type since client's TextInputStateChanged()
+    // function might not be called if text input types before the client loses
+    // focus and after it acquires focus again are the same.
+    OnTextInputTypeChanged(focused);
+
+    // Force to update caret bounds, in case the client thinks that the caret
+    // bounds has not changed.
+    OnCaretBoundsChanged(focused);
+  }
+  InputMethodWinBase::OnDidChangeFocusedClient(focused_before, focused);
+}
+
+LRESULT InputMethodWinImm32::OnImeSetContext(HWND window_handle,
+                                             UINT message,
+                                             WPARAM wparam,
+                                             LPARAM lparam,
+                                             BOOL* handled) {
+  if (!!wparam) {
+    imm32_manager_.CreateImeWindow(window_handle);
+    // Delay initialize the tsf to avoid perf regression.
+    // Loading tsf dll causes some time, so doing it in UpdateIMEState() will
+    // slow down the browser window creation.
+    // See https://crbug.com/509984.
+    tsf_inputscope::InitializeTsfForInputScopes();
+    tsf_inputscope::SetInputScopeForTsfUnawareWindow(
+        attached_window_handle_, GetTextInputType(), GetTextInputMode());
+  }
+
+  OnInputMethodChanged();
+  return imm32_manager_.SetImeWindowStyle(window_handle, message, wparam,
+                                          lparam, handled);
+}
+
+LRESULT InputMethodWinImm32::OnImeStartComposition(HWND window_handle,
+                                                   UINT message,
+                                                   WPARAM wparam,
+                                                   LPARAM lparam,
+                                                   BOOL* handled) {
+  // We have to prevent WTL from calling ::DefWindowProc() because the function
+  // calls ::ImmSetCompositionWindow() and ::ImmSetCandidateWindow() to
+  // over-write the position of IME windows.
+  *handled = TRUE;
+
+  // Reset the composition status and create IME windows.
+  composing_window_handle_ = window_handle;
+  imm32_manager_.CreateImeWindow(window_handle);
+  imm32_manager_.ResetComposition(window_handle);
+  return 0;
+}
+
+LRESULT InputMethodWinImm32::OnImeComposition(HWND window_handle,
+                                              UINT message,
+                                              WPARAM wparam,
+                                              LPARAM lparam,
+                                              BOOL* handled) {
+  // We have to prevent WTL from calling ::DefWindowProc() because we do not
+  // want for the IMM (Input Method Manager) to send WM_IME_CHAR messages.
+  *handled = TRUE;
+
+  // At first, update the position of the IME window.
+  imm32_manager_.UpdateImeWindow(window_handle);
+
+  // Retrieve the result string and its attributes of the ongoing composition
+  // and send it to a renderer process.
+  ui::CompositionText composition;
+  if (imm32_manager_.GetResult(window_handle, lparam, &composition.text)) {
+    if (!IsTextInputTypeNone())
+      GetTextInputClient()->InsertText(
+          composition.text,
+          ui::TextInputClient::InsertTextCursorBehavior::kMoveCursorAfterText);
+    imm32_manager_.ResetComposition(window_handle);
+    // Fall though and try reading the composition string.
+    // Japanese IMEs send a message containing both GCS_RESULTSTR and
+    // GCS_COMPSTR, which means an ongoing composition has been finished
+    // by the start of another composition.
+  }
+  // Retrieve the composition string and its attributes of the ongoing
+  // composition and send it to a renderer process.
+  if (imm32_manager_.GetComposition(window_handle, lparam, &composition) &&
+      !IsTextInputTypeNone())
+    GetTextInputClient()->SetCompositionText(composition);
+
+  return 0;
+}
+
+LRESULT InputMethodWinImm32::OnImeEndComposition(HWND window_handle,
+                                                 UINT message,
+                                                 WPARAM wparam,
+                                                 LPARAM lparam,
+                                                 BOOL* handled) {
+  // Let WTL call ::DefWindowProc() and release its resources.
+  *handled = FALSE;
+
+  composing_window_handle_ = NULL;
+
+  // This is a hack fix for MS Korean IME issue (https://crbug.com/647150).
+  // Messages received when hitting Space key during composition:
+  //   1. WM_IME_ENDCOMPOSITION (we usually clear composition for this MSG)
+  //   2. WM_IME_COMPOSITION with GCS_RESULTSTR (we usually commit composition)
+  // (Which is in the reversed order compared to MS Japanese and Chinese IME.)
+  // Hack fix:
+  //   * Discard WM_IME_ENDCOMPOSITION message if it's followed by a
+  //     WM_IME_COMPOSITION message with GCS_RESULTSTR.
+  // This works because we don't require WM_IME_ENDCOMPOSITION after committing
+  // composition (it doesn't do anything if there is no on-going composition).
+  // Also see Firefox's implementation:
+  // https://dxr.mozilla.org/mozilla-beta/source/widget/windows/IMMHandler.cpp#800
+  // TODO(crbug.com/654865): Further investigations and clean-ups required.
+  CHROME_MSG compositionMsg;
+  if (::PeekMessage(ChromeToWindowsType(&compositionMsg), window_handle,
+                    WM_IME_STARTCOMPOSITION, WM_IME_COMPOSITION, PM_NOREMOVE) &&
+      compositionMsg.message == WM_IME_COMPOSITION &&
+      (compositionMsg.lParam & GCS_RESULTSTR))
+    return 0;
+
+  if (!IsTextInputTypeNone() && GetTextInputClient()->HasCompositionText())
+    GetTextInputClient()->ClearCompositionText();
+
+  imm32_manager_.ResetComposition(window_handle);
+  imm32_manager_.DestroyImeWindow(window_handle);
+  return 0;
+}
+
+LRESULT InputMethodWinImm32::OnImeNotify(UINT message,
+                                         WPARAM wparam,
+                                         LPARAM lparam,
+                                         BOOL* handled) {
+  *handled = FALSE;
+
+  // Update |is_candidate_popup_open_|, whether a candidate window is open.
+  switch (wparam) {
+    case IMN_OPENCANDIDATE:
+      is_candidate_popup_open_ = true;
+      break;
+    case IMN_CLOSECANDIDATE:
+      is_candidate_popup_open_ = false;
+      break;
+  }
+
+  return 0;
+}
+
+void InputMethodWinImm32::RefreshInputLanguage() {
+  TextInputType type_original = GetTextInputType();
+  imm32_manager_.SetInputLanguage();
+  if (type_original != GetTextInputType()) {
+    // Only update the IME state when necessary.
+    // It's unnecessary to report IME state, when:
+    // 1) Switching betweeen 2 top-level windows, and the switched-away window
+    //    receives OnInputLocaleChanged.
+    // 2) The text input type is not changed by |SetInputLanguage|.
+    // Please refer to https://crbug.com/679564.
+    UpdateIMEState();
+  }
+}
+
+void InputMethodWinImm32::ConfirmCompositionText() {
+  // Makes sure the native IME app can be informed about the composition is
+  // cleared, so that it can clean up its internal states.
+  if (composing_window_handle_)
+    imm32_manager_.CleanupComposition(composing_window_handle_);
+}
+
+TextInputMode InputMethodWinImm32::GetTextInputMode() const {
+  TextInputClient* client = GetTextInputClient();
+  return client ? client->GetTextInputMode() : TEXT_INPUT_MODE_DEFAULT;
+}
+
+void InputMethodWinImm32::UpdateIMEState() {
+  // Use switch here in case we are going to add more text input types.
+  // We disable input method in password field.
+  const HWND window_handle = attached_window_handle_;
+  const TextInputType text_input_type = GetTextInputType();
+  const TextInputMode text_input_mode = GetTextInputMode();
+  switch (text_input_type) {
+    case ui::TEXT_INPUT_TYPE_NONE:
+    case ui::TEXT_INPUT_TYPE_PASSWORD:
+      imm32_manager_.DisableIME(window_handle);
+      enabled_ = false;
+      break;
+    default:
+      imm32_manager_.EnableIME(window_handle);
+      enabled_ = true;
+      break;
+  }
+
+  imm32_manager_.SetTextInputMode(window_handle, text_input_mode);
+  tsf_inputscope::SetInputScopeForTsfUnawareWindow(
+      window_handle, text_input_type, text_input_mode);
+}
+
+}  // namespace ui
diff --git a/ui/base/ime/win/input_method_win_imm32.h b/ui/base/ime/win/input_method_win_imm32.h
new file mode 100644
index 0000000000000..503399af4e060
--- /dev/null
+++ b/ui/base/ime/win/input_method_win_imm32.h
@@ -0,0 +1,104 @@
+// Copyright 2011 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_IME_WIN_INPUT_METHOD_WIN_IMM32_H_
+#define UI_BASE_IME_WIN_INPUT_METHOD_WIN_IMM32_H_
+
+#include <windows.h>
+
+#include "base/component_export.h"
+#include "ui/base/ime/win/imm32_manager.h"
+#include "ui/base/ime/win/input_method_win_base.h"
+
+namespace ui {
+
+// A common InputMethod implementation based on IMM32.
+class COMPONENT_EXPORT(UI_BASE_IME_WIN) InputMethodWinImm32
+    : public InputMethodWinBase {
+ public:
+  InputMethodWinImm32(ImeKeyEventDispatcher* ime_key_event_dispatcher,
+                      HWND attached_window_handle);
+
+  InputMethodWinImm32(const InputMethodWinImm32&) = delete;
+  InputMethodWinImm32& operator=(const InputMethodWinImm32&) = delete;
+
+  ~InputMethodWinImm32() override;
+
+  // Overridden from InputMethodBase:
+  void OnFocus() override;
+
+  // Overridden from InputMethod:
+  bool OnUntranslatedIMEMessage(const CHROME_MSG event,
+                                NativeEventResult* result) override;
+  void OnTextInputTypeChanged(TextInputClient* client) override;
+  void OnCaretBoundsChanged(const TextInputClient* client) override;
+  void CancelComposition(const TextInputClient* client) override;
+  void OnInputLocaleChanged() override;
+  bool IsInputLocaleCJK() const override;
+  bool IsCandidatePopupOpen() const override;
+
+ protected:
+  // Overridden from InputMethodBase:
+  // If a derived class overrides this method, it should call parent's
+  // implementation.
+  void OnWillChangeFocusedClient(TextInputClient* focused_before,
+                                 TextInputClient* focused) override;
+  void OnDidChangeFocusedClient(TextInputClient* focused_before,
+                                TextInputClient* focused) override;
+
+ private:
+  LRESULT OnImeSetContext(HWND window_handle,
+                          UINT message,
+                          WPARAM wparam,
+                          LPARAM lparam,
+                          BOOL* handled);
+  LRESULT OnImeStartComposition(HWND window_handle,
+                                UINT message,
+                                WPARAM wparam,
+                                LPARAM lparam,
+                                BOOL* handled);
+  LRESULT OnImeComposition(HWND window_handle,
+                           UINT message,
+                           WPARAM wparam,
+                           LPARAM lparam,
+                           BOOL* handled);
+  LRESULT OnImeEndComposition(HWND window_handle,
+                              UINT message,
+                              WPARAM wparam,
+                              LPARAM lparam,
+                              BOOL* handled);
+  LRESULT OnImeNotify(UINT message,
+                      WPARAM wparam,
+                      LPARAM lparam,
+                      BOOL* handled);
+
+  void RefreshInputLanguage();
+
+  // Enables or disables the IME according to the current text input type.
+  void UpdateIMEState();
+
+  void ConfirmCompositionText();
+
+  // Gets the text input mode of the focused text input client. Returns
+  // ui::TEXT_INPUT_MODE_DEFAULT if there is no focused client.
+  TextInputMode GetTextInputMode() const;
+
+  // Windows IMM32 wrapper.
+  // (See "ui/base/ime/win/ime_input.h" for its details.)
+  ui::IMM32Manager imm32_manager_;
+
+  // True when an IME should be allowed to process key events.
+  bool enabled_;
+
+  // True if we know for sure that a candidate window is open.
+  bool is_candidate_popup_open_;
+
+  // Window handle where composition is on-going. NULL when there is no
+  // composition.
+  HWND composing_window_handle_;
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_IME_WIN_INPUT_METHOD_WIN_IMM32_H_
diff --git a/ui/views/corewm/cursor_height_provider_win.cc b/ui/views/corewm/cursor_height_provider_win.cc
new file mode 100644
index 0000000000000..aed9fdce181db
--- /dev/null
+++ b/ui/views/corewm/cursor_height_provider_win.cc
@@ -0,0 +1,178 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/corewm/cursor_height_provider_win.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <windows.h>
+
+#include <algorithm>
+#include <map>
+#include <memory>
+
+#include "base/numerics/safe_conversions.h"
+#include "base/win/scoped_hdc.h"
+
+namespace {
+using PixelData = std::unique_ptr<uint32_t[]>;
+using HeightStorage = std::map<HCURSOR, int>;
+
+const uint32_t kBitsPeruint32 = sizeof(uint32_t) * 8;
+// All bits are 1 for transparent portion of monochromatic mask.
+constexpr uint32_t kTransparentMask = 0xffffffff;
+// This is height of default pointer arrow in Windows 7.
+constexpr int kDefaultHeight = 20;
+// Masks are monochromatic.
+constexpr size_t kNumberOfColors = 2;
+const size_t kHeaderAndPalette =
+    sizeof(BITMAPINFOHEADER) + kNumberOfColors * sizeof(RGBQUAD);
+
+HeightStorage* cached_heights = nullptr;
+
+// Extracts the pixel data of provided bitmap
+PixelData GetBitmapData(HBITMAP handle, const BITMAPINFO& info, HDC hdc) {
+  PixelData data;
+  // Masks are monochromatic.
+  DCHECK_EQ(info.bmiHeader.biBitCount, 1);
+  if (info.bmiHeader.biBitCount != 1)
+    return data;
+
+  // When getting pixel data palette is appended to memory pointed by
+  // BITMAPINFO passed so allocate additional memory to store additional data.
+  auto header = std::make_unique<char[]>(kHeaderAndPalette);
+  memcpy(header.get(), &(info.bmiHeader), sizeof(info.bmiHeader));
+
+  data = std::make_unique<uint32_t[]>(info.bmiHeader.biSizeImage /
+                                      sizeof(uint32_t));
+
+  int result = GetDIBits(
+      hdc, handle, 0, static_cast<UINT>(info.bmiHeader.biHeight), data.get(),
+      reinterpret_cast<BITMAPINFO*>(header.get()), DIB_RGB_COLORS);
+
+  if (result == 0)
+    data.reset();
+
+  return data;
+}
+
+// Checks if the specifed row is transparent in provided bitmap.
+bool IsRowTransparent(const PixelData& data,
+                      const uint32_t row_size,
+                      const uint32_t last_byte_mask,
+                      const uint32_t y) {
+  // Set the padding bits to 1 to make mask matching easier.
+  *(data.get() + (y + 1) * row_size - 1) |= last_byte_mask;
+  for (uint32_t i = y * row_size; i < (y + 1) * row_size; ++i) {
+    if (*(data.get() + i) != kTransparentMask)
+      return false;
+  }
+  return true;
+}
+
+// Gets the vertical offset between specified cursor's hotpoint and its bottom.
+//
+// Gets the cursor image data and extract cursor's visible height.
+// Based on that gets what should be the vertical offset between cursor's
+// hot point and the tooltip.
+int CalculateCursorHeight(HCURSOR cursor_handle) {
+  base::win::ScopedGetDC hdc(nullptr);
+
+  ICONINFO icon = {0};
+  GetIconInfo(cursor_handle, &icon);
+
+  BITMAPINFO bitmap_info = {};
+  bitmap_info.bmiHeader.biSize = sizeof(bitmap_info.bmiHeader);
+  if (GetDIBits(hdc, icon.hbmMask, 0, 0, nullptr, &bitmap_info,
+                DIB_RGB_COLORS) == 0)
+    return kDefaultHeight;
+
+  // Rows are padded to full DWORDs. OR with this mask will set them to 1
+  // to simplify matching with |transparent_mask|.
+  uint32_t last_byte_mask = 0xFFFFFFFF;
+  const auto width = static_cast<uint32_t>(bitmap_info.bmiHeader.biWidth);
+  const unsigned char bits_to_shift =
+      sizeof(last_byte_mask) * 8 - (width % kBitsPeruint32);
+  if (bits_to_shift != kBitsPeruint32)
+    last_byte_mask = (last_byte_mask << bits_to_shift);
+  else
+    last_byte_mask = 0;
+
+  const uint32_t row_size = (width + kBitsPeruint32 - 1) / kBitsPeruint32;
+  PixelData data(GetBitmapData(icon.hbmMask, bitmap_info, hdc));
+  if (data == nullptr)
+    return kDefaultHeight;
+
+  // There are 2 types of cursors: Ones that cover the area underneath
+  // completely (i.e. hand cursor) and ones that partially cover
+  // and partially blend with background (i. e. I-beam cursor).
+  // These will have either 1 square mask or 2 masks stacked on top
+  // of each other (xor mask and and mask).
+  const bool has_xor_mask =
+      bitmap_info.bmiHeader.biHeight == 2 * bitmap_info.bmiHeader.biWidth;
+  const auto height = static_cast<uint32_t>(bitmap_info.bmiHeader.biHeight);
+  const uint32_t cursor_height = has_xor_mask ? height / 2 : height;
+  uint32_t xor_offset;
+  if (has_xor_mask) {
+    for (xor_offset = 0; xor_offset < cursor_height; ++xor_offset) {
+      const uint32_t row_start = row_size * xor_offset;
+      const uint32_t row_boundary = row_start + row_size;
+      for (uint32_t i = row_start; i < row_boundary; ++i)
+        data.get()[i] = ~(data.get()[i]);
+      if (!IsRowTransparent(data, row_size, last_byte_mask, xor_offset)) {
+        break;
+      }
+    }
+  } else {
+    xor_offset = cursor_height;
+  }
+
+  uint32_t and_offset;
+
+  for (and_offset = has_xor_mask ? cursor_height : 0; and_offset < height;
+       ++and_offset) {
+    if (!IsRowTransparent(data, row_size, last_byte_mask, and_offset)) {
+      break;
+    }
+  }
+  if (has_xor_mask) {
+    and_offset -= cursor_height;
+  }
+  const uint32_t offset = std::min(xor_offset, and_offset);
+
+  DeleteObject(icon.hbmColor);
+  DeleteObject(icon.hbmMask);
+
+  // Apparently it's possible for the calculation here to underflow, and thus
+  // result in a negative value, maybe if the hotspot is below any visible
+  // portion of the cursor.  Not sure if this case should return 0 instead.
+  return static_cast<int>(cursor_height - offset - icon.yHotspot + 1);
+}
+
+}  // namespace
+
+namespace views {
+namespace corewm {
+
+int GetCurrentCursorVisibleHeight() {
+  CURSORINFO cursor = {0};
+  cursor.cbSize = sizeof(cursor);
+  GetCursorInfo(&cursor);
+
+  if (cached_heights == nullptr)
+    cached_heights = new HeightStorage;
+
+  HeightStorage::const_iterator cached_height =
+      cached_heights->find(cursor.hCursor);
+  if (cached_height != cached_heights->end())
+    return cached_height->second;
+
+  const int height = CalculateCursorHeight(cursor.hCursor);
+  (*cached_heights)[cursor.hCursor] = height;
+
+  return height;
+}
+
+}  // namespace corewm
+}  // namespace views
diff --git a/ui/views/corewm/cursor_height_provider_win.h b/ui/views/corewm/cursor_height_provider_win.h
new file mode 100644
index 0000000000000..ce0bf65a96948
--- /dev/null
+++ b/ui/views/corewm/cursor_height_provider_win.h
@@ -0,0 +1,21 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
+#define UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
+
+namespace views {
+namespace corewm {
+
+// Gets the visible height of current cursor.
+//
+// The height is offset between cursor's hot point and it's
+// bottom edge, derived from first non-transparent row of cursor's mask.
+
+int GetCurrentCursorVisibleHeight();
+
+}  // namespace corewm
+}  // namespace views
+
+#endif  // UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
diff --git a/ui/views/corewm/tooltip_win.cc b/ui/views/corewm/tooltip_win.cc
new file mode 100644
index 0000000000000..2d3f0f52dc16a
--- /dev/null
+++ b/ui/views/corewm/tooltip_win.cc
@@ -0,0 +1,186 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/corewm/tooltip_win.h"
+
+#include "base/i18n/rtl.h"
+#include "base/logging.h"
+#include "base/strings/string_util_win.h"
+#include "base/win/windowsx_shim.h"
+#include "ui/aura/window.h"
+#include "ui/base/l10n/l10n_util_win.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/display/win/screen_win.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/system_fonts_win.h"
+#include "ui/views/corewm/cursor_height_provider_win.h"
+
+namespace views::corewm {
+
+TooltipWin::TooltipWin(HWND parent)
+    : parent_hwnd_(parent), tooltip_hwnd_(nullptr), showing_(false) {
+  memset(&toolinfo_, 0, sizeof(toolinfo_));
+  toolinfo_.cbSize = sizeof(toolinfo_);
+  toolinfo_.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_ABSOLUTE;
+  toolinfo_.uId = reinterpret_cast<UINT_PTR>(parent_hwnd_);
+  toolinfo_.hwnd = parent_hwnd_;
+  toolinfo_.lpszText = nullptr;
+  toolinfo_.lpReserved = nullptr;
+  SetRectEmpty(&toolinfo_.rect);
+}
+
+TooltipWin::~TooltipWin() {
+  if (tooltip_hwnd_)
+    DestroyWindow(tooltip_hwnd_);
+}
+
+bool TooltipWin::HandleNotify(int w_param, NMHDR* l_param, LRESULT* l_result) {
+  if (tooltip_hwnd_ == nullptr)
+    return false;
+
+  switch (l_param->code) {
+    case TTN_POP:
+      showing_ = false;
+      return true;
+    case TTN_SHOW:
+      *l_result = TRUE;
+      PositionTooltip();
+      showing_ = true;
+      return true;
+    default:
+      break;
+  }
+  return false;
+}
+
+bool TooltipWin::EnsureTooltipWindow() {
+  if (tooltip_hwnd_)
+    return true;
+
+  tooltip_hwnd_ =
+      CreateWindowEx(WS_EX_TRANSPARENT | l10n_util::GetExtendedTooltipStyles(),
+                     TOOLTIPS_CLASS, nullptr, TTS_NOPREFIX | WS_POPUP, 0, 0, 0,
+                     0, parent_hwnd_, nullptr, nullptr, nullptr);
+  if (!tooltip_hwnd_) {
+    PLOG(WARNING) << "tooltip creation failed, disabling tooltips";
+    return false;
+  }
+
+  MaybeOverrideFont();
+
+  SendMessage(tooltip_hwnd_, TTM_ADDTOOL, 0,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+  return true;
+}
+
+void TooltipWin::PositionTooltip() {
+  gfx::Point screen_point =
+      display::win::ScreenWin::DIPToScreenPoint(anchor_point_);
+  const int cursoroffset = GetCurrentCursorVisibleHeight();
+  screen_point.Offset(0, cursoroffset);
+
+  LRESULT tooltip_size = SendMessage(tooltip_hwnd_, TTM_GETBUBBLESIZE, 0,
+                                     reinterpret_cast<LPARAM>(&toolinfo_));
+  const gfx::Size size(LOWORD(tooltip_size), HIWORD(tooltip_size));
+
+  const display::Display display(
+      display::Screen::GetScreen()->GetDisplayNearestPoint(anchor_point_));
+
+  gfx::Rect tooltip_bounds(screen_point, size);
+  // Align the center of the tooltip with the position when the tooltip is not
+  // following the cursor.
+  if (trigger_ == TooltipTrigger::kKeyboard)
+    tooltip_bounds.Offset(-size.width() / 2, 0);
+  else if (base::i18n::IsRTL())
+    tooltip_bounds.Offset(-size.width(), 0);
+  tooltip_bounds.AdjustToFit(display::win::ScreenWin::DIPToScreenRect(
+      parent_hwnd_, display.work_area()));
+  SetWindowPos(tooltip_hwnd_, nullptr, tooltip_bounds.x(), tooltip_bounds.y(),
+               0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
+
+  MaybeOverrideFont();
+}
+
+void TooltipWin::MaybeOverrideFont() {
+ // gfx::win::FontAdjustment font_adjustment;
+ // const HFONT old_font = GetWindowFont(tooltip_hwnd_);
+
+  // Determine if we need to override the font.
+ // if ((!override_font_.get() || override_font_.get() != old_font) &&
+ //     l10n_util::NeedOverrideDefaultUIFont(
+//          &font_adjustment.font_family_override, &font_adjustment.font_scale)) {
+    // Determine if we need to regenerate the font.
+    // There are a number of situations under which Windows can replace the
+    // font in a tooltip, but we don't actually need to regenerate our override
+    // font unless the underlying text/DPI scale of the window has changed.
+//    const float current_scale =
+ //       display::win::ScreenWin::GetScaleFactorForHWND(tooltip_hwnd_);
+//    if (!override_font_.get() || current_scale != override_scale_) {
+  //    override_font_.reset(
+  //        gfx::win::AdjustExistingSystemFont(old_font, font_adjustment));
+//      override_scale_ = current_scale;
+ //   }
+
+    // Override the font in the tooltip.
+//    SetWindowFont(tooltip_hwnd_, override_font_.get(), FALSE);
+  }
+//}
+
+int TooltipWin::GetMaxWidth(const gfx::Point& location) const {
+  const gfx::Point screen_point =
+      display::win::ScreenWin::DIPToScreenPoint(location);
+  display::Display display(
+      display::Screen::GetScreen()->GetDisplayNearestPoint(screen_point));
+  const gfx::Rect monitor_bounds = display.bounds();
+  return (monitor_bounds.width() + 1) / 2;
+}
+
+void TooltipWin::Update(aura::Window* window,
+                        const std::u16string& tooltip_text,
+                        const gfx::Point& position,
+                        const TooltipTrigger trigger) {
+  if (!EnsureTooltipWindow())
+    return;
+
+  // See comment in header for details on why `anchor_point_` and `trigger_` are
+  // needed here.
+  anchor_point_ = position + window->GetBoundsInScreen().OffsetFromOrigin();
+  trigger_ = trigger;
+
+  std::u16string adjusted_text(tooltip_text);
+  base::i18n::AdjustStringForLocaleDirection(&adjusted_text);
+  toolinfo_.lpszText = base::as_writable_wcstr(adjusted_text);
+  SendMessage(tooltip_hwnd_, TTM_SETTOOLINFO, 0,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+
+  int max_width = GetMaxWidth(anchor_point_);
+  SendMessage(tooltip_hwnd_, TTM_SETMAXTIPWIDTH, 0, max_width);
+}
+
+void TooltipWin::Show() {
+  if (!EnsureTooltipWindow())
+    return;
+
+  SendMessage(tooltip_hwnd_, TTM_TRACKACTIVATE, TRUE,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+
+  // Bring the window to the front.
+  SetWindowPos(tooltip_hwnd_, HWND_TOPMOST, 0, 0, 0, 0,
+               SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);
+}
+
+void TooltipWin::Hide() {
+  if (!tooltip_hwnd_)
+    return;
+
+  SendMessage(tooltip_hwnd_, TTM_TRACKACTIVATE, FALSE,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+}
+
+bool TooltipWin::IsVisible() {
+  return showing_;
+}
+
+}  // namespace views::corewm
diff --git a/ui/views/corewm/tooltip_win.h b/ui/views/corewm/tooltip_win.h
new file mode 100644
index 0000000000000..8f131b8d1bf86
--- /dev/null
+++ b/ui/views/corewm/tooltip_win.h
@@ -0,0 +1,92 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_COREWM_TOOLTIP_WIN_H_
+#define UI_VIEWS_COREWM_TOOLTIP_WIN_H_
+
+#include <windows.h>  // Must come before other Windows system headers.
+
+#include <commctrl.h>
+
+#include <string>
+
+#include "base/win/scoped_gdi_object.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/views/corewm/tooltip.h"
+
+namespace wm {
+class TooltipObserver;
+}
+
+namespace views::corewm {
+
+// Implementation of Tooltip that uses the native win32 control for showing the
+// tooltip.
+class VIEWS_EXPORT TooltipWin : public Tooltip {
+ public:
+  explicit TooltipWin(HWND parent);
+
+  TooltipWin(const TooltipWin&) = delete;
+  TooltipWin& operator=(const TooltipWin&) = delete;
+
+  ~TooltipWin() override;
+
+  void AddObserver(wm::TooltipObserver* observer) override {}
+  void RemoveObserver(wm::TooltipObserver* observer) override {}
+
+  // HandleNotify() is forwarded from DesktopWindowTreeHostWin to keep the
+  // native tooltip in sync.
+  bool HandleNotify(int w_param, NMHDR* l_param, LRESULT* l_result);
+
+ private:
+  // Ensures |tooltip_hwnd_| is valid. Returns true if valid, false if there
+  // a problem creating |tooltip_hwnd_|.
+  bool EnsureTooltipWindow();
+
+  // Sets the position of the tooltip.
+  void PositionTooltip();
+
+  // Might override the font size for localization (e.g. Hindi).
+  void MaybeOverrideFont();
+
+  // Tooltip:
+  int GetMaxWidth(const gfx::Point& location) const override;
+  void Update(aura::Window* window,
+              const std::u16string& tooltip_text,
+              const gfx::Point& position,
+              const TooltipTrigger trigger) override;
+  void Show() override;
+  void Hide() override;
+  bool IsVisible() override;
+
+  // Font we're currently overriding our UI font with.
+  // Should outlast |tooltip_hwnd_|.
+  base::win::ScopedHFONT override_font_;
+
+  // The window |tooltip_hwnd_| is parented to.
+  HWND parent_hwnd_;
+
+  // Shows the tooltip.
+  HWND tooltip_hwnd_;
+
+  // Used to modify the tooltip.
+  TOOLINFO toolinfo_;
+
+  // Is the tooltip showing?
+  bool showing_;
+
+  // In order to position the tooltip we need to know the size. The size is only
+  // available from TTN_SHOW, so we have to cache `anchor_point_` and `trigger_`
+  // which are required to calculate its position.
+  gfx::Point anchor_point_;
+  TooltipTrigger trigger_ = TooltipTrigger::kCursor;
+
+  // What the scale was the last time we overrode the font, to see if we can
+  // re-use our previous override.
+  float override_scale_ = 0.0f;
+};
+
+}  // namespace views::corewm
+
+#endif  // UI_VIEWS_COREWM_TOOLTIP_WIN_H_
