diff --git a/README.md b/README.md
index 590f4c94f2067..f5f245da9dacb 100644
--- a/README.md
+++ b/README.md
@@ -1,21 +1,2 @@
-# ![Logo](chrome/app/theme/chromium/product_logo_64.png) Chromium
-
-Chromium is an open-source browser project that aims to build a safer, faster,
-and more stable way for all users to experience the web.
-
-The project's web site is https://www.chromium.org.
-
-To check out the source code locally, don't use `git clone`! Instead,
-follow [the instructions on how to get the code](docs/get_the_code.md).
-
-Documentation in the source is rooted in [docs/README.md](docs/README.md).
-
-Learn how to [Get Around the Chromium Source Code Directory
-Structure](https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code).
-
-For historical reasons, there are some small top level directories. Now the
-guidance is that new top level directories are for product (e.g. Chrome,
-Android WebView, Ash). Even if these products have multiple executables, the
-code should be in subdirectories of the product.
-
-If you found a bug, please file it at https://crbug.com/new.
+# Supermium + Thorium
+A compiler optimized, Chromium-based browser for Windows Vista (exkernel), 7 and 8.x.
diff --git a/base/BUILD.gn b/base/BUILD.gn
index c00c41bc2c7fd..2f4557aa18fde 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -135,11 +135,6 @@ if (is_win) {
     ldflags = [
       # Linking with shcore.lib causes the shcore api forwarder dll to load.
       "/DELAYLOAD:api-ms-win-shcore-scaling-l1-1-1.dll",
-
-      # Linking with OneCore.lib causes the next three dlls to load.
-      "/DELAYLOAD:api-ms-win-core-realtime-l1-1-1.dll",
-      "/DELAYLOAD:api-ms-win-power-base-l1-1-0.dll",
-      "/DELAYLOAD:api-ms-win-power-setting-l1-1-0.dll",
       "/DELAYLOAD:cfgmgr32.dll",
       "/DELAYLOAD:powrprof.dll",
       "/DELAYLOAD:setupapi.dll",
@@ -1921,7 +1916,6 @@ component("base") {
     libs += [
       "cfgmgr32.lib",
       "ntdll.lib",
-      "onecore.lib",
       "pdh.lib",
       "powrprof.lib",
       "propsys.lib",
diff --git a/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h b/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h
index 44ef45c3e325f..994060bee0a78 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h
@@ -16,6 +16,17 @@
 
 namespace partition_alloc::internal {
 
+namespace {
+
+// On Windows, discarded pages are not returned to the system immediately and
+// not guaranteed to be zeroed when returned to the application.
+using DiscardVirtualMemoryFunction = DWORD(WINAPI*)(PVOID virtualAddress,
+                                                    SIZE_T size);
+DiscardVirtualMemoryFunction s_discard_virtual_memory =
+    reinterpret_cast<DiscardVirtualMemoryFunction>(-1);
+
+}  // namespace
+
 // |VirtualAlloc| will fail if allocation at the hint address is blocked.
 constexpr bool kHintIsAdvisory = false;
 std::atomic<int32_t> s_allocPageErrorCode{ERROR_SUCCESS};
@@ -226,12 +237,20 @@ bool TryRecommitSystemPagesInternal(
 }
 
 void DiscardSystemPagesInternal(uintptr_t address, size_t length) {
+  if (s_discard_virtual_memory ==
+      reinterpret_cast<DiscardVirtualMemoryFunction>(-1)) {
+      s_discard_virtual_memory =
+          reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+              GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+  }
+
   void* ptr = reinterpret_cast<void*>(address);
   // Use DiscardVirtualMemory when available because it releases faster than
   // MEM_RESET.
-  DWORD ret = DiscardVirtualMemory(ptr, length);
-  // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
-  // failure.
+  DWORD ret = 1;
+  if (s_discard_virtual_memory) {
+    ret = s_discard_virtual_memory(ptr, length);
+  }
   if (ret) {
     PA_CHECK(VirtualAllocWithRetry(ptr, length, MEM_RESET, PAGE_READWRITE));
   }
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc
index 39e574a61a3eb..37ba12bfa8c46 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc
@@ -43,6 +43,34 @@ namespace {
 
 #if BUILDFLAG(IS_WIN)
 
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+bool IsLegacyWindowsVersion() {
+  // Use ::RtlGetVersion instead of ::GetVersionEx or helpers from
+  // VersionHelpers.h because those alternatives change their behavior depending
+  // on whether or not the calling executable has a compatibility manifest
+  // resource. It's better for the allocator to not depend on that to decide the
+  // pool size.
+  // Assume legacy if ::RtlGetVersion is not available or it fails.
+  using RtlGetVersion = LONG(WINAPI*)(OSVERSIONINFOEX*);
+  const RtlGetVersion rtl_get_version = reinterpret_cast<RtlGetVersion>(
+      ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"), "RtlGetVersion"));
+  if (!rtl_get_version) {
+    return true;
+  }
+
+  OSVERSIONINFOEX version_info = {};
+  version_info.dwOSVersionInfoSize = sizeof(version_info);
+  if (rtl_get_version(&version_info) != ERROR_SUCCESS) {
+    return true;
+  }
+
+  // Anything prior to Windows 8.1 is considered legacy for the allocator.
+  // Windows 8.1 is major 6 with minor 3.
+  return version_info.dwMajorVersion < 6 ||
+         (version_info.dwMajorVersion == 6 && version_info.dwMinorVersion < 3);
+}
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+
 PA_NOINLINE void HandlePoolAllocFailureOutOfVASpace() {
   PA_NO_CODE_FOLDING();
   PA_CHECK(false);
@@ -67,9 +95,9 @@ PA_NOINLINE void HandlePoolAllocFailure() {
     HandlePoolAllocFailureOutOfVASpace();
   } else if (alloc_page_error_code == ERROR_COMMITMENT_LIMIT ||
              alloc_page_error_code == ERROR_COMMITMENT_MINIMUM) {
-    // Should not happen, since as of Windows 8.1+, reserving address space
-    // should not be charged against the commit limit, aside from a very small
-    // amount per 64kiB block. Keep this path anyway, to check in crash reports.
+    // On Windows <8.1, MEM_RESERVE increases commit charge to account for
+    // not-yet-committed PTEs needed to cover that VA space, if it was to be
+    // committed (see crbug.com/1101421#c16).
     HandlePoolAllocFailureOutOfCommitCharge();
   } else
 #endif  // BUILDFLAG(IS_WIN)
@@ -88,10 +116,7 @@ std::ptrdiff_t PartitionAddressSpace::brp_pool_shadow_offset_ = 0;
 #endif
 
 #if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
-#if !BUILDFLAG(IS_IOS)
-#error Dynamic pool size is only supported on iOS.
-#endif
-
+#if BUILDFLAG(IS_IOS)
 namespace {
 bool IsIOSTestProcess() {
   // On iOS, only applications with the extended virtual addressing entitlement
@@ -133,6 +158,15 @@ PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
 PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
   return IsIOSTestProcess() ? kBRPPoolSizeForIOSTestProcess : kBRPPoolSize;
 }
+#else
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
+  return IsLegacyWindowsVersion() ? kRegularPoolSizeForLegacyWindows
+                                  : kRegularPoolSize;
+}
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
+  return IsLegacyWindowsVersion() ? kBRPPoolSizeForLegacyWindows : kBRPPoolSize;
+}
+#endif  // BUILDFLAG(IS_IOS)
 #endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
 
 void PartitionAddressSpace::Init() {
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h
index 0b115ee775d6d..046918e248fb7 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h
@@ -276,6 +276,16 @@ class PA_COMPONENT_EXPORT(PARTITION_ALLOC) PartitionAddressSpace {
   static constexpr size_t kThreadIsolatedPoolSize = kGiB / 4;
   static_assert(std::has_single_bit(kThreadIsolatedPoolSize));
 #endif
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+  // We can't afford pool sizes as large as kPoolMaxSize on Windows <8.1 (see
+  // crbug.com/1101421 and crbug.com/1217759).
+  static constexpr size_t kRegularPoolSizeForLegacyWindows = 4 * kGiB;
+  static constexpr size_t kBRPPoolSizeForLegacyWindows = 4 * kGiB;
+  static_assert(kRegularPoolSizeForLegacyWindows < kRegularPoolSize);
+  static_assert(kBRPPoolSizeForLegacyWindows < kBRPPoolSize);
+  static_assert(std::has_single_bit(kRegularPoolSizeForLegacyWindows));
+  static_assert(std::has_single_bit(kBRPPoolSizeForLegacyWindows));
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
   static constexpr size_t kConfigurablePoolMaxSize = kPoolMaxSize;
   static constexpr size_t kConfigurablePoolMinSize = 1 * kGiB;
   static_assert(kConfigurablePoolMinSize <= kConfigurablePoolMaxSize);
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc
index fd1de0bd29861..c6d5a39bfe2e3 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc
@@ -13,31 +13,27 @@
 
 #include "partition_alloc/partition_alloc_base/check.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
 
 namespace partition_alloc::internal::base {
 
 void RandBytes(void* output, size_t output_length) {
-  // Import bcryptprimitives directly rather than cryptbase to avoid opening a
-  // handle to \\Device\KsecDD in the renderer.
-  // Note: we cannot use a magic static here as PA runs too early in process
-  // startup, but this should be safe as the process will be single-threaded
-  // when this first runs.
-  static decltype(&ProcessPrng) process_prng_fn = nullptr;
-  if (!process_prng_fn) {
-    HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-    PA_BASE_CHECK(hmod);
-    process_prng_fn = reinterpret_cast<decltype(&ProcessPrng)>(
-        GetProcAddress(hmod, "ProcessPrng"));
-    PA_BASE_CHECK(process_prng_fn);
-  }
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  PA_BASE_CHECK(success);
+   char* output_ptr = static_cast<char*>(output);
+   while (output_length > 0) {
+   const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+   const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    PA_BASE_CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+}
+
 }
 
 }  // namespace partition_alloc::internal::base
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
index c6445f267971f..5e19e5f01869b 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
@@ -34,7 +34,7 @@
 static_assert(sizeof(void*) == 8, "");
 #else
 static_assert(sizeof(void*) != 8, "");
-#endif  // PA_CONFIG(HAS_64_BITS_POINTERS)
+#endif  // BUILDFLAG(HAS_64_BITS_POINTERS)
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (defined(__ARM_NEON) || defined(__ARM_NEON__)) && defined(__ARM_FP)
@@ -43,18 +43,23 @@ static_assert(sizeof(void*) != 8, "");
 #define PA_CONFIG_STARSCAN_NEON_SUPPORTED() 0
 #endif
 
-#if BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#if BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) || BUILDFLAG(IS_WIN))
 // Allow PA to select an alternate pool size at run-time before initialization,
 // rather than using a single constexpr value.
 //
 // This is needed on iOS because iOS test processes can't handle large pools
 // (see crbug.com/1250788).
 //
+// This is needed on Windows, because OS versions <8.1 incur commit charge even
+// on reserved address space, thus don't handle large pools well (see
+// crbug.com/1101421 and crbug.com/1217759).
+//
 // This setting is specific to 64-bit, as 32-bit has a different implementation.
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 1
 #else
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 0
-#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) ||
+        // BUILDFLAG(IS_WIN))
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_ANDROID))
diff --git a/base/allocator/partition_allocator/src/partition_alloc/shim/shim_alloc_functions.h b/base/allocator/partition_allocator/src/partition_alloc/shim/shim_alloc_functions.h
index c322138dff6ea..002ab978e4123 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/shim/shim_alloc_functions.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/shim/shim_alloc_functions.h
@@ -19,6 +19,15 @@
 #include "partition_alloc/partition_alloc_buildflags.h"
 #include "partition_alloc/partition_alloc_check.h"
 
+#if BUILDFLAG(IS_WIN)
+#include <Windows.h>
+extern "C" {
+VOID __stdcall TLSInit_DllMain_ThreadAttach(IMAGE_DOS_HEADER* DllBase);
+}
+EXTERN_C IMAGE_DOS_HEADER __ImageBase;
+#define HINST_THISCOMPONENT ((HINSTANCE)&__ImageBase)
+#endif
+
 namespace {
 
 PA_ALWAYS_INLINE size_t GetCachedPageSize() {
@@ -112,6 +121,9 @@ PA_ALWAYS_INLINE void* ShimMalloc(size_t size, void* context) {
 }
 
 PA_ALWAYS_INLINE void* ShimCalloc(size_t n, size_t size, void* context) {
+  #if BUILDFLAG(IS_WIN)
+	TLSInit_DllMain_ThreadAttach(&__ImageBase);
+  #endif
   const allocator_shim::AllocatorDispatch* const chain_head =
       allocator_shim::internal::GetChainHead();
   void* ptr;
diff --git a/base/command_line.cc b/base/command_line.cc
index 69e4303165259..da42a22ed2894 100644
--- a/base/command_line.cc
+++ b/base/command_line.cc
@@ -27,8 +27,8 @@
 #include <windows.h>
 
 #include <shellapi.h>
-
 #include "base/strings/string_util_win.h"
+#include "base/win/windows_version.h"
 #endif  // BUILDFLAG(IS_WIN)
 
 namespace base {
@@ -310,6 +310,7 @@ bool CommandLine::HasSwitch(StringPiece switch_string) const {
 }
 
 bool CommandLine::HasSwitch(const char switch_constant[]) const {
+
   return HasSwitch(StringPiece(switch_constant));
 }
 
diff --git a/base/features.cc b/base/features.cc
index 50cb76282689b..ef0aaa5d56db4 100644
--- a/base/features.cc
+++ b/base/features.cc
@@ -34,6 +34,20 @@ BASE_FEATURE(kUseRustJsonParser,
 
 BASE_FEATURE(kJsonNegativeZero, "JsonNegativeZero", FEATURE_ENABLED_BY_DEFAULT);
 
+BASE_FEATURE(kForceDarkModeFlag,
+             "ForceDarkModeFlag",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
+BASE_FEATURE(kIncognitoBrandConsistencyForDesktop,
+			"IncognitoBrandConsistencyForDesktop",
+			base::FEATURE_DISABLED_BY_DEFAULT);
+
+#if BUILDFLAG(IS_WIN)
+BASE_FEATURE(kForceGdi,
+             "ForceGdi",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+#endif
+
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
 // Force to enable LowEndDeviceMode partially on Android 3Gb devices.
 // (see PartialLowEndModeOnMidRangeDevices below)
diff --git a/base/features.h b/base/features.h
index a80ac17fb20d1..167b5467076f0 100644
--- a/base/features.h
+++ b/base/features.h
@@ -25,6 +25,14 @@ BASE_EXPORT BASE_DECLARE_FEATURE(kUseRustJsonParser);
 
 BASE_EXPORT BASE_DECLARE_FEATURE(kJsonNegativeZero);
 
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceDarkModeFlag);
+
+BASE_EXPORT BASE_DECLARE_FEATURE(kIncognitoBrandConsistencyForDesktop);
+
+#if BUILDFLAG(IS_WIN)
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceGdi);
+#endif
+
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOn3GbDevices);
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOnMidRangeDevices);
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index a12c3324abdba..1ee643a98148f 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -698,7 +698,7 @@ bool GetSecureSystemTemp(FilePath* temp) {
 
   CHECK(temp);
 
-  for (const auto key : {DIR_WINDOWS, DIR_PROGRAM_FILES}) {
+  for (const auto key : {DIR_WINDOWS, DIR_IE_INTERNET_CACHE, DIR_PROGRAM_FILES}) {
     FilePath secure_system_temp;
     if (!PathService::Get(key, &secure_system_temp)) {
       continue;
@@ -1118,11 +1118,37 @@ bool SetNonBlocking(int fd) {
   return false;
 }
 
+namespace {
+
+// ::PrefetchVirtualMemory() is only available on Windows 8 and above. Chrome
+// supports Windows 7, so we need to check for the function's presence
+// dynamically.
+using PrefetchVirtualMemoryPtr = decltype(&::PrefetchVirtualMemory);
+
+// Returns null if ::PrefetchVirtualMemory() is not available.
+PrefetchVirtualMemoryPtr GetPrefetchVirtualMemoryPtr() {
+  HMODULE kernel32_dll = ::GetModuleHandleA("kernel32.dll");
+  return reinterpret_cast<PrefetchVirtualMemoryPtr>(
+      GetProcAddress(kernel32_dll, "PrefetchVirtualMemory"));
+}
+
+}  // namespace
+
 bool PreReadFile(const FilePath& file_path,
                  bool is_executable,
                  int64_t max_bytes) {
   DCHECK_GE(max_bytes, 0);
 
+  // On Win8 and higher use ::PrefetchVirtualMemory(). This is better than a
+  // simple data file read, more from a RAM perspective than CPU. This is
+  // because reading the file as data results in double mapping to
+  // Image/executable pages for all pages of code executed.
+  static PrefetchVirtualMemoryPtr prefetch_virtual_memory =
+      GetPrefetchVirtualMemoryPtr();
+
+  if (prefetch_virtual_memory == nullptr)
+    return internal::PreReadFileSlow(file_path, max_bytes);
+
   if (max_bytes == 0) {
     // ::PrefetchVirtualMemory() fails when asked to read zero bytes.
     // base::MemoryMappedFile::Initialize() fails on an empty file.
@@ -1145,7 +1171,7 @@ bool PreReadFile(const FilePath& file_path,
   // simple data file read, more from a RAM perspective than CPU. This is
   // because reading the file as data results in double mapping to
   // Image/executable pages for all pages of code executed.
-  if (!::PrefetchVirtualMemory(::GetCurrentProcess(),
+  if (!prefetch_virtual_memory(::GetCurrentProcess(),
                                /*NumberOfEntries=*/1, &address_range,
                                /*Flags=*/0)) {
     return internal::PreReadFileSlow(file_path, max_bytes);
@@ -1155,7 +1181,7 @@ bool PreReadFile(const FilePath& file_path,
 
 bool PreventExecuteMapping(const FilePath& path) {
   if (!base::FeatureList::IsEnabled(
-          features::kEnforceNoExecutableFileHandles)) {
+          features::kEnforceNoExecutableFileHandles) || base::win::GetVersion() == base::win::Version::PRE_XP) {
     return true;
   }
 
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index ecba26075f008..2159171af8da0 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -422,11 +422,23 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 #elif BUILDFLAG(IS_WIN)
   // On Windows, discarded pages are not returned to the system immediately and
   // not guaranteed to be zeroed when returned to the application.
+  using DiscardVirtualMemoryFunction =
+      DWORD(WINAPI*)(PVOID virtualAddress, SIZE_T size);
+  static DiscardVirtualMemoryFunction discard_virtual_memory =
+      reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+          GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+
   char* address = static_cast<char*>(shared_memory_mapping_.memory()) +
                   AlignToPageSize(sizeof(SharedState));
   size_t length = AlignToPageSize(mapped_size_);
 
-  DWORD ret = DiscardVirtualMemory(address, length);
+  // Use DiscardVirtualMemory when available because it releases faster than
+  // MEM_RESET.
+  DWORD ret = ERROR_NOT_SUPPORTED;
+  if (discard_virtual_memory) {
+    ret = discard_virtual_memory(address, length);
+  }
+
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret != ERROR_SUCCESS) {
diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index 96986601f6282..ab0bda806704a 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,7 +14,12 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
+
 
 namespace base::subtle {
 
@@ -73,6 +78,7 @@ HANDLE CreateFileMappingWithReducedPermissions(SECURITY_ATTRIBUTES* sa,
   HANDLE h = CreateFileMapping(INVALID_HANDLE_VALUE, sa, PAGE_READWRITE, 0,
                                static_cast<DWORD>(rounded_size), name);
   if (!h) {
+     LOG(ERROR) << "CreateFileMappingW failed with error " << GetLastError() << ".";
     return nullptr;
   }
 
@@ -211,6 +217,17 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(&rand_values, sizeof(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
diff --git a/base/message_loop/message_pump_win.cc b/base/message_loop/message_pump_win.cc
index c30066f515f63..479ba2345565e 100644
--- a/base/message_loop/message_pump_win.cc
+++ b/base/message_loop/message_pump_win.cc
@@ -792,6 +792,7 @@ bool MessagePumpForIO::GetIOItem(DWORD timeout, IOItem* item) {
                                    &overlapped, timeout)) {
     if (!overlapped)
       return false;  // Nothing in the queue.
+
     item->error = GetLastError();
     item->bytes_transfered = 0;
   }
diff --git a/base/metrics/field_trial.cc b/base/metrics/field_trial.cc
index 103e6460442ef..3129ce529d94b 100644
--- a/base/metrics/field_trial.cc
+++ b/base/metrics/field_trial.cc
@@ -51,6 +51,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
+#include "base/win/windows_version.h"
 #endif
 
 #if BUILDFLAG(IS_FUCHSIA)
@@ -714,6 +715,12 @@ void FieldTrialList::CreateTrialsInChildProcess(const CommandLine& cmd_line,
                                                 uint32_t fd_key) {
   global_->create_trials_in_child_process_called_ = true;
 
+#if BUILDFLAG(IS_WIN)
+  if (win::GetVersion() < win::Version::VISTA) {
+    return;
+  }
+#endif
+
 #if BUILDFLAG(USE_BLINK)
   // TODO(crbug.com/867558): Change to a CHECK.
   if (cmd_line.HasSwitch(switches::kFieldTrialHandle)) {
diff --git a/base/power_monitor/power_monitor_device_source_win.cc b/base/power_monitor/power_monitor_device_source_win.cc
index 4e7b6563bc229..3925a372ed509 100644
--- a/base/power_monitor/power_monitor_device_source_win.cc
+++ b/base/power_monitor/power_monitor_device_source_win.cc
@@ -32,8 +32,9 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
       power_event = PowerMonitorSource::POWER_STATE_EVENT;
       break;
     case PBT_APMRESUMEAUTOMATIC:  // Resume from suspend.
-      // We don't notify for PBT_APMRESUMESUSPEND
-      // because, if it occurs, it is always sent as a
+      //case PBT_APMRESUMESUSPEND:  // User-initiated resume from suspend.
+      // We don't notify for this latter event
+      // because if it occurs it is always sent as a
       // second event after PBT_APMRESUMEAUTOMATIC.
       power_event = PowerMonitorSource::RESUME_EVENT;
       break;
@@ -55,6 +56,28 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
   ProcessPowerEventHelper(power_event);
 }
 
+HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags) {
+  const auto register_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::RegisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "RegisterSuspendResumeNotification"));
+  if (!register_suspend_resume_notification_ptr)
+    return nullptr;
+
+  return register_suspend_resume_notification_ptr(hRecipient, Flags);
+}
+
+BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle) {
+  const auto unregister_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::UnregisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "UnregisterSuspendResumeNotification"));
+  if (!unregister_suspend_resume_notification_ptr)
+    return FALSE;
+
+  return unregister_suspend_resume_notification_ptr(Handle);
+}
+
 }  // namespace
 
 void PowerMonitorDeviceSource::PlatformInit() {
@@ -79,7 +102,7 @@ void PowerMonitorDeviceSource::PlatformDestroy() {
 // battery power.  Returns true if running on battery.
 bool PowerMonitorDeviceSource::IsOnBatteryPower() {
   SYSTEM_POWER_STATUS status;
-  if (!::GetSystemPowerStatus(&status)) {
+  if (!GetSystemPowerStatus(&status)) {
     DPLOG(ERROR) << "GetSystemPowerStatus failed";
     return false;
   }
@@ -92,7 +115,8 @@ int PowerMonitorDeviceSource::GetInitialSpeedLimit() {
   return PowerThermalObserver::kSpeedLimitMax;
 }
 
-PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
+PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow()
+    : instance_(NULL), message_hwnd_(NULL) {
   if (!CurrentUIThread::IsSet()) {
     // Creating this window in (e.g.) a renderer inhibits shutdown on Windows.
     // See http://crbug.com/230122. TODO(vandebo): http://crbug.com/236031
@@ -105,18 +129,21 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
       kWindowClassName,
       &base::win::WrappedWindowProc<
           PowerMonitorDeviceSource::PowerMessageWindow::WndProcThunk>,
-      0, 0, 0, nullptr, nullptr, nullptr, nullptr, nullptr, &window_class);
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL,
+      &window_class);
   instance_ = window_class.hInstance;
-  ATOM clazz = ::RegisterClassEx(&window_class);
+  ATOM clazz = RegisterClassEx(&window_class);
   DCHECK(clazz);
 
   message_hwnd_ =
-      ::CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, nullptr, WS_POPUP, 0,
-                       0, 0, 0, nullptr, nullptr, instance_, nullptr);
+      CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, NULL, WS_POPUP, 0, 0,
+                     0, 0, NULL, NULL, instance_, NULL);
   if (message_hwnd_) {
-    // On machines with modern standby calling RegisterSuspendResumeNotification
-    // is required in order to get the PBT_APMSUSPEND message.
-    power_notify_handle_ = ::RegisterSuspendResumeNotification(
+    // On machines with modern standby and Win8+, calling
+    // RegisterSuspendResumeNotification is required in order to get the
+    // PBT_APMSUSPEND message. The notification is no longer automatically
+    // fired.
+    power_notify_handle_ = base::RegisterSuspendResumeNotification(
         message_hwnd_, DEVICE_NOTIFY_WINDOW_HANDLE);
   }
 }
@@ -124,10 +151,10 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
 PowerMonitorDeviceSource::PowerMessageWindow::~PowerMessageWindow() {
   if (message_hwnd_) {
     if (power_notify_handle_)
-      ::UnregisterSuspendResumeNotification(power_notify_handle_);
+      base::UnregisterSuspendResumeNotification(power_notify_handle_);
 
-    ::DestroyWindow(message_hwnd_);
-    ::UnregisterClass(kWindowClassName, instance_);
+    DestroyWindow(message_hwnd_);
+    UnregisterClass(kWindowClassName, instance_);
   }
 }
 
diff --git a/base/process/launch_win.cc b/base/process/launch_win.cc
index eca51fa33f7fc..d522308e399f5 100644
--- a/base/process/launch_win.cc
+++ b/base/process/launch_win.cc
@@ -260,7 +260,7 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
   win::StartupInformation startup_info_wrapper;
   STARTUPINFO* startup_info = startup_info_wrapper.startup_info();
   DWORD flags = 0;
-
+  //
   // Count extended attributes before reserving space.
   DWORD attribute_count = 0;
   // Count PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY.
@@ -273,14 +273,17 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
   if (!options.handles_to_inherit.empty())
     ++attribute_count;
 
-  // Reserve space for attributes.
-  if (attribute_count > 0) {
-    if (!startup_info_wrapper.InitializeProcThreadAttributeList(
-            attribute_count)) {
-      DPLOG(ERROR);
-      return Process();
-    }
-    flags |= EXTENDED_STARTUPINFO_PRESENT;
+
+  if (base::win::GetVersion() >= base::win::Version::VISTA) {
+	  // Reserve space for attributes.
+	  if (attribute_count > 0) {
+		if (!startup_info_wrapper.InitializeProcThreadAttributeList(
+				attribute_count)) {
+		  DPLOG(ERROR);
+		  return Process();
+		}
+		flags |= EXTENDED_STARTUPINFO_PRESENT;
+	  }
   }
 
   // Set PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY.
@@ -298,7 +301,11 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
 
   // Set PROC_THREAD_ATTRIBUTE_HANDLE_LIST.
   bool inherit_handles = options.inherit_mode == LaunchOptions::Inherit::kAll;
-  if (!options.handles_to_inherit.empty()) {
+  if (!options.handles_to_inherit.empty() &&
+	  base::win::GetVersion() < base::win::Version::VISTA) {
+	  inherit_handles = true;
+  }
+  if (!options.handles_to_inherit.empty() && base::win::GetVersion() >= base::win::Version::VISTA) {
     DCHECK_GT(attribute_count, 0u);
     DCHECK_EQ(options.inherit_mode, LaunchOptions::Inherit::kSpecific);
 
diff --git a/base/process/process_util_unittest.cc b/base/process/process_util_unittest.cc
index 18bed2128814c..d563938dc4e2e 100644
--- a/base/process/process_util_unittest.cc
+++ b/base/process/process_util_unittest.cc
@@ -829,11 +829,19 @@ TEST_F(ProcessUtilTest, LaunchAsUser) {
 }
 
 MULTIPROCESS_TEST_MAIN(ChildVerifiesCetDisabled) {
-  // Policy not defined for Win < Win10 20H1 but that's ok.
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
+  // Not available for Win7 but this process should still work.
+  if (!get_process_mitigation_policy)
+    return kSuccess;
+
+  // Policy not defined for Win < Win10 20H1 but that's also ok.
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-  if (GetProcessMitigationPolicy(GetCurrentProcess(),
-                                 ProcessUserShadowStackPolicy, &policy,
-                                 sizeof(policy))) {
+  if (get_process_mitigation_policy(GetCurrentProcess(),
+                                    ProcessUserShadowStackPolicy, &policy,
+                                    sizeof(policy))) {
     if (policy.EnableUserShadowStack)
       return 1;
   }
diff --git a/base/process/process_win.cc b/base/process/process_win.cc
index 9a414d886f779..917e2a9a18233 100644
--- a/base/process/process_win.cc
+++ b/base/process/process_win.cc
@@ -265,35 +265,12 @@ bool Process::SetPriority(Priority priority) {
   // priority inversion, and having a process put itself in background mode is
   // broken in Windows 11 22H2. So, it is no longer supported. See
   // https://crbug.com/1396155 for details.
+  // NOTE: NtSetInformationProcess call (SetProcessInformation really) using ProcessPowerThrottling class removed because it is useless before Windows 10.
   DCHECK(!is_current());
   const DWORD priority_class = priority == Priority::kBestEffort
                                    ? IDLE_PRIORITY_CLASS
                                    : NORMAL_PRIORITY_CLASS;
 
-  if (base::win::OSInfo::GetInstance()->version() >=
-          base::win::Version::WIN11 &&
-      FeatureList::IsEnabled(kUseEcoQoSForBackgroundProcess)) {
-    PROCESS_POWER_THROTTLING_STATE power_throttling;
-    RtlZeroMemory(&power_throttling, sizeof(power_throttling));
-    power_throttling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;
-
-    if (priority == Priority::kBestEffort) {
-      // Sets Eco QoS level.
-      power_throttling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-      power_throttling.StateMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-    } else {
-      // Uses system default.
-      power_throttling.ControlMask = 0;
-      power_throttling.StateMask = 0;
-    }
-    bool ret =
-        ::SetProcessInformation(Handle(), ProcessPowerThrottling,
-                                &power_throttling, sizeof(power_throttling));
-    if (ret == 0) {
-      DPLOG(ERROR) << "Setting process QoS policy fails";
-    }
-  }
-
   return (::SetPriorityClass(Handle(), priority_class) != 0);
 }
 
diff --git a/base/rand_util_win.cc b/base/rand_util_win.cc
index 6aae763d98715..f1f21d13fba42 100644
--- a/base/rand_util_win.cc
+++ b/base/rand_util_win.cc
@@ -9,6 +9,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <atomic>
 #include <limits>
@@ -18,12 +25,6 @@
 #include "third_party/boringssl/src/include/openssl/crypto.h"
 #include "third_party/boringssl/src/include/openssl/rand.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace base {
 
 namespace internal {
@@ -53,18 +54,6 @@ bool UseBoringSSLForRandBytes() {
 
 namespace {
 
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
 void RandBytes(span<uint8_t> output, bool avoid_allocation) {
   if (!avoid_allocation && internal::UseBoringSSLForRandBytes()) {
     // Ensure BoringSSL is initialized so it can use things like RDRAND.
@@ -74,11 +63,18 @@ void RandBytes(span<uint8_t> output, bool avoid_allocation) {
     return;
   }
 
-  static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-  BOOL success =
-      process_prng_fn(static_cast<BYTE*>(output.data()), output.size());
-  // ProcessPrng is documented to always return TRUE.
-  CHECK(success);
+  unsigned char* output_ptr = output.data();
+  size_t output_size = output.size();
+  while (output_size > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_size, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    CHECK(success);
+    output_size -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+}
+
 }
 
 }  // namespace
diff --git a/base/sampling_heap_profiler/poisson_allocation_sampler.cc b/base/sampling_heap_profiler/poisson_allocation_sampler.cc
index 9c449e95ee85d..56ad97b314221 100644
--- a/base/sampling_heap_profiler/poisson_allocation_sampler.cc
+++ b/base/sampling_heap_profiler/poisson_allocation_sampler.cc
@@ -20,6 +20,15 @@
 #include "build/build_config.h"
 #include "third_party/abseil-cpp/absl/base/attributes.h"
 
+#if BUILDFLAG(IS_WIN)
+#include <windows.h>
+extern "C" {
+VOID __stdcall TLSInit_DllMain_ThreadAttach(IMAGE_DOS_HEADER* DllBase);
+}
+EXTERN_C IMAGE_DOS_HEADER __ImageBase;
+#define HINST_THISCOMPONENT ((HINSTANCE)&__ImageBase)
+#endif
+
 namespace base {
 
 namespace {
@@ -241,6 +250,10 @@ void PoissonAllocationSampler::DoRecordAllocation(
     size_t size,
     base::allocator::dispatcher::AllocationSubsystem type,
     const char* context) {
+
+  #if BUILDFLAG(IS_WIN)
+	TLSInit_DllMain_ThreadAttach(&__ImageBase);
+  #endif
   ThreadLocalData* const thread_local_data = GetThreadLocalData();
 
   thread_local_data->accumulated_bytes += size;
diff --git a/base/system/sys_info_win.cc b/base/system/sys_info_win.cc
index 68626967de317..0c68025ebf605 100644
--- a/base/system/sys_info_win.cc
+++ b/base/system/sys_info_win.cc
@@ -153,6 +153,9 @@ int SysInfo::NumberOfProcessors() {
 
 // static
 int SysInfo::NumberOfEfficientProcessorsImpl() {
+  // No efficiency support before Windows 10.
+  if (win::GetVersion() < win::Version::WIN10)
+	  return 0;
   std::vector<BYTE> efficiency_classes = GetCoreEfficiencyClasses();
   if (efficiency_classes.empty())
     return 0;
diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 38888cf0448a9..a7423863f3716 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -17,7 +17,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base {
@@ -445,8 +447,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
 
     // TODO(crbug.com/1498668): rollback the change or replace it with a CHECK
     // before closing the bug.
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index b8a0d23a43f6c..52291c7803a6b 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -54,6 +54,13 @@ namespace {
 // Flag used to set thread priority to |THREAD_PRIORITY_LOWEST| for
 // |kUseThreadPriorityLowest| Feature.
 std::atomic<bool> g_use_thread_priority_lowest{false};
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
 // Flag used to map Compositing ThreadType |THREAD_PRIORITY_ABOVE_NORMAL| on the
 // UI thread for |kAboveNormalCompositingBrowserWin| Feature.
 std::atomic<bool> g_above_normal_compositing_browser{true};
@@ -244,7 +251,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -443,8 +453,12 @@ void SetCurrentThreadPriority(ThreadType thread_type,
     // Override the memory priority.
     MEMORY_PRIORITY_INFORMATION memory_priority{.MemoryPriority =
                                                     MEMORY_PRIORITY_NORMAL};
+	  static const auto set_thread_information_fn =
+      reinterpret_cast<decltype(&::SetThreadInformation)>(::GetProcAddress(
+          ::GetModuleHandle(L"kernel32.dll"), "SetThreadInformation"));
+      DCHECK(set_thread_information_fn);
     [[maybe_unused]] const BOOL memory_priority_success =
-        SetThreadInformation(thread_handle, ::ThreadMemoryPriority,
+        set_thread_information_fn(thread_handle, ::ThreadMemoryPriority,
                              &memory_priority, sizeof(memory_priority));
     DPLOG_IF(ERROR, !memory_priority_success)
         << "Set thread memory priority failed.";
@@ -467,6 +481,15 @@ void SetCurrentThreadPriority(ThreadType thread_type,
 
 void SetCurrentThreadQualityOfService(ThreadType thread_type) {
   // QoS and power throttling were introduced in Win10 1709.
+ if (win::GetVersion() < win::Version::WIN10_RS3) {
+    return;
+  }
+
+  static const auto set_thread_information_fn =
+      reinterpret_cast<decltype(&::SetThreadInformation)>(::GetProcAddress(
+          ::GetModuleHandle(L"kernel32.dll"), "SetThreadInformation"));
+  DCHECK(set_thread_information_fn);
+
   bool desire_ecoqos = false;
   switch (thread_type) {
     case ThreadType::kBackground:
@@ -489,11 +512,10 @@ void SetCurrentThreadQualityOfService(ThreadType thread_type) {
       .StateMask =
           desire_ecoqos ? THREAD_POWER_THROTTLING_EXECUTION_SPEED : 0ul,
   };
-  [[maybe_unused]] const BOOL success = ::SetThreadInformation(
+  [[maybe_unused]] const BOOL success = set_thread_information_fn(
       ::GetCurrentThread(), ::ThreadPowerThrottling,
       &thread_power_throttling_state, sizeof(thread_power_throttling_state));
-  // Failure is expected on versions of Windows prior to RS3.
-  DPLOG_IF(ERROR, !success && win::GetVersion() >= win::Version::WIN10_RS3)
+  DPLOG_IF(ERROR, !success)
       << "Failed to set EcoQoS to " << std::boolalpha << desire_ecoqos;
 }
 
@@ -548,8 +570,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
     return ThreadPriorityForTest::kBackground;
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinDisplayPriority1:
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
index c6540592a5c18..f453dc2ed20cf 100644
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -646,11 +646,11 @@ TimeTicks::Clock TimeTicks::GetClock() {
 
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
-  ULONGLONG unbiased_interrupt_time;
-  QueryUnbiasedInterruptTimePrecise(&unbiased_interrupt_time);
+  LARGE_INTEGER unbiased_interrupt_time;
+  QueryPerformanceCounter(&unbiased_interrupt_time);
   // QueryUnbiasedInterruptTimePrecise gets the interrupt time in system time
   // units of 100 nanoseconds.
-  return LiveTicks() + Nanoseconds(unbiased_interrupt_time * 100);
+  return LiveTicks() + Nanoseconds(unbiased_interrupt_time.QuadPart * 100);
 }
 }  // namespace subtle
 
diff --git a/base/trace_event/trace_logging_minimal_win.cc b/base/trace_event/trace_logging_minimal_win.cc
index 5d565fa73bedb..ec786bb990517 100644
--- a/base/trace_event/trace_logging_minimal_win.cc
+++ b/base/trace_event/trace_logging_minimal_win.cc
@@ -10,6 +10,62 @@
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
 
+/*
+EventSetInformation configuration macros:
+
+TraceLogging works best if the EventSetInformation API can be used to notify
+ETW that the provider uses TraceLogging event encoding.
+
+The EventSetInformation API is available on Windows 8 and later. (It is also
+available on fully-patched Windows 7, but not on Windows 7 RTM).
+
+The TLM_HAVE_EVENT_SET_INFORMATION and TLM_EVENT_SET_INFORMATION macros can
+be set before compiling this file to  control how the TlmProvider class deals
+with the EventSetInformation API.
+
+If these macros are not set, the default behavior is to check the WINVER
+macro at compile time:
+
+- If WINVER is set to Windows 7 or before, TlmProvider will use GetProcAddress
+  to locate EventSetInformation, and then invoke it if present. This is less
+  efficient, but works on older versions of Windows.
+- If WINVER is set to Windows 8 or later, TlmProvider will directly invoke
+  EventSetInformation. This is more efficient, but the resulting application
+  will only work correctly on newer versions of Windows.
+
+If you need to run on Windows 7 RTM, but for some reason need to set WINVER to
+Windows 8 or higher, you can override the default behavior by defining
+TLM_HAVE_EVENT_SET_INFORMATION=2 when compiling this file.
+
+Details:
+- The TLM_EVENT_SET_INFORMATION macro can be set the name of a replacement
+  function that TlmProvider should use instead of EventSetInformation.
+- The TLM_HAVE_EVENT_SET_INFORMATION macro can be set to 0 (disable the use of
+  EventSetInformation), 1 (directly invoke EventSetInformation), or 2 (try to
+  locate EventSetInformation via GetProcAddress, and invoke if found).
+*/
+
+// This code needs to run on Windows 7 and this is magic which
+// removes static linking to EventSetInformation
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+
+#ifndef TLM_EVENT_SET_INFORMATION
+#define TLM_EVENT_SET_INFORMATION EventSetInformation
+#ifndef TLM_HAVE_EVENT_SET_INFORMATION
+#if WINVER < 0x0602 || !defined(EVENT_FILTER_TYPE_SCHEMATIZED)
+// Find "EventSetInformation" via GetModuleHandleExW+GetProcAddress
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+#else
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+#endif
+#elif !defined(TLM_HAVE_EVENT_SET_INFORMATION)
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+
+
 TlmProvider::TlmProvider() noexcept = default;
 
 TlmProvider::~TlmProvider() {
@@ -22,7 +78,7 @@ TlmProvider::TlmProvider(const char* provider_name,
                              on_updated_callback) noexcept {
   ULONG status =
       Register(provider_name, provider_guid, std::move(on_updated_callback));
-  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider resistration failure";
+  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider registration failure";
 }
 
 // Appends a nul-terminated string to a metadata block.
@@ -83,9 +139,42 @@ ULONG TlmProvider::Register(const char* provider_name,
   if (status != ERROR_SUCCESS)
     return status;
 
+#if TLM_HAVE_EVENT_SET_INFORMATION == 1
+
   // Best-effort, ignore failure.
-  return ::EventSetInformation(reg_handle_, EventProviderSetTraits,
-                               provider_metadata_, provider_metadata_size_);
+  status =
+      TLM_EVENT_SET_INFORMATION(reg_handle_, EventProviderSetTraits,
+                                provider_metadata_, provider_metadata_size_);
+
+#elif TLM_HAVE_EVENT_SET_INFORMATION == 2
+
+  HMODULE eventing_lib;
+  if (GetModuleHandleExW(0, L"api-ms-win-eventing-provider-l1-1-0.dll",
+                         &eventing_lib) ||
+      GetModuleHandleExW(0, L"advapi32.dll", &eventing_lib)) {
+    typedef ULONG(WINAPI * PFEventSetInformation)(
+        REGHANDLE reg_handle, EVENT_INFO_CLASS information_class,
+        PVOID event_information, ULONG information_length);
+    PFEventSetInformation event_set_information_ptr =
+        reinterpret_cast<decltype(&::EventSetInformation)>(
+            GetProcAddress(eventing_lib, "EventSetInformation"));
+    if (event_set_information_ptr) {
+      // Best-effort, ignore failure.
+      status = event_set_information_ptr(reg_handle_, EventProviderSetTraits,
+                                         provider_metadata_,
+                                         provider_metadata_size_);
+    }
+
+    FreeLibrary(eventing_lib);
+  }
+
+#else  // TLM_HAVE_EVENT_SET_INFORMATION == 0
+
+    // Make no attempt to invoke EventSetInformation.
+
+#endif  // TLM_HAVE_EVENT_SET_INFORMATION
+
+  return status;
 }
 
 bool TlmProvider::IsEnabled() const noexcept {
diff --git a/base/win/cet_shadow_stack_unittest.cc b/base/win/cet_shadow_stack_unittest.cc
index 8c58163cfbf44..cb73ea9e8e388 100644
--- a/base/win/cet_shadow_stack_unittest.cc
+++ b/base/win/cet_shadow_stack_unittest.cc
@@ -19,10 +19,14 @@ bool IsHardwareEnforcedShadowStacksEnabled() {
   if (base::win::GetVersion() < base::win::Version::WIN10_20H1)
     return false;
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return false;
   }
 
diff --git a/base/win/core_winrt_util.cc b/base/win/core_winrt_util.cc
index 25f5885bf2f40..3508cfe474bfd 100644
--- a/base/win/core_winrt_util.cc
+++ b/base/win/core_winrt_util.cc
@@ -3,17 +3,54 @@
 // found in the LICENSE file.
 
 #include "base/win/core_winrt_util.h"
+#include "base/threading/scoped_thread_priority.h"
 
 namespace base::win {
 
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoActivateInstance) GetRoActivateInstanceFunction() {
+  static decltype(&::RoActivateInstance) const function =
+      reinterpret_cast<decltype(&::RoActivateInstance)>(
+          LoadComBaseFunction("RoActivateInstance"));
+  return function;
+}
+
+decltype(&::RoGetActivationFactory) GetRoGetActivationFactoryFunction() {
+  static decltype(&::RoGetActivationFactory) const function =
+      reinterpret_cast<decltype(&::RoGetActivationFactory)>(
+          LoadComBaseFunction("RoGetActivationFactory"));
+  return function;
+}
+
+bool ResolveCoreWinRTDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+  return GetRoActivateInstanceFunction() && GetRoGetActivationFactoryFunction();
+}
+
 HRESULT RoGetActivationFactory(HSTRING class_id,
                                const IID& iid,
                                void** out_factory) {
-  return ::RoGetActivationFactory(class_id, iid, out_factory);
+  auto get_factory_func = GetRoGetActivationFactoryFunction();
+  if (!get_factory_func)
+    return E_FAIL;
+  return get_factory_func(class_id, iid, out_factory);
 }
 
 HRESULT RoActivateInstance(HSTRING class_id, IInspectable** instance) {
-  return ::RoActivateInstance(class_id, instance);
+  auto activate_instance_func = GetRoActivateInstanceFunction();
+  if (!activate_instance_func)
+    return E_FAIL;
+  return activate_instance_func(class_id, instance);
 }
 
 }  // namespace base::win
diff --git a/base/win/core_winrt_util.h b/base/win/core_winrt_util.h
index 3a6e0c9f3774c..c4a802c85d6ed 100644
--- a/base/win/core_winrt_util.h
+++ b/base/win/core_winrt_util.h
@@ -15,6 +15,8 @@
 
 namespace base::win {
 
+BASE_EXPORT bool ResolveCoreWinRTDelayload();
+
 // The following stubs are provided for when component build is enabled, in
 // order to avoid the propagation of delay-loading CoreWinRT to other modules.
 
diff --git a/base/win/dllmain.cc b/base/win/dllmain.cc
index 0c5546fb1b406..8bb1b45f053c6 100644
--- a/base/win/dllmain.cc
+++ b/base/win/dllmain.cc
@@ -89,9 +89,24 @@ NOINLINE static void CrashOnProcessDetach() {
   *static_cast<volatile int*>(nullptr) = 0x356;
 }
 
+extern "C" {
+
+VOID __stdcall TLSInit_DllMain_ProcessAttach(PVOID DllBase);
+
+VOID __stdcall TLSInit_DllMain_ThreadAttach(PVOID DllBase);
+
+}
+
 // Make DllMain call the listed callbacks.  This way any third parties that are
 // linked in will also be called.
 BOOL WINAPI DllMain(PVOID h, DWORD reason, PVOID reserved) {
+
+  if (DLL_PROCESS_ATTACH == reason)
+	  TLSInit_DllMain_ProcessAttach(h); // Implicit TLS initialization code for Windows XP and below
+                                             // Implemented in progwrp.dll.
+  if (DLL_THREAD_ATTACH == reason)
+	  TLSInit_DllMain_ThreadAttach(h);
+
   if (DLL_PROCESS_DETACH == reason && base::win::ShouldCrashOnProcessDetach())
     CrashOnProcessDetach();
 
diff --git a/base/win/hstring_reference.cc b/base/win/hstring_reference.cc
index b254fc64310a1..6b2b1a6290990 100644
--- a/base/win/hstring_reference.cc
+++ b/base/win/hstring_reference.cc
@@ -12,18 +12,54 @@
 #include "base/check_op.h"
 #include "base/numerics/safe_conversions.h"
 
-namespace base::win {
+namespace base {
+namespace {
+
+bool g_winrt_string_loaded = false;
+
+decltype(&::WindowsCreateStringReference) GetWindowsCreateStringReference() {
+  static auto const create_string_reference_func =
+      []() -> decltype(&::WindowsCreateStringReference) {
+    const HMODULE handle =
+        ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    if (handle) {
+      return reinterpret_cast<decltype(&::WindowsCreateStringReference)>(
+          ::GetProcAddress(handle, "WindowsCreateStringReference"));
+    }
+    return nullptr;
+  }();
+  return create_string_reference_func;
+}
+
+}  // namespace
+
+namespace win {
+
+// static
+bool HStringReference::ResolveCoreWinRTStringDelayload() {
+  g_winrt_string_loaded = GetWindowsCreateStringReference() != nullptr;
+  return g_winrt_string_loaded;
+}
 
 HStringReference::HStringReference(const wchar_t* str, size_t length) {
+
+  // This was added because otherwise, the checks below would consistently fail.
+  ResolveCoreWinRTStringDelayload();
+  DCHECK(g_winrt_string_loaded);
   // String must be null terminated for WindowsCreateStringReference.
   // nullptr str is OK so long as the length is 0.
   DCHECK(str ? str[length] == L'\0' : length == 0);
-  const HRESULT hr = ::WindowsCreateStringReference(
+  // If you nullptr crash here, you've failed to call
+  // ResolveCoreWinRTStringDelayLoad and check its return value.
+  const HRESULT hr = GetWindowsCreateStringReference()(
       str, checked_cast<UINT32>(length), &hstring_header_, &hstring_);
+  // All failure modes of WindowsCreateStringReference are handled gracefully
+  // but this class.
   DCHECK_EQ(hr, S_OK);
 }
 
 HStringReference::HStringReference(const wchar_t* str)
     : HStringReference(str, str ? wcslen(str) : 0) {}
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_reference.h b/base/win/hstring_reference.h
index 3cde4acef6f2e..2366a681e72c0 100644
--- a/base/win/hstring_reference.h
+++ b/base/win/hstring_reference.h
@@ -9,7 +9,8 @@
 
 #include "base/base_export.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 // HStringReference is an HSTRING representation of a null terminated
 // string backed by memory that outlives the HStringReference instance.
@@ -17,12 +18,31 @@ namespace base::win {
 // If you need an HSTRING class that manages its own memory, you should
 // use ScopedHString instead.
 //
+// Note that HStringReference requires certain functions that are only
+// available on Windows 8 and later, and that these functions need to be
+// delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using HStringReference.
+//
+// One-time Initialization for HStringReference:
+//
+//   const bool success = HStringReference::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // HStringReference can be used.
+//   } else {
+//     // Handle error.
+//   }
+//
 // Example use:
 //
 //   HStringReference string(L"abc");
 //
 class BASE_EXPORT HStringReference {
  public:
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  static bool ResolveCoreWinRTStringDelayload();
+
   HStringReference(const wchar_t* str, size_t len);
   explicit HStringReference(const wchar_t* str);
 
@@ -47,6 +67,7 @@ class BASE_EXPORT HStringReference {
   HSTRING_HEADER hstring_header_;
 };
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
 
 #endif  // BASE_WIN_HSTRING_REFERENCE_H_
diff --git a/base/win/hstring_reference_unittest.cc b/base/win/hstring_reference_unittest.cc
index 3f67ff223d87e..60bd3d27a9037 100644
--- a/base/win/hstring_reference_unittest.cc
+++ b/base/win/hstring_reference_unittest.cc
@@ -26,6 +26,8 @@ void VerifyHSTRINGEquals(HSTRING hstring, const wchar_t* test_string) {
 }  // namespace
 
 TEST(HStringReferenceTest, Init) {
+  EXPECT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
+
   const HStringReference string(kTestString);
   EXPECT_NE(string.Get(), nullptr);
   VerifyHSTRINGEquals(string.Get(), kTestString);
diff --git a/base/win/registry.cc b/base/win/registry.cc
index 7b9dcb90e627e..d24a4b0ede9d5 100644
--- a/base/win/registry.cc
+++ b/base/win/registry.cc
@@ -23,6 +23,7 @@
 #include "base/win/object_watcher.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 
 extern "C" NTSTATUS WINAPI NtDeleteKey(IN HANDLE KeyHandle);
 
@@ -87,8 +88,9 @@ bool RegKey::Watcher::StartWatching(HKEY key, ChangeCallback callback) {
   }
 
   DWORD filter = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
-                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY |
-                 REG_NOTIFY_THREAD_AGNOSTIC;
+                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY;
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    filter |= REG_NOTIFY_THREAD_AGNOSTIC;
   // Watch the registry key for a change of value.
   LONG result =
       RegNotifyChangeKeyValue(key, /*bWatchSubtree=*/TRUE, filter,
diff --git a/base/win/scoped_hstring.cc b/base/win/scoped_hstring.cc
index 20e027e34632b..c3342f122ca25 100644
--- a/base/win/scoped_hstring.cc
+++ b/base/win/scoped_hstring.cc
@@ -19,23 +19,89 @@
 
 namespace base {
 
+namespace {
+
+static bool g_load_succeeded = false;
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle =
+      ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::WindowsCreateString) GetWindowsCreateString() {
+  static decltype(&::WindowsCreateString) const function =
+      reinterpret_cast<decltype(&::WindowsCreateString)>(
+          LoadComBaseFunction("WindowsCreateString"));
+  return function;
+}
+
+decltype(&::WindowsDeleteString) GetWindowsDeleteString() {
+  static decltype(&::WindowsDeleteString) const function =
+      reinterpret_cast<decltype(&::WindowsDeleteString)>(
+          LoadComBaseFunction("WindowsDeleteString"));
+  return function;
+}
+
+decltype(&::WindowsGetStringRawBuffer) GetWindowsGetStringRawBuffer() {
+  static decltype(&::WindowsGetStringRawBuffer) const function =
+      reinterpret_cast<decltype(&::WindowsGetStringRawBuffer)>(
+          LoadComBaseFunction("WindowsGetStringRawBuffer"));
+  return function;
+}
+
+HRESULT WindowsCreateString(const wchar_t* src,
+                            uint32_t len,
+                            HSTRING* out_hstr) {
+  decltype(&::WindowsCreateString) create_string_func =
+      GetWindowsCreateString();
+  if (!create_string_func)
+    return E_FAIL;
+  return create_string_func(src, len, out_hstr);
+}
+
+HRESULT WindowsDeleteString(HSTRING hstr) {
+  decltype(&::WindowsDeleteString) delete_string_func =
+      GetWindowsDeleteString();
+  if (!delete_string_func)
+    return E_FAIL;
+  return delete_string_func(hstr);
+}
+
+const wchar_t* WindowsGetStringRawBuffer(HSTRING hstr, uint32_t* out_len) {
+  decltype(&::WindowsGetStringRawBuffer) get_string_raw_buffer_func =
+      GetWindowsGetStringRawBuffer();
+  if (!get_string_raw_buffer_func) {
+    *out_len = 0;
+    return nullptr;
+  }
+  return get_string_raw_buffer_func(hstr, out_len);
+}
+
+}  // namespace
+
 namespace internal {
 
 // static
 void ScopedHStringTraits::Free(HSTRING hstr) {
-  ::WindowsDeleteString(hstr);
+  base::WindowsDeleteString(hstr);
 }
 
 }  // namespace internal
 
 namespace win {
 
-ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {}
+ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {
+	DCHECK(g_load_succeeded);
+}
 
 // static
 ScopedHString ScopedHString::Create(std::wstring_view str) {
+  if(!g_load_succeeded) {
+	  return ScopedHString(nullptr);
+  }
   HSTRING hstr;
-  HRESULT hr = ::WindowsCreateString(str.data(),
+  HRESULT hr = base::WindowsCreateString(str.data(),
                                      checked_cast<UINT32>(str.length()), &hstr);
   if (SUCCEEDED(hr))
     return ScopedHString(hstr);
@@ -57,10 +123,22 @@ ScopedHString ScopedHString::Create(StringPiece str) {
   return Create(UTF8ToWide(str));
 }
 
+// static
+bool ScopedHString::ResolveCoreWinRTStringDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+
+  static const bool load_succeeded = []() {
+    bool success = GetWindowsCreateString() && GetWindowsDeleteString() &&
+                   GetWindowsGetStringRawBuffer();
+    g_load_succeeded = success;
+    return success;
+  }();
+  return load_succeeded;
+}
 // static
 std::wstring_view ScopedHString::Get() const {
   UINT32 length = 0;
-  const wchar_t* buffer = ::WindowsGetStringRawBuffer(get(), &length);
+  const wchar_t* buffer = base::WindowsGetStringRawBuffer(get(), &length);
   return std::wstring_view(buffer, length);
 }
 
diff --git a/base/win/scoped_hstring.h b/base/win/scoped_hstring.h
index 50b8451663c3b..7cd0247d93a31 100644
--- a/base/win/scoped_hstring.h
+++ b/base/win/scoped_hstring.h
@@ -28,7 +28,21 @@ struct BASE_EXPORT ScopedHStringTraits {
 
 namespace win {
 
-// ScopedHString is a wrapper around an HSTRING.
+// ScopedHString is a wrapper around an HSTRING. Note that it requires certain
+// functions that are only available on Windows 8 and later, and that these
+// functions need to be delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using ScopedHString.
+//
+// One-time Initialization for ScopedHString:
+//
+//   bool success = ScopedHString::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // ScopeHString can be used.
+//   } else {
+//     // Handle error.
+//   }
 //
 // Example use:
 //
@@ -49,6 +63,9 @@ class BASE_EXPORT ScopedHString
   static ScopedHString Create(std::wstring_view str);
   static ScopedHString Create(StringPiece str);
 
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  [[nodiscard]] static bool ResolveCoreWinRTStringDelayload();
+
   // Returns a view into the memory buffer managed by the instance. The returned
   // StringPiece is only valid during the lifetime of this ScopedHString
   // instance.
diff --git a/base/win/scoped_winrt_initializer.cc b/base/win/scoped_winrt_initializer.cc
index 4c93dcfabf658..85f83dab8192b 100644
--- a/base/win/scoped_winrt_initializer.cc
+++ b/base/win/scoped_winrt_initializer.cc
@@ -5,14 +5,61 @@
 #include "base/win/scoped_winrt_initializer.h"
 
 #include <roapi.h>
+#include <windows.h>
+
+#include <ostream>
 
 #include "base/check_op.h"
+#include "base/threading/scoped_thread_priority.h"
 #include "base/win/com_init_util.h"
+#include "base/win/core_winrt_util.h"
 
 namespace base::win {
 
+namespace {
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoInitialize) GetRoInitializeFunction() {
+  static decltype(&::RoInitialize) const function =
+      reinterpret_cast<decltype(&::RoInitialize)>(
+          LoadComBaseFunction("RoInitialize"));
+  return function;
+}
+
+decltype(&::RoUninitialize) GetRoUninitializeFunction() {
+  static decltype(&::RoUninitialize) const function =
+      reinterpret_cast<decltype(&::RoUninitialize)>(
+          LoadComBaseFunction("RoUninitialize"));
+  return function;
+}
+
+HRESULT CallRoInitialize(RO_INIT_TYPE init_type) {
+  auto ro_initialize_func = GetRoInitializeFunction();
+  if (!ro_initialize_func)
+    return E_FAIL;
+  return ro_initialize_func(init_type);
+}
+
+void CallRoUninitialize() {
+  auto ro_uninitialize_func = GetRoUninitializeFunction();
+  if (ro_uninitialize_func)
+    ro_uninitialize_func();
+}
+
+}  // namespace
+
 ScopedWinrtInitializer::ScopedWinrtInitializer()
-    : hr_(::RoInitialize(RO_INIT_MULTITHREADED)) {
+    : hr_(CallRoInitialize(RO_INIT_MULTITHREADED)) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 #if DCHECK_IS_ON()
   if (SUCCEEDED(hr_))
@@ -25,7 +72,7 @@ ScopedWinrtInitializer::ScopedWinrtInitializer()
 ScopedWinrtInitializer::~ScopedWinrtInitializer() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (SUCCEEDED(hr_))
-    ::RoUninitialize();
+    CallRoUninitialize();
 }
 
 bool ScopedWinrtInitializer::Succeeded() const {
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 25cc9b48a4d14..0995e8aad5788 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -39,6 +39,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/files/file_path.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
@@ -68,6 +69,21 @@ namespace win {
 
 namespace {
 
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+
+bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch(kDisableDirectWrite);
+}
+
 // Sets the value of |property_key| to |property_value| in |property_store|.
 bool SetPropVariantValueForPropertyStore(
     IPropertyStore* property_store,
@@ -96,10 +112,40 @@ void __cdecl ForceCrashOnSigAbort(int) {
   *((volatile int*)nullptr) = 0x1337;
 }
 
-// Returns the current platform role. We use the PowerDeterminePlatformRoleEx
+// Returns the current platform role. We use the PowerDeterminePlatformRole
 // API for that.
 POWER_PLATFORM_ROLE GetPlatformRole() {
-  return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
+	return PowerDeterminePlatformRole();
+}
+
+// Because we used to support versions earlier than 8.1, we dynamically load
+// this function from user32.dll, so it won't fail to load in runtime.
+// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  if (!IsUser32AndGdi32Available())
+    return false;
+
+  static const auto set_process_dpi_awareness_func =
+      reinterpret_cast<decltype(&::SetProcessDpiAwareness)>(
+          GetUser32FunctionPointer("SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr))
+      return true;
+    DLOG_IF(ERROR, hr == E_ACCESSDENIED)
+        << "Access denied error from SetProcessDpiAwarenessInternal. "
+           "Function called twice, or manifest was used.";
+    NOTREACHED()
+        << "SetProcessDpiAwarenessInternal failed with unexpected error: "
+        << hr;
+    return false;
+  }
+
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
+
+  return false;
 }
 
 // Enable V2 per-monitor high-DPI support for the process. This will cause
@@ -239,10 +285,16 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
            IsDeviceUsedAsATablet(/*reason=*/nullptr);
   }
 
+  if (!ResolveCoreWinRTDelayload() ||
+      !ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
+
   ScopedHString view_settings_guid = ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UIViewSettings);
   Microsoft::WRL::ComPtr<IUIViewSettingsInterop> view_settings_interop;
-  HRESULT hr = ::RoGetActivationFactory(view_settings_guid.get(),
+  HRESULT hr = win::RoGetActivationFactory(view_settings_guid.get(),
                                         IID_PPV_ARGS(&view_settings_interop));
   if (FAILED(hr))
     return false;
@@ -607,8 +659,17 @@ bool IsJoinedToAzureAD() {
 bool IsUser32AndGdi32Available() {
   static auto is_user32_and_gdi32_available = []() {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
+	if (!ShouldUseDirectWrite())
+        return true;
+	  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
+    if(!get_process_mitigation_policy)
+		return true;
+
     PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
+    if (get_process_mitigation_policy(GetCurrentProcess(),
                                      ProcessSystemCallDisablePolicy, &policy,
                                      sizeof(policy))) {
       return policy.DisallowWin32kSystemCalls == 0;
@@ -674,7 +735,7 @@ void DisableFlicks(HWND hwnd) {
 }
 
 void EnableHighDPISupport() {
-  if (!IsUser32AndGdi32Available())
+  if (!IsUser32AndGdi32Available() || GetVersion() < Version::VISTA)
     return;
 
   // Enable per-monitor V2 if it is available (Win10 1703 or later).
@@ -683,7 +744,7 @@ void EnableHighDPISupport() {
 
   // Fall back to per-monitor DPI for older versions of Win10.
   PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
-  if (!::SetProcessDpiAwareness(process_dpi_awareness)) {
+  if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
     // For windows versions where SetProcessDpiAwareness fails, try its
     // predecessor.
     BOOL result = ::SetProcessDPIAware();
diff --git a/base/win/winrt_storage_util_unittest.cc b/base/win/winrt_storage_util_unittest.cc
index 5c54819e4b85a..8f3f64f29011a 100644
--- a/base/win/winrt_storage_util_unittest.cc
+++ b/base/win/winrt_storage_util_unittest.cc
@@ -21,6 +21,10 @@ namespace win {
 TEST(WinrtStorageUtilTest, CreateBufferFromData) {
   ScopedCOMInitializer com_initializer(ScopedCOMInitializer::kMTA);
 
+  if (!ResolveCoreWinRTDelayload()) {
+    return;
+  }
+
   const std::vector<uint8_t> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   Microsoft::WRL::ComPtr<ABI::Windows::Storage::Streams::IBuffer> buffer;
   ASSERT_HRESULT_SUCCEEDED(
diff --git a/build/config/BUILD.gn b/build/config/BUILD.gn
index f341687194878..a1da6be7a8e22 100644
--- a/build/config/BUILD.gn
+++ b/build/config/BUILD.gn
@@ -162,6 +162,8 @@ config("default_libs") {
     # instead the targets that use the less common ones (e.g. wininet or
     # winspool) should include those explicitly.
     libs = [
+      "progwrp.lib",
+      "ntdll.lib",
       "advapi32.lib",
       "comdlg32.lib",
       "dbghelp.lib",
@@ -171,6 +173,7 @@ config("default_libs") {
       "odbc32.lib",
       "odbccp32.lib",
       "oleaut32.lib",
+      "psapi.lib",
       "shell32.lib",
       "shlwapi.lib",
       "user32.lib",
diff --git a/build/config/win/BUILD.gn b/build/config/win/BUILD.gn
index 6e1417aa40076..bb424912d52f1 100644
--- a/build/config/win/BUILD.gn
+++ b/build/config/win/BUILD.gn
@@ -43,6 +43,10 @@ declare_args() {
   #  and with this switch, clang emits it like this:
   #    foo/bar.cc:12:34: error: something went wrong
   use_clang_diagnostics_format = false
+
+
+  # Indicates whether to use /pdbpagesize:8192 to allow PDBs larger than 4 GiB.
+  use_large_pdbs = false
 }
 
 # This is included by reference in the //build/config/compiler config that
@@ -127,7 +131,11 @@ config("compiler") {
     # microarchitecture. MSVC only supports a subset of architectures, and the
     # next step after SSE2 will be AVX.
     if (current_cpu == "x86" || current_cpu == "x64") {
-      cflags += [ "-msse3" ]
+        if (target_cpu == "x64") {
+          cflags += [ "-msse3" ]
+        } else {
+          cflags += [ "-mmmx", "-mfxsr", "-msse", "-msse2" ]
+        }
     }
 
     # Enable ANSI escape codes if something emulating them is around (cmd.exe
@@ -168,7 +176,9 @@ config("compiler") {
     # Don't look for libpaths in %LIB%, similar to /X in cflags above.
     ldflags += [ "/lldignoreenv" ]
   }
-
+  if (use_large_pdbs) {
+    # This allows PDBs up to 8 GiB in size. This requires lld-link.exe or
+    # link.exe from VS 2022 or later.
   # Some binaries create PDBs larger than 4 GiB. Increasing the PDB page size
   # to 8 KiB allows 8 GiB PDBs. The larger page size also allows larger block maps
   # which is a PDB limit that was hit in https://crbug.com/1406510. The page size
@@ -182,6 +192,12 @@ config("compiler") {
     ldflags += [ "/pdbpagesize:16384" ]
   } else {
     ldflags += [ "/pdbpagesize:8192" ]
+
+    if (!defined(configs)) {
+      configs = []
+    }
+    configs += [ ":pdb_larger_than_4gb" ]
+  }
   }
 
   if (!is_debug && !is_component_build) {
@@ -243,7 +259,7 @@ config("runtime_library") {
     "_ATL_NO_OPENGL",
     "_WINDOWS",
     "CERT_CHAIN_PARA_HAS_EXTRA_FIELDS",
-    "PSAPI_VERSION=2",
+    "PSAPI_VERSION=1",
     "WIN32",
     "_SECURE_ATL",
   ]
@@ -689,3 +705,15 @@ config("lean_and_mean") {
 config("nominmax") {
   defines = [ "NOMINMAX" ]
 }
+
+# Some binaries create PDBs larger than 4 GiB. Increasing the PDB page size
+# to 8 KiB allows 8 GiB PDBs. The larger page size also allows larger block maps
+# which is a PDB limit that was hit in https://crbug.com/1406510. The page size
+# can easily be increased in the future to allow even larger PDBs or larger
+# block maps.
+config("pdb_larger_than_4gb") {
+  if (!defined(ldflags)) {
+    ldflags = []
+  }
+  ldflags += [ "/pdbpagesize:8192" ]
+}
diff --git a/chrome/BUILD.gn b/chrome/BUILD.gn
index ef32e9c1315f9..ae355834ff7d0 100644
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -455,6 +455,11 @@ if (is_win) {
     if (use_aura) {
       deps += [ "//ui/compositor" ]
     }
+     if (current_cpu == "x86") {
+     # Don"t set an x64 base address (to avoid breaking HE-ASLR).
+     ldflags = [ "/BASE:0x12000000" ]
+   }
+
   }
 
   copy("copy_first_run") {
diff --git a/chrome/app/chrome_exe_main_win.cc b/chrome/app/chrome_exe_main_win.cc
index 0aced300d8dce..d2c530353eca4 100644
--- a/chrome/app/chrome_exe_main_win.cc
+++ b/chrome/app/chrome_exe_main_win.cc
@@ -242,12 +242,24 @@ __declspec(dllexport) __cdecl void GetPakFileHashes(
   *chrome_200_pak = kSha256_chrome_200_percent_pak.data();
 }
 
+void SwitchToLFHeap() {
+  // Only needed on 2000/XP but harmless on other Windows flavors.
+  auto crt_heap = _get_heap_handle();
+  ULONG enable_LFH = 2;
+  if (HeapSetInformation(reinterpret_cast<HANDLE>(crt_heap),
+                         HeapCompatibilityInformation,
+                         &enable_LFH, sizeof(enable_LFH))) {
+    VLOG(1) << "low fragmentation heap enabled";
+  }
+}
+
 #if !defined(WIN_CONSOLE_APP)
 int APIENTRY wWinMain(HINSTANCE instance, HINSTANCE prev, wchar_t*, int) {
 #else   // !defined(WIN_CONSOLE_APP)
 int main() {
   HINSTANCE instance = GetModuleHandle(nullptr);
 #endif  // !defined(WIN_CONSOLE_APP)
+  SwitchToLFHeap();
 
 #if defined(ARCH_CPU_32_BITS)
   enum class FiberStatus { kConvertFailed, kCreateFiberFailed, kSuccess };
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 0811d62fd215d..8a64908d27de9 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -2265,6 +2265,7 @@ static_library("browser") {
     "//components/net_log",
     "//components/network_hints/common:mojo_bindings",
     "//components/network_session_configurator/browser",
+    "//components/network_session_configurator/common",
     "//components/network_time",
     "//components/no_state_prefetch/browser",
     "//components/no_state_prefetch/common",
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index de3be2eec25cc..c0d6d503ee465 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -15,6 +15,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
@@ -3776,6 +3777,63 @@ const FeatureEntry::FeatureVariation
         {"experimental V2", kCompressionDictionaryTransportBackendVersionV2,
          std::size(kCompressionDictionaryTransportBackendVersionV2), nullptr}};
 
+const FeatureEntry::Choice kTabHoverCards[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"None",
+     "tab-hover-cards",
+     "none"},
+    {"Tooltip",
+     "tab-hover-cards",
+     "tooltip"},
+};
+
+const FeatureEntry::Choice kBookmarkBarNewTab[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Never",
+     "bookmark-bar-ntp",
+     "never"},
+};
+const FeatureEntry::Choice kOmniboxAutocompleteFiltering[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Search suggestions only",
+     "omnibox-autocomplete-filtering",
+     "search"},
+    {"Search suggestions and bookmarks",
+     "omnibox-autocomplete-filtering",
+     "search-bookmarks"},
+    {"Search suggestions and internal chrome pages",
+     "omnibox-autocomplete-filtering",
+     "search-chrome"},
+    {"Search suggestions, bookmarks, and internal chrome pages",
+     "omnibox-autocomplete-filtering",
+     "search-bookmarks-chrome"},
+};
+const FeatureEntry::Choice kExtensionHandlingChoices[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Download as regular file",
+     "extension-mime-request-handling",
+     "download-as-regular-file"},
+    {"Always prompt for install",
+     "extension-mime-request-handling",
+     "always-prompt-for-install"},
+};
+const FeatureEntry::Choice kMaxConnectionsPerHostChoices[] = {
+    {"6", "", ""},
+    {"15", "max-connections-per-host", "15"},
+};
+const FeatureEntry::Choice kShowAvatarButtonChoices[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Always",
+     "show-avatar-button",
+     "always"},
+    {"Incognito and Guest",
+     "show-avatar-button",
+     "incognito-and-guest"},
+    {"Never",
+     "show-avatar-button",
+     "never"}
+};
+
 // RECORDING USER METRICS FOR FLAGS:
 // -----------------------------------------------------------------------------
 // The first line of the entry is the internal name.
@@ -6153,6 +6211,18 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kMemlogStackModeDescription, kOsAll,
      MULTI_VALUE_TYPE(kMemlogStackModeChoices)},
 
+    {"incognito-brand-consistency-for-desktop",
+     flag_descriptions::kIncognitoBrandConsistencyForDesktopName,
+     flag_descriptions::kIncognitoBrandConsistencyForDesktopDescription,
+     kOsDesktop,
+     FEATURE_VALUE_TYPE(base::features::kIncognitoBrandConsistencyForDesktop)},
+
+    {"inherit-native-theme-from-parent-widget",
+     flag_descriptions::kInheritNativeThemeFromParentWidgetName,
+     flag_descriptions::kInheritNativeThemeFromParentWidgetDescription,
+     kOsDesktop,
+     FEATURE_VALUE_TYPE(views::features::kInheritNativeThemeFromParentWidget)},
+
     {"omnibox-max-zero-suggest-matches",
      flag_descriptions::kOmniboxMaxZeroSuggestMatchesName,
      flag_descriptions::kOmniboxMaxZeroSuggestMatchesDescription,
@@ -6975,10 +7045,6 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableWindowsGamingInputDataFetcherName,
      flag_descriptions::kEnableWindowsGamingInputDataFetcherDescription, kOsWin,
      FEATURE_VALUE_TYPE(features::kEnableWindowsGamingInputDataFetcher)},
-
-    {"windows11-mica-titlebar", flag_descriptions::kWindows11MicaTitlebarName,
-     flag_descriptions::kWindows11MicaTitlebarDescription, kOsWin,
-     FEATURE_VALUE_TYPE(kWindows11MicaTitlebar)},
 #endif
 
 #if BUILDFLAG(IS_ANDROID)
@@ -10715,6 +10781,13 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableBuiltinHlsDescription, kOsAll,
      FEATURE_VALUE_TYPE(media::kBuiltInHlsPlayer)},
 #endif
+	{"ungoogled-thorium",
+	 flag_descriptions::kUngoogledThoriumName, flag_descriptions::kUngoogledThoriumDescription,
+	 kOsAll, SINGLE_VALUE_TYPE("ungoogled-thorium")},
+	{"disable-download-upload",
+	 "Disable Safe Browsing for Downloads and Download Sample Uploads", "Disables prompts about unsafe or uncommon downloads, and "
+												  "prevents samples of downloads from being sent to Google.",
+	 kOsAll, SINGLE_VALUE_TYPE("disable-download-upload")},
 
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
     {"profiles-reordering", flag_descriptions::kProfilesReorderingName,
@@ -11158,6 +11231,163 @@ const FeatureEntry kFeatureEntries[] = {
      FEATURE_VALUE_TYPE(syncer::kSyncShowIdentityErrorsForSignedInUsers)},
 #endif  // BUILDFLAG(IS_ANDROID)
 
+    {"force-dark-mode",
+	 flag_descriptions::kForceDarkModeFlagName, flag_descriptions::kForceDarkModeFlagDescription, kOsAll,
+	 FEATURE_VALUE_TYPE(base::features::kForceDarkModeFlag)},
+#if BUILDFLAG(IS_WIN)
+	{"disable-windows-10-custom-titlebar",
+	 flag_descriptions::kDisableWindows10CustomTitlebarName, flag_descriptions::kDisableWindows10CustomTitlebarDescription, kOsWin,
+	 SINGLE_VALUE_TYPE("disable-windows10-custom-titlebar")},
+	{"force-xp-theme",
+	 flag_descriptions::kForceXpThemeName, flag_descriptions::kForceXpThemeDescription, kOsWin,
+	 FEATURE_VALUE_TYPE(kForceXpTheme)},
+	{"force-gdi",
+	 flag_descriptions::kForceGdiName, flag_descriptions::kForceGdiDescription, kOsWin,
+	 SINGLE_VALUE_TYPE("disable-direct-write")},
+#endif
+    {"custom-tab-shapes",
+     "Thorium Custom Tabs UI",
+     "Changes the look of browser tabs to appear with a trapezoidal shape.",
+     kOsAll,
+     FEATURE_VALUE_TYPE(features::kThoriumCustomTabs)},
+
+    {"tab-hover-cards",
+     "Tab Hover Cards",
+     "Allows removing the tab hover cards or using a tooltip as a replacement. ungoogled-chromium flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kTabHoverCards)},
+    {"custom-ntp",
+     "Custom New Tab Page",
+     "Allows setting a custom URL for the new tab page. Value can be internal (e.g. `about:blank` or `chrome://new-tab-page`), external (e.g. `example.com`), or local (e.g. `file:///tmp/startpage.html`). This applies for incognito windows as well when not set to a `chrome://` internal page. ungoogled-chromium flag",
+     kOsDesktop, ORIGIN_LIST_VALUE_TYPE("custom-ntp", "")},
+    {"bookmark-bar-ntp",
+     "Bookmark Bar on New-Tab-Page",
+     "Disable the Bookmark Bar on the New-Tab-Page. ungoogled-chromium flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kBookmarkBarNewTab)},
+    {"remove-grab-handle",
+     "Remove Grab Handle",
+     "Removes the reserved empty space in the tabstrip for moving the window. ungoogled-chromium flag",
+     kOsDesktop, SINGLE_VALUE_TYPE("remove-grab-handle")},
+    {"omnibox-autocomplete-filtering",
+     "Omnibox Autocomplete Filtering",
+     "Restrict omnibox autocomplete results to a combination of search suggestions (if enabled), bookmarks, and internal chrome pages. ungoogled-chromium flag.",
+     kOsAll, MULTI_VALUE_TYPE(kOmniboxAutocompleteFiltering)},
+	{"disable-sharing-hub",
+	 "Disable Sharing Hub",
+     "Disables the sharing hub button. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("disable-sharing-hub")},
+	{"disable-grease-tls",
+     "Disable GREASE for TLS",
+     "Turn off GREASE (Generate Random Extensions And Sustain Extensibility) for TLS connections. ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-grease-tls")},
+	{"force-punycode-hostnames",
+     "Force punycode hostnames",
+     "Force punycode in hostnames instead of Unicode when displaying Internationalized Domain Names (IDNs). ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("force-punycode-hostnames")},
+	{"hide-crashed-bubble",
+     "Hide crashed bubble",
+     "Hides the bubble box with the message \"Restore Pages? Chromium didn't shut down correctly.\" that shows on startup after the browser did not exit cleanly. ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("hide-crashed-bubble")},
+	{"hide-extensions-menu",
+     "Hide Extensions Menu",
+     "Hides the extensions container. This includes the puzzle piece icon as well as any pinned extensions. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-extensions-menu")},
+	{"hide-fullscreen-exit-ui",
+     "Hide Fullscreen Exit UI",
+     "Hides the \"X\" that appears when the mouse cursor is moved towards the top of the window in fullscreen mode. Additionally, this hides the \"Press F11 to exit full screen\" popup. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-fullscreen-exit-ui")},
+	{"hide-sidepanel-button",
+     "Hide SidePanel Button",
+     "Hides the SidePanel Button. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-sidepanel-button")},
+	{"hide-tab-close-buttons",
+     "Hide tab close buttons",
+     "Hides the close buttons on tabs. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-tab-close-buttons")},
+    {"remove-tabsearch-button",
+     "Remove Tabsearch Button",
+     "Removes the tabsearch button from the tabstrip. ungoogled-chromium flag",
+     kOsDesktop, SINGLE_VALUE_TYPE("remove-tabsearch-button")},
+    {"http-accept-header",
+     "Custom HTTP Accept Header",
+     "Set a custom value for the Accept header which is sent by the browser with every HTTP request.  (e.g. `text/html,application/xhtmlxml,application/xml;q=0.9,image/webp,*/*;q=0.8`). ungoogled-chromium flag.",
+     kOsAll, ORIGIN_LIST_VALUE_TYPE("http-accept-header", "")},
+    {"clear-data-on-exit",
+     "Clear data on exit",
+     "Clears all browsing data on exit. ungoogled-chromium flag",
+     kOsDesktop, FEATURE_VALUE_TYPE(browsing_data::features::kClearDataOnExit)},
+    {"extension-mime-request-handling",
+     "Handling of extension MIME type requests",
+     "Used when deciding how to handle a request for a CRX or User Script MIME type. ungoogled-chromium flag.",
+     kOsAll, MULTI_VALUE_TYPE(kExtensionHandlingChoices)},
+	{"keep-old-history",
+     "Keep old history",
+     "Keep history older than 3 months. ungoogled-chromium flag",
+     kOsAll, SINGLE_VALUE_TYPE("keep-old-history")},
+	{"disable-qr-generator",
+     "Disable QR Generator",
+     "Disables the QR generator for sharing page links. ungoogled-chromium flag",
+     kOsDesktop, FEATURE_VALUE_TYPE(kDisableQRGenerator)},
+	{"disable-encryption",
+     "Disable encryption",
+     "Disable encryption of cookies, passwords, and settings which uses a generated machine-specific encryption key.  This is used to enable portable user data directories.  ungoogled-chromium flag.",
+     kOsWin, SINGLE_VALUE_TYPE("disable-encryption")},
+	{"disable-machine-id",
+     "Disable machine ID",
+     "Disables use of a generated machine-specific ID to lock the user data directory to that machine.  This is used to enable portable user data directories.  ungoogled-chromium flag.",
+     kOsWin, SINGLE_VALUE_TYPE("disable-machine-id")},
+	{"compact-ui",
+     "Compact UI",
+     "Reduces the amount of padding in all UI elements.",
+     kOsDesktop, SINGLE_VALUE_TYPE("compact-ui")},
+	{"transparent-tabs",
+     "Semi-Transparent Tabs",
+     "Reduces the opacity of tabs and the new tab button, as was done before the 2018 UI refresh.",
+     kOsDesktop, SINGLE_VALUE_TYPE("transparent-tabs")},
+	{"override-tab-outline-default",
+     "Override Tab Outline Default",
+     "Trapezoidal tabs normally have outlines while rounded tabs do not. This option allows the user to override the default setting for the tab shape.",
+     kOsDesktop, SINGLE_VALUE_TYPE("override-tab-outline-default")},
+	{"override-new-tab-button-shape-default",
+     "Override New Tab Button Shape Default",
+     "Trapezoidal tabs used a trapzeoidal new tab button while rounded tabs used a round NTB. This option allows the user to override the default setting for the tab shape.",
+     kOsDesktop, SINGLE_VALUE_TYPE("override-new-tab-button-shape-default")},
+    {"download-bubble", "Enable download bubble",
+     "Enables the download bubble instead of the download shelf.",
+     kOsLinux | kOsLacros | kOsMac | kOsWin,
+     FEATURE_VALUE_TYPE(safe_browsing::kDownloadBubble)},
+    {"power-bookmarks-side-panel", "Power bookmarks side panel",
+     "Enables the power bookmarks version of the bookmarks side panel content.", kOsDesktop,
+     FEATURE_VALUE_TYPE(features::kPowerBookmarksSidePanel)},
+	{"windows11-mica-titlebar",
+     "Windows 11 Mica Taskbar",
+     "Enables support for the Windows 11 Mica Taskbar, as used in 22H2 and up.",
+     kOsDesktop, SINGLE_VALUE_TYPE("windows11-mica-titlebar")},
+	{"legacy-tooltips-win",
+     "Legacy tooltips for Windows",
+     "Force the use of native legacy tooltips on Windows 8 and up.",
+     kOsWin, SINGLE_VALUE_TYPE("legacy-tooltips-win")},
+	{"disable-pwa-install-prompt",
+     "Disable PWA Install Prompt in Address Bar",
+     "Disables the PWA (portable web app) install prompt in the address bar.",
+     kOsDesktop, SINGLE_VALUE_TYPE("disable-pwa-install-prompt")},
+	{"max-connections-per-host",
+     "Maximum connections per host",
+     "Customize maximum allowed connections per host. ungoogled-chromium flag, Bromite feature.",
+     kOsAll, MULTI_VALUE_TYPE(kMaxConnectionsPerHostChoices)},
+	{"disable-search-engine-collection",
+     "Disable search engine collection",
+     "Prevents search engines from being added automatically. ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-search-engine-collection")},
+	{"popups-to-tabs",
+     "Popups to tabs",
+     "Makes popups open in new tabs. ungoogled-chromium flag",
+     kOsAll, SINGLE_VALUE_TYPE("popups-to-tabs")},
+	 {"show-avatar-button",
+     "Show avatar/people/profile button",
+     "Show avatar/people/profile button in the browser toolbar. ungoogled-chromium flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kShowAvatarButtonChoices)}
+	// TODO: move all Supermium-specific flags to new source file.
+
     // NOTE: Adding a new flag requires adding a corresponding entry to enum
     // "LoginCustomFlags" in tools/metrics/histograms/enums.xml. See "Flag
     // Histograms" in tools/metrics/histograms/README.md (run the
diff --git a/chrome/browser/browser_process_impl.cc b/chrome/browser/browser_process_impl.cc
index 57cb42c63eb6a..b3db6309c5f59 100644
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -20,11 +20,13 @@
 #include "base/functional/callback.h"
 #include "base/functional/callback_helpers.h"
 #include "base/location.h"
+#include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
 #include "base/path_service.h"
 #include "base/run_loop.h"
+#include "base/strings/string_number_conversions.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/task/sequenced_task_runner.h"
 #include "base/task/single_thread_task_runner.h"
@@ -105,6 +107,7 @@
 #include "components/metrics/metrics_service.h"
 #include "components/metrics_services_manager/metrics_services_manager.h"
 #include "components/metrics_services_manager/metrics_services_manager_client.h"
+#include "components/network_session_configurator/common/network_switches.h"
 #include "components/network_time/network_time_tracker.h"
 #include "components/os_crypt/async/browser/os_crypt_async.h"
 #include "components/permissions/permissions_client.h"
@@ -136,6 +139,7 @@
 #include "media/media_buildflags.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "net/log/net_log.h"
+#include "net/socket/client_socket_pool_manager.h"
 #include "ppapi/buildflags/buildflags.h"
 #include "printing/buildflags/buildflags.h"
 #include "services/network/public/cpp/features.h"
@@ -371,6 +375,18 @@ void BrowserProcessImpl::Init() {
   pref_change_registrar_.Add(metrics::prefs::kMetricsReportingEnabled,
                              base::BindRepeating(&ApplyMetricsReportingPolicy));
 
+  int max_connections_per_host = 0;
+  auto switch_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
+      "max-connections-per-host");
+  if (!switch_value.empty() && !base::StringToInt(switch_value, &max_connections_per_host)) {
+    LOG(DFATAL) << "--" << "max-connections-per-host"
+      << " expected integer; got (\"" << switch_value << "\" instead)";
+  }
+  if (max_connections_per_host != 0) {
+    net::ClientSocketPoolManager::set_max_sockets_per_group(
+        net::HttpNetworkSession::NORMAL_SOCKET_POOL, max_connections_per_host);
+  }
+
   DCHECK(!webrtc_event_log_manager_);
   webrtc_event_log_manager_ = WebRtcEventLogManager::CreateSingletonInstance();
 
diff --git a/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc b/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
index d912e49786837..3b8a9066f376d 100644
--- a/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
@@ -28,6 +28,7 @@
 #include "chrome/browser/sync/sync_service_factory.h"
 #include "chrome/common/chrome_switches.h"
 #include "chrome/common/pref_names.h"
+#include "components/browsing_data/core/features.h"
 #include "components/browsing_data/core/browsing_data_policies_utils.h"
 #include "components/browsing_data/core/pref_names.h"
 #include "components/keep_alive_registry/keep_alive_types.h"
@@ -148,6 +149,21 @@ class BrowsingDataRemoverObserver
 #endif
 };
 
+uint64_t AllOriginTypeMask() {
+  return content::BrowsingDataRemover::ORIGIN_TYPE_PROTECTED_WEB |
+         content::BrowsingDataRemover::ORIGIN_TYPE_UNPROTECTED_WEB;
+}
+
+uint64_t AllRemoveMask() {
+  return content::BrowsingDataRemover::DATA_TYPE_CACHE |
+         content::BrowsingDataRemover::DATA_TYPE_DOWNLOADS |
+         chrome_browsing_data_remover::DATA_TYPE_CONTENT_SETTINGS |
+         chrome_browsing_data_remover::DATA_TYPE_FORM_DATA |
+         chrome_browsing_data_remover::DATA_TYPE_HISTORY |
+         chrome_browsing_data_remover::DATA_TYPE_PASSWORDS |
+         chrome_browsing_data_remover::DATA_TYPE_SITE_DATA;
+}
+
 uint64_t GetOriginTypeMask(const base::Value::List& data_types) {
   uint64_t result = 0;
   for (const auto& data_type : data_types) {
@@ -315,9 +331,10 @@ void ChromeBrowsingDataLifetimeManager::ClearBrowsingDataForOnExitPolicy(
   const base::Value::List& data_types = profile_->GetPrefs()->GetList(
       browsing_data::prefs::kClearBrowsingDataOnExitList);
 
-  if (!data_types.empty() &&
+   bool cdoe = base::FeatureList::IsEnabled(browsing_data::features::kClearDataOnExit);
+   if (cdoe || (!data_types.empty() &&
       IsConditionSatisfiedForBrowsingDataRemoval(GetSyncTypesForPolicyPref(
-          profile_, browsing_data::prefs::kClearBrowsingDataOnExitList))) {
+          profile_, browsing_data::prefs::kClearBrowsingDataOnExitList)))) {
     profile_->GetPrefs()->SetBoolean(
         browsing_data::prefs::kClearBrowsingDataOnExitDeletionPending, true);
     auto* remover = profile_->GetBrowsingDataRemover();
@@ -328,8 +345,8 @@ void ChromeBrowsingDataLifetimeManager::ClearBrowsingDataForOnExitPolicy(
       DCHECK(keep_browser_alive);
 #endif
     remover->RemoveAndReply(base::Time(), base::Time::Max(),
-                            GetRemoveMask(data_types),
-                            GetOriginTypeMask(data_types),
+                            cdoe ? AllRemoveMask() : GetRemoveMask(data_types),
++                           cdoe ? AllOriginTypeMask() : GetOriginTypeMask(data_types),
                             BrowsingDataRemoverObserver::Create(
                                 remover, /*filterable_deletion=*/true, profile_,
                                 keep_browser_alive));
diff --git a/chrome/browser/chrome_browser_interface_binders.cc b/chrome/browser/chrome_browser_interface_binders.cc
index 9851839728f08..fa2ea794f3038 100644
--- a/chrome/browser/chrome_browser_interface_binders.cc
+++ b/chrome/browser/chrome_browser_interface_binders.cc
@@ -1199,9 +1199,17 @@ void PopulateChromeWebUIFrameBinders(
     }
   }
 
-  RegisterWebUIControllerInterfaceBinder<
-      page_image_service::mojom::PageImageServiceHandler, HistoryUI,
-      HistoryClustersSidePanelUI, NewTabPageUI, BookmarksSidePanelUI>(map);
+  if ((history_clusters_service &&
+       history_clusters_service->is_journeys_feature_flag_enabled() &&
+       history_clusters_service->IsJourneysImagesEnabled()) ||
+      base::FeatureList::IsEnabled(ntp_features::kNtpHistoryClustersModule) ||
+      base::FeatureList::IsEnabled(
+          ntp_features::kNtpHistoryClustersModuleLoad) ||
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+    RegisterWebUIControllerInterfaceBinder<
+        page_image_service::mojom::PageImageServiceHandler, HistoryUI,
+        HistoryClustersSidePanelUI, NewTabPageUI, BookmarksSidePanelUI>(map);
+  }
 
   RegisterWebUIControllerInterfaceBinder<
       browser_command::mojom::CommandHandlerFactory, NewTabPageUI, WhatsNewUI>(
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 8e21b0a1e691a..f760166426d86 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -882,10 +882,15 @@ bool HandleNewTabPageLocationOverride(
 
   // Don't change the URL when incognito mode.
   if (profile->IsOffTheRecord())
+   if (!base::CommandLine::ForCurrentProcess()->HasSwitch("custom-ntp"))
     return false;
 
   std::string ntp_location =
       profile->GetPrefs()->GetString(prefs::kNewTabPageLocationOverride);
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("custom-ntp"))
+    ntp_location = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("custom-ntp");
+  if (profile->IsOffTheRecord() && ntp_location.find("chrome://") != std::string::npos)
+	return false;
   if (ntp_location.empty())
     return false;
   url::Component scheme;
@@ -4312,6 +4317,13 @@ std::string ChromeContentBrowserClient::GetDefaultDownloadName() {
   return l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME);
 }
 
+base::FilePath ChromeContentBrowserClient::GetFontLookupTableCacheDir() {
+  base::FilePath user_data_dir;
+  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+  DCHECK(!user_data_dir.empty());
+  return user_data_dir.Append(FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
   base::FilePath user_data_dir;
   base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
@@ -4726,7 +4738,7 @@ bool ChromeContentBrowserClient::PreSpawnChild(
     return true;
 
   sandbox::MitigationFlags mitigations = config->GetProcessMitigations();
-  mitigations |= sandbox::MITIGATION_FORCE_MS_SIGNED_BINS;
+  //mitigations |= sandbox::MITIGATION_FORCE_MS_SIGNED_BINS;
   sandbox::ResultCode result = config->SetProcessMitigations(mitigations);
   if (result != sandbox::SBOX_ALL_OK)
     return false;
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index 8ac74856217e4..c11ba71dc1e48 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -443,6 +443,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void BrowserURLHandlerCreated(content::BrowserURLHandler* handler) override;
   base::FilePath GetDefaultDownloadDirectory() override;
   std::string GetDefaultDownloadName() override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   base::FilePath GetShaderDiskCacheDirectory() override;
   base::FilePath GetGrShaderDiskCacheDirectory() override;
   base::FilePath GetGraphiteDawnDiskCacheDirectory() override;
diff --git a/chrome/browser/device_reauth/win/authenticator_win.cc b/chrome/browser/device_reauth/win/authenticator_win.cc
index 1d9342a94ad70..c12ef488478df 100644
--- a/chrome/browser/device_reauth/win/authenticator_win.cc
+++ b/chrome/browser/device_reauth/win/authenticator_win.cc
@@ -45,6 +45,11 @@ using ABI::Windows::Security::Credentials::UI::
     UserConsentVerifierAvailability_NotConfiguredForUser;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 BiometricAuthenticationStatusWin ConvertUserConsentVerifierAvailability(
     UserConsentVerifierAvailability availability) {
   switch (availability) {
@@ -93,6 +98,11 @@ void GetBiometricAvailabilityFromWindows(
   // (http://crbug/973868).
   SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
 
+  if (!ResolveCoreWinRT()) {
+    ReportCantCheckAvailability(thread, std::move(callback));
+    return;
+  }
+
   ComPtr<IUserConsentVerifierStatics> factory;
   HRESULT hr = base::win::GetActivationFactory<
       IUserConsentVerifierStatics,
diff --git a/chrome/browser/download/bubble/download_bubble_prefs.cc b/chrome/browser/download/bubble/download_bubble_prefs.cc
index 7c5414de30926..0730e36567cca 100644
--- a/chrome/browser/download/bubble/download_bubble_prefs.cc
+++ b/chrome/browser/download/bubble/download_bubble_prefs.cc
@@ -15,13 +15,13 @@
 
 namespace download {
 
-bool IsDownloadBubbleEnabled() {
+bool IsDownloadBubbleEnabled(Profile* profile) {
 // Download bubble won't replace the old download notification in
 // Ash. See https://crbug.com/1323505.
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   return false;
 #else
-  return true;
+  return base::FeatureList::IsEnabled(safe_browsing::kDownloadBubble);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 }
 
diff --git a/chrome/browser/download/bubble/download_bubble_prefs.h b/chrome/browser/download/bubble/download_bubble_prefs.h
index 5ac863183a3ab..887ca94e6ab31 100644
--- a/chrome/browser/download/bubble/download_bubble_prefs.h
+++ b/chrome/browser/download/bubble/download_bubble_prefs.h
@@ -10,7 +10,8 @@
 namespace download {
 
 // Called when deciding whether to show the bubble or the old download shelf UI.
-bool IsDownloadBubbleEnabled();
+// TODO(chlily): Remove unused profile arg.
+bool IsDownloadBubbleEnabled(Profile* profile);
 
 // Called when deciding whether to show or hide the bubble.
 bool ShouldShowDownloadBubble(Profile* profile);
diff --git a/chrome/browser/download/bubble/download_bubble_prefs_unittest.cc b/chrome/browser/download/bubble/download_bubble_prefs_unittest.cc
index 177edb3f14861..fa0e602998a4e 100644
--- a/chrome/browser/download/bubble/download_bubble_prefs_unittest.cc
+++ b/chrome/browser/download/bubble/download_bubble_prefs_unittest.cc
@@ -18,6 +18,7 @@
 #include "chrome/test/base/testing_profile_manager.h"
 #include "components/enterprise/common/proto/connectors.pb.h"
 #include "components/prefs/pref_service.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "content/public/test/browser_task_environment.h"
@@ -71,18 +72,28 @@ class DownloadBubblePrefsTest : public testing::Test {
   raw_ptr<TestingProfile, DanglingUntriaged> profile_;
   base::test::ScopedFeatureList feature_list_;
 
+  void ExpectFeatureFlagEnabledStatus(bool expect_enabled) {
+    bool is_enabled = IsDownloadBubbleEnabled(profile_);
+#if BUILDFLAG(IS_CHROMEOS_ASH)
+    EXPECT_FALSE(is_enabled);
+#else
+    EXPECT_EQ(is_enabled, expect_enabled);
+#endif
+  }
+
  private:
   content::BrowserTaskEnvironment task_environment_;
   TestingProfileManager testing_profile_manager_;
 };
 
-TEST_F(DownloadBubblePrefsTest, IsDownloadBubbleEnabled) {
-  bool is_enabled = IsDownloadBubbleEnabled();
-#if BUILDFLAG(IS_CHROMEOS_ASH)
-  EXPECT_FALSE(is_enabled);
-#else
-  EXPECT_TRUE(is_enabled);
-#endif
+TEST_F(DownloadBubblePrefsTest, FeatureFlagEnabled) {
+  feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  ExpectFeatureFlagEnabledStatus(/*expect_enabled=*/true);
+}
+
+TEST_F(DownloadBubblePrefsTest, FeatureFlagDisabled) {
+  feature_list_.InitAndDisableFeature(safe_browsing::kDownloadBubble);
+  ExpectFeatureFlagEnabledStatus(/*expect_enabled=*/false);
 }
 
 TEST_F(DownloadBubblePrefsTest, DoesDownloadConnectorBlock) {
diff --git a/chrome/browser/download/bubble/download_bubble_update_service_unittest.cc b/chrome/browser/download/bubble/download_bubble_update_service_unittest.cc
index 929cae16cfdf9..333b3623a4cf3 100644
--- a/chrome/browser/download/bubble/download_bubble_update_service_unittest.cc
+++ b/chrome/browser/download/bubble/download_bubble_update_service_unittest.cc
@@ -6,6 +6,7 @@
 
 #include <memory>
 
+#include "base/test/scoped_feature_list.h"
 #include "base/time/time.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/download/bubble/download_bubble_display_info.h"
@@ -23,6 +24,7 @@
 #include "components/offline_items_collection/core/offline_item.h"
 #include "components/offline_items_collection/core/offline_item_state.h"
 #include "components/offline_items_collection/core/test_support/mock_offline_content_provider.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "components/webapps/common/web_app_id.h"
 #include "content/public/browser/download_item_utils.h"
 #include "content/public/test/browser_task_environment.h"
@@ -69,7 +71,9 @@ void RemoveDownloadItemsObserver(
 class DownloadBubbleUpdateServiceTest : public testing::Test {
  public:
   DownloadBubbleUpdateServiceTest()
-      : testing_profile_manager_(TestingBrowserProcess::GetGlobal()) {}
+      : testing_profile_manager_(TestingBrowserProcess::GetGlobal()) {
+    feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  }
   DownloadBubbleUpdateServiceTest(const DownloadBubbleUpdateServiceTest&) =
       delete;
   DownloadBubbleUpdateServiceTest& operator=(
@@ -295,6 +299,7 @@ class DownloadBubbleUpdateServiceTest : public testing::Test {
                                                    delta);
   }
 
+  base::test::ScopedFeatureList feature_list_;
   content::BrowserTaskEnvironment task_environment_{
       base::test::TaskEnvironment::TimeSource::MOCK_TIME};
   raw_ptr<NiceMock<content::MockDownloadManager>, DanglingUntriaged>
diff --git a/chrome/browser/download/chrome_download_manager_delegate.cc b/chrome/browser/download/chrome_download_manager_delegate.cc
index 201cd68c5175c..aed9ef6c63595 100644
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -57,6 +57,7 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pdf_util.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
@@ -1693,6 +1694,10 @@ bool ChromeDownloadManagerDelegate::IsOpenInBrowserPreferredForFile(
 bool ChromeDownloadManagerDelegate::ShouldBlockFile(
     download::DownloadItem* item,
     download::DownloadDangerType danger_type) const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableDownloadUpload) ||
+		base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kUngoogledThorium))	{
+	  return false;
+  }
   // Chrome-initiated background downloads should not be blocked.
   if (item && !item->RequireSafetyChecks()) {
     return false;
@@ -1940,7 +1945,7 @@ void ChromeDownloadManagerDelegate::OnManagerInitialized() {
 #if !BUILDFLAG(IS_ANDROID)
 void ChromeDownloadManagerDelegate::ScheduleCancelForEphemeralWarning(
     const std::string& guid) {
-  if (!download::IsDownloadBubbleEnabled()) {
+  if (!download::IsDownloadBubbleEnabled(profile_)) {
     return;
   }
   LogCancelEphemeralWarningEvent(
@@ -1977,7 +1982,7 @@ void ChromeDownloadManagerDelegate::CancelForEphemeralWarning(
 }
 
 void ChromeDownloadManagerDelegate::CancelAllEphemeralWarnings() {
-  if (!download::IsDownloadBubbleEnabled()) {
+  if (!download::IsDownloadBubbleEnabled(profile_)) {
     return;
   }
   content::DownloadManager::DownloadVector downloads;
diff --git a/chrome/browser/download/chrome_download_manager_delegate_unittest.cc b/chrome/browser/download/chrome_download_manager_delegate_unittest.cc
index 94bef7049f004..15590dc046217 100644
--- a/chrome/browser/download/chrome_download_manager_delegate_unittest.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate_unittest.cc
@@ -1818,6 +1818,9 @@ TEST_F(ChromeDownloadManagerDelegateTest,
 #if !BUILDFLAG(IS_ANDROID)
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
 TEST_F(ChromeDownloadManagerDelegateTest, ScheduleCancelForEphemeralWarning) {
+  base::test::ScopedFeatureList feature_list;
+  feature_list.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+
   std::unique_ptr<download::MockDownloadItem> download_item =
       CreateActiveDownloadItem(0);
   EXPECT_CALL(*download_item, GetDangerType())
@@ -1836,6 +1839,8 @@ TEST_F(ChromeDownloadManagerDelegateTest, ScheduleCancelForEphemeralWarning) {
 
 TEST_F(ChromeDownloadManagerDelegateTest,
        ScheduleCancelForEphemeralWarning_DownloadKept) {
+  base::test::ScopedFeatureList feature_list;
+  feature_list.InitAndEnableFeature(safe_browsing::kDownloadBubble);
   std::unique_ptr<download::MockDownloadItem> download_item =
       CreateActiveDownloadItem(0);
   EXPECT_CALL(*download_item, GetDangerType())
diff --git a/chrome/browser/download/download_browsertest.cc b/chrome/browser/download/download_browsertest.cc
index 3dd33e91a4403..311d1453c7fa1 100644
--- a/chrome/browser/download/download_browsertest.cc
+++ b/chrome/browser/download/download_browsertest.cc
@@ -502,19 +502,23 @@ void CreateCompletedDownload(content::DownloadManager* download_manager,
 // Whether download UI is visible at all (download toolbar button for download
 // bubble, or download shelf).
 bool IsDownloadUiVisible(BrowserWindow* window) {
-  return window->GetDownloadBubbleUIController()
-      ->GetDownloadDisplayController()
-      ->download_display_for_testing()
-      ->IsShowing();
+  return base::FeatureList::IsEnabled(safe_browsing::kDownloadBubble)
+             ? window->GetDownloadBubbleUIController()
+                   ->GetDownloadDisplayController()
+                   ->download_display_for_testing()
+                   ->IsShowing()
+             : window->IsDownloadShelfVisible();
 }
 
 // Whether download details are visible in the UI (partial view for download
 // bubble, or download shelf).
 bool IsDownloadDetailedUiVisible(BrowserWindow* window) {
-  return window->GetDownloadBubbleUIController()
-      ->GetDownloadDisplayController()
-      ->download_display_for_testing()
-      ->IsShowingDetails();
+  return base::FeatureList::IsEnabled(safe_browsing::kDownloadBubble)
+             ? window->GetDownloadBubbleUIController()
+                   ->GetDownloadDisplayController()
+                   ->download_display_for_testing()
+                   ->IsShowingDetails()
+             : window->IsDownloadShelfVisible();
 }
 #endif
 
@@ -5006,12 +5010,20 @@ IN_PROC_BROWSER_TEST_F(DownloadTest, DISABLED_DownloadAndWait) {
   EXPECT_TRUE(IsDownloadDetailedUiVisible(browser()->window()));
 }
 
-// Tests for the download shelf.
-#if BUILDFLAG(IS_CHROMEOS_ASH)
+class DownloadShelfTest : public DownloadTest {
+ public:
+  DownloadShelfTest() {
+    feature_list_.InitAndDisableFeature(safe_browsing::kDownloadBubble);
+  }
+
+ private:
+  base::test::ScopedFeatureList feature_list_;
+};
+
 // Test that the download shelf is per-window by starting a download in one
 // tab, opening a second tab, closing the shelf, going back to the first tab,
 // and checking that the shelf is closed.
-IN_PROC_BROWSER_TEST_F(DownloadTest, PerWindowShelf) {
+IN_PROC_BROWSER_TEST_F(DownloadShelfTest, PerWindowShelf) {
   embedded_test_server()->ServeFilesFromDirectory(GetTestDataDirectory());
   ASSERT_TRUE(embedded_test_server()->Start());
   GURL url = embedded_test_server()->GetURL("/download-test3.gif");
@@ -5050,7 +5062,7 @@ IN_PROC_BROWSER_TEST_F(DownloadTest, PerWindowShelf) {
 
 // Check whether the downloads shelf is closed when the downloads tab is
 // invoked.
-IN_PROC_BROWSER_TEST_F(DownloadTest, CloseShelfOnDownloadsTab) {
+IN_PROC_BROWSER_TEST_F(DownloadShelfTest, CloseShelfOnDownloadsTab) {
   embedded_test_server()->ServeFilesFromDirectory(GetTestDataDirectory());
   ASSERT_TRUE(embedded_test_server()->Start());
   GURL url =
@@ -5068,7 +5080,6 @@ IN_PROC_BROWSER_TEST_F(DownloadTest, CloseShelfOnDownloadsTab) {
   // The download shelf should now be closed.
   EXPECT_FALSE(browser()->window()->IsDownloadShelfVisible());
 }
-#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
 // Flaky. crbug.com/1383009
 // Test that when downloading an item in Incognito mode, the download surface is
diff --git a/chrome/browser/download/download_crx_util.cc b/chrome/browser/download/download_crx_util.cc
index 2a1554690f890..6653161db3b95 100644
--- a/chrome/browser/download/download_crx_util.cc
+++ b/chrome/browser/download/download_crx_util.cc
@@ -8,6 +8,7 @@
 
 #include <memory>
 
+#include "base/command_line.h"
 #include "chrome/browser/extensions/crx_installer.h"
 #include "chrome/browser/extensions/extension_install_prompt.h"
 #include "chrome/browser/extensions/extension_management.h"
@@ -101,6 +102,14 @@ scoped_refptr<extensions::CrxInstaller> CreateCrxInstaller(
   return installer;
 }
 
+bool ShouldDownloadAsRegularFile() {
+    const base::CommandLine& command_line =
+        *base::CommandLine::ForCurrentProcess();
+    return command_line.HasSwitch("extension-mime-request-handling") &&
+        command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+        "download-as-regular-file";
+}
+
 bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetTargetDisposition() ==
       DownloadItem::TARGET_DISPOSITION_PROMPT)
@@ -109,7 +118,7 @@ bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetMimeType() == extensions::Extension::kMimeType ||
       extensions::UserScript::IsURLUserScript(download_item.GetURL(),
                                               download_item.GetMimeType())) {
-    return true;
+    return !ShouldDownloadAsRegularFile();
   } else {
     return false;
   }
diff --git a/chrome/browser/download/download_crx_util.h b/chrome/browser/download/download_crx_util.h
index 1846c1dcb4028..a50a9af030c77 100644
--- a/chrome/browser/download/download_crx_util.h
+++ b/chrome/browser/download/download_crx_util.h
@@ -35,6 +35,10 @@ scoped_refptr<extensions::CrxInstaller> CreateCrxInstaller(
     Profile* profile,
     const download::DownloadItem& download_item);
 
+// Returns true if the user wants all extensions to be downloaded as regular
+// files.
+bool ShouldDownloadAsRegularFile();
+
 // Returns true if this is an extension download. This also considers user
 // scripts to be extension downloads, since we convert those automatically.
 bool IsExtensionDownload(const download::DownloadItem& download_item);
diff --git a/chrome/browser/download/download_item_model_unittest.cc b/chrome/browser/download/download_item_model_unittest.cc
index 76c2cea6fd8a3..849162633b49b 100644
--- a/chrome/browser/download/download_item_model_unittest.cc
+++ b/chrome/browser/download/download_item_model_unittest.cc
@@ -1244,8 +1244,10 @@ class DownloadItemModelTailoredWarningTest : public DownloadItemModelTest {
  public:
   DownloadItemModelTailoredWarningTest() {
     DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-    scoped_feature_list_.InitAndEnableFeature(
-        safe_browsing::kDownloadTailoredWarnings);
+    scoped_feature_list_.InitWithFeatures(
+        {safe_browsing::kDownloadBubble,
+         safe_browsing::kDownloadTailoredWarnings},
+        {});
   }
 
   ~DownloadItemModelTailoredWarningTest() override = default;
@@ -1393,8 +1395,9 @@ class DownloadItemModelTailoredWarningDisabledTest
  public:
   DownloadItemModelTailoredWarningDisabledTest() {
     DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-    scoped_feature_list_.InitAndDisableFeature(
-        safe_browsing::kDownloadTailoredWarnings);
+    scoped_feature_list_.InitWithFeatures(
+        {safe_browsing::kDownloadBubble},
+        {safe_browsing::kDownloadTailoredWarnings});
   }
 
   ~DownloadItemModelTailoredWarningDisabledTest() override = default;
diff --git a/chrome/browser/download/download_target_determiner.cc b/chrome/browser/download/download_target_determiner.cc
index f5108b18c95a6..1d4fb400b67f0 100644
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -1201,10 +1201,12 @@ DownloadConfirmationReason DownloadTargetDeterminer::NeedsConfirmation(
     return DownloadConfirmationReason::SAVE_AS;
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
-  // Don't prompt for extension downloads if the installation site is white
-  // listed.
-  if (download_crx_util::IsTrustedExtensionDownload(GetProfile(), *download_))
-    return DownloadConfirmationReason::NONE;
+if (!download_crx_util::ShouldDownloadAsRegularFile()) {
+    // Don't prompt for extension downloads.
+    if (download_crx_util::IsTrustedExtensionDownload(GetProfile(), *download_) ||
+        filename.MatchesExtension(extensions::kExtensionFileExtension))
+      return DownloadConfirmationReason::NONE;
+  }
 #endif
 
   // Don't prompt for file types that are marked for opening automatically.
diff --git a/chrome/browser/download/download_ui_controller.cc b/chrome/browser/download/download_ui_controller.cc
index 1fbe7daeb81bf..e832d0824ad75 100644
--- a/chrome/browser/download/download_ui_controller.cc
+++ b/chrome/browser/download/download_ui_controller.cc
@@ -193,7 +193,7 @@ class CrOSUIControllerDelegate : public DownloadUIController::Delegate {
   explicit CrOSUIControllerDelegate(content::DownloadManager* manager) {
     // Conditionally add the `DownloadBubbleUIControllerDelegate`.
     auto* profile = Profile::FromBrowserContext(manager->GetBrowserContext());
-    if (download::IsDownloadBubbleEnabled()) {
+    if (download::IsDownloadBubbleEnabled(profile)) {
       delegates_.emplace_back(
           std::make_unique<DownloadBubbleUIControllerDelegate>(profile));
       InitializeDownloadBubbleUpdateService(profile, manager);
@@ -264,7 +264,7 @@ DownloadUIController::DownloadUIController(content::DownloadManager* manager,
   if (!delegate_) {
     Profile* profile =
         Profile::FromBrowserContext(manager->GetBrowserContext());
-    if (download::IsDownloadBubbleEnabled()) {
+    if (download::IsDownloadBubbleEnabled(profile)) {
       delegate_ = std::make_unique<DownloadBubbleUIControllerDelegate>(profile);
       InitializeDownloadBubbleUpdateService(profile, manager);
     } else {
diff --git a/chrome/browser/download/notification/download_notification_browsertest.cc b/chrome/browser/download/notification/download_notification_browsertest.cc
index 3222646006f07..7f4e2095fa712 100644
--- a/chrome/browser/download/notification/download_notification_browsertest.cc
+++ b/chrome/browser/download/notification/download_notification_browsertest.cc
@@ -19,6 +19,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/synchronization/lock.h"
 #include "base/task/sequenced_task_runner.h"
+#include "base/test/scoped_feature_list.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/ash/profiles/profile_helper.h"
 #include "chrome/browser/browser_process.h"
@@ -41,6 +42,7 @@
 #include "chrome/test/base/ui_test_utils.h"
 #include "components/download/public/common/download_item.h"
 #include "components/prefs/pref_service.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "components/session_manager/core/session_manager.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #include "components/signin/public/identity_manager/identity_test_utils.h"
@@ -292,7 +294,9 @@ void WaitForDownloadNotificationForDisplayService(
 // Base class for tests of download notifications.
 class DownloadNotificationTestBase : public InProcessBrowserTest {
  public:
-  DownloadNotificationTestBase() = default;
+  DownloadNotificationTestBase() {
+    scoped_feature_list_.InitAndDisableFeature(safe_browsing::kDownloadBubble);
+  }
 
   void SetUpOnMainThread() override {
     ASSERT_TRUE(embedded_test_server()->Start());
@@ -327,6 +331,8 @@ class DownloadNotificationTestBase : public InProcessBrowserTest {
   std::unique_ptr<NotificationDisplayServiceTester> display_service_;
   std::unique_ptr<NotificationDisplayServiceTester> incognito_display_service_;
   std::unique_ptr<SlowDownloadInterceptor> interceptor_;
+
+  base::test::ScopedFeatureList scoped_feature_list_;
 };
 
 //////////////////////////////////////////////////
diff --git a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
index ff0195c8fd8c6..c9cada3abd5ea 100644
--- a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
+++ b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
@@ -88,6 +88,11 @@ class WebAccountSupportFinder
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
 
+    if (!base::win::ResolveCoreWinRTDelayload())
+      return;  // Unsupported.
+    if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+      return;  // Unsupported.
+
     // Get the `WebAuthenticationCoreManager`.
     ComPtr<IWebAuthenticationCoreManagerStatics> auth_manager;
     HRESULT hresult = base::win::GetActivationFactory<
diff --git a/chrome/browser/extensions/api/downloads/downloads_api.cc b/chrome/browser/extensions/api/downloads/downloads_api.cc
index 1b72198fd44fd..540d7d82306cf 100644
--- a/chrome/browser/extensions/api/downloads/downloads_api.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api.cc
@@ -1587,6 +1587,9 @@ ExtensionFunction::ResponseAction DownloadsSetShelfEnabledFunction::Run() {
 
   MaybeSetUiEnabled(service, incognito_service, extension(), params->enabled);
 
+  bool is_bubble_enabled = download::IsDownloadBubbleEnabled(
+      Profile::FromBrowserContext(browser_context()));
+
   BrowserList* browsers = BrowserList::GetInstance();
   if (browsers) {
     for (Browser* browser : *browsers) {
@@ -1603,7 +1606,7 @@ ExtensionFunction::ResponseAction DownloadsSetShelfEnabledFunction::Run() {
       // using this API is still compatible with the new download bubble. This
       // API will eventually be deprecated (replaced by the SetUiOptions API
       // below).
-      if (download::IsDownloadBubbleEnabled() &&
+      if (is_bubble_enabled &&
           browser->window()->GetDownloadBubbleUIController()) {
         browser->window()->GetDownloadBubbleUIController()->HideDownloadUi();
       } else if (browser->window()->IsDownloadShelfVisible()) {
@@ -1643,6 +1646,9 @@ ExtensionFunction::ResponseAction DownloadsSetUiOptionsFunction::Run() {
 
   MaybeSetUiEnabled(service, incognito_service, extension(), options.enabled);
 
+  bool is_bubble_enabled = download::IsDownloadBubbleEnabled(
+      Profile::FromBrowserContext(browser_context()));
+
   BrowserList* browsers = BrowserList::GetInstance();
   if (browsers) {
     for (Browser* browser : *browsers) {
@@ -1655,7 +1661,7 @@ ExtensionFunction::ResponseAction DownloadsSetUiOptionsFunction::Run() {
       if (!match_current_service || current_service->IsDownloadUiEnabled()) {
         continue;
       }
-      if (download::IsDownloadBubbleEnabled() &&
+      if (is_bubble_enabled &&
           browser->window()->GetDownloadBubbleUIController()) {
         browser->window()->GetDownloadBubbleUIController()->HideDownloadUi();
       } else if (browser->window()->IsDownloadShelfVisible()) {
diff --git a/chrome/browser/extensions/api/downloads/downloads_api_browsertest.cc b/chrome/browser/extensions/api/downloads/downloads_api_browsertest.cc
index d474558ee9457..f0b336499a287 100644
--- a/chrome/browser/extensions/api/downloads/downloads_api_browsertest.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api_browsertest.cc
@@ -25,6 +25,7 @@
 #include "base/strings/utf_string_conversion_utils.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/test/bind.h"
+#include "base/test/scoped_feature_list.h"
 #include "base/threading/thread_restrictions.h"
 #include "base/time/time.h"
 #include "base/uuid.h"
@@ -55,6 +56,7 @@
 #include "components/download/public/common/download_item.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/content/common/file_type_policies_test_util.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
@@ -4586,7 +4588,9 @@ IN_PROC_BROWSER_TEST_F(DownloadExtensionTest,
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
 class DownloadExtensionBubbleEnabledTest : public DownloadExtensionTest {
  public:
-  DownloadExtensionBubbleEnabledTest() = default;
+  DownloadExtensionBubbleEnabledTest() {
+    feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  }
 
   DownloadDisplay* GetDownloadToolbarButton() {
     return current_browser()
@@ -4595,6 +4599,9 @@ class DownloadExtensionBubbleEnabledTest : public DownloadExtensionTest {
         ->GetDownloadDisplayController()
         ->download_display_for_testing();
   }
+
+ private:
+  base::test::ScopedFeatureList feature_list_;
 };
 
 IN_PROC_BROWSER_TEST_F(DownloadExtensionBubbleEnabledTest, SetUiOptions) {
diff --git a/chrome/browser/extensions/api/extension_action/browser_action_interactive_test.cc b/chrome/browser/extensions/api/extension_action/browser_action_interactive_test.cc
index 89bb296635360..94e5afbbe5d8a 100644
--- a/chrome/browser/extensions/api/extension_action/browser_action_interactive_test.cc
+++ b/chrome/browser/extensions/api/extension_action/browser_action_interactive_test.cc
@@ -57,6 +57,7 @@
 #include "chrome/browser/download/bubble/download_bubble_ui_controller.h"
 #include "chrome/browser/download/bubble/download_display_controller.h"
 #include "chrome/browser/ui/download/download_display.h"
+#include "components/safe_browsing/core/common/features.h"
 #endif
 
 #if BUILDFLAG(IS_WIN)
@@ -68,10 +69,12 @@ namespace {
 
 #if !BUILDFLAG(IS_CHROMEOS)
 bool IsDownloadSurfaceVisible(BrowserWindow* window) {
-  return window->GetDownloadBubbleUIController()
-      ->GetDownloadDisplayController()
-      ->download_display_for_testing()
-      ->IsShowingDetails();
+  return base::FeatureList::IsEnabled(safe_browsing::kDownloadBubble)
+             ? window->GetDownloadBubbleUIController()
+                   ->GetDownloadDisplayController()
+                   ->download_display_for_testing()
+                   ->IsShowingDetails()
+             : window->IsDownloadShelfVisible();
 }
 #endif
 
diff --git a/chrome/browser/extensions/extension_management.cc b/chrome/browser/extensions/extension_management.cc
index 16c5b86a66345..6ad24e278dcb0 100644
--- a/chrome/browser/extensions/extension_management.cc
+++ b/chrome/browser/extensions/extension_management.cc
@@ -8,6 +8,7 @@
 #include <string>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -253,6 +254,13 @@ bool ExtensionManagement::IsInstallationExplicitlyBlocked(
 bool ExtensionManagement::IsOffstoreInstallAllowed(
     const GURL& url,
     const GURL& referrer_url) const {
+   const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch("extension-mime-request-handling") &&
+      command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+      "always-prompt-for-install") {
+    return true;
+  }
   // No allowed install sites specified, disallow by default.
   if (!global_settings_->install_sources.has_value())
     return false;
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index d70932e1ad965..217901daf481d 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -1765,6 +1765,11 @@
     "owners": [ "cros-networking@google.com" ],
     "expiry_milestone": 121
   },
+  {
+    "name": "disable-download-upload",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disable-explicit-dma-fences",
     "owners": [ "chromeos-gfx@google.com" ],
@@ -1833,6 +1838,11 @@
     // workaround for some issues.
     "expiry_milestone": -1
   },
+  {
+    "name": "disable-windows-10-custom-titlebar",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disallow-doc-written-script-loads",
     "owners": [ "//chrome/browser/data_saver/OWNERS" ],
@@ -4507,6 +4517,11 @@
     // have no access to commandline flags.
     "expiry_milestone": -1
   },
+  {
+    "name": "force-xp-theme",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "forced-colors",
     "owners": [ "almaher@microsoft.com" ],
@@ -4888,11 +4903,6 @@
     "owners": [ "//chrome/android/feed/OWNERS", "jianli@chromium.org" ],
     "expiry_milestone": 130
   },
-  {
-    "name": "insecure-download-warnings",
-    "owners": [ "jdeblasio@chromium.org", "trusty-transport@chromium.org" ],
-    "expiry_milestone": 120
-  },
   {
     "name": "install-isolated-web-app-from-url",
     "owners": [ "kuragin@chromium.org", "reillyg@chromium.org", "rmcelrath@chromium.org" ],
diff --git a/chrome/browser/flag-never-expire-list.json b/chrome/browser/flag-never-expire-list.json
index a0af02d2a73eb..cb11c893bf0ae 100644
--- a/chrome/browser/flag-never-expire-list.json
+++ b/chrome/browser/flag-never-expire-list.json
@@ -32,10 +32,12 @@
   "disable-accelerated-video-decode",
   "disable-accelerated-video-encode",
   "disable-buffer-bw-compression",
+  "disable-download-upload",
   "disable-explicit-dma-fences",
   "disable-javascript-harmony-shipping",
   "disable-webrtc-hw-decoding",
   "disable-webrtc-hw-encoding",
+  "disable-windows-10-custom-titlebar",
   "disallow-doc-written-script-loads",
   "enable-autofill-credit-card-upload",
   "enable-benchmarking",
@@ -81,12 +83,15 @@
   "extensions-on-chrome-urls",
   "external-navigation-debug-logs",
   "force-color-profile",
+  "force-dark-mode",
   "force-effective-connection-type",
+  "force-gdi",
   "force-show-update-menu-badge",
   "force-startup-signin-promo",
   "force-text-direction",
   "force-ui-direction",
   "force-update-menu-type",
+  "force-xp-theme",
   "fullscreen-promos-manager-skip-internal-limits",
   "fullscreen-viewport-adjustment-experiment",
   "gesture-properties-dbus-service",
@@ -133,6 +138,7 @@
   "ui-debug-tools",
   "ui-disable-partial-swap",
   "ui-slow-animations",
+  "ungoogled-thorium",
   "unsafely-treat-insecure-origin-as-secure",
   "update-menu-item-custom-summary",
   "use-android-staging-smds",
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 8385c597f050e..8425e7513d5b1 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -1818,6 +1818,18 @@ const char kDrawImmediatelyWhenInteractiveDescription[] =
     "Causes viz to activate and draw frames immediately during a touch "
     "interaction or scroll.";
 
+const char kIncognitoBrandConsistencyForDesktopName[] =
+    "Enable Incognito brand consistency in desktop.";
+const char kIncognitoBrandConsistencyForDesktopDescription[] =
+    "When enabled, removes any theme or background customization done by the "
+    "user on the Incognito UI.";
+
+const char kInheritNativeThemeFromParentWidgetName[] =
+    "Allow widgets to inherit native theme from its parent widget.";
+const char kInheritNativeThemeFromParentWidgetDescription[] =
+    "When enabled, secondary UI like menu, dialog etc would be in dark mode "
+    "when Incognito mode is open.";
+
 const char kFillingAcrossGroupedSitesName[] =
     "Password filling across grouped websites";
 const char kFillingAcrossGroupedSitesDescription[] =
@@ -1854,6 +1866,14 @@ const char kForceTextDirectionDescription[] =
 const char kForceDirectionLtr[] = "Left-to-right";
 const char kForceDirectionRtl[] = "Right-to-left";
 
+const char kForceGdiName[] = "Force GDI font rendering";
+const char kForceGdiDescription[] =
+    "Use GDI font rendering in place of DirectWrite font rendering on Windows.";
+
+const char kDisableWindows10CustomTitlebarName[] = "Force disabling of Windows 10 custom titlebar";
+const char kDisableWindows10CustomTitlebarDescription[] =
+    "Disable the \"Windows 10\" custom titlebar to take advantage of Aero Glass fixes for the operating system.";
+
 const char kForceUiDirectionName[] = "Force UI direction";
 const char kForceUiDirectionDescription[] =
     "Explicitly force the UI to left-to-right (LTR) or right-to-left (RTL) "
@@ -2004,6 +2024,10 @@ const char kHideIncognitoMediaMetadataDescription[] =
     "When enabled, media metadata will be hidden from your OS' media player "
     "if you are in an Incognito session.";
 
+const char kUngoogledThoriumName[] = "\"Ungoogled\" Thorium Mode";
+const char kUngoogledThoriumDescription[] = "A work in progress - this rolls all new privacy-protecting "
+											"features in Thorium into one option";
+
 const char kTabAudioMutingName[] = "Tab audio muting UI control";
 const char kTabAudioMutingDescription[] =
     "When enabled, the audio indicators in the tab strip double as tab audio "
@@ -2814,6 +2838,16 @@ const char kAutoWebContentsDarkModeName[] = "Auto Dark Mode for Web Contents";
 const char kAutoWebContentsDarkModeDescription[] =
     "Automatically render all web contents using a dark theme.";
 
+const char kForceDarkModeFlagName[] = "Forced Dark Mode for UI";
+const char kForceDarkModeFlagDescription[] =
+	"Enables dark mode for all UI elements (but not web contents - "
+	"enable #enable-force-dark for darkening web contents).";
+
+const char kForceXpThemeName[] = "Use Classic Theme";
+const char kForceXpThemeDescription[] =
+	"Use the classic Chromium theme designed to mimick \"Aero\" window controls. "
+	"Typically used when desktop composition is disabled or unavailable.";
+
 const char kForcedColorsName[] = "Forced Colors";
 const char kForcedColorsDescription[] =
     "Enables forced colors mode for web content.";
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index a023e473a3c31..3ea23cfcdccd3 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1601,6 +1601,18 @@ extern const char kParallelDownloadingDescription[];
 extern const char kPasswordGenerationExperimentName[];
 extern const char kPasswordGenerationExperimentDescription[];
 
+extern const char kDisableDownloadUploadName[];
+extern const char kDisableDownloadUploadDescription[];
+
+extern const char kUngoogledThoriumName[];
+extern const char kUngoogledThoriumDescription[];
+
+extern const char kForceGdiName[];
+extern const char kForceGdiDescription[];
+
+extern const char kDisableWindows10CustomTitlebarName[];
+extern const char kDisableWindows10CustomTitlebarDescription[];
+
 extern const char kPasswordGenerationStrongLabelExperimentName[];
 extern const char kPasswordGenerationStrongLabelExperimentDescription[];
 
@@ -1619,6 +1631,12 @@ extern const char kPdfXfaFormsDescription[];
 extern const char kAutoWebContentsDarkModeName[];
 extern const char kAutoWebContentsDarkModeDescription[];
 
+extern const char kForceDarkModeFlagName[];
+extern const char kForceDarkModeFlagDescription[];
+
+extern const char kForceXpThemeName[];
+extern const char kForceXpThemeDescription[];
+
 extern const char kForcedColorsName[];
 extern const char kForcedColorsDescription[];
 
@@ -4612,6 +4630,12 @@ extern const char kTheoraVideoCodecDescription[];
 extern const char kForceSigninFlowInProfilePickerName[];
 extern const char kForceSigninFlowInProfilePickerDescription[];
 
+extern const char kIncognitoBrandConsistencyForDesktopName[];
+extern const char kIncognitoBrandConsistencyForDesktopDescription[];
+
+extern const char kInheritNativeThemeFromParentWidgetName[];
+extern const char kInheritNativeThemeFromParentWidgetDescription[];
+
 // ============================================================================
 // Don't just add flags to the end, put them in the right section in
 // alphabetical order. See top instructions for more.
diff --git a/chrome/browser/metrics/chrome_feature_list_creator.cc b/chrome/browser/metrics/chrome_feature_list_creator.cc
index 4013c8788b569..38fdd6c19a8e1 100644
--- a/chrome/browser/metrics/chrome_feature_list_creator.cc
+++ b/chrome/browser/metrics/chrome_feature_list_creator.cc
@@ -91,6 +91,9 @@ GetSwitchDependentFeatureOverrides(const base::CommandLine& command_line) {
       {switches::kEnableDownloadWarningImprovements,
        std::cref(safe_browsing::kDeepScanningEncryptedArchives),
        base::FeatureList::OVERRIDE_ENABLE_FEATURE},
+      {switches::kEnableDownloadWarningImprovements,
+       std::cref(safe_browsing::kDownloadBubble),
+       base::FeatureList::OVERRIDE_ENABLE_FEATURE},
       {switches::kEnableDownloadWarningImprovements,
        std::cref(safe_browsing::kDownloadTailoredWarnings),
        base::FeatureList::OVERRIDE_ENABLE_FEATURE},
diff --git a/chrome/browser/notifications/notification_platform_bridge_win.cc b/chrome/browser/notifications/notification_platform_bridge_win.cc
index 7e03b25b999fc..f1a2d52f28f50 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win.cc
@@ -775,7 +775,7 @@ class NotificationPlatformBridgeWinImpl
         InstallUtil::IsStartMenuShortcutWithActivatorGuidInstalled();
 
     int status = static_cast<int>(SetReadyCallbackStatus::kSuccess);
-    bool enabled = activator_registered && shortcut_installed;
+    bool enabled = base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload() && activator_registered && shortcut_installed;
 
     if (!enabled) {
       if (!shortcut_installed) {
@@ -786,6 +786,8 @@ class NotificationPlatformBridgeWinImpl
         status |= static_cast<int>(
             SetReadyCallbackStatus::kComServerMisconfiguration);
       }
+      if (!(base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload()))
+        status |= static_cast<int>(SetReadyCallbackStatus::kComNotInitialized);
     }
 
     LogSetReadyCallbackStatus(static_cast<SetReadyCallbackStatus>(status));
diff --git a/chrome/browser/notifications/win/notification_metrics.h b/chrome/browser/notifications/win/notification_metrics.h
index 7332d8bf3fa45..8d8fc295ba4ac 100644
--- a/chrome/browser/notifications/win/notification_metrics.h
+++ b/chrome/browser/notifications/win/notification_metrics.h
@@ -139,8 +139,8 @@ enum class SetReadyCallbackStatus {
   kSuccess = 0,
   kShortcutMisconfiguration = 1 << 0,
   kComServerMisconfiguration = 1 << 1,
-  kComNotInitializedObsolete = 1 << 2,  // No longer possible w/ Win10+ only.
-  kMaxValue = kComNotInitializedObsolete,
+  kComNotInitialized = 1 << 2,
+  kMaxValue = kComNotInitialized,
 };
 
 // These values are persisted to logs. Entries should not be renumbered and
diff --git a/chrome/browser/obsolete_system/obsolete_system_win.cc b/chrome/browser/obsolete_system/obsolete_system_win.cc
index 689026a405de0..356efbd904b66 100644
--- a/chrome/browser/obsolete_system/obsolete_system_win.cc
+++ b/chrome/browser/obsolete_system/obsolete_system_win.cc
@@ -22,16 +22,12 @@ base::win::Version GetRealOSVersion() {
   return base::win::OSInfo::Kernel32Version();
 }
 
-bool IsObsoleteOsVersion() {
-  return GetRealOSVersion() < base::win::Version::WIN10;
-}
-
 }  // namespace
 
 namespace ObsoleteSystem {
 
 bool IsObsoleteNowOrSoon() {
-  return IsObsoleteOsVersion();
+  return false;
 }
 
 std::u16string LocalizedObsoleteString() {
@@ -52,7 +48,7 @@ bool IsEndOfTheLine() {
   // M109 was the last milestone to support Win 7/8/8.1, the last deprecated
   // Windows version. Future deprecations should update this to the last
   // milestone that supports the soon-to-be-deprecated Windows version.
-  return CHROME_VERSION_MAJOR >= 109;
+  return false;
 }
 
 const char* GetLinkURL() {
diff --git a/chrome/browser/resources/side_panel/bookmarks/BUILD.gn b/chrome/browser/resources/side_panel/bookmarks/BUILD.gn
index 3de29e5e0223a..a575d9af8c31b 100644
--- a/chrome/browser/resources/side_panel/bookmarks/BUILD.gn
+++ b/chrome/browser/resources/side_panel/bookmarks/BUILD.gn
@@ -10,6 +10,7 @@ build_webui("build") {
   grd_prefix = "side_panel_bookmarks"
 
   static_files = [
+    "bookmarks.html",
     "images/bookmarks_empty_dark.svg",
     "images/bookmarks_empty.svg",
     "power_bookmarks.html",
@@ -17,6 +18,8 @@ build_webui("build") {
 
   # Files holding a Polymer element definition and have an equivalent .html file.
   web_component_files = [
+    "bookmark_folder.ts",
+    "bookmarks_list.ts",
     "commerce/shopping_list.ts",
     "power_bookmark_row.ts",
     "power_bookmarks_context_menu.ts",
@@ -27,6 +30,7 @@ build_webui("build") {
 
   non_web_component_files = [
     "bookmarks_api_proxy.ts",
+    "bookmarks_drag_manager.ts",
     "power_bookmarks_drag_manager.ts",
     "power_bookmarks_service.ts",
   ]
diff --git a/chrome/browser/sharing/features.cc b/chrome/browser/sharing/features.cc
index b82544d1eb4ab..2358483c69a41 100644
--- a/chrome/browser/sharing/features.cc
+++ b/chrome/browser/sharing/features.cc
@@ -6,12 +6,14 @@
 
 #include "build/build_config.h"
 
-BASE_FEATURE(kClickToCall, "ClickToCall", base::FEATURE_DISABLED_BY_DEFAULT);
+BASE_FEATURE(kClickToCall, "ClickToCall", base::FEATURE_ENABLED_BY_DEFAULT);
 
 BASE_FEATURE(kSharingMatchPulseInterval,
              "SharingMatchPulseInterval",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kDisableQRGenerator, "DisableQRGenerator", base::FEATURE_DISABLED_BY_DEFAULT);
+
 const base::FeatureParam<int> kSharingPulseDeltaDesktopHours = {
     &kSharingMatchPulseInterval, "SharingPulseDeltaDesktopHours", 24};
 
diff --git a/chrome/browser/sharing/features.h b/chrome/browser/sharing/features.h
index f1c8b48443cf3..daea87ef05d6c 100644
--- a/chrome/browser/sharing/features.h
+++ b/chrome/browser/sharing/features.h
@@ -13,6 +13,8 @@ BASE_DECLARE_FEATURE(kClickToCall);
 // Feature flag for matching device expiration to pulse interval.
 BASE_DECLARE_FEATURE(kSharingMatchPulseInterval);
 
+BASE_DECLARE_FEATURE(kDisableQRGenerator);
+
 // The delta from the pulse interval in hours after which a device is considered
 // expired, for Desktop devices. Chrome on Desktop is expected to update the
 // last updated timestamp quite frequently because it can do this when
diff --git a/chrome/browser/sharing_hub/sharing_hub_features.cc b/chrome/browser/sharing_hub/sharing_hub_features.cc
index 57d5a500579aa..168b1b576f47a 100644
--- a/chrome/browser/sharing_hub/sharing_hub_features.cc
+++ b/chrome/browser/sharing_hub/sharing_hub_features.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/sharing_hub/sharing_hub_features.h"
 
+#include "base/command_line.h"
 #include "build/build_config.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/share/share_features.h"
@@ -37,6 +38,8 @@ bool ScreenshotsDisabledByPolicy(content::BrowserContext* context) {
 }  // namespace
 
 bool SharingHubOmniboxEnabled(content::BrowserContext* context) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-sharing-hub"))
+	  return false;
 #if BUILDFLAG(IS_CHROMEOS)
   return false;
 #else
@@ -69,7 +72,7 @@ bool HasPageAction(content::BrowserContext* context, bool is_popup_mode) {
 
 BASE_FEATURE(kDesktopScreenshots,
              "DesktopScreenshots",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+             base::FEATURE_ENABLED_BY_DEFAULT);
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS)
 void RegisterProfilePrefs(PrefRegistrySimple* registry) {
diff --git a/chrome/browser/themes/theme_helper.cc b/chrome/browser/themes/theme_helper.cc
index 43b03f9c3dce7..b09f78acef546 100644
--- a/chrome/browser/themes/theme_helper.cc
+++ b/chrome/browser/themes/theme_helper.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/themes/theme_service.h"
 
 #include "base/feature_list.h"
+#include "base/features.h"
 #include "base/no_destructor.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -116,6 +117,59 @@ base::RefCountedMemory* ThemeHelper::GetRawData(
   return data;
 }
 
+// For legacy reasons, the theme supplier requires the incognito variants of
+// color IDs.  This converts from normal to incognito IDs where they exist.
+int GetIncognitoId(int id) {
+  switch (id) {
+    case TP::COLOR_FRAME_ACTIVE:
+      return TP::COLOR_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_FRAME_INACTIVE:
+      return TP::COLOR_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_ACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_ACTIVE;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_INACTIVE;
+    default:
+      return id;
+  }
+}
+
+// static
+bool ThemeHelper::ShouldIgnoreThemeSupplier(
+    int id,
+    bool incognito,
+    const CustomThemeSupplier* theme_supplier) {
+  if (incognito && base::FeatureList::IsEnabled(
+                       base::features::kIncognitoBrandConsistencyForDesktop)) {
+    return true;
+  }
+  // The incognito NTP uses the default background color instead of any theme
+  // background color, unless the theme also sets a custom background image.
+  return incognito && (id == TP::COLOR_NTP_BACKGROUND) &&
+         !HasCustomImage(IDR_THEME_NTP_BACKGROUND, theme_supplier);
+}
+
+
+// static
+bool ThemeHelper::UseIncognitoColor(int id,
+                                    const CustomThemeSupplier* theme_supplier) {
+  // Incognito is disabled for any non-ignored custom theme colors so they apply
+  // atop a predictable state.
+  return ShouldIgnoreThemeSupplier(id, true, theme_supplier) ||
+         (!IsCustomTheme(theme_supplier) &&
+          (!theme_supplier || theme_supplier->CanUseIncognitoColors()));
+}
+
+
+
 color_utils::HSL ThemeHelper::GetTint(
     int id,
     bool incognito,
@@ -125,7 +179,7 @@ color_utils::HSL ThemeHelper::GetTint(
   if (theme_supplier && theme_supplier->GetTint(id, &hsl))
     return hsl;
 
-  return TP::GetDefaultTint(id, incognito, UseDarkModeColors(theme_supplier));
+  return TP::GetDefaultTint(id, incognito  && UseIncognitoColor(id, theme_supplier), UseDarkModeColors(theme_supplier));
 }
 
 gfx::ImageSkia* ThemeHelper::GetImageSkiaNamed(
diff --git a/chrome/browser/themes/theme_helper.h b/chrome/browser/themes/theme_helper.h
index 095e3d1c69a43..628fa729b5c63 100644
--- a/chrome/browser/themes/theme_helper.h
+++ b/chrome/browser/themes/theme_helper.h
@@ -95,9 +95,21 @@ class ThemeHelper {
  private:
   friend class theme_service_internal::ThemeServiceTest;
 
+  // Whether the default incognito color/tint for |id| should be used, if
+  // available.
+  static bool UseIncognitoColor(int id,
+                                const CustomThemeSupplier* theme_supplier);
+
   // Whether dark default colors/tints should be used, if available.
   static bool UseDarkModeColors(const CustomThemeSupplier* theme_supplier);
 
+  // Whether the color from |theme_supplier| (if any) should be ignored for
+  // the given |id| and |incognito| state.
+  static bool ShouldIgnoreThemeSupplier(
+      int id,
+      bool incognito,
+      const CustomThemeSupplier* theme_supplier);
+
   // Returns a cross platform image for an id.
   gfx::Image GetImageNamed(int id,
                            bool incognito,
diff --git a/chrome/browser/themes/theme_helper_win.cc b/chrome/browser/themes/theme_helper_win.cc
index 259668e16470f..aef2186c2dee7 100644
--- a/chrome/browser/themes/theme_helper_win.cc
+++ b/chrome/browser/themes/theme_helper_win.cc
@@ -8,6 +8,11 @@
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/theme_resources.h"
+#include "base/win/windows_version.h"
+
+BASE_FEATURE(kForceXpTheme,
+             "ForceXpTheme",
+             base::FEATURE_DISABLED_BY_DEFAULT);
 
 int ThemeHelperWin::GetDefaultDisplayProperty(int id) const {
   if (id == ThemeProperties::SHOULD_FILL_BACKGROUND_TAB_COLOR) {
@@ -19,5 +24,10 @@ int ThemeHelperWin::GetDefaultDisplayProperty(int id) const {
 
 bool ThemeHelperWin::ShouldUseNativeFrame(
     const CustomThemeSupplier* theme_supplier) const {
-  return true;
+		// If it returns false, the XP fallback theme is used.
+		// And yes, Chromium has muddied the waters of what is considered "native".
+		// Aero Glass is "native", Mica is "native", and so is the Windows 10-style theme that is drawn
+		// by Chromium itself.
+		// Only the "original" Chromium theme that mimicks Aero is not considered native.
+  return (!HasCustomImage(IDR_THEME_FRAME, theme_supplier) && (base::win::GetVersion() >= base::win::Version::VISTA)) && !base::FeatureList::IsEnabled(kForceXpTheme);
 }
diff --git a/chrome/browser/themes/theme_properties.cc b/chrome/browser/themes/theme_properties.cc
index afeeddccbb9e4..d20c44473831d 100644
--- a/chrome/browser/themes/theme_properties.cc
+++ b/chrome/browser/themes/theme_properties.cc
@@ -259,8 +259,8 @@ color_utils::HSL ThemeProperties::GetDefaultTint(int id,
       return {-1, 0.54, 0.567};  // Roughly kGoogleGrey900 -> kGoogleGrey800
 
     if (incognito)
-      return {0.57, 0.65, 0.1405};  // #DEE1E6 -> kGoogleGrey800
-    return {-1, -1, 0.642};         // #DEE1E6 -> #E7EAED
+      return {0.57, 0.65, 0.87};  // #DEE1E6 -> kGoogleGrey800
+    return {-1, -1, 0.75};         // #DEE1E6 -> #E7EAED
   }
 
   return {-1, -1, -1};
diff --git a/chrome/browser/themes/theme_service.cc b/chrome/browser/themes/theme_service.cc
index ae7735b2bee81..fc84a77bd4a99 100644
--- a/chrome/browser/themes/theme_service.cc
+++ b/chrome/browser/themes/theme_service.cc
@@ -12,6 +12,7 @@
 
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
+#include "base/features.h"
 #include "base/files/file_util.h"
 #include "base/functional/bind.h"
 #include "base/location.h"
@@ -236,7 +237,10 @@ base::RefCountedMemory* ThemeService::BrowserThemeProvider::GetRawData(
 
 CustomThemeSupplier* ThemeService::BrowserThemeProvider::GetThemeSupplier()
     const {
-  return incognito_ ? nullptr : delegate_->GetThemeSupplier();
+    bool should_ignore_theme_supplier =
+      incognito_ && base::FeatureList::IsEnabled(
+                        base::features::kIncognitoBrandConsistencyForDesktop);
+  return should_ignore_theme_supplier ? nullptr : delegate_->GetThemeSupplier();
 }
 
 // ThemeService ---------------------------------------------------------------
diff --git a/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc b/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
index 721e51828987d..61443a280a9b9 100644
--- a/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/bookmarks/bookmark_tab_helper.h"
 
+#include "base/command_line.h"
 #include "base/observer_list.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -38,6 +39,11 @@ bool IsNTP(content::WebContents* web_contents) {
   if (entry->IsInitialEntry())
     entry = web_contents->GetController().GetVisibleEntry();
   const GURL& url = entry->GetURL();
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("custom-ntp")) {
+    std::string ntp_location = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("custom-ntp");
+	if(GURL(ntp_location).DeprecatedGetOriginAsURL() == url.DeprecatedGetOriginAsURL())
+		return true;
+  }
   return NewTabUI::IsNewTab(url) || NewTabPageUI::IsNewTabPageOrigin(url) ||
          NewTabPageThirdPartyUI::IsNewTabPageOrigin(url) ||
          search::NavEntryIsInstantNTP(web_contents, entry);
@@ -70,10 +76,12 @@ bool BookmarkTabHelper::ShouldShowBookmarkBar() const {
       !prefs->GetBoolean(bookmarks::prefs::kShowBookmarkBar))
     return false;
 
+  const std::string flag_value =
+    base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("bookmark-bar-ntp");
   // The bookmark bar is only shown on the NTP if the user
   // has added something to it.
   return IsNTP(web_contents()) && bookmark_model_ &&
-         bookmark_model_->HasBookmarks();
+         bookmark_model_->HasBookmarks() && (flag_value != "never");
 }
 
 void BookmarkTabHelper::AddObserver(BookmarkTabHelperObserver* observer) {
diff --git a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
index 681b1aebbf3e4..1de53c7de73c0 100644
--- a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
+++ b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
@@ -31,7 +31,7 @@ const size_t kMaxMRUFolders = 5;
 struct RecentlyUsedFoldersComboModel::Item {
   enum Type {
     TYPE_NODE,
-    TYPE_ALL_BOOKMARKS_NODE,
+    TYPE_OTHER_NODE,
     TYPE_SEPARATOR,
     TYPE_CHOOSE_ANOTHER_FOLDER
   };
@@ -87,7 +87,7 @@ RecentlyUsedFoldersComboModel::RecentlyUsedFoldersComboModel(
 
   // And put the bookmark bar and other nodes at the end of the list.
   items_.emplace_back(model->bookmark_bar_node(), Item::TYPE_NODE);
-  items_.emplace_back(model->other_node(), Item::TYPE_ALL_BOOKMARKS_NODE);
+  items_.emplace_back(model->other_node(), Item::TYPE_OTHER_NODE);
   if (model->mobile_node()->IsVisible())
     items_.emplace_back(model->mobile_node(), Item::TYPE_NODE);
   items_.emplace_back(nullptr, Item::TYPE_SEPARATOR);
@@ -106,8 +106,10 @@ std::u16string RecentlyUsedFoldersComboModel::GetItemAt(size_t index) const {
   switch (items_[index].type) {
     case Item::TYPE_NODE:
       return items_[index].node->GetTitle();
-    case Item::TYPE_ALL_BOOKMARKS_NODE:
-      return l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS);
+    case Item::TYPE_OTHER_NODE:
+      return base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+                 ? l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS)
+                 : items_[index].node->GetTitle();
     case Item::TYPE_SEPARATOR:
       // This function should not be called for separators.
       NOTREACHED();
@@ -134,8 +136,7 @@ std::optional<size_t> RecentlyUsedFoldersComboModel::GetDefaultIndex() const {
   // now a lot of code in Combobox assumes an index within `items_` bounds.
   auto it = base::ranges::find(items_, Item(parent_node_, Item::TYPE_NODE));
   if (it == items_.end()) {
-    it = base::ranges::find(items_,
-                            Item(parent_node_, Item::TYPE_ALL_BOOKMARKS_NODE));
+    it = base::ranges::find(items_, Item(parent_node_, Item::TYPE_OTHER_NODE));
   }
   return it == items_.end() ? 0 : static_cast<int>(it - items_.begin());
 }
@@ -229,7 +230,7 @@ void RecentlyUsedFoldersComboModel::MaybeChangeParent(const BookmarkNode* node,
                                                       size_t selected_index) {
   DCHECK_LT(selected_index, items_.size());
   if (items_[selected_index].type != Item::TYPE_NODE &&
-      items_[selected_index].type != Item::TYPE_ALL_BOOKMARKS_NODE) {
+      items_[selected_index].type != Item::TYPE_OTHER_NODE) {
     return;
   }
 
diff --git a/chrome/browser/ui/browser_command_controller.cc b/chrome/browser/ui/browser_command_controller.cc
index 5664d44624283..c3ce856e4f238 100644
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -1395,7 +1395,8 @@ void BrowserCommandController::InitCommandState() {
   command_updater_.UpdateCommandEnabled(IDC_WINDOW_CLOSE_OTHER_TABS,
                                         normal_window);
 
-  const bool enable_tab_search_commands = browser_->is_type_normal();
+  const bool enable_tab_search_commands = browser_->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH,
                                         enable_tab_search_commands);
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH_CLOSE,
@@ -1416,7 +1417,10 @@ void BrowserCommandController::InitCommandState() {
   }
 #endif
 
-  command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_SIDE_PANEL, true);
+  if ((browser_->is_type_normal() && features::IsChromeRefresh2023()) ||
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+    command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_SIDE_PANEL, true);
+  }
 
   if (features::IsChromeRefresh2023()) {
     if (browser_->is_type_normal()) {
diff --git a/chrome/browser/ui/browser_commands.cc b/chrome/browser/ui/browser_commands.cc
index 2feee0eb96a33..9749a09c6f019 100644
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1315,7 +1315,8 @@ void BookmarkCurrentTab(Browser* browser) {
   bool was_bookmarked_by_user = bookmarks::IsBookmarkedByUser(model, url);
 #if !BUILDFLAG(IS_ANDROID)
   PrefService* prefs = browser->profile()->GetPrefs();
-  if (!prefs->GetBoolean(
+  if (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel) &&
+      !prefs->GetBoolean(
           bookmarks::prefs::kAddedBookmarkSincePowerBookmarksLaunch)) {
     bookmarks::AddIfNotBookmarked(model, url, title, model->other_node());
     prefs->SetBoolean(bookmarks::prefs::kAddedBookmarkSincePowerBookmarksLaunch,
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index cc83cf5b38e68..37e8ce7f6cebb 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -10,6 +10,7 @@
 #include "base/functional/bind.h"
 #include "base/no_destructor.h"
 #include "base/win/windows_version.h"
+#include "chrome/browser/themes/browser_theme_pack.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/win/titlebar_config.h"
@@ -46,6 +47,13 @@ class FrameColorHelper {
   static FrameColorHelper* Get();
 
  private:
+  // Returns whether there is a custom image provided for the given id.
+  bool HasCustomImage(int id, const ui::ColorProviderKey& key) const;
+
+  // Returns true if colors from DWM can be used, i.e. this is a native frame
+  // on Windows 8+.
+  bool DwmColorsAllowed(const ui::ColorProviderKey& key) const;
+
   // Returns the Tint for the given |id|. If there is no tint, the identity tint
   // {-1, -1, -1} is returned and won't tint the color on which it is used.
   color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) const;
@@ -73,6 +81,12 @@ class FrameColorHelper {
   SkColor dwm_accent_border_color_ = SK_ColorWHITE;
 };
 
+SkColor GetDefaultInactiveFrameColor() {
+  return base::win::GetVersion() < base::win::Version::WIN10
+             ? SkColorSetRGB(0xEB, 0xEB, 0xEB)
+             : SK_ColorWHITE;
+}
+
 FrameColorHelper::FrameColorHelper() {
   FetchAccentColors();
 }
@@ -90,12 +104,16 @@ void FrameColorHelper::AddNativeChromeColors(
     return std::nullopt;
   };
 
-  // When we're custom-drawing the titlebar we want to use either the colors
-  // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
-  // custom-drawing the titlebar we want to match the color Windows actually
-  // uses because some things (like the incognito icon) use this color to
-  // decide whether they should draw in light or dark mode. Incognito colors
-  // should be the same as non-incognito in all cases here.
+  if (DwmColorsAllowed(key)) {
+    // When we're custom-drawing the titlebar we want to use either the colors
+    // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
+    // custom-drawing the titlebar we want to match the color Windows actually
+    // uses because some things (like the incognito icon) use this color to
+    // decide whether they should draw in light or dark mode. Incognito colors
+    // should be the same as non-incognito in all cases here.
+
+    constexpr SkColor kSystemSolidDarkInactiveFrameColor =
+        SkColorSetRGB(0x2B, 0x2B, 0x2B);
 
   constexpr SkColor kSystemMicaLightFrameColor =
       SkColorSetRGB(0xE8, 0xE8, 0xE8);
@@ -169,13 +187,37 @@ void FrameColorHelper::AddNativeChromeColors(
     mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
   }
 
-  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
-    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonInkDropFrameActive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
-    mixer[kColorNewTabButtonInkDropFrameInactive] =
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      mixer[ui::kColorFrameInactive] = {color.value()};
+    } else if (dwm_inactive_frame_color_) {
+      mixer[ui::kColorFrameInactive] = {dwm_inactive_frame_color_.value()};
+    } else if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemMicaDarkFrameColor
+                                            : kSystemMicaLightFrameColor};
+    } else if (!ShouldCustomDrawSystemTitlebar()) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemSolidDarkInactiveFrameColor
+                                            : GetDefaultInactiveFrameColor()};
+    } else if (dwm_frame_color_) {
+      mixer[ui::kColorFrameInactive] =
+          ui::HSLShift({dwm_frame_color_.value()},
+                       GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+    }
+
+    if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonInkDropFrameInactive] =
         ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
+      mixer[kColorNewTabButtonInkDropFrameActive] =
+          ui::GetColorWithMaxContrast(ui::kColorFrameActive);
+    }
+  } else {
+    if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE))
+      mixer[ui::kColorFrameActive] = {color.value()};
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE))
+      mixer[ui::kColorFrameInactive] = {color.value()};
   }
 }
 
@@ -198,6 +240,19 @@ FrameColorHelper* FrameColorHelper::Get() {
   return g_frame_color_helper.get();
 }
 
+bool FrameColorHelper::HasCustomImage(
+    int id,
+    const ui::ColorProviderKey& key) const {
+  return BrowserThemePack::IsPersistentImageID(id) && key.custom_theme &&
+         key.custom_theme->HasCustomImage(id);
+}
+
+bool FrameColorHelper::DwmColorsAllowed(
+    const ui::ColorProviderKey& key) const {
+  return (!ShouldCustomDrawSystemTitlebar() ||
+         !HasCustomImage(IDR_THEME_FRAME, key));
+}
+
 color_utils::HSL FrameColorHelper::GetTint(
     int id,
     const ui::ColorProviderKey& key) const {
@@ -234,10 +289,15 @@ void FrameColorHelper::FetchAccentColors() {
   }
 
   dwm_accent_border_color_ =
-      accent_color_observer->accent_border_color().value_or(SK_ColorWHITE);
-
-  dwm_frame_color_ = accent_color;
-  dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
+      accent_color_observer->accent_border_color().value_or(
+          GetDefaultInactiveFrameColor());
+
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    dwm_frame_color_ = dwm_accent_border_color_;
+  } else {
+    dwm_frame_color_ = accent_color_observer->accent_color();
+    dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
+  }
 }
 
 ui::ColorTransform GetCaptionForegroundColor(
diff --git a/chrome/browser/ui/download/download_bubble_row_view_info_unittest.cc b/chrome/browser/ui/download/download_bubble_row_view_info_unittest.cc
index 39c273134d874..9f4302f433b49 100644
--- a/chrome/browser/ui/download/download_bubble_row_view_info_unittest.cc
+++ b/chrome/browser/ui/download/download_bubble_row_view_info_unittest.cc
@@ -46,10 +46,12 @@ using TailoredVerdict = safe_browsing::ClientDownloadResponse::TailoredVerdict;
 class DownloadBubbleRowViewInfoTest : public testing::Test,
                                       public DownloadBubbleRowViewInfoObserver {
  public:
-  DownloadBubbleRowViewInfoTest() = default;
+  DownloadBubbleRowViewInfoTest() {
+    scoped_feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  }
 
   void SetUp() override {
-    if (!download::IsDownloadBubbleEnabled()) {
+    if (!download::IsDownloadBubbleEnabled(profile())) {
       GTEST_SKIP();
     }
     item_ = std::make_unique<NiceMock<download::MockDownloadItem>>();
@@ -125,6 +127,7 @@ class DownloadBubbleRowViewInfoTest : public testing::Test,
     }
   }
 
+  base::test::ScopedFeatureList scoped_feature_list_;
   content::BrowserTaskEnvironment task_environment_;
   TestingProfile profile_;
   std::unique_ptr<NiceMock<download::MockDownloadItem>> item_;
diff --git a/chrome/browser/ui/frame/window_frame_util.cc b/chrome/browser/ui/frame/window_frame_util.cc
index b2966b46fe9db..4826ca00bbd94 100644
--- a/chrome/browser/ui/frame/window_frame_util.cc
+++ b/chrome/browser/ui/frame/window_frame_util.cc
@@ -8,6 +8,7 @@
 #include "ui/gfx/geometry/size.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/command_line.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "ui/base/ui_base_features.h"
@@ -34,7 +35,8 @@ gfx::Size WindowFrameUtil::GetWindowsCaptionButtonAreaSize() {
 bool WindowFrameUtil::IsWindowsTabSearchCaptionButtonEnabled(
     const Browser* browser) {
 #if BUILDFLAG(IS_WIN)
-  return !features::IsChromeRefresh2023() && browser->is_type_normal();
+  return !features::IsChromeRefresh2023() && browser->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
 #else
   return false;
 #endif  // BUILDFLAG(IS_WIN)
diff --git a/chrome/browser/ui/layout_constants.cc b/chrome/browser/ui/layout_constants.cc
index 347b900c1dab8..87d6cc266381c 100644
--- a/chrome/browser/ui/layout_constants.cc
+++ b/chrome/browser/ui/layout_constants.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/layout_constants.h"
 
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/notreached.h"
 #include "build/build_config.h"
@@ -19,6 +20,7 @@
 #endif
 
 int GetLayoutConstant(LayoutConstant constant) {
+  const bool compact_ui = base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui");
   const bool touch_ui = ui::TouchUiController::Get()->touch_ui();
   switch (constant) {
     case APP_MENU_PROFILE_ROW_AVATAR_ICON_SIZE:
@@ -46,14 +48,20 @@ int GetLayoutConstant(LayoutConstant constant) {
       // stretching the container view.
       return 16;
     case LOCATION_BAR_BUBBLE_FONT_VERTICAL_PADDING:
+	  if(compact_ui)
+		  return 0;
       return 2;
     case LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET:
       return 1;
     case LOCATION_BAR_CHILD_INTERIOR_PADDING:
+	  if(compact_ui)
+		  return 0;
       return 3;
     case LOCATION_BAR_CHILD_CORNER_RADIUS:
       return 12;
     case LOCATION_BAR_ELEMENT_PADDING:
+	  if(compact_ui)
+		  return 0;
       return touch_ui ? 3 : 2;
     case LOCATION_BAR_PAGE_INFO_ICON_VERTICAL_PADDING:
       return touch_ui ? 3 : 5;
@@ -67,6 +75,8 @@ int GetLayoutConstant(LayoutConstant constant) {
     case LOCATION_BAR_TRAILING_DECORATION_EDGE_PADDING:
       return touch_ui ? 3 : 12;
     case LOCATION_BAR_HEIGHT:
+	  if(compact_ui)
+		  return 28;
       if (base::FeatureList::IsEnabled(omnibox::kOmniboxSteadyStateHeight) ||
           features::GetChromeRefresh2023Level() ==
               features::ChromeRefresh2023Level::kLevel2) {
@@ -93,6 +103,8 @@ int GetLayoutConstant(LayoutConstant constant) {
     case TAB_CLOSE_BUTTON_SIZE:
       return touch_ui ? 24 : 16;
     case TAB_HEIGHT: {
+	  if(compact_ui)
+		  return 24;
       bool use_touch_padding = touch_ui && !features::IsChromeRefresh2023();
 #if BUILDFLAG(IS_CHROMEOS)
       use_touch_padding &= !chromeos::features::IsRoundedWindowsEnabled();
diff --git a/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc b/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
index bd38b23f61c16..0f266a3b5496a 100644
--- a/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
+++ b/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
@@ -23,7 +23,7 @@ QRCodeGeneratorBubbleController::~QRCodeGeneratorBubbleController() {
 
 // static
 bool QRCodeGeneratorBubbleController::IsGeneratorAvailable(const GURL& url) {
-  if (!url.SchemeIsHTTPOrHTTPS())
+  if (!url.SchemeIsHTTPOrHTTPS() || base::FeatureList::IsEnabled(kDisableQRGenerator))
     return false;
 
   return true;
diff --git a/chrome/browser/ui/startup/bad_flags_prompt.cc b/chrome/browser/ui/startup/bad_flags_prompt.cc
index fd2bd40a10288..f984e16e57281 100644
--- a/chrome/browser/ui/startup/bad_flags_prompt.cc
+++ b/chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -73,7 +73,6 @@ const char* const kBadFlags[] = {
     sandbox::policy::switches::kDisableGpuSandbox,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kDisableSetuidSandbox,
-    sandbox::policy::switches::kNoSandbox,
 #if BUILDFLAG(IS_WIN)
     sandbox::policy::switches::kAllowThirdPartyModules,
 #endif
diff --git a/chrome/browser/ui/startup/default_browser_infobar_delegate.cc b/chrome/browser/ui/startup/default_browser_infobar_delegate.cc
index a2724af3f2cc2..996d9ddb9b917 100644
--- a/chrome/browser/ui/startup/default_browser_infobar_delegate.cc
+++ b/chrome/browser/ui/startup/default_browser_infobar_delegate.cc
@@ -60,7 +60,7 @@ DefaultBrowserInfoBarDelegate::GetIdentifier() const {
 }
 
 const gfx::VectorIcon& DefaultBrowserInfoBarDelegate::GetVectorIcon() const {
-  return vector_icons::kProductIcon;
+  return vector_icons::kInfoOutlineIcon;
 }
 
 bool DefaultBrowserInfoBarDelegate::ShouldExpire(
diff --git a/chrome/browser/ui/startup/infobar_utils.cc b/chrome/browser/ui/startup/infobar_utils.cc
index 0ee4b04c7bb63..26b70281e679b 100644
--- a/chrome/browser/ui/startup/infobar_utils.cc
+++ b/chrome/browser/ui/startup/infobar_utils.cc
@@ -117,7 +117,8 @@ void AddInfoBarsIfNecessary(Browser* browser,
     return;
 
   // Web apps should not display the session restore bubble (crbug.com/1264121)
-  if (!is_web_app && HasPendingUncleanExit(browser->profile()))
+  if (!is_web_app && HasPendingUncleanExit(browser->profile()) &&
+      !startup_command_line.HasSwitch("hide-crashed-bubble"))
     SessionCrashedBubble::ShowIfNotOffTheRecordProfile(
         browser, /*skip_tab_checking=*/false);
 
diff --git a/chrome/browser/ui/tabs/tab_style.cc b/chrome/browser/ui/tabs/tab_style.cc
index aa9cd30374311..1d5ef0e93e4a4 100644
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/tabs/tab_style.h"
 
+#include "base/command_line.h"
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "ui/base/ui_base_features.h"
@@ -71,7 +72,9 @@ TabStyle::~TabStyle() = default;
 
 int GM2TabStyle::GetStandardWidth() const {
   // The standard tab width is 240 DIP including both separators.
-  constexpr int kTabWidth = 240;
+  int kTabWidth = 240;
+  if(base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui"))
+	kTabWidth = 193;
   // The overlap includes one separator, so subtract it here.
   return kTabWidth + GetTabOverlap() - GetSeparatorSize().width();
 }
@@ -118,7 +121,7 @@ int GM2TabStyle::GetMinimumInactiveWidth() const {
 }
 
 int GM2TabStyle::GetTabOverlap() const {
-  return GetBottomCornerRadius() * 2 + GetSeparatorSize().width();
+	return GetBottomCornerRadius() * 2 + GetSeparatorSize().width();
 }
 
 int GM2TabStyle::GetDragHandleExtension(int height) const {
@@ -126,8 +129,15 @@ int GM2TabStyle::GetDragHandleExtension(int height) const {
 }
 
 gfx::Size GM2TabStyle::GetSeparatorSize() const {
-  return gfx::Size(kGM2SeparatorThickness,
+  if (!base::FeatureList::IsEnabled(features::kThoriumCustomTabs)) {
+	  if(base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui"))
+		  return gfx::Size(kGM2SeparatorThickness,
+                   GetLayoutConstant(TAB_SEPARATOR_HEIGHT) * 0.6);
+	return gfx::Size(kGM2SeparatorThickness,
                    GetLayoutConstant(TAB_SEPARATOR_HEIGHT));
+  }
+  else
+	  return gfx::Size(0, 0);
 }
 
 gfx::Insets GM2TabStyle::GetSeparatorMargins() const {
@@ -147,12 +157,12 @@ gfx::Size GM2TabStyle::GetPreviewImageSize() const {
 }
 
 int GM2TabStyle::GetTopCornerRadius() const {
-  return views::LayoutProvider::Get()->GetCornerRadiusMetric(
+	return views::LayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kHigh);
 }
 
 int GM2TabStyle::GetBottomCornerRadius() const {
-  return views::LayoutProvider::Get()->GetCornerRadiusMetric(
+	return views::LayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kHigh);
 }
 
@@ -169,10 +179,15 @@ SkColor GM2TabStyle::GetTabBackgroundColor(
   const SkColor active_color = color_provider.GetColor(
       frame_active ? kColorTabBackgroundActiveFrameActive
                    : kColorTabBackgroundActiveFrameInactive);
+#if BUILDFLAG(IS_WIN)
   const SkColor inactive_color = color_provider.GetColor(
       frame_active ? kColorTabBackgroundInactiveFrameActive
                    : kColorTabBackgroundInactiveFrameInactive);
-
+#else
+  const SkColor inactive_color = color_provider.GetColor(
+      frame_active ? kColorTabBackgroundInactiveFrameActive
+                   : kColorTabBackgroundInactiveFrameInactive);
+#endif
   if (hovered) {
     return active_color;
   }
@@ -206,10 +221,10 @@ int ChromeRefresh2023TabStyle::GetBottomCornerRadius() const {
 
 int ChromeRefresh2023TabStyle::GetTabOverlap() const {
   // The overlap removes the width and the margins of the separator.
-  const float total_separator_width = GetSeparatorMargins().left() +
-                                      GetSeparatorSize().width() +
-                                      GetSeparatorMargins().right();
-  return 2 * GetBottomCornerRadius() - total_separator_width;
+	const float total_separator_width = GetSeparatorMargins().left() +
+										GetSeparatorSize().width() +
+										GetSeparatorMargins().right();
+	return 2 * GetBottomCornerRadius() - total_separator_width;
 }
 
 gfx::Size ChromeRefresh2023TabStyle::GetSeparatorSize() const {
diff --git a/chrome/browser/ui/test/test_browser_ui.cc b/chrome/browser/ui/test/test_browser_ui.cc
index 2f61aef15bbf8..2b49f57680e6f 100644
--- a/chrome/browser/ui/test/test_browser_ui.cc
+++ b/chrome/browser/ui/test/test_browser_ui.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/ui/test/test_browser_ui.h"
 
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/test/gtest_util.h"
 #include "base/test/test_switches.h"
 #include "build/build_config.h"
@@ -159,8 +160,8 @@ void TestBrowserUi::ShowAndVerifyUi() {
   // Gold files for pixel tests are for light mode, so if dark mode is not
   // forced, and host is in dark mode, skip test.
   if (!IsInteractiveUi() &&
-      !base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode) &&
+      (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag) &&
       ui::NativeTheme::GetInstanceForNativeUi()->ShouldUseDarkColors()) {
     GTEST_SKIP() << "Host is in dark mode; skipping test";
   }
diff --git a/chrome/browser/ui/ui_features.cc b/chrome/browser/ui/ui_features.cc
index a5621a1406701..a89093804ccfc 100644
--- a/chrome/browser/ui/ui_features.cc
+++ b/chrome/browser/ui/ui_features.cc
@@ -98,6 +98,11 @@ BASE_FEATURE(kLightweightExtensionOverrideConfirmations,
              base::FEATURE_ENABLED_BY_DEFAULT);
 #endif
 
+// Enables Bookmarks++ Side Panel UI.
+BASE_FEATURE(kPowerBookmarksSidePanel,
+             "PowerBookmarksSidePanel",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+
 // Enables the QuickCommands UI surface. See https://crbug.com/1014639
 BASE_FEATURE(kQuickCommands,
              "QuickCommands",
diff --git a/chrome/browser/ui/ui_features.h b/chrome/browser/ui/ui_features.h
index 4f1f84c1ed3fe..596b2219a2263 100644
--- a/chrome/browser/ui/ui_features.h
+++ b/chrome/browser/ui/ui_features.h
@@ -60,6 +60,8 @@ BASE_DECLARE_FEATURE(kHaTSWebUI);
 BASE_DECLARE_FEATURE(kLightweightExtensionOverrideConfirmations);
 #endif
 
+BASE_DECLARE_FEATURE(kPowerBookmarksSidePanel);
+
 BASE_DECLARE_FEATURE(kQuickCommands);
 
 BASE_DECLARE_FEATURE(kResponsiveToolbar);
diff --git a/chrome/browser/ui/view_ids.h b/chrome/browser/ui/view_ids.h
index 32cb1ec72c112..ca49cd278596b 100644
--- a/chrome/browser/ui/view_ids.h
+++ b/chrome/browser/ui/view_ids.h
@@ -75,7 +75,7 @@ enum ViewID {
 
   // The Bookmark Bar.
   VIEW_ID_BOOKMARK_BAR,
-  VIEW_ID_ALL_BOOKMARKS,
+  VIEW_ID_OTHER_BOOKMARKS,
   VIEW_ID_MANAGED_BOOKMARKS,
   // Used for bookmarks/folders on the bookmark bar.
   VIEW_ID_BOOKMARK_BAR_ELEMENT,
diff --git a/chrome/browser/ui/views/apps/app_window_frame_view_win.cc b/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
index cdd99c6adf68c..cec34b3d9ebc6 100644
--- a/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
+++ b/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
@@ -6,6 +6,8 @@
 
 #include <windows.h>
 
+#include "base/win/windows_version.h"
+
 #include <algorithm>
 
 #include "extensions/browser/app_window/native_app_window.h"
@@ -33,13 +35,32 @@ gfx::Insets AppWindowFrameViewWin::GetFrameInsets() const {
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYSIZEFRAME) +
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYCAPTION);
 
-  return gfx::Insets::TLBR(caption_height, 0, 0, 0);
+  int frame_size =
+      base::win::GetVersion() < base::win::Version::WIN10
+          ? display::win::ScreenWin::GetSystemMetricsInDIP(SM_CXSIZEFRAME)
+          : 0;
+
+  return gfx::Insets::TLBR(caption_height, frame_size, frame_size, frame_size);
 }
 
 gfx::Insets AppWindowFrameViewWin::GetClientAreaInsets(HMONITOR monitor) const {
-  const int frame_thickness = ui::GetFrameThickness(monitor);
-  return gfx::Insets::TLBR(0, frame_thickness, frame_thickness,
-                           frame_thickness);
+  gfx::Insets insets;
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    // This tells Windows that most of the window is a client area, meaning
+    // Chrome will draw it. Windows still fills in the glass bits because of the
+    // DwmExtendFrameIntoClientArea call in |UpdateDWMFrame|.
+    // Without this 1 pixel offset on the right and bottom:
+    //   * windows paint in a more standard way, and
+    //   * we get weird black bars at the top when maximized in multiple monitor
+    //     configurations.
+    int border_thickness = 1;
+    insets = gfx::Insets::TLBR(0, 0, border_thickness, border_thickness);
+  } else {
+    const int frame_thickness = ui::GetFrameThickness(monitor);
+    insets =
+        gfx::Insets::TLBR(0, frame_thickness, frame_thickness, frame_thickness);
+  }
+  return insets;
 }
 
 gfx::Rect AppWindowFrameViewWin::GetBoundsForClientView() const {
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
index 025e162e8e40b..90d3642460c10 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
@@ -893,9 +893,9 @@ const BookmarkNode* BookmarkBarView::GetNodeForButtonAtModelIndex(
     return bookmark_model_->bookmark_bar_node();
   }
 
-  // And finally the all bookmarks button.
-  if (all_bookmarks_button_->GetVisible() &&
-      all_bookmarks_button_->bounds().Contains(adjusted_loc)) {
+  // And finally the other folder.
+  if (other_bookmarks_button_->GetVisible() &&
+      other_bookmarks_button_->bounds().Contains(adjusted_loc)) {
     return bookmark_model_->other_node();
   }
 
@@ -907,7 +907,7 @@ MenuButton* BookmarkBarView::GetMenuButtonForNode(const BookmarkNode* node) {
     return managed_bookmarks_button_;
   }
   if (node == bookmark_model_->other_node()) {
-    return all_bookmarks_button_;
+    return other_bookmarks_button_;
   }
   if (node == bookmark_model_->bookmark_bar_node()) {
     return overflow_button_;
@@ -926,11 +926,10 @@ void BookmarkBarView::GetAnchorPositionForButton(
     MenuButton* button,
     views::MenuAnchorPosition* anchor) {
   using Position = views::MenuAnchorPosition;
-  if (button == all_bookmarks_button_ || button == overflow_button_) {
+  if (button == other_bookmarks_button_ || button == overflow_button_)
     *anchor = Position::kTopRight;
-  } else {
+  else
     *anchor = Position::kTopLeft;
-  }
 }
 
 int BookmarkBarView::GetLeadingMargin() const {
@@ -1006,7 +1005,7 @@ gfx::Size BookmarkBarView::CalculatePreferredSize() const {
 
 gfx::Size BookmarkBarView::GetMinimumSize() const {
   // The minimum width of the bookmark bar should at least contain the overflow
-  // button, by which one can access all the Bookmark Bar items, and the "All
+  // button, by which one can access all the Bookmark Bar items, and the "Other
   // Bookmarks" folder, along with appropriate margins and button padding.
   // It should also contain the Managed Bookmarks folder, if it is visible.
   int width = GetLeadingMargin();
@@ -1020,8 +1019,8 @@ gfx::Size BookmarkBarView::GetMinimumSize() const {
     gfx::Size size = managed_bookmarks_button_->GetPreferredSize();
     width += size.width() + bookmark_bar_button_padding;
   }
-  if (all_bookmarks_button_->GetVisible()) {
-    gfx::Size size = all_bookmarks_button_->GetPreferredSize();
+  if (other_bookmarks_button_->GetVisible()) {
+    gfx::Size size = other_bookmarks_button_->GetPreferredSize();
     width += size.width() + bookmark_bar_button_padding;
   }
   if (overflow_button_->GetVisible()) {
@@ -1078,9 +1077,10 @@ void BookmarkBarView::Layout() {
   };
   const int y = center_y(button_height);
 
-  gfx::Size all_bookmarks_pref = all_bookmarks_button_->GetVisible()
-                                     ? all_bookmarks_button_->GetPreferredSize()
-                                     : gfx::Size();
+  gfx::Size other_bookmarks_pref =
+      other_bookmarks_button_->GetVisible()
+          ? other_bookmarks_button_->GetPreferredSize()
+          : gfx::Size();
   gfx::Size overflow_pref = overflow_button_->GetPreferredSize();
   gfx::Size bookmarks_separator_pref =
       bookmarks_separator_view_->GetPreferredSize();
@@ -1094,8 +1094,8 @@ void BookmarkBarView::Layout() {
 
   int max_x = GetLeadingMargin() + width - overflow_pref.width() -
               bookmarks_separator_pref.width();
-  if (all_bookmarks_button_->GetVisible()) {
-    max_x -= all_bookmarks_pref.width() + bookmark_bar_button_padding;
+  if (other_bookmarks_button_->GetVisible()) {
+    max_x -= other_bookmarks_pref.width() + bookmark_bar_button_padding;
   }
 
   // Start with the apps page shortcut button.
@@ -1214,11 +1214,11 @@ void BookmarkBarView::Layout() {
     x += bookmarks_separator_pref.width();
   }
 
-  // The "All Bookmarks" button.
-  if (all_bookmarks_button_->GetVisible()) {
-    all_bookmarks_button_->SetBounds(x, y, all_bookmarks_pref.width(),
-                                     button_height);
-    x += all_bookmarks_pref.width();
+  // The "All/Other Bookmarks" button.
+  if (other_bookmarks_button_->GetVisible()) {
+    other_bookmarks_button_->SetBounds(x, y, other_bookmarks_pref.width(),
+                                       button_height);
+    x += other_bookmarks_pref.width();
   }
 }
 
@@ -1355,9 +1355,9 @@ int BookmarkBarView::OnDragUpdated(const ui::DropTargetEvent& event) {
   }
 
   if (location.on || location.button_type == DROP_OVERFLOW ||
-      location.button_type == DROP_ALL_BOOKMARKS_FOLDER) {
+      location.button_type == DROP_OTHER_FOLDER) {
     const BookmarkNode* node;
-    if (location.button_type == DROP_ALL_BOOKMARKS_FOLDER) {
+    if (location.button_type == DROP_OTHER_FOLDER) {
       node = bookmark_model_->other_node();
     } else if (location.button_type == DROP_OVERFLOW) {
       node = bookmark_model_->bookmark_bar_node();
@@ -1465,17 +1465,19 @@ void BookmarkBarView::BookmarkModelLoaded(BookmarkModel* model,
   // once, or we didn't properly clear things. Either of which shouldn't happen.
   // The actual bookmark buttons are added from Layout().
   DCHECK(bookmark_buttons_.empty());
-  const std::u16string all_bookmarks_button_text =
-      l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS);
-  all_bookmarks_button_->SetAccessibleName(all_bookmarks_button_text);
-  all_bookmarks_button_->SetText(all_bookmarks_button_text);
+  const std::u16string other_bookmarks_button_text =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+          ? l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS)
+          : model->other_node()->GetTitle();
+  other_bookmarks_button_->SetAccessibleName(other_bookmarks_button_text);
+  other_bookmarks_button_->SetText(other_bookmarks_button_text);
   const auto managed_title = managed_->managed_node()->GetTitle();
   managed_bookmarks_button_->SetAccessibleName(
       GetFolderButtonAccessibleName(managed_title));
   managed_bookmarks_button_->SetText(managed_title);
   UpdateAppearanceForTheme();
   UpdateOtherAndManagedButtonsVisibility();
-  all_bookmarks_button_->SetEnabled(true);
+  other_bookmarks_button_->SetEnabled(true);
   managed_bookmarks_button_->SetEnabled(true);
   LayoutAndPaint();
 }
@@ -1708,7 +1710,7 @@ void BookmarkBarView::ShowContextMenuForViewImpl(
 
   const BookmarkNode* parent = nullptr;
   std::vector<raw_ptr<const BookmarkNode, VectorExperimental>> nodes;
-  if (source == all_bookmarks_button_) {
+  if (source == other_bookmarks_button_) {
     parent = bookmark_model_->other_node();
     // Do this so the user can open all bookmarks. BookmarkContextMenu makes
     // sure the user can't edit/delete the node in this case.
@@ -1764,9 +1766,9 @@ void BookmarkBarView::Init() {
 
   overflow_button_ = AddChildView(CreateOverflowButton());
 
-  all_bookmarks_button_ = AddChildView(CreateAllBookmarksButton());
+  other_bookmarks_button_ = AddChildView(CreateOtherBookmarksButton());
   // We'll re-enable when the model is loaded.
-  all_bookmarks_button_->SetEnabled(false);
+  other_bookmarks_button_->SetEnabled(false);
 
   profile_pref_registrar_.Init(browser_->profile()->GetPrefs());
   profile_pref_registrar_.Add(
@@ -1817,13 +1819,13 @@ size_t BookmarkBarView::GetFirstHiddenNodeIndex() const {
   return i - bookmark_buttons_.cbegin();
 }
 
-std::unique_ptr<MenuButton> BookmarkBarView::CreateAllBookmarksButton() {
+std::unique_ptr<MenuButton> BookmarkBarView::CreateOtherBookmarksButton() {
   auto button = std::make_unique<BookmarkFolderButton>(base::BindRepeating(
       [](BookmarkBarView* bar, const ui::Event& event) {
         bar->OnMenuButtonPressed(bar->bookmark_model_->other_node(), event);
       },
       base::Unretained(this)));
-  button->SetID(VIEW_ID_ALL_BOOKMARKS);
+  button->SetID(VIEW_ID_OTHER_BOOKMARKS);
   button->set_context_menu_controller(this);
   return button;
 }
@@ -2110,12 +2112,12 @@ void BookmarkBarView::CalculateDropLocation(
   int mirrored_x = GetMirroredXInView(event.x());
 
   bool found = false;
-  const int other_delta_x = mirrored_x - all_bookmarks_button_->x();
+  const int other_delta_x = mirrored_x - other_bookmarks_button_->x();
   Profile* profile = browser_->profile();
-  if (all_bookmarks_button_->GetVisible() && other_delta_x >= 0 &&
-      other_delta_x < all_bookmarks_button_->width()) {
+  if (other_bookmarks_button_->GetVisible() && other_delta_x >= 0 &&
+      other_delta_x < other_bookmarks_button_->width()) {
     // Mouse is over 'other' folder.
-    location->button_type = DROP_ALL_BOOKMARKS_FOLDER;
+    location->button_type = DROP_OTHER_FOLDER;
     location->on = true;
     found = true;
   } else if (bookmark_buttons_.empty()) {
@@ -2175,8 +2177,8 @@ void BookmarkBarView::CalculateDropLocation(
       } else {
         return;
       }
-    } else if (!all_bookmarks_button_->GetVisible() ||
-               mirrored_x < all_bookmarks_button_->x()) {
+    } else if (!other_bookmarks_button_->GetVisible() ||
+               mirrored_x < other_bookmarks_button_->x()) {
       // Mouse is after the last visible button but before more recently
       // bookmarked; use the last visible index.
       location->index = GetFirstHiddenNodeIndex();
@@ -2186,12 +2188,11 @@ void BookmarkBarView::CalculateDropLocation(
   }
 
   if (location->on) {
-    const BookmarkNode* parent =
-        (location->button_type == DROP_ALL_BOOKMARKS_FOLDER)
-            ? bookmark_model_->other_node()
-            : bookmark_model_->bookmark_bar_node()
-                  ->children()[location->index.value()]
-                  .get();
+    const BookmarkNode* parent = (location->button_type == DROP_OTHER_FOLDER)
+                                     ? bookmark_model_->other_node()
+                                     : bookmark_model_->bookmark_bar_node()
+                                           ->children()[location->index.value()]
+                                           .get();
     location->operation = chrome::GetBookmarkDropOperation(
         profile, event, data, parent, parent->children().size());
     if (location->operation != DragOperation::kNone && !data.has_single_url() &&
@@ -2243,8 +2244,8 @@ void BookmarkBarView::UpdateAppearanceForTheme() {
   }
 
   const SkColor color = color_provider->GetColor(kColorBookmarkBarForeground);
-  all_bookmarks_button_->SetEnabledTextColors(color);
-  all_bookmarks_button_->SetImageModel(
+  other_bookmarks_button_->SetEnabledTextColors(color);
+  other_bookmarks_button_->SetImageModel(
       views::Button::STATE_NORMAL,
       chrome::GetBookmarkFolderIcon(chrome::BookmarkFolderIconType::kNormal,
                                     kColorBookmarkFolderIcon));
@@ -2275,9 +2276,10 @@ void BookmarkBarView::UpdateAppearanceForTheme() {
 
 bool BookmarkBarView::UpdateOtherAndManagedButtonsVisibility() {
   bool has_other_children = !bookmark_model_->other_node()->children().empty();
-  bool update_other = has_other_children != all_bookmarks_button_->GetVisible();
+  bool update_other =
+      has_other_children != other_bookmarks_button_->GetVisible();
   if (update_other) {
-    all_bookmarks_button_->SetVisible(has_other_children);
+    other_bookmarks_button_->SetVisible(has_other_children);
     UpdateBookmarksSeparatorVisibility();
   }
 
@@ -2297,12 +2299,13 @@ void BookmarkBarView::UpdateBookmarksSeparatorVisibility() {
   // ChromeOS does not paint the bookmarks separator line because it looks odd
   // on the flat background. We keep it present for layout, but don't draw it.
   if (features::IsChromeRefresh2023()) {
-    bookmarks_separator_view_->SetVisible(all_bookmarks_button_->GetVisible());
+    bookmarks_separator_view_->SetVisible(
+        other_bookmarks_button_->GetVisible());
   } else {
     bookmarks_separator_view_->SetVisible(false);
   }
 #else
-  bookmarks_separator_view_->SetVisible(all_bookmarks_button_->GetVisible());
+  bookmarks_separator_view_->SetVisible(other_bookmarks_button_->GetVisible());
 #endif
 }
 
@@ -2331,7 +2334,7 @@ void BookmarkBarView::InsertBookmarkButtonAtIndex(
 // All of the secondary buttons are always in the view hierarchy, even if
 // they're not visible. The order should be: [Apps shortcut] [Managed bookmark
 // button] [saved tab group bar] [..bookmark buttons..] [Overflow chevron]
-// [All bookmarks]
+// [All/Other bookmarks]
 #if DCHECK_IS_ON()
   auto i = children().cbegin();
   DCHECK_EQ(*i++, apps_page_shortcut_);
@@ -2342,11 +2345,11 @@ void BookmarkBarView::InsertBookmarkButtonAtIndex(
   const auto is_bookmark_button = [this](const View* v) {
     return (views::IsViewClass<BookmarkButton>(v) ||
             views::IsViewClass<BookmarkFolderButton>(v)) &&
-           v != overflow_button_ && v != all_bookmarks_button_;
+           v != overflow_button_ && v != other_bookmarks_button_;
   };
   i = std::find_if_not(i, children().cend(), is_bookmark_button);
   DCHECK_EQ(*i++, overflow_button_);
-  DCHECK_EQ(*i++, all_bookmarks_button_);
+  DCHECK_EQ(*i++, other_bookmarks_button_);
 #endif
   const auto view_index = saved_tab_group_bar_
                               ? GetIndexOf(saved_tab_group_bar_).value()
@@ -2366,7 +2369,7 @@ size_t BookmarkBarView::GetIndexForButton(views::View* button) {
 const BookmarkNode* BookmarkBarView::GetParentNodeAndIndexForDrop(
     size_t& index) {
   const BookmarkNode* root =
-      (drop_info_->location.button_type == DROP_ALL_BOOKMARKS_FOLDER)
+      (drop_info_->location.button_type == DROP_OTHER_FOLDER)
           ? bookmark_model_->other_node()
           : bookmark_model_->bookmark_bar_node();
 
@@ -2376,7 +2379,7 @@ const BookmarkNode* BookmarkBarView::GetParentNodeAndIndexForDrop(
   }
 
   const BookmarkNode* parent_node;
-  if (drop_info_->location.button_type == DROP_ALL_BOOKMARKS_FOLDER) {
+  if (drop_info_->location.button_type == DROP_OTHER_FOLDER) {
     parent_node = root;
     index = parent_node->children().size();
   } else if (drop_info_->location.on) {
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h
index 81a446510fb2c..039b2dd0c9296 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h
@@ -125,8 +125,8 @@ class BookmarkBarView : public views::AccessiblePaneView,
 
   // Returns the button responsible for showing bookmarks in the
   // "Other Bookmarks" folder.
-  views::MenuButton* all_bookmarks_button() const {
-    return all_bookmarks_button_;
+  views::MenuButton* other_bookmarks_button() const {
+    return other_bookmarks_button_;
   }
 
   // Returns the button used when not all the items on the bookmark bar fit.
@@ -239,11 +239,7 @@ class BookmarkBarView : public views::AccessiblePaneView,
   friend class BookmarkBarViewEventTestBase;
 
   // Used to identify what the user is dropping onto.
-  enum DropButtonType {
-    DROP_BOOKMARK,
-    DROP_ALL_BOOKMARKS_FOLDER,
-    DROP_OVERFLOW
-  };
+  enum DropButtonType { DROP_BOOKMARK, DROP_OTHER_FOLDER, DROP_OVERFLOW };
 
   // Creates recent bookmark button and when visible button as well as
   // calculating the preferred height.
@@ -266,8 +262,8 @@ class BookmarkBarView : public views::AccessiblePaneView,
   // visible, this returns GetBookmarkButtonCount().
   size_t GetFirstHiddenNodeIndex() const;
 
-  // Creates the button showing the "All Bookmarks" folder.
-  std::unique_ptr<views::MenuButton> CreateAllBookmarksButton();
+  // Creates the button showing the "Other Bookmarks" folder.
+  std::unique_ptr<views::MenuButton> CreateOtherBookmarksButton();
 
   // Creates the button showing the "Managed Bookmarks" folder.
   std::unique_ptr<views::MenuButton> CreateManagedBookmarksButton();
@@ -411,7 +407,7 @@ class BookmarkBarView : public views::AccessiblePaneView,
   raw_ptr<SavedTabGroupBar> saved_tab_group_bar_ = nullptr;
 
   // Shows the "Other Bookmarks" folder button.
-  raw_ptr<views::MenuButton> all_bookmarks_button_ = nullptr;
+  raw_ptr<views::MenuButton> other_bookmarks_button_ = nullptr;
 
   // Shows the managed bookmarks entries.
   raw_ptr<views::MenuButton> managed_bookmarks_button_ = nullptr;
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
index 213540e0cc6f3..e76cdef698660 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
@@ -911,7 +911,7 @@ class BookmarkBarViewTest7 : public BookmarkBarViewDragTestBase {
 
     // The button should be highlighted now.
     EXPECT_EQ(views::Button::STATE_PRESSED,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     // Cause the target view to trigger a mouse up when dragged over.
     const views::View* target_view = drop_menu->GetSubmenu()->GetMenuItemAt(1);
@@ -931,7 +931,7 @@ class BookmarkBarViewTest7 : public BookmarkBarViewDragTestBase {
   void OnWidgetDragComplete(views::Widget* widget) override {
     // The button should be in normal state now.
     EXPECT_EQ(views::Button::STATE_NORMAL,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     BookmarkBarViewDragTestBase::OnWidgetDragComplete(widget);
   }
@@ -946,7 +946,7 @@ class BookmarkBarViewTest7 : public BookmarkBarViewDragTestBase {
 
   gfx::Point GetDragTargetInScreen() const override {
     return ui_test_utils::GetCenterInScreenCoordinates(
-        bb_view_->all_bookmarks_button());
+        bb_view_->other_bookmarks_button());
   }
 };
 
@@ -1002,7 +1002,7 @@ class BookmarkBarViewTest8 : public BookmarkBarViewDragTestBase {
 
   gfx::Point GetDragTargetInScreen() const override {
     return ui_test_utils::GetCenterInScreenCoordinates(
-        bb_view_->all_bookmarks_button());
+        bb_view_->other_bookmarks_button());
   }
 };
 
@@ -1595,7 +1595,7 @@ class BookmarkBarViewTest17 : public BookmarkBarViewEventTestBase {
 #endif
 VIEW_TEST(BookmarkBarViewTest17, MAYBE_ContextMenus3)
 
-// Verifies sibling menus works. Clicks on the 'all bookmarks' folder, then
+// Verifies sibling menus works. Clicks on the 'other bookmarks' folder, then
 // moves the mouse over the first item on the bookmark bar and makes sure the
 // menu appears.
 class BookmarkBarViewTest18 : public BookmarkBarViewEventTestBase {
@@ -1610,7 +1610,7 @@ class BookmarkBarViewTest18 : public BookmarkBarViewEventTestBase {
   void Step2() {
     // The button should be pressed.
     EXPECT_EQ(views::Button::STATE_PRESSED,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     // Move the mouse to the first folder on the bookmark bar.
     views::LabelButton* button = GetBookmarkButton(0);
@@ -1627,9 +1627,9 @@ class BookmarkBarViewTest18 : public BookmarkBarViewEventTestBase {
     // The menu for the first folder should be in the pressed state (since the
     // menu is showing for it)...
     EXPECT_EQ(views::Button::STATE_PRESSED, GetBookmarkButton(0)->GetState());
-    // ... And the "all bookmarks" button should no longer be pressed.
+    // ... And the "other bookmarks" button should no longer be pressed.
     EXPECT_EQ(views::Button::STATE_NORMAL,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     bb_view_->GetMenu()->GetMenuController()->Cancel(
         views::MenuController::ExitType::kAll);
@@ -1663,8 +1663,8 @@ class BookmarkBarViewTest19 : public BookmarkBarViewEventTestBase {
   void Step3() {
     ASSERT_TRUE(MenuIsShowing());
 
-    // Move the mouse back to the "All Bookmarks" button.
-    views::LabelButton* button = bb_view_->all_bookmarks_button();
+    // Move the mouse back to the "Other Bookmarks" button.
+    views::LabelButton* button = bb_view_->other_bookmarks_button();
     gfx::Point button_center(button->width() / 2, button->height() / 2);
     views::View::ConvertPointToScreen(button, &button_center);
     ASSERT_TRUE(ui_controls::SendMouseMoveNotifyWhenDone(
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
index 6c809c86fbac2..648b69fb793ea 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
@@ -326,8 +326,10 @@ class BookmarkBubbleView::BookmarkBubbleDelegate
                   ->GetComboboxByUniqueId(kBookmarkFolderFieldId)
                   ->selected_index());
 
-    browser_->window()->MaybeShowFeaturePromo(
-        feature_engagement::kIPHPowerBookmarksSidePanelFeature);
+    if (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+      browser_->window()->MaybeShowFeaturePromo(
+          feature_engagement::kIPHPowerBookmarksSidePanelFeature);
+    }
   }
 
   RecentlyUsedFoldersComboModel* GetFolderModel() {
@@ -391,6 +393,7 @@ void BookmarkBubbleView::ShowBubble(
     product_info = shopping_service->GetAvailableProductInfoForUrl(url);
   }
 
+  if (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
   if (product_info.has_value() && !product_info->image_url.is_empty()) {
     HandleImageUrlResponse(profile, product_info->image_url);
   } else {
@@ -400,10 +403,20 @@ void BookmarkBubbleView::ShowBubble(
 
   // Display favicon while awaiting one of the above options to load.
   const auto centered_favicon = GetFaviconForWebContents(web_contents);
+
   gfx::ImageSkia main_image = centered_favicon;
 
   dialog_model_builder.SetMainImage(ui::ImageModel::FromImageSkia(main_image));
 
+  } else {
+    dialog_model_builder.AddExtraButton(
+        base::BindRepeating(&BookmarkBubbleDelegate::OnEditButton,
+                            base::Unretained(bubble_delegate)),
+        ui::DialogModel::Button::Params()
+            .SetLabel(l10n_util::GetStringUTF16(IDS_BOOKMARK_BUBBLE_OPTIONS))
+            .AddAccelerator(ui::Accelerator(ui::VKEY_E, ui::EF_ALT_DOWN)));
+  }
+
   ui::ElementIdentifier initially_focused_field = kBookmarkNameFieldId;
   std::u16string secondary_button_label =
       l10n_util::GetStringUTF16(IDS_BOOKMARK_BUBBLE_REMOVE_BOOKMARK);
@@ -490,6 +503,9 @@ void BookmarkBubbleView::ShowBubble(
     bool is_price_tracked = shopping_service->IsSubscribedFromCache(
         commerce::BuildUserSubscriptionForClusterId(
             product_info->product_cluster_id.value()));
+	if (!base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+      dialog_model_builder.AddSeparator();
+    }
     dialog_model_builder.AddCustomField(
         std::make_unique<views::BubbleDialogModelHost::CustomView>(
             std::make_unique<PriceTrackingView>(profile, url, is_price_tracked,
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc
index 7a61f89fb8d21..114ba5cb30a92 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc
@@ -132,6 +132,32 @@ class PowerBookmarkBubbleViewBrowserTest
   ~PowerBookmarkBubbleViewBrowserTest() override = default;
 };
 
+// Ash always has sync ON
+#if !BUILDFLAG(IS_CHROMEOS_ASH)
+IN_PROC_BROWSER_TEST_F(BookmarkBubbleViewBrowserTest,
+                       InvokeUi_bookmark_details_synced_off) {
+  ShowAndVerifyUi();
+}
+#endif
+
+IN_PROC_BROWSER_TEST_F(BookmarkBubbleViewBrowserTest,
+                       InvokeUi_bookmark_details_synced_on) {
+  ShowAndVerifyUi();
+}
+
+// TODO(crbug.com/1473858): Flaky on Windows and Chrome OS.
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_CHROMEOS)
+#define MAYBE_InvokeUi_bookmark_details_on_trackable_product \
+  DISABLED_InvokeUi_bookmark_details_on_trackable_product
+#else
+#define MAYBE_InvokeUi_bookmark_details_on_trackable_product \
+  InvokeUi_bookmark_details_on_trackable_product
+#endif
+IN_PROC_BROWSER_TEST_F(BookmarkBubbleViewBrowserTest,
+                       MAYBE_InvokeUi_bookmark_details_on_trackable_product) {
+  ShowAndVerifyUi();
+}
+
 IN_PROC_BROWSER_TEST_F(PowerBookmarkBubbleViewBrowserTest,
                        InvokeUi_bookmark_details_on_trackable_product) {
   ShowAndVerifyUi();
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc b/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc
index 993424968a989..69a537b3b8e41 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc
@@ -632,7 +632,8 @@ void BookmarkMenuDelegate::BuildMenu(const BookmarkNode* parent,
                                      size_t start_child_index,
                                      MenuItemView* menu) {
   DCHECK_LE(start_child_index, parent->children().size());
-  if (parent == GetBookmarkModel()->other_node()) {
+  if (parent == GetBookmarkModel()->other_node()&&
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
     ui::ImageModel bookmarks_side_panel_icon =
         features::IsSidePanelPinningEnabled()
             ? ui::ImageModel::FromVectorIcon(
diff --git a/chrome/browser/ui/views/commerce/price_tracking_view.cc b/chrome/browser/ui/views/commerce/price_tracking_view.cc
index be19d0361b0b6..528f29d2b0f67 100644
--- a/chrome/browser/ui/views/commerce/price_tracking_view.cc
+++ b/chrome/browser/ui/views/commerce/price_tracking_view.cc
@@ -34,6 +34,8 @@
 #include "ui/views/layout/layout_provider.h"
 
 namespace {
+constexpr int kProductImageSize = 56;
+constexpr int kImageBorderRadius = 4;
 constexpr int kIconSize = 16;
 constexpr int kIconMargin = 14;
 constexpr int kIconSizeRefresh = 20;
@@ -59,22 +61,49 @@ PriceTrackingView::PriceTrackingView(Profile* profile,
       is_price_track_enabled_(is_price_track_enabled),
       product_info_(product_info) {
   auto* layout_provider = views::LayoutProvider::Get();
-  const int label_spacing = 0;
-  const auto label_context = views::style::CONTEXT_LABEL;
+  const bool power_bookmarks_side_panel_enabled =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel);
+  const int label_spacing = power_bookmarks_side_panel_enabled ? 0 : 4;
+  const auto label_context = power_bookmarks_side_panel_enabled
+                                 ? views::style::CONTEXT_LABEL
+                                 : views::style::CONTEXT_DIALOG_BODY_TEXT;
   const int horizontal_spacing = layout_provider->GetDistanceMetric(
       views::DISTANCE_RELATED_CONTROL_HORIZONTAL);
   const gfx::Insets dialog_insets =
       layout_provider->GetInsetsMetric(views::INSETS_DIALOG);
-  if (features::IsChromeRefresh2023()) {
-    SetCrossAxisAlignment(views::LayoutAlignment::kStart);
+  if (power_bookmarks_side_panel_enabled) {
+    if (features::IsChromeRefresh2023()) {
+      SetCrossAxisAlignment(views::LayoutAlignment::kStart);
+    }
+    // Icon column
+    auto* icon = AddChildView(std::make_unique<views::ImageView>());
+    icon->SetImage(
+        ui::ImageModel::FromVectorIcon(omnibox::kPriceTrackingDisabledIcon,
+                                       kColorBookmarkDialogTrackPriceIcon));
+    icon->SetImageSize(GetIconSize());
+    icon->SetProperty(views::kMarginsKey,
+                      gfx::Insets::TLBR(0, 0, 0, GetIconMargin()));
+  } else {
+    // image column
+    auto* product_image_containter =
+        AddChildView(std::make_unique<views::BoxLayoutView>());
+    product_image_containter->SetCrossAxisAlignment(
+        views::BoxLayout::CrossAxisAlignment::kCenter);
+    product_image_containter->SetProperty(
+        views::kMarginsKey, gfx::Insets::TLBR(0, 0, 0, horizontal_spacing));
+    // Set product image.
+    product_image_containter->AddChildView(
+        views::Builder<views::ImageView>()
+            .SetImageSize(gfx::Size(kProductImageSize, kProductImageSize))
+            .SetPreferredSize(gfx::Size(kProductImageSize, kProductImageSize))
+            // TODO(meiliang@): Verify color and corner radius with UX.
+            .SetBorder(views::CreateThemedRoundedRectBorder(
+                1, kImageBorderRadius, kColorBookmarkDialogProductImageBorder))
+            .SetImage(
+						ui::ImageModel::FromVectorIcon(omnibox::kPriceTrackingDisabledIcon,
+                      kColorBookmarkDialogTrackPriceIcon))
+            .Build());
   }
-  // Icon column
-  auto* icon = AddChildView(std::make_unique<views::ImageView>());
-  icon->SetImage(ui::ImageModel::FromVectorIcon(
-      omnibox::kPriceTrackingDisabledIcon, kColorBookmarkDialogTrackPriceIcon));
-  icon->SetImageSize(GetIconSize());
-  icon->SetProperty(views::kMarginsKey,
-                    gfx::Insets::TLBR(0, 0, 0, GetIconMargin()));
 
   // Text column
   auto text_container = std::make_unique<views::FlexLayoutView>();
@@ -110,7 +139,9 @@ PriceTrackingView::PriceTrackingView(Profile* profile,
   body_label_ = text_container->AddChildView(std::make_unique<views::Label>(
       l10n_util::GetStringUTF16(body_string_id), label_context,
       views::style::STYLE_SECONDARY));
-  body_label_->SetFontList(body_label_->font_list().DeriveWithSizeDelta(-1));
+  if (power_bookmarks_side_panel_enabled) {
+    body_label_->SetFontList(body_label_->font_list().DeriveWithSizeDelta(-1));
+  }
   body_label_->SetProperty(views::kMarginsKey,
                            gfx::Insets::TLBR(label_spacing, 0, 0, 0));
   body_label_->SetMultiLine(true);
@@ -136,17 +167,24 @@ PriceTrackingView::PriceTrackingView(Profile* profile,
   const int bubble_width = ChromeLayoutProvider::Get()->GetDistanceMetric(
       views::DISTANCE_BUBBLE_PREFERRED_WIDTH);
   int label_width;
-  toggle_button_->SetProperty(
-      views::kFlexBehaviorKey,
-      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
-                               features::IsChromeRefresh2023()
-                                   ? views::MaximumFlexSizeRule::kPreferred
-                                   : views::MaximumFlexSizeRule::kUnbounded)
-          .WithAlignment(views::LayoutAlignment::kEnd));
-
-  label_width = bubble_width - horizontal_spacing * 2 - dialog_insets.right() -
-                GetIconMargin() - GetIconSize().width() -
-                toggle_button_->GetPreferredSize().width();
+  if (power_bookmarks_side_panel_enabled) {
+    toggle_button_->SetProperty(
+        views::kFlexBehaviorKey,
+        views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
+                                 features::IsChromeRefresh2023()
+                                     ? views::MaximumFlexSizeRule::kPreferred
+                                     : views::MaximumFlexSizeRule::kUnbounded)
+            .WithAlignment(views::LayoutAlignment::kEnd));
+
+    label_width = bubble_width - horizontal_spacing * 2 -
+                  dialog_insets.right() - GetIconMargin() -
+                  GetIconSize().width() -
+                  toggle_button_->GetPreferredSize().width();
+  } else {
+    label_width = bubble_width - horizontal_spacing * 2 -
+                  dialog_insets.width() - kProductImageSize -
+                  toggle_button_->GetPreferredSize().width();
+  }
   body_label_->SizeToFit(label_width);
   base::RecordAction(base::UserMetricsAction(
       "Commerce.PriceTracking.BookmarkDialogPriceTrackViewShown"));
diff --git a/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc b/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc
index 75a72ed465192..baf60d48bd696 100644
--- a/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc
+++ b/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc
@@ -40,7 +40,11 @@ ShoppingCollectionIphView::ShoppingCollectionIphView() {
       views::style::STYLE_BODY_4_MEDIUM));
   title->SetHorizontalAlignment(gfx::HorizontalAlignment::ALIGN_LEFT);
 
-  const auto label_context = views::style::CONTEXT_LABEL;
+  const bool power_bookmarks_side_panel_enabled =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel);
+  const auto label_context = power_bookmarks_side_panel_enabled
+                                 ? views::style::CONTEXT_LABEL
+                                 : views::style::CONTEXT_DIALOG_BODY_TEXT;
   std::u16string body_text =
       l10n_util::GetStringUTF16(IDS_SHOPPING_COLLECTION_IPH_BODY);
   views::Label* body_label = AddChildView(std::make_unique<views::Label>(
@@ -48,7 +52,10 @@ ShoppingCollectionIphView::ShoppingCollectionIphView() {
   body_label->SetEnabledColorId(ui::kColorSysOnSurfaceSubtle);
   body_label->SetMultiLine(true);
   body_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
-  body_label->SetFontList(body_label->font_list().DeriveWithSizeDelta(-1));
+
+  if (power_bookmarks_side_panel_enabled) {
+    body_label->SetFontList(body_label->font_list().DeriveWithSizeDelta(-1));
+  }
 }
 
 ShoppingCollectionIphView::~ShoppingCollectionIphView() = default;
diff --git a/chrome/browser/ui/views/download/bubble/download_bubble_row_list_view_unittest.cc b/chrome/browser/ui/views/download/bubble/download_bubble_row_list_view_unittest.cc
index 3707e01fb4ae8..fc13011125862 100644
--- a/chrome/browser/ui/views/download/bubble/download_bubble_row_list_view_unittest.cc
+++ b/chrome/browser/ui/views/download/bubble/download_bubble_row_list_view_unittest.cc
@@ -18,6 +18,7 @@
 #include "components/download/public/common/download_item.h"
 #include "components/download/public/common/mock_download_item.h"
 #include "components/offline_items_collection/core/offline_item.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "content/public/browser/download_item_utils.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -31,7 +32,9 @@ using ::testing::ReturnRefOfCopy;
 
 class DownloadBubbleRowListViewTest : public TestWithBrowserView {
  public:
-  DownloadBubbleRowListViewTest() = default;
+  DownloadBubbleRowListViewTest() {
+    scoped_feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  }
   ~DownloadBubbleRowListViewTest() override = default;
 
   DownloadBubbleRowListViewTest(const DownloadBubbleRowListViewTest&) = delete;
@@ -90,6 +93,7 @@ class DownloadBubbleRowListViewTest : public TestWithBrowserView {
   }
 
  protected:
+  base::test::ScopedFeatureList scoped_feature_list_;
   std::unique_ptr<DownloadBubbleRowListViewInfo> info_;
   std::unique_ptr<DownloadBubbleRowListView> row_list_view_;
   std::vector<std::unique_ptr<NiceMock<download::MockDownloadItem>>>
diff --git a/chrome/browser/ui/views/download/bubble/download_bubble_row_view_unittest.cc b/chrome/browser/ui/views/download/bubble/download_bubble_row_view_unittest.cc
index 79932141f03c9..804287d21ca79 100644
--- a/chrome/browser/ui/views/download/bubble/download_bubble_row_view_unittest.cc
+++ b/chrome/browser/ui/views/download/bubble/download_bubble_row_view_unittest.cc
@@ -12,6 +12,7 @@
 #include "chrome/browser/ui/views/frame/test_with_browser_view.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_view.h"
 #include "components/download/public/common/mock_download_item.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "components/vector_icons/vector_icons.h"
 #include "content/public/browser/download_item_utils.h"
 #include "testing/gmock/include/gmock/gmock.h"
@@ -36,7 +37,9 @@ class DownloadBubbleRowViewTest : public TestWithBrowserView {
  public:
   DownloadBubbleRowViewTest()
       : TestWithBrowserView(
-            content::BrowserTaskEnvironment::TimeSource::MOCK_TIME) {}
+            content::BrowserTaskEnvironment::TimeSource::MOCK_TIME) {
+    scoped_feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  }
 
   DownloadBubbleRowViewTest(const DownloadBubbleRowViewTest&) = delete;
   DownloadBubbleRowViewTest& operator=(const DownloadBubbleRowViewTest&) =
@@ -77,6 +80,7 @@ class DownloadBubbleRowViewTest : public TestWithBrowserView {
   download::MockDownloadItem* download_item() { return &download_item_; }
 
  protected:
+  base::test::ScopedFeatureList scoped_feature_list_;
   NiceMock<download::MockDownloadItem> download_item_;
   std::unique_ptr<DownloadBubbleRowViewInfo> info_;
   std::unique_ptr<DownloadBubbleRowView> row_view_;
diff --git a/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc b/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
index bd44a6dfc03ed..2388b5f0f2635 100644
--- a/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
+++ b/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <memory>
 
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
@@ -35,6 +36,7 @@
 #include "chrome/browser/ui/views/frame/toolbar_button_provider.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_action_hover_card_controller.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.h"
+#include "chrome/browser/ui/views/toolbar/toolbar_view.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/feature_engagement/public/event_constants.h"
@@ -538,10 +540,20 @@ void ExtensionsToolbarContainer::AnchorAndShowWidgetImmediately(
   // * AnchorAndShowWidgetImmediately runs.
   // Revisit how to handle that, likely the Widget should Close on removal which
   // would remove the AnchoredWidget entry.
-  views::View* const anchor_view = GetViewForId(iter->extension_id);
+  views::View* anchor_view = GetViewForId(iter->extension_id);
   widget->widget_delegate()->AsBubbleDialogDelegate()->SetAnchorView(
       anchor_view && anchor_view->GetVisible() ? anchor_view
                                                : GetExtensionsButton());
+
+  // Fix the position of widgets. Without this fix, extension-installed-bubble
+  // and extension-uninstall-dialog may be out of the window border on Linux.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-extensions-menu"))
+  {
+    anchor_view = BrowserView::GetBrowserViewForBrowser(browser_)
+      ->toolbar_button_provider()->GetAppMenuButton();
+    widget->widget_delegate()->AsBubbleDialogDelegate()
+      ->SetAnchorView(anchor_view);
+  }
   widget->Show();
 }
 
@@ -919,6 +931,9 @@ void ExtensionsToolbarContainer::UpdateContainerVisibility() {
 }
 
 bool ExtensionsToolbarContainer::ShouldContainerBeVisible() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-extensions-menu"))
+    return false;
+
   // The container (and extensions-menu button) should not be visible if we have
   // no extensions.
   if (!HasAnyExtensions())
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
index 625c6931ab746..a387da94cc498 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
@@ -367,12 +367,20 @@ bool BrowserDesktopWindowTreeHostWin::GetDwmFrameInsetsInPixels(
     *insets = gfx::Insets();
   } else {
     // The glass should extend to the bottom of the tabstrip.
+    HWND hwnd = GetHWND();
     gfx::Rect tabstrip_region_bounds(browser_frame_->GetBoundsForTabStripRegion(
         browser_view_->tab_strip_region_view()->GetMinimumSize()));
-    tabstrip_region_bounds = display::win::ScreenWin::DIPToClientRect(
-        GetHWND(), tabstrip_region_bounds);
-
-    *insets = gfx::Insets::TLBR(tabstrip_region_bounds.bottom(), 0, 0, 0);
+    tabstrip_region_bounds =
+        display::win::ScreenWin::DIPToClientRect(hwnd, tabstrip_region_bounds);
+
+    // The 2 px (not DIP) at the inner edges of Win 7 glass are a light and dark
+    // line, so we must inset further to account for those.
+    constexpr int kWin7GlassInset = 2;
+    const int inset = (base::win::GetVersion() < base::win::Version::WIN8)
+                          ? kWin7GlassInset
+                          : 0;
+    *insets = gfx::Insets::TLBR(tabstrip_region_bounds.bottom() + inset, inset,
+                                inset, inset);
   }
   return true;
 }
@@ -465,6 +473,9 @@ void BrowserDesktopWindowTreeHostWin::PostHandleMSG(UINT message,
 }
 
 views::FrameMode BrowserDesktopWindowTreeHostWin::GetFrameMode() const {
+  if (browser_view_->GetIsWebAppType())
+	  return views::FrameMode::CUSTOM_DRAWN;
+
   const views::FrameMode system_frame_mode =
       ShouldBrowserCustomDrawTitlebar(browser_view_)
           ? views::FrameMode::SYSTEM_DRAWN_NO_CONTROLS
@@ -494,11 +505,13 @@ bool BrowserDesktopWindowTreeHostWin::ShouldUseNativeFrame() const {
   if (!browser_view_->browser())
     return false;
 
-  // We don't theme popup or app windows, so regardless of whether or not a
-  // theme is active for normal browser windows, we don't want to use the custom
-  // frame for popups/apps.
-  if (!browser_view_->GetIsNormalType())
-    return true;
+  // Use the custom frame where desired.
+  if (!browser_view_->GetIsNormalType()) {
+	 if(!browser_view_->GetIsWebAppType() && GetWidget()->GetThemeProvider()->ShouldUseNativeFrame())
+		return true;
+	 else
+		return false;
+  }
   // Otherwise, we use the native frame when we're told we should by the theme
   // provider (e.g. no custom theme is active).
   return GetWidget()->GetThemeProvider()->ShouldUseNativeFrame();
diff --git a/chrome/browser/ui/views/frame/browser_frame.cc b/chrome/browser/ui/views/frame/browser_frame.cc
index a52bb8913d37f..1c1c20afe32df 100644
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -10,6 +10,7 @@
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/debug/leak_annotations.h"
+#include "base/features.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
 #include "build/build_config.h"
@@ -347,7 +348,8 @@ const ui::ThemeProvider* BrowserFrame::GetThemeProvider() const {
 ui::ColorProviderKey::ThemeInitializerSupplier* BrowserFrame::GetCustomTheme()
     const {
   // Do not return any custom theme if this is an incognito browser.
-  if (IsIncognitoBrowser()) {
+  if (IsIncognitoBrowser() && base::FeatureList::IsEnabled(
+            base::features::kIncognitoBrandConsistencyForDesktop)) {
     return nullptr;
   }
 
@@ -568,8 +570,20 @@ void BrowserFrame::SelectNativeTheme() {
   // of system theme (gtk, qt etc).
   ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
   if (IsIncognitoBrowser()) {
-    SetNativeTheme(native_theme);
-    return;
+    // If the flag is enabled, then no matter if we are using the default theme
+    // or not we always use the dark ui instance.
+      if (base::FeatureList::IsEnabled(
+            base::features::kIncognitoBrandConsistencyForDesktop)) {
+      SetNativeTheme(ui::NativeTheme::GetInstanceForDarkUI());
+      return;
+    }
+
+    // Flag is disabled, fallback to using dark theme only if the incognito
+    // profile is using a default theme.
+      if (ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile())
+            ->UsingDefaultTheme()) {
+        native_theme = ui::NativeTheme::GetInstanceForDarkUI();
+	}
   }
 
   // Ignore the system theme for web apps with window-controls-overlay as the
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.cc b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
index bd59ccd1b1784..ac51accaaec18 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
@@ -417,7 +417,7 @@ void BrowserFrameViewWin::ResetWindowControls() {
 void BrowserFrameViewWin::OnThemeChanged() {
   BrowserNonClientFrameView::OnThemeChanged();
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
@@ -663,24 +663,26 @@ bool BrowserFrameViewWin::ShouldShowWindowTitle(TitlebarType type) const {
 
 void BrowserFrameViewWin::TabletModeChanged() {
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
-void BrowserFrameViewWin::SetSystemMicaTitlebarAttributes() {
-  CHECK(SystemTitlebarCanUseMicaMaterial());
-
-  const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
-                        sizeof(dark_titlebar_enabled));
+void BrowserFrameViewWin::SetSystemTitlebarAttributes() {
+  if (SystemTitlebarSupportsDarkMode()) {
+    const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
+                          sizeof(dark_titlebar_enabled));
+  }
 
-  const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
-      browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
-                                           : DWMSBT_MAINWINDOW;
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
-                        sizeof(dwm_backdrop_type));
+  if (ShouldBrowserUseMicaTitlebar(browser_view())) {
+    const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
+        browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
+                                             : DWMSBT_MAINWINDOW;
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
+                          sizeof(dwm_backdrop_type));
+  }
 }
 
 SkColor BrowserFrameViewWin::GetTitlebarColor() const {
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.h b/chrome/browser/ui/views/frame/browser_frame_view_win.h
index 8f24aba4b8a61..c7ad27ec219e9 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.h
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.h
@@ -146,8 +146,8 @@ class BrowserFrameViewWin : public BrowserNonClientFrameView,
   // Called when the device enters or exits tablet mode.
   void TabletModeChanged();
 
-  // Sets DWM attributes for rendering the system-drawn Mica titlebar.
-  void SetSystemMicaTitlebarAttributes();
+  // Sets DWM attributes for rendering the system-drawn titlebar.
+  void SetSystemTitlebarAttributes();
 
   // Paint various sub-components of this view.
   void PaintTitlebar(gfx::Canvas* canvas) const;
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index a3090da2ca8b4..3c13e0d5f5f39 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1895,6 +1895,9 @@ void BrowserView::UpdateExclusiveAccessExitBubbleContent(
     ExclusiveAccessBubbleHideCallback bubble_first_hide_callback,
     bool notify_download,
     bool force_update) {
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "hide-fullscreen-exit-ui"))
+		return;
   // Trusted pinned mode does not allow to escape. So do not show the bubble.
   bool is_trusted_pinned =
       platform_util::IsBrowserLockedFullscreen(browser_.get());
@@ -3074,7 +3077,8 @@ DownloadShelf* BrowserView::GetDownloadShelf() {
   // Don't show download shelf if download bubble is enabled, except that the
   // shelf is already showing (this can happen if prefs were changed at
   // runtime).
-  if (download::IsDownloadBubbleEnabled() && !download_shelf_) {
+  if (download::IsDownloadBubbleEnabled(browser_->profile()) &&
+      !download_shelf_) {
     return nullptr;
   }
   if (!download_shelf_) {
diff --git a/chrome/browser/ui/views/frame/tab_strip_region_view.cc b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
index 1dd00552036cb..9e131e95d0982 100644
--- a/chrome/browser/ui/views/frame/tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/frame/tab_strip_region_view.h"
 
+#include "base/command_line.h"
 #include "base/functional/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
@@ -66,6 +67,8 @@ class FrameGrabHandle : public views::View {
     // Reserve some space for the frame to be grabbed by, even if the tabstrip
     // is full.
     // TODO(tbergquist): Define this relative to the NTB insets again.
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("remove-grab-handle"))
+		return gfx::Size(0, 0);
     return gfx::Size(42, 0);
   }
 };
@@ -98,7 +101,8 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
 
   // Add and configure the TabSearchContainer.
   std::unique_ptr<TabSearchContainer> tab_search_container;
-  if (browser && browser->is_type_normal()) {
+  if (browser && browser->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button")) {
     tab_search_container = std::make_unique<TabSearchContainer>(
         tab_strip_->controller(), render_tab_search_before_tab_strip_, this);
     tab_search_container->SetProperty(views::kCrossAxisAlignmentKey,
diff --git a/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc b/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
index ccafa0c6ed945..8e003293c011b 100644
--- a/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
+++ b/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
@@ -67,6 +67,9 @@ constexpr base::TimeDelta kTouchPopupTimeout = base::Seconds(10);
 constexpr base::TimeDelta kKeyPressPopupDelay = base::Seconds(1);
 
 bool IsExitUiEnabled() {
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "hide-fullscreen-exit-ui"))
+		return false;
 #if BUILDFLAG(IS_MAC)
   // Exit UI is unnecessary, since Mac uses the OS fullscreen such that window
   // menu and controls reveal when the cursor is moved to the top.
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index b4b2f01a846a7..aacfb61847cd0 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -9,6 +9,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/containers/adapters.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -347,14 +348,17 @@ void LocationBarView::Init() {
 
     params.types_enabled.push_back(PageActionIconType::kSendTabToSelf);
     params.types_enabled.push_back(PageActionIconType::kClickToCall);
-    params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
+	if (!base::FeatureList::IsEnabled(kDisableQRGenerator))
+      params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
     if (base::FeatureList::IsEnabled(kWebOTPCrossDevice))
       params.types_enabled.push_back(PageActionIconType::kSmsRemoteFetcher);
     params.types_enabled.push_back(PageActionIconType::kManagePasswords);
     if (!apps::features::ShouldShowLinkCapturingUX()) {
       params.types_enabled.push_back(PageActionIconType::kIntentPicker);
     }
-    params.types_enabled.push_back(PageActionIconType::kPwaInstall);
+	if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-pwa-install-prompt")) {
+      params.types_enabled.push_back(PageActionIconType::kPwaInstall);
+	}
     params.types_enabled.push_back(PageActionIconType::kFind);
     params.types_enabled.push_back(PageActionIconType::kTranslate);
     params.types_enabled.push_back(PageActionIconType::kZoom);
diff --git a/chrome/browser/ui/views/location_bar/location_icon_view.cc b/chrome/browser/ui/views/location_bar/location_icon_view.cc
index 1f3878e1879a6..6f4a84bde8cd0 100644
--- a/chrome/browser/ui/views/location_bar/location_icon_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_icon_view.cc
@@ -21,6 +21,7 @@
 #include "components/dom_distiller/core/url_constants.h"
 #include "components/omnibox/browser/omnibox_edit_model.h"
 #include "components/omnibox/browser/omnibox_field_trial.h"
+#include "components/omnibox/browser/vector_icons.h"
 #include "components/security_state/core/security_state.h"
 #include "components/strings/grit/components_strings.h"
 #include "content/public/browser/web_contents.h"
@@ -291,8 +292,15 @@ void LocationIconView::UpdateIcon() {
   }
 #endif
 
-  if (!icon.IsEmpty())
-    SetImageModel(icon);
+  if (!icon.IsEmpty()) {
+	  if (icon.IsVectorIcon() && icon.GetVectorIcon().vector_icon()->name != omnibox::kProductChromeRefreshIcon.name &&
+       icon.GetVectorIcon().vector_icon()->name != omnibox::kProductIcon.name)
+	    SetImageModel(icon);
+	   else if (!icon.IsVectorIcon())
+		SetImageModel(icon);
+	  else
+		SetImageModel(ui::ImageModel());
+  }
 }
 
 void LocationIconView::UpdateBackground() {
diff --git a/chrome/browser/ui/views/omnibox/omnibox_text_view.cc b/chrome/browser/ui/views/omnibox/omnibox_text_view.cc
index dce591e1acdf1..9e1a1f5406431 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_text_view.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_text_view.cc
@@ -28,6 +28,10 @@
 #include "ui/views/style/typography.h"
 #include "ui/views/style/typography_provider.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace {
 
 // Use the primary style for everything. TextStyle sometimes controls color, but
@@ -135,6 +139,12 @@ void OmniboxTextView::OnPaint(gfx::Canvas* canvas) {
 
   if (!render_text_)
     return;
+
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled()) {
+	  render_text_->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+  }
+  #endif
   render_text_->SetDisplayRect(GetContentsBounds());
   render_text_->Draw(canvas);
 }
diff --git a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
index 2077715fff453..0f7fcb11e6608 100644
--- a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
+++ b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
@@ -65,6 +65,7 @@ ScreenshotCapturedBubble::ScreenshotCapturedBubble(
       image_(image),
       web_contents_(web_contents->GetWeakPtr()),
       profile_(profile) {
+
   SetButtons(ui::DIALOG_BUTTON_NONE);
   SetTitle(IDS_BROWSER_SHARING_SCREENSHOT_POST_CAPTURE_TITLE);
 }
diff --git a/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc b/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc
index e59856207a85e..c0a2637c0559a 100644
--- a/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc
@@ -76,7 +76,9 @@ constexpr int kSidePanelContentContainerViewId = 42;
 constexpr int kSidePanelContentWrapperViewId = 43;
 
 SidePanelEntry::Id GetDefaultEntry() {
-  return SidePanelEntry::Id::kBookmarks;
+  return base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+             ? SidePanelEntry::Id::kBookmarks
+             : SidePanelEntry::Id::kReadingList;
 }
 
 void ConfigureControlButton(views::ImageButton* button) {
diff --git a/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc b/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc
index ef0c01072a3f3..424c17078b4ad 100644
--- a/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc
@@ -4,6 +4,7 @@
 
 #include "base/test/bind.h"
 #include "base/test/gtest_util.h"
+#include "base/test/scoped_feature_list.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser.h"
@@ -55,9 +56,13 @@ class SidePanelInteractiveTest : public InteractiveBrowserTest {
   ~SidePanelInteractiveTest() override = default;
 
   void SetUp() override {
+    scoped_feature_list_.InitAndEnableFeature(features::kPowerBookmarksSidePanel);
     set_open_about_blank_on_browser_launch(true);
     InteractiveBrowserTest::SetUp();
   }
+
+ private:
+  base::test::ScopedFeatureList scoped_feature_list_;
 };
 
 // This test is specifically to guard against this regression
diff --git a/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc b/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc
index 55004e2aeb699..d70584897ec2c 100644
--- a/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc
+++ b/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc
@@ -53,7 +53,9 @@ BubbleSyncPromoSigninButtonView::BubbleSyncPromoSigninButtonView(
           : l10n_util::GetStringUTF16(IDS_PROFILES_DICE_NOT_SYNCING_TITLE);
 
   const views::BoxLayout::Orientation orientation =
-      views::BoxLayout::Orientation::kHorizontal;
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+          ? views::BoxLayout::Orientation::kHorizontal
+          : views::BoxLayout::Orientation::kVertical;
 
   std::unique_ptr<views::BoxLayout> button_layout =
       std::make_unique<views::BoxLayout>(orientation, gfx::Insets(), 16);
diff --git a/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc b/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc
index 27e784aa16b31..ffdfb435fad62 100644
--- a/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc
+++ b/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc
@@ -45,8 +45,10 @@ BubbleSyncPromoView::BubbleSyncPromoView(
   }
 
   const views::LayoutOrientation orientation =
-      account.IsEmpty() ? views::LayoutOrientation::kHorizontal
-                        : views::LayoutOrientation::kVertical;
+      (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel) &&
+       account.IsEmpty())
+          ? views::LayoutOrientation::kHorizontal
+          : views::LayoutOrientation::kVertical;
 
   std::unique_ptr<views::FlexLayout> layout =
       std::make_unique<views::FlexLayout>();
diff --git a/chrome/browser/ui/views/tabs/new_tab_button.cc b/chrome/browser/ui/views/tabs/new_tab_button.cc
index 9e77662e57e76..5074cb3dfadd5 100644
--- a/chrome/browser/ui/views/tabs/new_tab_button.cc
+++ b/chrome/browser/ui/views/tabs/new_tab_button.cc
@@ -7,6 +7,7 @@
 #include <memory>
 #include <string>
 
+#include "base/command_line.h"
 #include "base/strings/string_number_conversions.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -112,11 +113,23 @@ void NewTabButton::AnimateToStateForTesting(views::InkDropState state) {
 
 void NewTabButton::AddLayerToRegion(ui::Layer* new_layer,
                                     views::LayerRegion region) {
-  ink_drop_container_->AddLayerToRegion(new_layer, region);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			!base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+			(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	}
+	else
+		ink_drop_container_->AddLayerToRegion(new_layer, region);
 }
 
 void NewTabButton::RemoveLayerFromRegions(ui::Layer* old_layer) {
-  ink_drop_container_->RemoveLayerFromRegions(old_layer);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+		!base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+		base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	}
+	else
+		ink_drop_container_->RemoveLayerFromRegions(old_layer);
 }
 
 SkColor NewTabButton::GetForegroundColor() const {
@@ -139,17 +152,27 @@ SkPath NewTabButton::GetBorderPath(const gfx::Point& origin,
   const float radius = GetCornerRadius();
 
   SkPath path;
-  if (extend_to_top) {
-    path.moveTo(origin.x(), 0);
-    const float diameter = radius * 2;
-    path.rLineTo(diameter, 0);
-    path.rLineTo(0, origin.y() + radius);
-    path.rArcTo(radius, radius, 0, SkPath::kSmall_ArcSize, SkPathDirection::kCW,
-                -diameter, 0);
-    path.close();
-  } else {
-    path.addCircle(origin.x() + radius, origin.y() + radius, radius);
-  }
+  if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    !base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	  if (extend_to_top) {
+		path.moveTo(origin.x(), 0);
+		const float diameter = radius * 2;
+		path.rLineTo(diameter, 0);
+		path.rLineTo(0, origin.y() + radius);
+		path.rArcTo(radius, radius, 0, SkPath::kSmall_ArcSize, SkPathDirection::kCW,
+					-diameter, 0);
+		path.close();
+	  } else {
+		path.addCircle(origin.x() + radius, origin.y() + radius,
+					   radius);
+	  }
+   } else {
+	   SkPoint pts [] = {SkPoint(0.0, 8.0), SkPoint(20.0, 8.0), SkPoint(30.0, 20.0), SkPoint(10.0, 20.0)};
+	   path.moveTo(origin.x() * 1.10, SkScalar(8.0));
+	   path.addPoly(pts, 4, true);
+   }
   return path;
 }
 
@@ -209,7 +232,12 @@ void NewTabButton::NotifyClick(const ui::Event& event) {
 
 void NewTabButton::PaintButtonContents(gfx::Canvas* canvas) {
   PaintFill(canvas);
-  PaintIcon(canvas);
+  if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    !base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	PaintIcon(canvas);
+  }
 }
 
 gfx::Size NewTabButton::CalculatePreferredSize() const {
@@ -257,11 +285,31 @@ void NewTabButton::PaintFill(gfx::Canvas* canvas) const {
     cc::PaintFlags flags;
     flags.setAntiAlias(true);
     canvas->Translate(GetContentsBounds().OffsetFromOrigin());
-    flags.setColor(GetColorProvider()->GetColor(
-        GetWidget()->ShouldPaintAsActive()
-            ? background_frame_active_color_id_
-            : background_frame_inactive_color_id_));
+	if(((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			!base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default")) ||
+			(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default"))) &&
+			GetState() == STATE_HOVERED) {
+		flags.setColor(SkColorSetRGB(90, 90, 90));
+	} else {
+		flags.setColor(GetColorProvider()->GetColor(
+			GetWidget()->ShouldPaintAsActive()
+				? background_frame_active_color_id_
+				: background_frame_inactive_color_id_));
+	}
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch("transparent-tabs"))
+		flags.setAlphaf(0.7f);
     canvas->DrawPath(GetBorderPath(gfx::Point(), false), flags);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			!base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default")) ||
+			(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default"))) {
+	flags.setAlphaf(1.0f);
+	flags.setColor(SkColorSetRGB(0, 0, 0));
+	flags.setStyle(cc::PaintFlags::kStroke_Style);
+	canvas->DrawPath(GetBorderPath(gfx::Point(), false),
+						flags);
+	}
   }
 }
 
diff --git a/chrome/browser/ui/views/tabs/tab.cc b/chrome/browser/ui/views/tabs/tab.cc
index 7b2f9ecb903b2..1e2a746faf3a4 100644
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -11,6 +11,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/debug/alias.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
@@ -695,7 +696,9 @@ void Tab::OnGestureEvent(ui::GestureEvent* event) {
 }
 
 std::u16string Tab::GetTooltipText(const gfx::Point& p) const {
-  // Tab hover cards replace tooltips for tabs.
+  if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "tooltip")
+     return GetTooltipText(data_.title, GetAlertStateToShow(data_.alert_state));
+  // Tab hover cards don't replace tooltips for tabs in all cases ^.
   return std::u16string();
 }
 
@@ -1063,7 +1066,11 @@ void Tab::UpdateIconVisibility() {
   if (IsActive()) {
     // Close button is shown on active tabs regardless of the size.
     showing_close_button_ = true;
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-tab-close-buttons")) {
+      showing_close_button_ = false;
+    } else {
     available_width -= close_button_width;
+	}
 
     showing_alert_indicator_ =
         has_alert_icon && alert_icon_width <= available_width;
@@ -1088,6 +1095,8 @@ void Tab::UpdateIconVisibility() {
     }
 
     showing_close_button_ = large_enough_for_close_button;
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-tab-close-buttons"))
+      showing_close_button_ = false;
     if (showing_close_button_) {
       available_width -= close_button_width;
     }
diff --git a/chrome/browser/ui/views/tabs/tab_strip.cc b/chrome/browser/ui/views/tabs/tab_strip.cc
index 87f6543bb0da0..a03097a466fc4 100644
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -15,6 +15,7 @@
 #include <vector>
 
 #include "base/compiler_specific.h"
+#include "base/command_line.h"
 #include "base/containers/adapters.h"
 #include "base/containers/contains.h"
 #include "base/containers/flat_map.h"
@@ -1762,6 +1763,8 @@ void TabStrip::OnMouseEventInTab(views::View* source,
 }
 
 void TabStrip::UpdateHoverCard(Tab* tab, HoverCardUpdateType update_type) {
+  if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "tooltip" ||
+      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("tab-hover-cards") == "none") return;
   tab_container_->UpdateHoverCard(tab, update_type);
 }
 
diff --git a/chrome/browser/ui/views/tabs/tab_style_views.cc b/chrome/browser/ui/views/tabs/tab_style_views.cc
index 33c62c24cc521..ccd2eebbf1f2c 100644
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
@@ -322,87 +323,106 @@ SkPath GM2TabStyleViews::GetPath(TabStyle::PathType path_type,
     // stroke width.
 
     // Start with the left side of the shape.
-    path.moveTo(left, extended_bottom);
-
-    if (tab_left != left) {
-      // Draw the left edge of the extension.
-      //   ╭─────────╮
-      //   │ Content │
-      // ┏─╯         ╰─┐
-      if (tab_bottom != extended_bottom)
-        path.lineTo(left, tab_bottom);
-
-      // Draw the bottom-left corner.
-      //   ╭─────────╮
-      //   │ Content │
-      // ┌━╝         ╰─┐
-      if (extend_left_to_bottom) {
-        path.lineTo(tab_left, tab_bottom);
-      } else {
-        path.lineTo(tab_left - extension_corner_radius, tab_bottom);
-        path.arcTo(extension_corner_radius, extension_corner_radius, 0,
-                   SkPath::kSmall_ArcSize, SkPathDirection::kCCW, tab_left,
-                   tab_bottom - extension_corner_radius);
-      }
-    }
-
-    // Draw the ascender and top-left curve, if present.
-    if (extend_to_top) {
-      //   ┎─────────╮
-      //   ┃ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_left, tab_top);
-    } else {
-      //   ╔─────────╮
-      //   ┃ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_left, tab_top + content_corner_radius);
-      path.arcTo(content_corner_radius, content_corner_radius, 0,
-                 SkPath::kSmall_ArcSize, SkPathDirection::kCW,
-                 tab_left + content_corner_radius, tab_top);
-    }
 
-    // Draw the top crossbar and top-right curve, if present.
-    if (extend_to_top) {
-      //   ┌━━━━━━━━━┑
-      //   │ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_right, tab_top);
-    } else {
-      //   ╭━━━━━━━━━╗
-      //   │ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_right - content_corner_radius, tab_top);
-      path.arcTo(content_corner_radius, content_corner_radius, 0,
-                 SkPath::kSmall_ArcSize, SkPathDirection::kCW, tab_right,
-                 tab_top + content_corner_radius);
+    if (!base::FeatureList::IsEnabled(features::kThoriumCustomTabs)) {
+		path.moveTo(left, extended_bottom);
+		if (tab_left != left) {
+		  // Draw the left edge of the extension.
+		  //   ╭─────────╮
+		  //   │ Content │
+		  // ┏─╯         ╰─┐
+		  if (tab_bottom != extended_bottom)
+			path.lineTo(left, tab_bottom);
+
+		  // Draw the bottom-left corner.
+		  //   ╭─────────╮
+		  //   │ Content │
+		  // ┌━╝         ╰─┐
+		  if (extend_left_to_bottom) {
+			path.lineTo(tab_left, tab_bottom);
+		  } else {
+			path.lineTo(tab_left - extension_corner_radius, tab_bottom);
+			path.arcTo(extension_corner_radius, extension_corner_radius, 0,
+					   SkPath::kSmall_ArcSize, SkPathDirection::kCCW, tab_left,
+					   tab_bottom - extension_corner_radius);
+		  }
+		}
+
+		// Draw the ascender and top-left curve, if present.
+		if (extend_to_top) {
+		  //   ┎─────────╮
+		  //   ┃ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_left, tab_top);
+		} else {
+		  //   ╔─────────╮
+		  //   ┃ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_left, tab_top + content_corner_radius);
+		  path.arcTo(content_corner_radius, content_corner_radius, 0,
+					 SkPath::kSmall_ArcSize, SkPathDirection::kCW,
+					 tab_left + content_corner_radius, tab_top);
+		}
+
+		// Draw the top crossbar and top-right curve, if present.
+		if (extend_to_top) {
+		  //   ┌━━━━━━━━━┑
+		  //   │ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_right, tab_top);
+		} else {
+		  //   ╭━━━━━━━━━╗
+		  //   │ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_right - content_corner_radius, tab_top);
+		  path.arcTo(content_corner_radius, content_corner_radius, 0,
+					 SkPath::kSmall_ArcSize, SkPathDirection::kCW, tab_right,
+					 tab_top + content_corner_radius);
+		}
+
+		if (tab_right != right) {
+		  // Draw the descender and bottom-right corner.
+		  //   ╭─────────╮
+		  //   │ Content ┃
+		  // ┌─╯         ╚━┐
+		  if (extend_right_to_bottom) {
+			path.lineTo(tab_right, tab_bottom);
+		  } else {
+			path.lineTo(tab_right, tab_bottom - extension_corner_radius);
+			path.arcTo(extension_corner_radius, extension_corner_radius, 0,
+					   SkPath::kSmall_ArcSize, SkPathDirection::kCCW,
+					   tab_right + extension_corner_radius, tab_bottom);
+		  }
+		  if (tab_bottom != extended_bottom)
+			path.lineTo(right, tab_bottom);
+		}
+
+		// Draw anything remaining: the descender, the bottom right horizontal
+		// stroke, or the right edge of the extension, depending on which
+		// conditions fired above.
+		//   ╭─────────╮
+		//   │ Content │
+		// ┌─╯         ╰─┓
+		path.lineTo(right, extended_bottom);
     }
-
-    if (tab_right != right) {
-      // Draw the descender and bottom-right corner.
-      //   ╭─────────╮
-      //   │ Content ┃
-      // ┌─╯         ╚━┐
-      if (extend_right_to_bottom) {
-        path.lineTo(tab_right, tab_bottom);
-      } else {
-        path.lineTo(tab_right, tab_bottom - extension_corner_radius);
-        path.arcTo(extension_corner_radius, extension_corner_radius, 0,
-                   SkPath::kSmall_ArcSize, SkPathDirection::kCCW,
-                   tab_right + extension_corner_radius, tab_bottom);
-      }
-      if (tab_bottom != extended_bottom)
-        path.lineTo(right, tab_bottom);
-    }
-
-    // Draw anything remaining: the descender, the bottom right horizontal
-    // stroke, or the right edge of the extension, depending on which
-    // conditions fired above.
-    //   ╭─────────╮
-    //   │ Content │
-    // ┌─╯         ╰─┓
-    path.lineTo(right, extended_bottom);
-
+	else {
+		path.moveTo(left, extended_bottom);
+		if (extend_to_top) {
+		  // Create the vertical extension by extending the side diagonals until
+		  // they reach the top of the bounds.
+			path.cubicTo(left, extended_bottom, (((tab_left + 10) + left) / 2), ((tab_top + extended_bottom) / 2), tab_left + 10,
+						  tab_top);
+			path.lineTo(tab_right - 10, tab_top);
+			path.cubicTo(tab_right - 10, tab_top, (((tab_right - 10) + right) / 2), ((tab_top + extended_bottom) / 2), right,
+					  extended_bottom);
+		} else {
+			path.cubicTo(left, extended_bottom, (((tab_left + 10) + left) / 2), (((tab_top * 0.5) + extended_bottom) / 2), tab_left + 10,
+						(tab_top * 0.5));
+			path.cubicTo(tab_left + 10, (tab_top * 0.5), ((tab_left + 10) + (tab_right - 10) /2), tab_top * 0.5, tab_right - 10, tab_top * 0.5);
+			path.cubicTo(tab_right - 10, (tab_top * 0.5), (((tab_right - 10) + right) / 2), (((tab_top * 0.5) + extended_bottom) / 2), right,
+					  extended_bottom);
+		}
+	}
     if (path_type != TabStyle::PathType::kBorder) {
       path.close();
     }
@@ -664,6 +684,9 @@ float GM2TabStyleViews::GetSeparatorOpacity(bool for_layout,
 
   const Tab* adjacent_tab =
       tab_->controller()->GetAdjacentTab(tab_, leading ? -1 : 1);
+  // The separator should never appear at the end of the tab strip.
+  if (!adjacent_tab && !leading)
+	  return 0.0f;
 
   const Tab* left_tab = leading ? adjacent_tab : tab_.get();
   const Tab* right_tab = leading ? tab_.get() : adjacent_tab;
@@ -671,6 +694,7 @@ float GM2TabStyleViews::GetSeparatorOpacity(bool for_layout,
       right_tab && right_tab->group().has_value() &&
       (!left_tab || left_tab->group() != right_tab->group());
 
+
   // If the current tab is selected, default to hiding the separator. Only show
   // the separator if it's adjacent to other selected tabs.
   if (tab_->IsSelected()) {
@@ -936,8 +960,21 @@ void GM2TabStyleViews::PaintTabBackgroundFill(
     cc::PaintFlags flags;
     flags.setAntiAlias(true);
     flags.setColor(GetCurrentTabBackgroundColor(selection_state, hovered));
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("transparent-tabs") &&
+	    selection_state != TabStyle::TabSelectionState::kActive)
+		flags.setAlphaf(0.7f);
     canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),
                      flags);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    !base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default"))) {
+	flags.setAlphaf(1.0f);
+	flags.setColor(SkColorSetRGB(0, 0, 0));
+	flags.setStyle(cc::PaintFlags::kStroke_Style);
+	canvas->DrawPath(fill_path,
+                     flags);
+	}
   }
 
   if (fill_id.has_value()) {
diff --git a/chrome/browser/ui/views/toolbar/toolbar_view.cc b/chrome/browser/ui/views/toolbar/toolbar_view.cc
index e6aca6cbb09e8..c4db1429b9911 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_view.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.cc
@@ -280,7 +280,7 @@ void ToolbarView::Init() {
   size_animation_.Reset(1);
 
   std::unique_ptr<DownloadToolbarButtonView> download_button;
-  if (download::IsDownloadBubbleEnabled()) {
+  if (download::IsDownloadBubbleEnabled(browser_->profile())) {
     download_button =
         std::make_unique<DownloadToolbarButtonView>(browser_view_);
   }
@@ -452,7 +452,8 @@ void ToolbarView::Init() {
     send_tab_to_self_button_ =
         container_view_->AddChildView(std::move(send_tab_to_self_button));
 
-  if (!features::IsSidePanelPinningEnabled()) {
+  if (!features::IsSidePanelPinningEnabled()&&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("hide-sidepanel-button")) {
     if (companion::IsCompanionFeatureEnabled()) {
       side_panel_container_ = container_view_->AddChildView(
           std::make_unique<SidePanelToolbarContainer>(browser_view_));
@@ -476,6 +477,17 @@ void ToolbarView::Init() {
 #elif BUILDFLAG(IS_CHROMEOS_LACROS)
   show_avatar_toolbar_button = !chromeos::IsManagedGuestSession();
 #endif
+
+  const std::string sab_value = base::CommandLine::ForCurrentProcess()->
+                                GetSwitchValueASCII("show-avatar-button");
+  if (sab_value == "always")
+    show_avatar_toolbar_button = true;
+  else if (sab_value == "incognito-and-guest")
+    show_avatar_toolbar_button = browser_->profile()->IsIncognitoProfile() ||
+                                 browser_->profile()->IsGuestSession();
+  else if (sab_value == "never")
+    show_avatar_toolbar_button = false;
+
   avatar_->SetVisible(show_avatar_toolbar_button);
 
 #if BUILDFLAG(ENABLE_WEBUI_TAB_STRIP)
diff --git a/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_frame_toolbar_browsertest.cc b/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_frame_toolbar_browsertest.cc
index 3efd08881b205..d19679d0f5713 100644
--- a/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_frame_toolbar_browsertest.cc
+++ b/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_frame_toolbar_browsertest.cc
@@ -70,6 +70,7 @@
 #include "chrome/test/base/ui_test_utils.h"
 #include "components/infobars/content/content_infobar_manager.h"
 #include "components/permissions/permission_request_manager.h"
+#include "components/safe_browsing/core/common/features.h"
 #include "components/webapps/services/web_app_origin_association/test/test_web_app_origin_association_fetcher.h"
 #include "content/public/browser/notification_service.h"
 #include "content/public/browser/render_view_host.h"
@@ -862,7 +863,9 @@ class WebAppFrameToolbarBrowserTest_WindowControlsOverlay
     }
   };
 
-  WebAppFrameToolbarBrowserTest_WindowControlsOverlay() = default;
+  WebAppFrameToolbarBrowserTest_WindowControlsOverlay() {
+    scoped_feature_list_.InitAndEnableFeature(safe_browsing::kDownloadBubble);
+  }
 
   void SetUp() override {
     ASSERT_TRUE(temp_dir_.CreateUniqueTempDir());
@@ -1008,6 +1011,7 @@ class WebAppFrameToolbarBrowserTest_WindowControlsOverlay
   content::test::FencedFrameTestHelper fenced_frame_helper_;
 
  private:
+  base::test::ScopedFeatureList scoped_feature_list_;
   base::ScopedTempDir temp_dir_;
 };
 
diff --git a/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_toolbar_button_container.cc b/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_toolbar_button_container.cc
index fd05f19ee52d4..73aa7d1581d59 100644
--- a/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_toolbar_button_container.cc
+++ b/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_toolbar_button_container.cc
@@ -167,7 +167,7 @@ WebAppToolbarButtonContainer::WebAppToolbarButtonContainer(
                                static_cast<int>(HTCLIENT));
   }
 
-  if (download::IsDownloadBubbleEnabled()) {
+  if (download::IsDownloadBubbleEnabled(browser_view_->browser()->profile())) {
     download_button_ = AddChildView(
         std::make_unique<DownloadToolbarButtonView>(browser_view_));
     views::SetHitTestComponent(download_button_, static_cast<int>(HTCLIENT));
diff --git a/chrome/browser/ui/webui/settings/settings_ui.cc b/chrome/browser/ui/webui/settings/settings_ui.cc
index f0a747d230c47..2a8e8f3f2224e 100644
--- a/chrome/browser/ui/webui/settings/settings_ui.cc
+++ b/chrome/browser/ui/webui/settings/settings_ui.cc
@@ -400,7 +400,7 @@ SettingsUI::SettingsUI(content::WebUI* web_ui)
 
   html_source->AddBoolean(
       "downloadBubblePartialViewControlledByPref",
-      download::IsDownloadBubbleEnabled() &&
+      download::IsDownloadBubbleEnabled(profile) &&
           download::IsDownloadBubblePartialViewControlledByPref());
 
 #if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
diff --git a/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc b/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc
index 91684b8998732..46b241f52841c 100644
--- a/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc
+++ b/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc
@@ -214,7 +214,10 @@ BookmarksSidePanelUI::BookmarksSidePanelUI(content::WebUI* web_ui)
   content::URLDataSource::Add(
       profile, std::make_unique<FaviconSource>(
                    profile, chrome::FaviconUrlFormat::kFavicon2));
-  const int resource = IDR_SIDE_PANEL_BOOKMARKS_POWER_BOOKMARKS_HTML;
+  const int resource =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+          ? IDR_SIDE_PANEL_BOOKMARKS_POWER_BOOKMARKS_HTML
+          : IDR_SIDE_PANEL_BOOKMARKS_BOOKMARKS_HTML;
   webui::SetupWebUIDataSource(source,
                               base::make_span(kSidePanelBookmarksResources,
                                               kSidePanelBookmarksResourcesSize),
diff --git a/chrome/browser/webshare/win/fake_storage_file_statics.cc b/chrome/browser/webshare/win/fake_storage_file_statics.cc
index 6308ccec3a576..f17033b2d1ec7 100644
--- a/chrome/browser/webshare/win/fake_storage_file_statics.cc
+++ b/chrome/browser/webshare/win/fake_storage_file_statics.cc
@@ -9,7 +9,6 @@
 #include <wrl/module.h>
 
 #include <memory>
-#include <string>
 #include <tuple>
 
 #include "base/functional/bind.h"
@@ -279,6 +278,13 @@ IFACEMETHODIMP FakeStorageFileStatics::CreateStreamedFileAsync(
     IStreamedFileDataRequestedHandler* data_requested,
     IRandomAccessStreamReference* thumbnail,
     IAsyncOperation<StorageFile*>** operation) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    ADD_FAILURE() << "Attempted to use FakeStorageFileStatics in an "
+                     "environment that doesn't support ScopedHStrings.";
+    return E_UNEXPECTED;
+  }
+
   auto fake_iasync_operation =
       Make<base::win::FakeIAsyncOperation<StorageFile*>>();
   HRESULT hr = fake_iasync_operation->QueryInterface(IID_PPV_ARGS(operation));
diff --git a/chrome/browser/webshare/win/share_operation.cc b/chrome/browser/webshare/win/share_operation.cc
index ef09f08ba9cf4..8747e21cbe552 100644
--- a/chrome/browser/webshare/win/share_operation.cc
+++ b/chrome/browser/webshare/win/share_operation.cc
@@ -370,6 +370,13 @@ void ShareOperation::Run(blink::mojom::ShareService::ShareCallback callback) {
   DCHECK(!callback_);
   callback_ = std::move(callback);
 
+  // Ensure that the required WinRT functionality is available/loaded.
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    Complete(blink::mojom::ShareError::INTERNAL_ERROR);
+    return;
+  }
+
   // If the corresponding web_contents have already been cleaned up, cancel
   // the operation.
   if (!web_contents_) {
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
index 15f2def437648..021f9f2b55471 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
@@ -40,6 +40,12 @@ HRESULT GetDataTransferManagerHandles(
     HWND hwnd,
     IDataTransferManagerInterop** data_transfer_manager_interop,
     IDataTransferManager** data_transfer_manager) {
+
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return E_FAIL;
+  }
+
   // IDataTransferManagerInterop is semi-hidden behind a CloakedIid
   // structure on the DataTransferManager, excluding it from things
   // used by RoGetActivationFactory like GetIids(). Because of this,
diff --git a/chrome/browser/win/titlebar_config.cc b/chrome/browser/win/titlebar_config.cc
index f088a7071b1e0..3e829274cd26b 100644
--- a/chrome/browser/win/titlebar_config.cc
+++ b/chrome/browser/win/titlebar_config.cc
@@ -4,28 +4,57 @@
 
 #include "chrome/browser/win/titlebar_config.h"
 
+#include <Windows.h>
+#include "base/command_line.h"
 #include "base/win/windows_version.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/common/chrome_switches.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/native_theme/native_theme.h"
 
-// Allows the titlebar to be drawn by the system using the Mica material
-// on Windows 11, version 22H2 and above.
-BASE_FEATURE(kWindows11MicaTitlebar,
-             "Windows11MicaTitlebar",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+bool ShouldCustomDrawSystemTitlebar() {
+  // Some extra code added here because those with pre-win8 and no DWM will have to fallback on the custom titlebar.
+  BOOL result = FALSE;
+
+  typedef HRESULT(WINAPI* DwmIsCompositionEnabledFunc)(BOOL* enabled);
+  DwmIsCompositionEnabledFunc func_ = nullptr;
+
+  HMODULE dwmapi_library_ = LoadLibraryW(L"dwmapi.dll");
+  if (dwmapi_library_) {
+    func_ = reinterpret_cast<DwmIsCompositionEnabledFunc>(
+        GetProcAddress(dwmapi_library_, "DwmIsCompositionEnabled"));
+  }
+  else
+	  return true;
+
+  if (func_) {
+	  func_(&result);
+  }
+  else
+	  return true;
+  // Cache flag lookup.
+  static const bool custom_titlebar_disabled =
+      base::CommandLine::InitializedForCurrentProcess() &&
+      (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableWindows10CustomTitlebar) ||
+	  base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "windows11-mica-titlebar"));
+
+  return (!custom_titlebar_disabled &&
+         base::win::GetVersion() >= base::win::Version::WIN10) || !result;
+}
 
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view) {
-  return !ShouldDefaultThemeUseMicaTitlebar() ||
-         !ThemeServiceFactory::GetForProfile(browser_view->GetProfile())
-              ->UsingSystemTheme() ||
+
+  return ShouldCustomDrawSystemTitlebar() ||
          (!browser_view->browser()->is_type_normal() &&
           !browser_view->browser()->is_type_popup() &&
           !browser_view->browser()->is_type_devtools());
 }
 
+
 bool ShouldDefaultThemeUseMicaTitlebar() {
   return SystemTitlebarCanUseMicaMaterial() &&
          !ui::AccentColorObserver::Get()->use_dwm_frame_color() &&
@@ -34,6 +63,15 @@ bool ShouldDefaultThemeUseMicaTitlebar() {
 }
 
 bool SystemTitlebarCanUseMicaMaterial() {
-  return base::win::GetVersion() >= base::win::Version::WIN11_22H2 &&
-         base::FeatureList::IsEnabled(kWindows11MicaTitlebar);
+  return base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "windows11-mica-titlebar");
+}
+
+bool ShouldBrowserUseMicaTitlebar(class BrowserView *) {
+  return base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "windows11-mica-titlebar");
+}
+
+bool SystemTitlebarSupportsDarkMode() {
+  return base::win::GetVersion() >= base::win::Version::WIN11;
 }
diff --git a/chrome/browser/win/titlebar_config.h b/chrome/browser/win/titlebar_config.h
index 48f413792d5aa..596d9ad041c21 100644
--- a/chrome/browser/win/titlebar_config.h
+++ b/chrome/browser/win/titlebar_config.h
@@ -10,10 +10,18 @@
 class BrowserView;
 
 BASE_DECLARE_FEATURE(kWindows11MicaTitlebar);
+BASE_DECLARE_FEATURE(kForceXpTheme);
 
 // Returns whether we should custom draw the titlebar for a browser window.
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view);
 
+// Returns whether we should always custom draw the system title bar.
+bool ShouldCustomDrawSystemTitlebar();
+
+// Returns whether we should use the Mica titlebar material for a browser
+// window.
+bool ShouldBrowserUseMicaTitlebar(BrowserView* browser_view);
+
 // Returns whether we should use the Mica titlebar in standard browser windows
 // using the default theme.
 bool ShouldDefaultThemeUseMicaTitlebar();
@@ -22,4 +30,7 @@ bool ShouldDefaultThemeUseMicaTitlebar();
 // material.
 bool SystemTitlebarCanUseMicaMaterial();
 
+// Returns whether the system-drawn titlebar can be drawn in dark mode.
+bool SystemTitlebarSupportsDarkMode();
+
 #endif  // CHROME_BROWSER_WIN_TITLEBAR_CONFIG_H_
diff --git a/chrome/chrome_elf/BUILD.gn b/chrome/chrome_elf/BUILD.gn
index 37e2d2a50aa2c..196858a63c713 100644
--- a/chrome/chrome_elf/BUILD.gn
+++ b/chrome/chrome_elf/BUILD.gn
@@ -150,6 +150,7 @@ static_library("hook_util") {
   deps = [
     "//base:base_static",  # pe_image
   ]
+  public_deps = [ "//base" ]
 }
 
 # This target contains utility functions which must only depend on
diff --git a/chrome/chrome_elf/chrome_elf_main.cc b/chrome/chrome_elf/chrome_elf_main.cc
index 7ccdb12bf2258..2b706eb4463ca 100644
--- a/chrome/chrome_elf/chrome_elf_main.cc
+++ b/chrome/chrome_elf/chrome_elf_main.cc
@@ -49,6 +49,14 @@ bool GetUserDataDirectoryThunk(wchar_t* user_data_dir,
   return true;
 }
 
+extern "C" {
+
+VOID __stdcall TLSInit_DllMain_ProcessAttach(HMODULE DllBase);
+
+VOID __stdcall TLSInit_DllMain_ThreadAttach(HMODULE DllBase);
+
+}
+
 // DllMain
 // -------
 // Warning: The OS loader lock is held during DllMain.  Be careful.
@@ -59,6 +67,13 @@ bool GetUserDataDirectoryThunk(wchar_t* user_data_dir,
 //         that will blow up with the loader lock held.
 //         https://bugs.chromium.org/p/chromium/issues/detail?id=748949#c18
 BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
+
+  if (DLL_PROCESS_ATTACH == reason)
+	  TLSInit_DllMain_ProcessAttach(module); // Implicit TLS initialization code for Windows XP and below
+                                             // Implemented in progwrp.dll.
+  if (DLL_THREAD_ATTACH == reason)
+	  TLSInit_DllMain_ThreadAttach(module);
+
   if (reason == DLL_PROCESS_ATTACH) {
     install_static::InitializeProductDetailsForPrimaryModule();
     install_static::InitializeProcessType();
diff --git a/chrome/chrome_elf/chrome_elf_security.cc b/chrome/chrome_elf/chrome_elf_security.cc
index e7bda43a9814b..00146f72d7a61 100644
--- a/chrome/chrome_elf/chrome_elf_security.cc
+++ b/chrome/chrome_elf/chrome_elf_security.cc
@@ -85,6 +85,7 @@ class ExtensionPointDisableSet {
 }  // namespace
 
 void EarlyBrowserSecurity() {
+  typedef decltype(SetProcessMitigationPolicy)* SetProcessMitigationPolicyFunc;
   // This function is called from within DllMain.
   // Don't do anything naughty while we have the loader lock.
   NTSTATUS ret_val = STATUS_SUCCESS;
@@ -108,12 +109,20 @@ void EarlyBrowserSecurity() {
 
   nt::CloseRegKey(handle);
 
-  // Disable extension points (legacy hooking) in this process.
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  policy.DisableExtensionPoints = true;
-  SetProcessMitigationPolicy(ProcessExtensionPointDisablePolicy, &policy,
-                             sizeof(policy));
-  ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+  if (::IsWindows8OrGreater()) {
+    SetProcessMitigationPolicyFunc set_process_mitigation_policy =
+        reinterpret_cast<SetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "SetProcessMitigationPolicy"));
+    if (set_process_mitigation_policy) {
+      // Disable extension points in this process.
+      // (Legacy hooking.)
+      PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+      policy.DisableExtensionPoints = true;
+      set_process_mitigation_policy(ProcessExtensionPointDisablePolicy, &policy,
+                                    sizeof(policy));
+      ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+    }
+  }
 
   return;
 }
diff --git a/chrome/chrome_elf/chrome_elf_util_unittest.cc b/chrome/chrome_elf/chrome_elf_util_unittest.cc
index 5ee09effb6e03..3af5789ad6185 100644
--- a/chrome/chrome_elf/chrome_elf_util_unittest.cc
+++ b/chrome/chrome_elf/chrome_elf_util_unittest.cc
@@ -4,6 +4,8 @@
 
 #include <windows.h>
 
+#include <versionhelpers.h>  // windows.h must be before.
+
 #include <tuple>
 
 #include "base/test/test_reg_util_win.h"
@@ -37,14 +39,28 @@ bool SetExtensionPointEnabledFlag(bool creation) {
 }
 
 bool IsSecuritySet() {
-  // Check that extension points are disabled. (Legacy hooking.)
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                    ProcessExtensionPointDisablePolicy, &policy,
-                                    sizeof(policy))) {
-    return false;
+  typedef decltype(GetProcessMitigationPolicy)* GetProcessMitigationPolicyFunc;
+
+  // Check the settings from EarlyBrowserSecurity().
+  if (::IsWindows8OrGreater()) {
+    GetProcessMitigationPolicyFunc get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (!get_process_mitigation_policy)
+      return false;
+
+    // Check that extension points are disabled.
+    // (Legacy hooking.)
+    PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+    if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                       ProcessExtensionPointDisablePolicy,
+                                       &policy, sizeof(policy)))
+      return false;
+
+    return policy.DisableExtensionPoints;
   }
-  return policy.DisableExtensionPoints;
+
+  return true;
 }
 
 void RegRedirect(nt::ROOT_KEY key,
@@ -70,6 +86,9 @@ void CancelRegRedirect(nt::ROOT_KEY key) {
 }
 
 TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
+
+  if (!::IsWindows8OrGreater())
+    return;
   // We should validate the exe version isn't used for this test
   elf_security::ValidateExeForTesting(true);
 
@@ -78,6 +97,8 @@ TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
 }
 
 TEST(ChromeElfUtilTest, BrowserProcessSecurityTest) {
+  if (!::IsWindows8OrGreater())
+    return;
   // Set up registry override for this test.
   registry_util::RegistryOverrideManager override_manager;
   ASSERT_NO_FATAL_FAILURE(RegRedirect(nt::HKCU, &override_manager));
diff --git a/chrome/chrome_elf/hook_util/hook_util.cc b/chrome/chrome_elf/hook_util/hook_util.cc
index ce309c8b6888b..96ab0afa9bbf3 100644
--- a/chrome/chrome_elf/hook_util/hook_util.cc
+++ b/chrome/chrome_elf/hook_util/hook_util.cc
@@ -8,6 +8,9 @@
 #include <versionhelpers.h>  // windows.h must be before
 
 #include "base/win/pe_image.h"
+#include "chrome/chrome_elf/nt_registry/nt_registry.h"  // utils
+#include "sandbox/win/src/internal_types.h"
+#include "sandbox/win/src/service_resolver.h"
 
 namespace {
 
@@ -194,6 +197,44 @@ DWORD RemoveIATHook(void* intercept_function,
 
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed) {
+  // Create a thunk via the appropriate ServiceResolver instance.
+  sandbox::ServiceResolverThunk* thunk = nullptr;
+
+  // No hooking on unsupported OS versions.
+  if (!::IsWindows7OrGreater())
+    return thunk;
+
+  // Pseudo-handle, no need to close.
+  HANDLE current_process = ::GetCurrentProcess();
+
+#if defined(_WIN64)
+  // ServiceResolverThunk can handle all the formats in 64-bit (instead only
+  // handling one like it does in 32-bit versions).
+  thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+#else
+  BOOL is_wow64 = FALSE;
+  if (::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64) {
+    if (::IsWindows10OrGreater())
+      thunk = new sandbox::Wow64W10ResolverThunk(current_process, relaxed);
+    else if (::IsWindows8OrGreater())
+      thunk = new sandbox::Wow64W8ResolverThunk(current_process, relaxed);
+    else
+      thunk = new sandbox::Wow64ResolverThunk(current_process, relaxed);
+  } else if (::IsWindows8OrGreater()) {
+    thunk = new sandbox::Win8ResolverThunk(current_process, relaxed);
+  } else {
+    thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+  }
+#endif
+
+  return thunk;
+}
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/hook_util/hook_util.h b/chrome/chrome_elf/hook_util/hook_util.h
index 9070b9d93a6f0..687042ec330c7 100644
--- a/chrome/chrome_elf/hook_util/hook_util.h
+++ b/chrome/chrome_elf/hook_util/hook_util.h
@@ -7,8 +7,20 @@
 
 #include <windows.h>
 
+namespace sandbox {
+class ServiceResolverThunk;
+}
+
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+// Creates a |ServiceResolverThunk| based on the OS version. Ownership of the
+// resulting thunk is passed to the caller.
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed);
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 356739e4e088a..bc7dce68e4d77 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -779,7 +779,15 @@ const char kRelauncherProcessDMGDevice[] = "dmg-device";
 const char kMakeChromeDefault[] = "make-chrome-default";
 #endif  // BUILDFLAG(IS_MAC)
 
+const char kDisableDownloadUpload[] = "disable-download-upload";
+
+const char kUngoogledThorium[] = "ungoogled-thorium";
+
 #if BUILDFLAG(IS_WIN)
+// Disables custom-drawing the window titlebar on Windows 10.
+const char kDisableWindows10CustomTitlebar[] =
+    "disable-windows10-custom-titlebar";
+
 // Force-enables the profile shortcut manager. This is needed for tests since
 // they use a custom-user-data-dir which disables this.
 const char kEnableProfileShortcutManager[] = "enable-profile-shortcut-manager";
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index 96ce2223297a2..e3d8006e1bf5d 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -246,7 +246,11 @@ extern const char kRelauncherProcessDMGDevice[];
 extern const char kMakeChromeDefault[];
 #endif  // BUILDFLAG(IS_MAC)
 
+extern const char kDisableDownloadUpload[];
+extern const char kUngoogledThorium[];
+
 #if BUILDFLAG(IS_WIN)
+extern const char kDisableWindows10CustomTitlebar[];
 extern const char kEnableProfileShortcutManager[];
 extern const char kFromInstaller[];
 extern const char kHideIcons[];
diff --git a/chrome/installer/setup/install.cc b/chrome/installer/setup/install.cc
index 26d3bab930e68..c14608e55811c 100644
--- a/chrome/installer/setup/install.cc
+++ b/chrome/installer/setup/install.cc
@@ -28,6 +28,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_params.h"
@@ -134,6 +135,7 @@ void ExecuteAndLogShortcutOperation(
   // For Start Menu shortcut creation on versions of Win10 that support
   // pinning, record whether or not the installer pinned Chrome.
   if (location == ShellUtil::SHORTCUT_LOCATION_START_MENU_ROOT &&
+      base::win::GetVersion() >= base::win::Version::WIN10 &&
       CanPinShortcutToTaskbar()) {
     SetInstallerPinnedChromeToTaskbar(properties.pin_to_taskbar && pinned);
   }
diff --git a/chrome/installer/setup/setup_util.cc b/chrome/installer/setup/setup_util.cc
index a191dea4d7b80..f237f4fedb0cc 100644
--- a/chrome/installer/setup/setup_util.cc
+++ b/chrome/installer/setup/setup_util.cc
@@ -374,7 +374,7 @@ bool ContainsUnsupportedSwitch(const base::CommandLine& cmd_line) {
 
 bool IsProcessorSupported() {
 #if defined(ARCH_CPU_X86_FAMILY)
-  return base::CPU().has_sse3();
+  return base::CPU().has_sse2();
 #elif defined(ARCH_CPU_ARM64)
   return true;
 #else
diff --git a/chrome/installer/util/install_util.cc b/chrome/installer/util/install_util.cc
index 03a38089b56a8..2a7fdd070d030 100644
--- a/chrome/installer/util/install_util.cc
+++ b/chrome/installer/util/install_util.cc
@@ -243,10 +243,10 @@ base::Version InstallUtil::GetCriticalUpdateVersion() {
 }
 
 bool InstallUtil::IsOSSupported() {
-  // We do not support anything prior to Windows 10.
+  // We do not support anything prior to Windows Vista.
   VLOG(1) << base::SysInfo::OperatingSystemName() << ' '
           << base::SysInfo::OperatingSystemVersion();
-  return base::win::GetVersion() >= base::win::Version::WIN10;
+  return base::win::GetVersion() >= base::win::Version::VISTA;
 }
 
 void InstallUtil::AddInstallerResultItems(bool system_install,
diff --git a/chrome/installer/util/shell_util.cc b/chrome/installer/util/shell_util.cc
index 1f9d3449c04ce..cc8e13047c4c3 100644
--- a/chrome/installer/util/shell_util.cc
+++ b/chrome/installer/util/shell_util.cc
@@ -295,12 +295,13 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
     entries->back()->set_removal_flag(RegistryEntry::RemovalFlag::VALUE);
   }
 
-  // The following entries are required but do not depend on the DelegateExecute
-  // verb handler being set.
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
-  }
+  // The following entries are required as of Windows 8, but do not
+  // depend on the DelegateExecute verb handler being set.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
 
   // Add \Software\Classes\<prog_id>\Application entries
   std::wstring application_path(prog_id_path + ShellUtil::kRegApplication);
@@ -330,6 +331,7 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
         app_info.publisher_name));
   }
 }
+}
 
 // This method returns a list of all the registry entries that are needed to
 // register this installation's ProgIds and AppId.
@@ -742,11 +744,12 @@ bool QuickIsChromeRegisteredForMode(
   }
   reg_key += ShellUtil::kRegShellOpen;
 
-  // ProgId and shell integration registrations are allowed to reside in HKCU
-  // for user-level installs, and values there have priority over values in
-  // HKLM.
+  // ProgId registrations are allowed to reside in HKCU for user-level installs
+  // (and values there have priority over values in HKLM). The same is true for
+  // shell integration entries as of Windows 8.
   if (confirmation_level == CONFIRM_PROGID_REGISTRATION ||
-      confirmation_level == CONFIRM_SHELL_REGISTRATION) {
+      (confirmation_level == CONFIRM_SHELL_REGISTRATION &&
+       base::win::GetVersion() >= base::win::Version::WIN8)) {
     const RegKey key_hkcu(HKEY_CURRENT_USER, reg_key.c_str(), KEY_QUERY_VALUE);
     std::wstring hkcu_value;
     // If |reg_key| is present in HKCU, assert that it points to |chrome_exe|.
@@ -821,7 +824,9 @@ bool GetInstallationSpecificSuffix(const base::FilePath& chrome_exe,
 // be placed for this install. As of Windows 8 everything can go in HKCU for
 // per-user installs.
 HKEY DetermineRegistrationRoot(bool is_per_user) {
-  return is_per_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
+    return is_per_user && base::win::GetVersion() >= base::win::Version::WIN8
+             ? HKEY_CURRENT_USER
+             : HKEY_LOCAL_MACHINE;
 }
 
 // Associates Chrome with supported protocols and file associations. This should
@@ -1040,6 +1045,7 @@ ShellUtil::DefaultState ProbeProtocolHandlers(const base::FilePath& chrome_exe,
 // Returns true on success.
 bool GetAppShortcutsFolder(ShellUtil::ShellChange level, base::FilePath* path) {
   DCHECK(path);
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
 
   base::FilePath folder;
   if (!base::PathService::Get(base::DIR_APP_SHORTCUTS, &folder)) {
@@ -1417,6 +1423,7 @@ bool RegisterChromeBrowserImpl(const base::FilePath& chrome_exe,
 bool RegisterApplicationForProtocols(const std::vector<std::wstring>& protocols,
                                      const std::wstring& prog_id,
                                      const base::FilePath& chrome_exe) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
   std::vector<std::unique_ptr<RegistryEntry>> entries;
   ShellUtil::ApplicationInfo app_info =
       ShellUtil::GetApplicationInfoForProgId(prog_id);
@@ -1569,10 +1576,12 @@ bool ShellUtil::ShortcutLocationIsSupported(ShortcutLocation location) {
     case SHORTCUT_LOCATION_START_MENU_ROOT:                   // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_DIR_DEPRECATED:  // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR:        // Falls through.
-    case SHORTCUT_LOCATION_STARTUP:                           // Falls through.
-    case SHORTCUT_LOCATION_TASKBAR_PINS:                      // Falls through.
-    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+    case SHORTCUT_LOCATION_STARTUP:
       return true;
+    case SHORTCUT_LOCATION_TASKBAR_PINS:
+      return base::win::GetVersion() >= base::win::Version::WIN7;
+    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+      return base::win::GetVersion() >= base::win::Version::WIN8;
     default:
       NOTREACHED();
       return false;
@@ -2518,16 +2527,19 @@ bool ShellUtil::AddAppProtocolAssociations(
     if (!AddRegistryEntries(HKEY_CURRENT_USER, entries))
       success = false;
 
-    // Removing the existing user choice for a given protocol forces Windows to
-    // present a disambiguation dialog the next time this protocol is invoked
-    // from the OS.
-    std::unique_ptr<RegistryEntry> entry = GetProtocolUserChoiceEntry(protocol);
-    if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
-                                        WorkItem::kWow64Default, kRegProgId)) {
-      success = false;
+    // On Windows 10, removing the existing user choice for a given protocol
+    // forces Windows to present a disambiguation dialog the next time this
+    // protocol is invoked from the OS.
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      std::unique_ptr<RegistryEntry> entry =
+          GetProtocolUserChoiceEntry(protocol);
+      if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
+                                          WorkItem::kWow64Default,
+                                          kRegProgId)) {
+        success = false;
+      }
     }
   }
-
   return success;
 }
 
diff --git a/chrome/installer/util/taskbar_util.cc b/chrome/installer/util/taskbar_util.cc
index 0329447fdd3ad..e247deca60ff5 100644
--- a/chrome/installer/util/taskbar_util.cc
+++ b/chrome/installer/util/taskbar_util.cc
@@ -112,7 +112,9 @@ bool UnpinShortcutWithIPinnedList3(const base::FilePath& shortcut) {
 bool CanPinShortcutToTaskbar() {
   // "Pin to taskbar" isn't directly supported in Windows 10, but WIN10_RS5 has
   // some undocumented interfaces to do pinning.
-  return base::win::GetVersion() >= base::win::Version::WIN10_RS5;
+  // And the alternate method should theoretically work since Windows Desktop Update,
+  // always return true.
+  return true;
 }
 
 bool PinShortcutToTaskbar(const base::FilePath& shortcut) {
diff --git a/chrome/renderer/chrome_render_frame_observer.cc b/chrome/renderer/chrome_render_frame_observer.cc
index ef842d9e17cf3..6a6815b8ac9bc 100644
--- a/chrome/renderer/chrome_render_frame_observer.cc
+++ b/chrome/renderer/chrome_render_frame_observer.cc
@@ -251,15 +251,16 @@ void ChromeRenderFrameObserver::DidFinishLoad() {
   // Don't do anything for subframes.
   if (frame->Parent() || frame->IsInFencedFrameTree())
     return;
-
-  GURL osdd_url = frame->GetDocument().OpenSearchDescriptionURL();
-  if (!osdd_url.is_empty()) {
-    mojo::Remote<chrome::mojom::OpenSearchDescriptionDocumentHandler>
-        osdd_handler;
-    render_frame()->GetBrowserInterfaceBroker()->GetInterface(
-        osdd_handler.BindNewPipeAndPassReceiver());
-    osdd_handler->PageHasOpenSearchDescriptionDocument(
-        frame->GetDocument().Url(), osdd_url);
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-search-engine-collection")) {
+	  GURL osdd_url = frame->GetDocument().OpenSearchDescriptionURL();
+	  if (!osdd_url.is_empty()) {
+		mojo::Remote<chrome::mojom::OpenSearchDescriptionDocumentHandler>
+			osdd_handler;
+		render_frame()->GetBrowserInterfaceBroker()->GetInterface(
+			osdd_handler.BindNewPipeAndPassReceiver());
+		osdd_handler->PageHasOpenSearchDescriptionDocument(
+			frame->GetDocument().Url(), osdd_url);
+	}
   }
 }
 
diff --git a/chrome/services/util_win/processor_metrics.cc b/chrome/services/util_win/processor_metrics.cc
index 29c5bb2dd47f4..8742d122b3879 100644
--- a/chrome/services/util_win/processor_metrics.cc
+++ b/chrome/services/util_win/processor_metrics.cc
@@ -7,7 +7,6 @@
 #include <objbase.h>
 #include <sysinfoapi.h>
 #include <wbemidl.h>
-#include <winbase.h>
 #include <wrl/client.h>
 
 #include "base/metrics/histogram_functions.h"
@@ -110,63 +109,36 @@ void RecordCetAvailability() {
           ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"),
                            "IsUserCetAvailableInEnvironment"));
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
   if (is_user_cet_available_in_environment) {
     available = is_user_cet_available_in_environment(
         USER_CET_ENVIRONMENT_WIN32_PROCESS);
   }
   base::UmaHistogramBoolean("Windows.CetAvailable", available);
 
-  if (available) {
+  if (available && get_process_mitigation_policy) {
     PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {0};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                     ProcessUserShadowStackPolicy, &policy,
-                                     sizeof(policy))) {
+    if (get_process_mitigation_policy(GetCurrentProcess(),
+                                      ProcessUserShadowStackPolicy, &policy,
+                                      sizeof(policy))) {
       base::UmaHistogramBoolean("Windows.CetEnabled",
                                 policy.EnableUserShadowStack);
     }
   }
 }
 
-void RecordEnclaveAvailabilityInternal(base::StringPiece type,
-                                       DWORD enclave_type) {
-  // This API does not appear to be exported from kernel32.dll on
-  // Windows 10.0.10240.
-  static auto is_enclave_type_supported_func =
-      reinterpret_cast<decltype(&IsEnclaveTypeSupported)>(::GetProcAddress(
-          ::GetModuleHandleW(L"kernel32.dll"), "IsEnclaveTypeSupported"));
-
-  bool is_supported = false;
-
-  if (is_enclave_type_supported_func) {
-    is_supported = is_enclave_type_supported_func(enclave_type);
-  }
-
-  base::UmaHistogramBoolean(
-      base::StrCat({"Windows.Enclave.", type, ".Available"}), is_supported);
-}
-
-void RecordEnclaveAvailability() {
-  RecordEnclaveAvailabilityInternal("SGX", ENCLAVE_TYPE_SGX);
-  RecordEnclaveAvailabilityInternal("SGX2", ENCLAVE_TYPE_SGX2);
-  RecordEnclaveAvailabilityInternal("VBS", ENCLAVE_TYPE_VBS);
-  RecordEnclaveAvailabilityInternal("VBSBasic", ENCLAVE_TYPE_VBS_BASIC);
-}
-
 void RecordProcessorMetrics() {
-  // These metrics do not require a WMI connection.
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+  ComPtr<IWbemServices> wmi_services;
+  if (!base::win::CreateLocalWmiConnection(true, &wmi_services))
+    return;
+  RecordProcessorMetricsFromWMI(wmi_services);
+  RecordHypervStatusFromWMI(wmi_services);
   RecordCetAvailability();
-  RecordEnclaveAvailability();
-
-  {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-    ComPtr<IWbemServices> wmi_services;
-    if (!base::win::CreateLocalWmiConnection(true, &wmi_services)) {
-      return;
-    }
-    RecordProcessorMetricsFromWMI(wmi_services);
-    RecordHypervStatusFromWMI(wmi_services);
-  }
 }
 
 }  // namespace
diff --git a/chrome/test/data/webui/BUILD.gn b/chrome/test/data/webui/BUILD.gn
index 437c3716c37a6..0f254ac1af106 100644
--- a/chrome/test/data/webui/BUILD.gn
+++ b/chrome/test/data/webui/BUILD.gn
@@ -202,6 +202,7 @@ source_set("interactive_ui_tests") {
     "new_tab_page/new_tab_page_focus_test.cc",
     "password_manager/password_manager_focus_test.cc",
     "settings/settings_focus_test.cc",
+    "side_panel/bookmarks/sp_bookmarks_focus_test.cc",
     "support_tool/support_tool_focus_test.cc",
     "tab_search/tab_search_focus_test.cc",
   ]
diff --git a/chrome/test/data/webui/side_panel/BUILD.gn b/chrome/test/data/webui/side_panel/BUILD.gn
index 1997193e8539d..6dad0386ff454 100644
--- a/chrome/test/data/webui/side_panel/BUILD.gn
+++ b/chrome/test/data/webui/side_panel/BUILD.gn
@@ -6,6 +6,10 @@ import("../build_webui_tests.gni")
 
 build_webui_tests("build") {
   files = [
+    "bookmarks/bookmark_folder_test.ts",
+    "bookmarks/bookmarks_drag_manager_test.ts",
+    "bookmarks/bookmarks_list_focus_test.ts",
+    "bookmarks/bookmarks_list_test.ts",
     "bookmarks/power_bookmarks_context_menu_test.ts",
     "bookmarks/power_bookmarks_drag_manager_test.ts",
     "bookmarks/power_bookmarks_edit_dialog_test.ts",
diff --git a/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts b/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts
index 8810a38c7aa30..3891e6fba6ed2 100644
--- a/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts
+++ b/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts
@@ -3,7 +3,7 @@
 // found in the LICENSE file.
 
 import 'chrome://bookmarks-side-panel.top-chrome/commerce/shopping_list.js';
-import 'chrome://bookmarks-side-panel.top-chrome/power_bookmarks_list.js';
+import 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
 
 import {ActionSource} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks.mojom-webui.js';
 import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
diff --git a/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc
index 56a720efad282..7da20843509fd 100644
--- a/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc
+++ b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc
@@ -15,6 +15,18 @@ class SidePanelBookmarksTest : public WebUIMochaBrowserTest {
   }
 };
 
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksTest, List) {
+  RunTest("side_panel/bookmarks/bookmarks_list_test.js", "mocha.run()");
+}
+
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksTest, DragManager) {
+  RunTest("side_panel/bookmarks/bookmarks_drag_manager_test.js", "mocha.run()");
+}
+
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksTest, BookmarkFolder) {
+  RunTest("side_panel/bookmarks/bookmark_folder_test.js", "mocha.run()");
+}
+
 // TODO(crbug.com/1396268): Flaky on Mac and Linux dbg. Re-enable this test.
 #if BUILDFLAG(IS_MAC) || (BUILDFLAG(IS_LINUX) && !defined(NDEBUG))
 #define MAYBE_ShoppingList DISABLED_ShoppingList
diff --git a/chrome/updater/net/network_fetcher_win.cc b/chrome/updater/net/network_fetcher_win.cc
index 102ff03867ebc..dc6c1d31f037a 100644
--- a/chrome/updater/net/network_fetcher_win.cc
+++ b/chrome/updater/net/network_fetcher_win.cc
@@ -21,10 +21,12 @@
 #include "base/sequence_checker.h"
 #include "base/strings/sys_string_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "chrome/updater/net/network.h"
 #include "chrome/updater/policy/service.h"
 #include "chrome/updater/util/util.h"
 #include "chrome/updater/util/win_util.h"
+#include "chrome/updater/win/scoped_impersonation.h"
 #include "chrome/updater/win/user_info.h"
 #include "components/update_client/network.h"
 #include "components/winhttp/proxy_configuration.h"
@@ -34,6 +36,56 @@
 namespace updater {
 namespace {
 
+	std::wstring FromCharOrEmpty(const wchar_t* str) {
+  return str ? std::wstring(str) : std::wstring();
+}
+
+// Wrapper for WINHTTP_CURRENT_USER_IE_PROXY_CONFIG structure.
+// According to MSDN, callers must free strings with GlobalFree.
+class ScopedIeProxyConfig {
+ public:
+  ScopedIeProxyConfig();
+  ScopedIeProxyConfig(const ScopedIeProxyConfig&) = delete;
+  ScopedIeProxyConfig& operator=(const ScopedIeProxyConfig&) = delete;
+  ~ScopedIeProxyConfig();
+
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* receive() { return &ie_proxy_config_; }
+
+  bool auto_detect() const { return ie_proxy_config_.fAutoDetect; }
+  std::wstring auto_config_url() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszAutoConfigUrl);
+  }
+  std::wstring proxy() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxy);
+  }
+  std::wstring proxy_bypass() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxyBypass);
+  }
+
+ private:
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG ie_proxy_config_ = {};
+};
+
+ScopedIeProxyConfig::ScopedIeProxyConfig() {
+  ie_proxy_config_.fAutoDetect = false;
+  ie_proxy_config_.lpszAutoConfigUrl = nullptr;
+  ie_proxy_config_.lpszProxy = nullptr;
+  ie_proxy_config_.lpszProxyBypass = nullptr;
+}
+
+ScopedIeProxyConfig::~ScopedIeProxyConfig() {
+  if (ie_proxy_config_.lpszAutoConfigUrl)
+    ::GlobalFree(ie_proxy_config_.lpszAutoConfigUrl);
+
+  if (ie_proxy_config_.lpszProxy)
+    ::GlobalFree(ie_proxy_config_.lpszProxy);
+
+  if (ie_proxy_config_.lpszProxyBypass)
+    ::GlobalFree(ie_proxy_config_.lpszProxyBypass);
+}
+
+
+
 // Factory method for the proxy configuration strategy.
 scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
     std::optional<PolicyServiceProxyConfiguration>
@@ -50,7 +102,32 @@ scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
 
   VLOG(1) << "Using the system configuration for proxy.";
 
-  return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+   const base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  const bool supports_automatic_proxy =
+      os_info->version() >= base::win::Version::WIN8_1;
+  if (supports_automatic_proxy) {
+    return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+  }
+
+  ScopedImpersonation impersonate_user;
+  if (IsLocalSystemUser()) {
+    VLOG(2) << "Running as SYSTEM, impersonate the current user.";
+    base::win::ScopedHandle user_token = GetUserTokenFromCurrentSessionId();
+    if (user_token.IsValid()) {
+      impersonate_user.Impersonate(user_token.Get());
+    }
+  }
+
+  ScopedIeProxyConfig ie_proxy_config;
+  if (::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config.receive())) {
+    return base::MakeRefCounted<winhttp::ProxyConfiguration>(winhttp::ProxyInfo{
+        ie_proxy_config.auto_detect(), ie_proxy_config.auto_config_url(),
+        ie_proxy_config.proxy(), ie_proxy_config.proxy_bypass()});
+  } else {
+    PLOG(ERROR) << "Failed to get proxy for current user";
+  }
+
+  return base::MakeRefCounted<winhttp::ProxyConfiguration>();
 }
 
 class NetworkFetcher : public update_client::NetworkFetcher {
diff --git a/chrome/updater/win/installer/installer.cc b/chrome/updater/win/installer/installer.cc
index 0cb917e3c840b..2ef47f76f238b 100644
--- a/chrome/updater/win/installer/installer.cc
+++ b/chrome/updater/win/installer/installer.cc
@@ -324,7 +324,7 @@ ProcessExitResult InstallerMain(HMODULE module) {
   CHECK(EnableSecureDllLoading());
   EnableProcessHeapMetadataProtection();
 
-  if (base::win::GetVersion() < base::win::Version::WIN10) {
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
     return ProcessExitResult(UNSUPPORTED_WINDOWS_VERSION);
   }
 
diff --git a/components/browsing_data/core/features.cc b/components/browsing_data/core/features.cc
index 6060759c7da9a..2c45c8a526a49 100644
--- a/components/browsing_data/core/features.cc
+++ b/components/browsing_data/core/features.cc
@@ -7,6 +7,8 @@
 #include "build/build_config.h"
 
 namespace browsing_data::features {
+BASE_FEATURE(kClearDataOnExit, "ClearDataOnExit", base::FEATURE_DISABLED_BY_DEFAULT);
+
 BASE_FEATURE(kEnableBrowsingDataLifetimeManager,
              "BrowsingDataLifetimeManager",
              base::FEATURE_ENABLED_BY_DEFAULT);
diff --git a/components/browsing_data/core/features.h b/components/browsing_data/core/features.h
index 9877fd49ac0af..43f3d14a937d4 100644
--- a/components/browsing_data/core/features.h
+++ b/components/browsing_data/core/features.h
@@ -8,6 +8,7 @@
 #include "base/feature_list.h"
 
 namespace browsing_data::features {
+BASE_DECLARE_FEATURE(kClearDataOnExit);
 
 // Enable BrowsingDataLifetimeManager that periodically delete browsing data as
 // defined by the BrowsingDataLifetime policy.
diff --git a/components/components_chromium_strings.grd b/components/components_chromium_strings.grd
index 1bb22e041c9db..9d07a665aad93 100644
--- a/components/components_chromium_strings.grd
+++ b/components/components_chromium_strings.grd
@@ -22,7 +22,7 @@
     <output filename="components_chromium_strings_de.pak" type="data_package" lang="de" />
     <output filename="components_chromium_strings_el.pak" type="data_package" lang="el" />
     <output filename="components_chromium_strings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="components_chromium_strings_en-US.pak" type="data_package" lang="en" />
+    <output filename="components_chromium_strings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="components_chromium_strings_es.pak" type="data_package" lang="es" />
     <if expr="is_ios">
       <!-- iOS uses es-MX for es-419 -->
diff --git a/components/components_locale_settings.grd b/components/components_locale_settings.grd
index 8a13525fd218f..cb316b0023a37 100644
--- a/components/components_locale_settings.grd
+++ b/components/components_locale_settings.grd
@@ -20,7 +20,7 @@
     <output filename="components_locale_settings_de.pak" type="data_package" lang="de" />
     <output filename="components_locale_settings_el.pak" type="data_package" lang="el" />
     <output filename="components_locale_settings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="components_locale_settings_en-US.pak" type="data_package" lang="en" />
+    <output filename="components_locale_settings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="components_locale_settings_es.pak" type="data_package" lang="es" />
     <if expr="is_ios">
       <then>
diff --git a/components/components_strings.grd b/components/components_strings.grd
index 1f9eba905658c..6359976ed21ef 100644
--- a/components/components_strings.grd
+++ b/components/components_strings.grd
@@ -22,7 +22,7 @@
     <output filename="components_strings_de.pak" type="data_package" lang="de" />
     <output filename="components_strings_el.pak" type="data_package" lang="el" />
     <output filename="components_strings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="components_strings_en-US.pak" type="data_package" lang="en" />
+    <output filename="components_strings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="components_strings_es.pak" type="data_package" lang="es" />
     <if expr="is_ios">
       <!-- iOS uses es-MX for es-419 -->
diff --git a/components/crash/core/app/crashpad.cc b/components/crash/core/app/crashpad.cc
index 9ea9021f16006..bc737d6b77bde 100644
--- a/components/crash/core/app/crashpad.cc
+++ b/components/crash/core/app/crashpad.cc
@@ -249,7 +249,6 @@ void SetUploadConsent(bool consent) {
     // if consent is present.
     enable_uploads = consent && !crash_reporter_client->IsRunningUnattended();
   }
-
   crashpad::Settings* settings = g_database->GetSettings();
   settings->SetUploadsEnabled(enable_uploads &&
                               crash_reporter_client->GetCollectStatsInSample());
diff --git a/components/download/internal/common/base_file_win.cc b/components/download/internal/common/base_file_win.cc
index 1db03ae8852aa..4de26908df8bc 100644
--- a/components/download/internal/common/base_file_win.cc
+++ b/components/download/internal/common/base_file_win.cc
@@ -14,6 +14,7 @@
 
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/com_init_util.h"
+#include "base/win/windows_version.h"
 #include "components/download/public/common/download_interrupt_reasons_utils.h"
 #include "components/download/public/common/download_stats.h"
 
@@ -142,6 +143,212 @@ DownloadInterruptReason HRESULTToDownloadInterruptReason(HRESULT hr) {
   return DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
 }
 
+// Maps the result of a call to |SHFileOperation()| onto a
+// |DownloadInterruptReason|.
+//
+// These return codes are *old* (as in, DOS era), and specific to
+// |SHFileOperation()|.
+// They do not appear in any windows header.
+//
+// See http://msdn.microsoft.com/en-us/library/bb762164(VS.85).aspx.
+DownloadInterruptReason MapShFileOperationCodes(int code) {
+  DownloadInterruptReason result = DOWNLOAD_INTERRUPT_REASON_NONE;
+
+  // Check these pre-Win32 error codes first, then check for matches
+  // in Winerror.h.
+  // This switch statement should be kept in sync with the list of codes
+  // above.
+  switch (code) {
+    // Not a pre-Win32 error code; here so that this particular case shows up in
+    // our histograms. Unfortunately, it is used not just to signal actual
+    // ACCESS_DENIED errors, but many other errors as well. So we treat it as a
+    // transient error.
+    case ERROR_ACCESS_DENIED:  // Access is denied.
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // This isn't documented but returned from SHFileOperation. Sharing
+    // violations indicate that another process had the file open while we were
+    // trying to rename. Anti-virus is believed to be the cause of this error in
+    // the wild. Treated as a transient error on the assumption that the file
+    // will be made available for renaming at a later time.
+    case ERROR_SHARING_VIOLATION:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // This is also not a documented return value of SHFileOperation, but has
+    // been observed in the wild. We are treating it as a transient error based
+    // on the cases we have seen so far.  See http://crbug.com/368455.
+    case ERROR_INVALID_PARAMETER:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // The source and destination files are the same file.
+    // DE_SAMEFILE == 0x71
+    case 0x71:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The operation was canceled by the user, or silently canceled if the
+    // appropriate flags were supplied to SHFileOperation.
+    // DE_OPCANCELLED == 0x75
+    case 0x75:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Security settings denied access to the source.
+    // DE_ACCESSDENIEDSRC == 0x78
+    case 0x78:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source or destination path exceeded or would exceed MAX_PATH.
+    // DE_PATHTOODEEP == 0x79
+    case 0x79:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // The path in the source or destination or both was invalid.
+    // DE_INVALIDFILES == 0x7C
+    case 0x7C:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination path is an existing file.
+    // DE_FLDDESTISFILE == 0x7E
+    case 0x7E:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination path is an existing folder.
+    // DE_FILEDESTISFLD == 0x80
+    case 0x80:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The name of the file exceeds MAX_PATH.
+    // DE_FILENAMETOOLONG == 0x81
+    case 0x81:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // The destination is a read-only CD-ROM, possibly unformatted.
+    // DE_DEST_IS_CDROM == 0x82
+    case 0x82:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The destination is a read-only DVD, possibly unformatted.
+    // DE_DEST_IS_DVD == 0x83
+    case 0x83:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The destination is a writable CD-ROM, possibly unformatted.
+    // DE_DEST_IS_CDRECORD == 0x84
+    case 0x84:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The file involved in the operation is too large for the destination
+    // media or file system.
+    // DE_FILE_TOO_LARGE == 0x85
+    case 0x85:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE;
+      break;
+
+    // The source is a read-only CD-ROM, possibly unformatted.
+    // DE_SRC_IS_CDROM == 0x86
+    case 0x86:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source is a read-only DVD, possibly unformatted.
+    // DE_SRC_IS_DVD == 0x87
+    case 0x87:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source is a writable CD-ROM, possibly unformatted.
+    // DE_SRC_IS_CDRECORD == 0x88
+    case 0x88:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // MAX_PATH was exceeded during the operation.
+    // DE_ERROR_MAX == 0xB7
+    case 0xB7:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // An unspecified error occurred on the destination.
+    // XE_ERRORONDEST == 0x10000
+    case 0x10000:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Multiple file paths were specified in the source buffer, but only one
+    // destination file path.
+    // DE_MANYSRC1DEST == 0x72
+    case 0x72:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Rename operation was specified but the destination path is
+    // a different directory. Use the move operation instead.
+    // DE_DIFFDIR == 0x73
+    case 0x73:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The source is a root directory, which cannot be moved or renamed.
+    // DE_ROOTDIR == 0x74
+    case 0x74:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination is a subtree of the source.
+    // DE_DESTSUBTREE == 0x76
+    case 0x76:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The operation involved multiple destination paths,
+    // which can fail in the case of a move operation.
+    // DE_MANYDEST == 0x7A
+    case 0x7A:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The source and destination have the same parent folder.
+    // DE_DESTSAMETREE == 0x7D
+    case 0x7D:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // An unknown error occurred.  This is typically due to an invalid path in
+    // the source or destination.  This error does not occur on Windows Vista
+    // and later.
+    // DE_UNKNOWN_ERROR == 0x402
+    case 0x402:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Destination is a root directory and cannot be renamed.
+    // DE_ROOTDIR | ERRORONDEST == 0x10074
+    case 0x10074:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+  }
+
+  if (result != DOWNLOAD_INTERRUPT_REASON_NONE)
+    return result;
+
+  // If not one of the above codes, it should be a standard Windows error code.
+  return ConvertFileErrorToInterruptReason(
+      base::File::OSErrorToFileError(code));
+}
+
 class FileOperationProgressSink
     : public Microsoft::WRL::RuntimeClass<
           Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom>,
@@ -244,6 +451,35 @@ DownloadInterruptReason BaseFile::MoveFileAndAdjustPermissions(
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
+  if(base::win::GetVersion() < base::win::Version::VISTA) {
+	  // The parameters to SHFileOperation must be terminated with 2 NULL chars.
+	  base::FilePath::StringType source = full_path_.value();
+	  base::FilePath::StringType target = new_path.value();
+
+	  source.append(1, L'\0');
+	  target.append(1, L'\0');
+
+	  SHFILEOPSTRUCT move_info = {nullptr};
+	  move_info.wFunc = FO_MOVE;
+	  move_info.pFrom = source.c_str();
+	  move_info.pTo = target.c_str();
+	  move_info.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOERRORUI |
+						 FOF_NOCONFIRMMKDIR | FOF_NOCOPYSECURITYATTRIBS;
+
+	  int result = SHFileOperation(&move_info);
+	  DownloadInterruptReason interrupt_reason = DOWNLOAD_INTERRUPT_REASON_NONE;
+
+	  if (result == 0 && move_info.fAnyOperationsAborted)
+		interrupt_reason = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+	  else if (result != 0)
+		interrupt_reason = MapShFileOperationCodes(result);
+
+	  if (interrupt_reason != DOWNLOAD_INTERRUPT_REASON_NONE)
+		return LogInterruptReason("SHFileOperation", result, interrupt_reason);
+
+	  return interrupt_reason;
+  }
+
   base::win::AssertComInitialized();
   Microsoft::WRL::ComPtr<IShellItem> original_path;
   HRESULT hr = SHCreateItemFromParsingName(full_path_.value().c_str(), nullptr,
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index 44cf15e1b4703..5dfe3eaee5ba0 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -88,13 +88,45 @@ int GetPreRS5UniversalApiContractVersion() {
     return 6;
   }
   // The list above should account for all Windows versions prior to
-  // RS5.
-  NOTREACHED();
+  // RS5. 0 represents all pre-Win10 releases.
   return 0;
 }
 
+int GetLegacyWindowsVersion() {
+// The User Agent Client Hints specification indicates that Windows 7 through 8.x
+// should be handled as having a major version of 0 while using the OS' minor version.
+// (i.e. Windows 7 is 0.1). This does not account for how to handle Windows Vista and below.
+// As a result, Vista will report as 0.60 and NT 5.x as 0.5x.
+// TODO: introduce UA-CH spoofer to avoid any undesirable impacts of having the "wrong" values in future.
+	const base::win::Version version = base::win::OSInfo::Kernel32Version();
+	if (version == base::win::Version::WIN8_1) {
+		return 3;
+	}
+	if (version == base::win::Version::WIN8) {
+		return 2;
+	}
+	if (version == base::win::Version::WIN7) {
+		return 1;
+	}
+	if (version == base::win::Version::VISTA) {
+		return 60;
+	}
+	if (version == base::win::Version::SERVER_2003) {
+		return 52;
+	}
+	if (version == base::win::Version::XP) {
+		return 51;
+	}
+	if (version == base::win::Version::PRE_XP) {
+		return 50;
+	}
+	return 0;
+}
+
 // Returns the UniversalApiContract version number, which is available for
-// Windows versions greater than RS5. Otherwise, returns 0.
+// Windows versions greater than RS5. Otherwise, returns a version value
+// representing the Windows version (non-zero major version for early Windows 10,
+// non-zero minor version for pre-Windows 10).
 const std::string& GetUniversalApiContractVersion() {
   // Do not use this for runtime environment detection logic. This method should
   // only be used to help populate the Sec-CH-UA-Platform client hint. If
@@ -108,6 +140,7 @@ const std::string& GetUniversalApiContractVersion() {
         if (base::win::OSInfo::Kernel32Version() <=
             base::win::Version::WIN10_RS4) {
           major_version = GetPreRS5UniversalApiContractVersion();
+		  minor_version = GetLegacyWindowsVersion();
         } else {
           base::win::RegKey version_key(
               HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
diff --git a/components/flags_ui/flags_state.cc b/components/flags_ui/flags_state.cc
index 35dea65d76a69..2ab8de1b9780e 100644
--- a/components/flags_ui/flags_state.cc
+++ b/components/flags_ui/flags_state.cc
@@ -221,6 +221,10 @@ std::string GetCombinedOriginListValue(const FlagsStorage& flags_storage,
       command_line.GetSwitchValueASCII(command_line_switch);
   const std::string new_value =
       flags_storage.GetOriginListFlag(internal_entry_name);
+  if (command_line_switch == "custom-ntp")
+	  return existing_value.empty() ? new_value : existing_value;
+  if (command_line_switch == "http-accept-header")
+	  return existing_value.empty() ? new_value : existing_value;
   return CombineAndSanitizeOriginLists(existing_value, new_value);
 }
 
@@ -459,6 +463,8 @@ void FlagsState::SetOriginListFlag(const std::string& internal_name,
                                    const std::string& value,
                                    FlagsStorage* flags_storage) {
   const std::string new_value =
+      internal_name == "custom-ntp" ? value :
+	  internal_name == "http-accept-header" ? value :
       CombineAndSanitizeOriginLists(std::string(), value);
   flags_storage->SetOriginListFlag(internal_name, new_value);
 
diff --git a/components/history/core/browser/history_backend.cc b/components/history/core/browser/history_backend.cc
index b1a10264877c8..47d24487252c4 100644
--- a/components/history/core/browser/history_backend.cc
+++ b/components/history/core/browser/history_backend.cc
@@ -14,6 +14,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/command_line.h"
 #include "base/compiler_specific.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
@@ -1316,7 +1317,8 @@ void HistoryBackend::InitImpl(
   db_->GetStartDate(&first_recorded_time_);
 
   // Start expiring old stuff.
-  expirer_.StartExpiringOldStuff(base::Days(kExpireDaysThreshold));
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("keep-old-history"))
+    expirer_.StartExpiringOldStuff(base::Days(kExpireDaysThreshold));
 }
 
 void HistoryBackend::OnMemoryPressure(
diff --git a/components/metrics/machine_id_provider_win.cc b/components/metrics/machine_id_provider_win.cc
index c92ad1f2eabd0..c9defd3459b56 100644
--- a/components/metrics/machine_id_provider_win.cc
+++ b/components/metrics/machine_id_provider_win.cc
@@ -9,6 +9,7 @@
 #include <winioctl.h>
 
 #include "base/base_paths.h"
+#include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/notreached.h"
 #include "base/path_service.h"
@@ -19,6 +20,9 @@ namespace metrics {
 
 // static
 bool MachineIdProvider::HasId() {
+if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-machine-id")) {
+    return false;
+  }
   return true;
 }
 
@@ -26,6 +30,9 @@ bool MachineIdProvider::HasId() {
 // is running from.
 // static
 std::string MachineIdProvider::GetMachineId() {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-machine-id")) {
+    return std::string();
+  }
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
diff --git a/components/metrics/motherboard.cc b/components/metrics/motherboard.cc
index 4b2270d10a86d..e97bde5ddf5d1 100644
--- a/components/metrics/motherboard.cc
+++ b/components/metrics/motherboard.cc
@@ -16,6 +16,7 @@
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
 
+#include "base/scoped_native_library.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/scoped_bstr.h"
@@ -142,7 +143,19 @@ void ReadWin32Bios(const ComPtr<IWbemServices>& services,
 
 void ReadFirmwareType(absl::optional<Motherboard::BiosType>* bios_type) {
   FIRMWARE_TYPE firmware_type = FirmwareTypeUnknown;
-  if (::GetFirmwareType(&firmware_type)) {
+  // NOTE: GetFirmwareType API only exists on >= Win8.  Dynamically
+  //       get function handle.
+  using GetFirmwareTypeFunction = decltype(&GetFirmwareType);
+  base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+  if (!dll.is_valid())
+    return;
+  GetFirmwareTypeFunction get_firmware_type_function =
+      reinterpret_cast<GetFirmwareTypeFunction>(
+          dll.GetFunctionPointer("GetFirmwareType"));
+  if (!get_firmware_type_function)
+    return;
+
+  if (get_firmware_type_function(&firmware_type)) {
     if (firmware_type == FirmwareTypeBios) {
       *bios_type = Motherboard::BiosType::kLegacy;
     } else if (firmware_type == FirmwareTypeUefi) {
diff --git a/components/omnibox/browser/autocomplete_controller.cc b/components/omnibox/browser/autocomplete_controller.cc
index bb091060cf93e..73210ab0662f4 100644
--- a/components/omnibox/browser/autocomplete_controller.cc
+++ b/components/omnibox/browser/autocomplete_controller.cc
@@ -19,6 +19,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/feature_list.h"
 #include "base/format_macros.h"
@@ -394,6 +395,15 @@ AutocompleteController::AutocompleteController(
           metrics::OmniboxEventProto::UNKNOWN_POSITION) {
   provider_types &= ~OmniboxFieldTrial::GetDisabledProviderTypes();
 
+if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering")) {
+    const std::string flag_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("omnibox-autocomplete-filtering");
+    provider_types &= AutocompleteProvider::TYPE_KEYWORD | AutocompleteProvider::TYPE_SEARCH |
+        AutocompleteProvider::TYPE_HISTORY_URL | AutocompleteProvider::TYPE_BOOKMARK | AutocompleteProvider::TYPE_BUILTIN;
+    if (!base::Contains(flag_value, "bookmarks"))
+      provider_types &= ~AutocompleteProvider::TYPE_BOOKMARK;
+    if (!base::Contains(flag_value, "chrome"))
+      provider_types &= ~AutocompleteProvider::TYPE_BUILTIN;
+  }
   // Providers run in the order they're added. Async providers should run first
   // so their async requests can be kicked off before waiting a few milliseconds
   // for the other sync providers to complete.
diff --git a/components/omnibox/browser/history_url_provider.cc b/components/omnibox/browser/history_url_provider.cc
index 83f8b0fb22983..75eaea36b134a 100644
--- a/components/omnibox/browser/history_url_provider.cc
+++ b/components/omnibox/browser/history_url_provider.cc
@@ -479,6 +479,8 @@ void HistoryURLProvider::Start(const AutocompleteInput& input,
   if (fixed_up_input.type() != metrics::OmniboxInputType::QUERY)
     matches_.push_back(what_you_typed_match);
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering"))
+    return;
   // We'll need the history service to run both passes, so try to obtain it.
   history::HistoryService* const history_service =
       client()->GetHistoryService();
diff --git a/components/omnibox/browser/search_provider.cc b/components/omnibox/browser/search_provider.cc
index 9ef95f00eaacc..11378f7e96981 100644
--- a/components/omnibox/browser/search_provider.cc
+++ b/components/omnibox/browser/search_provider.cc
@@ -10,6 +10,7 @@
 #include <utility>
 
 #include "base/base64.h"
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
@@ -645,6 +646,8 @@ void SearchProvider::Run(bool query_is_private) {
 void SearchProvider::DoHistoryQuery(bool minimal_changes) {
   // The history query results are synchronous, so if minimal_changes is true,
   // we still have the last results and don't need to do anything.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering"))
+    return;
   if (minimal_changes)
     return;
 
diff --git a/components/os_crypt/sync/os_crypt_win.cc b/components/os_crypt/sync/os_crypt_win.cc
index 235bc61a371df..62ddd4d14d313 100644
--- a/components/os_crypt/sync/os_crypt_win.cc
+++ b/components/os_crypt/sync/os_crypt_win.cc
@@ -5,6 +5,7 @@
 #include <windows.h>
 
 #include "base/base64.h"
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/logging.h"
 #include "base/memory/singleton.h"
@@ -45,6 +46,10 @@ constexpr char kDPAPIKeyPrefix[] = "DPAPI";
 
 bool EncryptStringWithDPAPI(const std::string& plaintext,
                             std::string* ciphertext) {
+   if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-encryption")) {
+    *ciphertext = plaintext;
+    return true;
+  }
   DATA_BLOB input;
   input.pbData =
       const_cast<BYTE*>(reinterpret_cast<const BYTE*>(plaintext.data()));
@@ -79,6 +84,10 @@ bool EncryptStringWithDPAPI(const std::string& plaintext,
 
 bool DecryptStringWithDPAPI(const std::string& ciphertext,
                             std::string* plaintext) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-encryption")) {
+    *plaintext = ciphertext;
+    return true;
+  }
   DATA_BLOB input;
   input.pbData =
       const_cast<BYTE*>(reinterpret_cast<const BYTE*>(ciphertext.data()));
diff --git a/components/safe_browsing/core/common/features.cc b/components/safe_browsing/core/common/features.cc
index 71e42b821fbd9..6e3a3f7e8ae9e 100644
--- a/components/safe_browsing/core/common/features.cc
+++ b/components/safe_browsing/core/common/features.cc
@@ -52,6 +52,10 @@ const base::FeatureParam<bool> kDelayedWarningsEnableMouseClicks{
     &kDelayedWarnings, "mouse",
     /*default_value=*/false};
 
+BASE_FEATURE(kDownloadBubble,
+             "DownloadBubble",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+
 BASE_FEATURE(kDownloadTailoredWarnings,
              "DownloadTailoredWarnings",
              base::FEATURE_ENABLED_BY_DEFAULT);
@@ -295,6 +299,7 @@ constexpr struct {
     {&kClientSideDetectionKillswitch, true},
     {&kCreateWarningShownClientSafeBrowsingReports, false},
     {&kDelayedWarnings, true},
+	{&kDownloadBubble, true},
     {&kDownloadTailoredWarnings, true},
     {&kExtensionTelemetryDisableOffstoreExtensions, true},
     {&kExtensionTelemetryInterceptRemoteHostsContactedInRenderer, true},
diff --git a/components/safe_browsing/core/common/features.h b/components/safe_browsing/core/common/features.h
index c9cd78f4fdb7e..d566ecd9b8b13 100644
--- a/components/safe_browsing/core/common/features.h
+++ b/components/safe_browsing/core/common/features.h
@@ -42,6 +42,9 @@ BASE_DECLARE_FEATURE(kDelayedWarnings);
 // warnings feature is enabled.
 extern const base::FeatureParam<bool> kDelayedWarningsEnableMouseClicks;
 
+// Whether to use download bubble instead of download shelf.
+BASE_DECLARE_FEATURE(kDownloadBubble);
+
 // The kill switch for download tailored warnings. The main control is on the
 // server-side.
 BASE_DECLARE_FEATURE(kDownloadTailoredWarnings);
diff --git a/components/search_engines/template_url_service.cc b/components/search_engines/template_url_service.cc
index 48b351d2e56ad..0bd04aa016505 100644
--- a/components/search_engines/template_url_service.cc
+++ b/components/search_engines/template_url_service.cc
@@ -15,6 +15,7 @@
 #include "base/base64url.h"
 #include "base/check_deref.h"
 #include "base/check_is_test.h"
+#include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/containers/flat_map.h"
 #include "base/debug/crash_logging.h"
@@ -181,6 +182,12 @@ bool IsCreatedByExtension(const TemplateURL* template_url) {
          template_url->type() == TemplateURL::OMNIBOX_API_EXTENSION;
 }
 
+bool ShouldAutocollect() {
+  const base::CommandLine& command_line =
+    *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-search-engine-collection");
+}
+
 // Checks if `new_values` has updated versions of `existing_turl`. Only fields
 // set by the `SiteSearchSettings` policy are checked.
 bool ShouldMergeEnterpriseSiteSearchEngines(const TemplateURL& existing_turl,
@@ -389,6 +396,7 @@ TemplateURLService::TemplateURLService(
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
     )
     : prefs_(prefs),
+	  should_autocollect_(true),
       search_engine_choice_service_(search_engine_choice_service),
       search_terms_data_(std::move(search_terms_data)),
       web_data_service_(web_data_service),
@@ -520,8 +528,8 @@ bool TemplateURLService::CanAddAutogeneratedKeyword(
   // that may interfere with search queries).  An easy heuristic for this is
   // whether the user has a TemplateURL that has been manually modified (e.g.,
   // renamed) connected to the same host.
-  return !url.is_valid() || url.host().empty() ||
-      CanAddAutogeneratedKeywordForHost(url.host());
+  return should_autocollect_ && (!url.is_valid() || url.host().empty() ||
+      CanAddAutogeneratedKeywordForHost(url.host()));
 }
 
 bool TemplateURLService::IsPrepopulatedOrDefaultProviderByPolicy(
@@ -1900,6 +1908,8 @@ SyncDataMap TemplateURLService::CreateGUIDToSyncDataMap(
 }
 
 void TemplateURLService::Init() {
+  should_autocollect_ = ShouldAutocollect();
+
   if (client_)
     client_->SetOwner(this);
 
@@ -2074,6 +2084,8 @@ void TemplateURLService::ChangeToLoadedState() {
 
 bool TemplateURLService::CanAddAutogeneratedKeywordForHost(
     const std::string& host) const {
+  if (!should_autocollect_)
+    return false;
   const TemplateURLSet* urls = provider_map_->GetURLsForHost(host);
   if (!urls)
     return true;
diff --git a/components/search_engines/template_url_service.h b/components/search_engines/template_url_service.h
index e2b43ef5d67bb..52280dcd3882b 100644
--- a/components/search_engines/template_url_service.h
+++ b/components/search_engines/template_url_service.h
@@ -878,6 +878,8 @@ class TemplateURLService final : public WebDataServiceConsumer,
   // ---------- Browser state related members ---------------------------------
   raw_ptr<PrefService> prefs_ = nullptr;
 
+  bool should_autocollect_; // Whether search engines should be auto-collected
+
   raw_ptr<search_engines::SearchEngineChoiceService>
       search_engine_choice_service_ = nullptr;
 
diff --git a/components/system_media_controls/win/system_media_controls_win.cc b/components/system_media_controls/win/system_media_controls_win.cc
index c932ad09c40ac..a855edb420af1 100644
--- a/components/system_media_controls/win/system_media_controls_win.cc
+++ b/components/system_media_controls/win/system_media_controls_win.cc
@@ -81,6 +81,11 @@ bool SystemMediaControlsWin::Initialize() {
 
   attempted_to_initialize_ = true;
 
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
   Microsoft::WRL::ComPtr<ISystemMediaTransportControlsInterop> interop;
   HRESULT hr = base::win::GetActivationFactory<
       ISystemMediaTransportControlsInterop,
diff --git a/components/url_formatter/url_fixer.cc b/components/url_formatter/url_fixer.cc
index e3aa778739688..b48a5e3c10bb7 100644
--- a/components/url_formatter/url_fixer.cc
+++ b/components/url_formatter/url_fixer.cc
@@ -7,6 +7,8 @@
 #include <stddef.h>
 
 #include "base/check_op.h"
+#include "base/containers/contains.h"
+#include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/i18n/char_iterator.h"
@@ -617,6 +619,8 @@ GURL FixupURLInternal(const std::string& text,
 
     FixupHost(trimmed, parts.host, parts.scheme.is_valid(), desired_tld, &url);
     if (chrome_url && !parts.host.is_valid())
+		if (!base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering") ||
+			base::Contains(base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("omnibox-autocomplete-filtering"), "chrome"))
       url.append(kChromeUIDefaultHost);
     FixupPort(trimmed, parts.port, &url);
     FixupPath(trimmed, parts.path, &url);
diff --git a/components/url_formatter/url_formatter.cc b/components/url_formatter/url_formatter.cc
index 9936039f78fdd..ab7234423f134 100644
--- a/components/url_formatter/url_formatter.cc
+++ b/components/url_formatter/url_formatter.cc
@@ -9,6 +9,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/command_line.h"
 #include "base/lazy_instance.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
@@ -311,6 +312,13 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
   host16.reserve(host.length());
   host16.insert(host16.end(), host.begin(), host.end());
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("force-punycode-hostnames")) {
+    // Leave as punycode.
+    IDNConversionResult result;
+    result.result = host16;
+    return result;
+  }
+
   // Compute the top level domain to be used in spoof checks later.
   base::StringPiece top_level_domain;
   std::u16string top_level_domain_unicode;
diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index 6600e576a857f..6259f4a0754e9 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,6 +20,10 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,16 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
+#elif BUILDFLAG(IS_ANDROID)
+    // On Android we run a Finch experiment testing direct memory allocation.
+    config.force_direct_shared_memory_allocation = base::FeatureList::IsEnabled(
+        mojo::core::kMojoDirectSharedMemoryAndroid);
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index a460c6503d695..598067532ae00 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2849,6 +2849,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/legacy_render_widget_host_win.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 8c144725c6e54..c6c1b602562b5 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -195,6 +195,7 @@
 #include <windows.h>
 
 #include "base/threading/platform_thread_win.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
@@ -1015,6 +1016,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/compositor/viz_process_transport_factory.cc b/content/browser/compositor/viz_process_transport_factory.cc
index 516c7f65097f1..000815240587e 100644
--- a/content/browser/compositor/viz_process_transport_factory.cc
+++ b/content/browser/compositor/viz_process_transport_factory.cc
@@ -158,7 +158,6 @@ VizProcessTransportFactory::VizProcessTransportFactory(
   GetHostFrameSinkManager()->SetConnectionLostCallback(
       base::BindRepeating(&VizProcessTransportFactory::OnGpuProcessLost,
                           weak_ptr_factory_.GetWeakPtr()));
-
   if (GpuDataManagerImpl::GetInstance()->IsGpuCompositingDisabled()) {
     DisableGpuCompositing(nullptr);
   }
diff --git a/content/browser/font_access/font_enumeration_data_source_win.cc b/content/browser/font_access/font_enumeration_data_source_win.cc
index 094283551322c..01dc697c6178d 100644
--- a/content/browser/font_access/font_enumeration_data_source_win.cc
+++ b/content/browser/font_access/font_enumeration_data_source_win.cc
@@ -4,6 +4,7 @@
 
 #include "content/browser/font_access/font_enumeration_data_source_win.h"
 
+#include <Windows.h>
 #include <dwrite.h>
 #include <stdint.h>
 #include <wrl/client.h>
@@ -178,6 +179,23 @@ FontEnumerationDataSourceWin::~FontEnumerationDataSourceWin() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 }
 
+int CALLBACK EnumFontFamProc(ENUMLOGFONTA* lpelf,
+                             NEWTEXTMETRICA* lpntm,
+                             DWORD FontType,
+                             LPARAM lParam)
+{
+  blink::FontEnumerationTable* font_enumeration_table =
+      (blink::FontEnumerationTable*)lParam;
+  blink::FontEnumerationTable_FontData* data =
+      font_enumeration_table->add_fonts();
+  data->set_postscript_name(std::string());
+  data->set_full_name(std::string("Click the font name itself"));
+  data->set_family(std::string((const char*)lpelf->elfFullName));
+  data->set_style(std::string((const char*)lpelf->elfStyle));
+
+  return 1;
+}
+
 blink::FontEnumerationTable FontEnumerationDataSourceWin::GetFonts(
     const std::string& locale) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -185,6 +203,14 @@ blink::FontEnumerationTable FontEnumerationDataSourceWin::GetFonts(
   blink::FontEnumerationTable font_enumeration_table;
 
   Microsoft::WRL::ComPtr<IDWriteFontCollection> collection = GetSystemFonts();
+  if (!collection)
+  {
+    HDC hDC = ::GetDC(NULL);
+    ::EnumFontFamiliesA(hDC, NULL, (FONTENUMPROCA)EnumFontFamProc,
+                        (LPARAM) &font_enumeration_table);
+    ::ReleaseDC(NULL, hDC);
+    return font_enumeration_table;
+  }
   uint32_t family_count;
   {
     base::ScopedBlockingCall scoped_blocking_call(
diff --git a/content/browser/installedapp/installed_app_provider_impl_win.cc b/content/browser/installedapp/installed_app_provider_impl_win.cc
index 252da4a57d373..4f379ef5a3d65 100644
--- a/content/browser/installedapp/installed_app_provider_impl_win.cc
+++ b/content/browser/installedapp/installed_app_provider_impl_win.cc
@@ -112,6 +112,13 @@ void FilterInstalledAppsForWin(
     std::vector<blink::mojom::RelatedApplicationPtr> related_apps,
     blink::mojom::InstalledAppProvider::FilterInstalledAppsCallback callback,
     const GURL frame_url) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload() ||
+      !base::win::ResolveCoreWinRTDelayload()) {
+    std::move(callback).Run(std::vector<blink::mojom::RelatedApplicationPtr>());
+    return;
+  }
+
   ComPtr<ILauncherStatics4> launcher_statics;
   HRESULT hr = base::win::RoActivateInstance(
       base::win::ScopedHString::Create(RuntimeClass_Windows_System_Launcher)
diff --git a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
index 62cc6bca47934..5e47b05ee71ee 100644
--- a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
+++ b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
@@ -12,6 +12,7 @@
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox_policy.h"
@@ -33,10 +34,13 @@ bool PpapiPluginSandboxedProcessLauncherDelegate::InitializeConfig(
   // The Pepper process is as locked-down as a renderer except that it can
   // create the server side of Chrome pipes.
   sandbox::ResultCode result;
+  // We don't support PPAPI win32k lockdown prior to Windows 10.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
   result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
   if (result != sandbox::SBOX_ALL_OK) {
     return false;
   }
+  }
 
   // No plugins can generate executable code.
   sandbox::MitigationFlags flags = config->GetDelayedProcessMitigations();
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index b04194c32a4d1..d760a109ff576 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,10 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +46,9 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
@@ -173,9 +181,12 @@ void DirectManipulationHelper::OnPointerHitTest(WPARAM w_param) {
   // For WM_POINTER, the pointer type will show the event from mouse.
   // For WM_POINTERACTIVATE, the pointer id will be different with the following
   // message.
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(pointer_id, &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     viewport_->SetContact(pointer_id);
   }
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index 257f8480a4c49..955f34a4b2973 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -36,6 +36,9 @@
 #include "third_party/abseil-cpp/absl/utility/utility.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/ports/SkTypeface_win.h"
 #include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/text_analysis_source.h"
 
@@ -446,6 +449,40 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -542,7 +579,52 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {
+  InitializeDirectWrite();
+  callback = mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+      std::move(callback),
+      blink::mojom::FallbackFamilyAndStyle::New("",
+                                                /* weight */ 0,
+                                                /* width */ 0,
+                                                /* slant */ 0));
+
+  if (!codepoint || !collection_ || !factory_)
+    return;
+
+  sk_sp<SkFontMgr> font_mgr(
+      SkFontMgr_New_DirectWrite(factory_.Get(), collection_.Get()));
+
+  if (!font_mgr)
+    return;
+
+  const char* bcp47_locales[] = {locale_name.c_str()};
+  int num_locales = locale_name.empty() ? 0 : 1;
+  const char** locales = locale_name.empty() ? nullptr : bcp47_locales;
+
+  sk_sp<SkTypeface> typeface(font_mgr->matchFamilyStyleCharacter(
+      base_family_name.c_str(), SkFontStyle(), locales, num_locales,
+      codepoint));
+
+  if (!typeface)
+    return;
+
+  SkString family_name;
+  typeface->getFamilyName(&family_name);
+
+  SkFontStyle font_style = typeface->fontStyle();
+
+  auto result_fallback_and_style = blink::mojom::FallbackFamilyAndStyle::New(
+      family_name.c_str(), font_style.weight(), font_style.width(),
+      font_style.slant());
+  std::move(callback).Run(std::move(result_fallback_and_style));
+}
+
 void DWriteFontProxyImpl::InitializeDirectWrite() {
+  HRESULT hr;
   if (direct_write_initialized_)
     return;
   direct_write_initialized_ = true;
@@ -556,20 +638,30 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
-  // Normally identical to factory_->GetSystemFontCollection() unless a
-  // sideloaded font has been added using SideLoadFontForTesting().
-  HRESULT hr = GetLocalFontCollection(factory3_, &collection_);
+  // On Windows 10 and up (or Vista exkernel/Windows 8.x with modified dwrite.dll from 1809)
+  // you can take advantage of the extended DirectWrite APIs to sideload local fonts in
+  // addition to system fonts. But if IDWriteFactory3 is unavailable, fall back to
+  // GetSystemFontCollection.
+  // TODO: make DirectWrite optional for the benefit of the NT 5 users.
+
+  if(factory3_  == nullptr) {
+  hr = factory_->GetSystemFontCollection(&collection_);
   DCHECK(SUCCEEDED(hr));
+  }
+  else {
+  hr = GetLocalFontCollection(factory3_, &collection_);
+  DCHECK(SUCCEEDED(hr));
+  }
+
 
   if (!collection_) {
     return;
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index 11af003ea85fe..efb8c813661f5 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_thread.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
@@ -62,6 +63,20 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
   void InitializeDirectWrite();
 
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
index 5f8c1b00295ce..152f73280e000 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
@@ -25,6 +25,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
 #include "third_party/icu/source/common/unicode/umachine.h"
+#include "ui/gfx/test/font_fallback_test_data.h"
 
 namespace content {
 
@@ -182,6 +183,32 @@ TEST_F(DWriteFontProxyImplUnitTest, TestCustomFontFiles) {
   }
 }
 
+TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
+  for (auto& fallback_request : gfx::kGetFontFallbackTests) {
+    blink::mojom::FallbackFamilyAndStylePtr fallback_family_and_style;
+    UChar32 codepoint;
+    U16_GET(fallback_request.text.c_str(), 0, 0, fallback_request.text.size(),
+            codepoint);
+    dwrite_font_proxy().FallbackFamilyAndStyleForCodepoint(
+        "Times New Roman", fallback_request.language_tag, codepoint,
+        &fallback_family_and_style);
+
+    EXPECT_TRUE(base::Contains(fallback_request.fallback_fonts,
+                               fallback_family_and_style->fallback_family_name))
+        << "Did not find expected fallback font for language: "
+        << fallback_request.language_tag << ", codepoint U+" << std::hex
+        << codepoint << " DWrite returned font name: \""
+        << fallback_family_and_style->fallback_family_name << "\""
+        << ", expected: "
+        << base::JoinString(fallback_request.fallback_fonts, ", ");
+    EXPECT_EQ(fallback_family_and_style->weight, 400u);
+    EXPECT_EQ(fallback_family_and_style->width,
+              5u);  // SkFontStyle::Width::kNormal_Width
+    EXPECT_EQ(fallback_family_and_style->slant,
+              0u);  // SkFontStyle::Slant::kUpright_Slant
+  }
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index b656054d342f5..1fe6db41ba459 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3569,7 +3569,9 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kRendererWaitForJavaDebugger,
 #endif
 #if BUILDFLAG(IS_WIN)
+    switches::kDisableDirectWrite,
     switches::kDisableHighResTimer,
+    switches::kEnableWin7WebRtcHWH264Decoding,
     switches::kTrySupportedChannelLayouts,
     switches::kRaiseTimerFrequency,
 #endif
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
index 896d975020696..f6857fa9353f2 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
@@ -41,9 +41,19 @@ base::RepeatingCallback<mojo::PendingRemote<blink::mojom::DWriteFontProxy>(
 void CreateDirectWriteFactory(IDWriteFactory** factory) {
   // This shouldn't be necessary, but not having this causes breakage in
   // content_browsertests, and possibly other high-stress cases.
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+
+  HMODULE dwrite_dll = GetModuleHandleW(L"dwrite.dll");
+
   PatchServiceManagerCalls();
 
-  CHECK(SUCCEEDED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_ISOLATED,
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
+  CHECK(SUCCEEDED(dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_ISOLATED,
                                       __uuidof(IDWriteFactory),
                                       reinterpret_cast<IUnknown**>(factory))));
 }
@@ -53,6 +63,10 @@ void CreateDirectWriteFactory(IDWriteFactory** factory) {
 void InitializeDWriteFontProxy() {
   TRACE_EVENT0("dwrite,fonts", "InitializeDWriteFontProxy");
   mswr::ComPtr<IDWriteFactory> factory;
+  // Halt the init process if the DLL is not there.
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
 
   CreateDirectWriteFactory(&factory);
 
@@ -79,7 +93,7 @@ void InitializeDWriteFontProxy() {
 
   skia::OverrideDefaultSkFontMgr(std::move(skia_font_manager));
 
-  DCHECK(g_font_fallback);
+  blink::WebFontRendering::SetUseSkiaFontFallback(g_font_fallback ? true : false);
 }
 
 void UninitializeDWriteFontProxy() {
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
index 163d1ecca00c1..0186a5a3d8b8d 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
@@ -52,8 +52,18 @@ class DWriteFontProxyUnitTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
-                        &factory);
+    using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+    if (!dwrite_dll)
+      return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+      return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+                               &factory);
 
     std::vector<wchar_t> font_path;
     font_path.resize(MAX_PATH);
diff --git a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
index 90a04f1deef7f..3f40491a80b7b 100644
--- a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
@@ -27,7 +27,17 @@ namespace {
 class FontFallbackUnitTest : public testing::Test {
  public:
   FontFallbackUnitTest() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+	DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+	if (!dwrite_create_factory_proc)
+		return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory_);
 
     factory_->CreateNumberSubstitution(DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE,
diff --git a/content/child/font_warmup_win_unittest.cc b/content/child/font_warmup_win_unittest.cc
index 051af55e65a2c..eb511cfa3cee1 100644
--- a/content/child/font_warmup_win_unittest.cc
+++ b/content/child/font_warmup_win_unittest.cc
@@ -19,6 +19,7 @@
 #include "base/path_service.h"
 #include "base/sys_byteorder.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 
 #include "content/child/dwrite_font_proxy/dwrite_font_proxy_win.h"
 #include "content/public/common/content_paths.h"
@@ -69,6 +70,16 @@ class GDIFontEmulationTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+	HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+		return;
     DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory);
   }
@@ -136,6 +147,8 @@ int CALLBACK EnumFontCallbackTest(const LOGFONT* log_font,
 }  // namespace
 
 TEST_F(GDIFontEmulationTest, CreateDeleteDCSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_FALSE(!patch_data);
 
@@ -147,6 +160,8 @@ TEST_F(GDIFontEmulationTest, CreateDeleteDCSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateUniqueDCSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
 
@@ -162,6 +177,8 @@ TEST_F(GDIFontEmulationTest, CreateUniqueDCSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateFontSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   LOGFONTW logfont = {0};
@@ -173,6 +190,8 @@ TEST_F(GDIFontEmulationTest, CreateFontSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateFontFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   LOGFONTW logfont = {0};
@@ -182,6 +201,8 @@ TEST_F(GDIFontEmulationTest, CreateFontFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, EnumFontFamilySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -194,6 +215,8 @@ TEST_F(GDIFontEmulationTest, EnumFontFamilySuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, EnumFontFamilyFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -206,6 +229,8 @@ TEST_F(GDIFontEmulationTest, EnumFontFamilyFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, DeleteDCFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = reinterpret_cast<HDC>(0x55667788);
@@ -213,6 +238,8 @@ TEST_F(GDIFontEmulationTest, DeleteDCFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, DeleteObjectFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HFONT font = reinterpret_cast<HFONT>(0x88aabbcc);
@@ -220,6 +247,8 @@ TEST_F(GDIFontEmulationTest, DeleteObjectFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataSizeSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -237,6 +266,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataSizeSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataInvalidTagSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -253,6 +284,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataInvalidTagSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataInvalidFontSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -263,6 +296,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataInvalidFontSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataDataSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
diff --git a/content/child/runtime_features.cc b/content/child/runtime_features.cc
index 5a5b3c03b3b26..fa39ca2868ae6 100644
--- a/content/child/runtime_features.cc
+++ b/content/child/runtime_features.cc
@@ -4,7 +4,6 @@
 
 #include "content/child/runtime_features.h"
 
-#include <string>
 #include <vector>
 
 #include "base/base_switches.h"
@@ -55,6 +54,10 @@
 #include "device/vr/public/cpp/features.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using blink::WebRuntimeFeatures;
 
 namespace {
diff --git a/content/child/webthemeengine_impl_default_browsertest.cc b/content/child/webthemeengine_impl_default_browsertest.cc
index a638c432bb49d..e68ee23fdbd23 100644
--- a/content/child/webthemeengine_impl_default_browsertest.cc
+++ b/content/child/webthemeengine_impl_default_browsertest.cc
@@ -15,7 +15,7 @@ namespace content {
 
 class WebThemeEngineImplDefaultBrowserTest : public ContentBrowserTest {
  public:
-  WebThemeEngineImplDefaultBrowserTest() = default;
+  WebThemeEngineImplDefaultBrowserTest() {}
 };
 
 #if BUILDFLAG(IS_WIN)
@@ -23,9 +23,6 @@ IN_PROC_BROWSER_TEST_F(WebThemeEngineImplDefaultBrowserTest, GetSystemColor) {
   // The test non-deterministically fails on Windows-2008ServerR2 builders due
   // to a difference in the default theme. As a result, only run the test on
   // non-server versions.
-  // TODO(https://crbug.com/1385856): Remove this, and the windows_version.h
-  // include, if the failure turns out to be specific to Windows-2008ServerR2
-  // and not any Windows server.
   if (base::win::OSInfo::GetInstance()->version_type() ==
       base::win::VersionType::SUITE_SERVER) {
     return;
@@ -115,19 +112,36 @@ IN_PROC_BROWSER_TEST_F(WebThemeEngineImplDefaultBrowserTest, GetSystemColor) {
                                   "window",
                                   "windowFrame",
                                   "windowText"};
-  const std::vector<std::string> expected_colors = {
-      "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
-      "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
-      "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
-      "rgb(0, 120, 215)",   "rgb(255, 255, 255)", "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
-      "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
-      "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  std::vector<std::string> expected_colors;
+  if (base::win::GetVersion() <= base::win::Version::WIN8_1) {
+    expected_colors = {
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
+        "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
+        "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
+        "rgb(51, 153, 255)",  "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  } else {
+    expected_colors = {
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
+        "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
+        "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
+        "rgb(0, 120, 215)",   "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  }
 
   ASSERT_EQ(ids.size(), expected_colors.size());
 
diff --git a/content/common/sandbox_init_win.cc b/content/common/sandbox_init_win.cc
index 498f60227d13e..724ce1120b720 100644
--- a/content/common/sandbox_init_win.cc
+++ b/content/common/sandbox_init_win.cc
@@ -17,6 +17,7 @@
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace content {
 
diff --git a/content/ppapi_plugin/ppapi_plugin_main.cc b/content/ppapi_plugin/ppapi_plugin_main.cc
index 89e84b2c25c52..8af071d123a33 100644
--- a/content/ppapi_plugin/ppapi_plugin_main.cc
+++ b/content/ppapi_plugin/ppapi_plugin_main.cc
@@ -172,7 +172,12 @@ int PpapiPluginMain(MainFunctionParams parameters) {
 #if BUILDFLAG(IS_WIN)
   if (!base::win::IsUser32AndGdi32Available())
     gfx::win::InitializeDirectWrite();
-  InitializeDWriteFontProxy();
+  bool use_direct_write = gfx::win::IsDirectWriteEnabled();
+  if (use_direct_write) {
+    InitializeDWriteFontProxy();
+  }
+
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   int antialiasing_enabled = 1;
   base::StringToInt(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index d004abc6fe3da..1d43fe3c9eeee 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -746,6 +746,10 @@ std::string ContentBrowserClient::GetDefaultDownloadName() {
   return std::string();
 }
 
+base::FilePath ContentBrowserClient::GetFontLookupTableCacheDir() {
+  return base::FilePath();
+}
+
 base::FilePath ContentBrowserClient::GetShaderDiskCacheDirectory() {
   return base::FilePath();
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index d0a5dbc454670..670c9a80489b8 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1220,6 +1220,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // else we should do with the file.
   virtual std::string GetDefaultDownloadName();
 
+  // Returns the path to the font lookup table cache directory in which - on
+  // Windows 7 & 8 - we cache font name meta information to perform @font-face {
+  // src: local() } lookups.
+  virtual base::FilePath GetFontLookupTableCacheDir();
+
   // Returns the path to the browser shader disk cache root.
   virtual base::FilePath GetShaderDiskCacheDirectory();
 
diff --git a/content/public/browser/frame_accept_header.cc b/content/public/browser/frame_accept_header.cc
index 341a585720048..9d08e62fc9f01 100644
--- a/content/public/browser/frame_accept_header.cc
+++ b/content/public/browser/frame_accept_header.cc
@@ -4,6 +4,7 @@
 
 #include "content/public/browser/frame_accept_header.h"
 
+#include "base/command_line.h"
 #include "content/browser/web_package/signed_exchange_consts.h"
 #include "content/browser/web_package/signed_exchange_utils.h"
 #include "content/common/content_constants_internal.h"
@@ -12,6 +13,8 @@ namespace content {
 
 std::string FrameAcceptHeaderValue(bool allow_sxg_responses,
                                    BrowserContext* browser_context) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("http-accept-header"))
+     return base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("http-accept-header");
   std::string header_value = kFrameAcceptHeaderValue;
 
   if (allow_sxg_responses &&
diff --git a/content/public/common/content_features.cc b/content/public/common/content_features.cc
index 7890cd4195e8f..53b8c7b09f63f 100644
--- a/content/public/common/content_features.cc
+++ b/content/public/common/content_features.cc
@@ -4,8 +4,6 @@
 
 #include "content/public/common/content_features.h"
 
-#include <string>
-
 #include "base/feature_list.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
@@ -13,6 +11,10 @@
 #include "content/common/buildflags.h"
 #include "content/public/common/dips_utils.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace features {
 
 // All features in alphabetical order.
@@ -1399,6 +1401,11 @@ VideoCaptureServiceConfiguration GetVideoCaptureServiceConfiguration() {
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
   return VideoCaptureServiceConfiguration::kEnabledForBrowserProcess;
 #else
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return VideoCaptureServiceConfiguration::kEnabledForBrowserProcess;
+  }
+#endif
   return base::FeatureList::IsEnabled(
              features::kRunVideoCaptureServiceInBrowserProcess)
              ? VideoCaptureServiceConfiguration::kEnabledForBrowserProcess
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index 0e06580a8d496..43106e9dc7aa4 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -1027,6 +1027,10 @@ const char kDeviceScaleFactor[]     = "device-scale-factor";
 // Disable the Legacy Window which corresponds to the size of the WebContents.
 const char kDisableLegacyIntermediateWindow[] = "disable-legacy-window";
 
+// Enables H264 HW decode acceleration for WebRtc on Win 7.
+const char kEnableWin7WebRtcHWH264Decoding[] =
+    "enable-win7-webrtc-hw-h264-decoding";
+
 // DirectWrite FontCache is shared by browser to renderers using shared memory.
 // This switch allows us to pass the shared memory handle to the renderer.
 const char kFontCacheSharedHandle[] = "font-cache-shared-handle";
diff --git a/content/public/common/content_switches.h b/content/public/common/content_switches.h
index 1708337fd82f0..5519702d8f0c3 100644
--- a/content/public/common/content_switches.h
+++ b/content/public/common/content_switches.h
@@ -284,6 +284,7 @@ CONTENT_EXPORT extern const char kPrefetchArgumentOther[];
 // like renderers, etc.
 CONTENT_EXPORT extern const char kDeviceScaleFactor[];
 CONTENT_EXPORT extern const char kDisableLegacyIntermediateWindow[];
+CONTENT_EXPORT extern const char kEnableWin7WebRtcHWH264Decoding[];
 // Switch to pass the font cache shared memory handle to the renderer.
 CONTENT_EXPORT extern const char kFontCacheSharedHandle[];
 CONTENT_EXPORT extern const char kPpapiAntialiasedTextEnabled[];
diff --git a/content/renderer/pepper/content_renderer_pepper_host_factory.cc b/content/renderer/pepper/content_renderer_pepper_host_factory.cc
index 54379d58e8cd0..c732b56f4a3d6 100644
--- a/content/renderer/pepper/content_renderer_pepper_host_factory.cc
+++ b/content/renderer/pepper/content_renderer_pepper_host_factory.cc
@@ -40,6 +40,10 @@
 #include "third_party/blink/public/web/web_document.h"
 #include "third_party/blink/public/web/web_plugin_container.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using ppapi::host::ResourceHost;
 using ppapi::UnpackMessage;
 
@@ -120,10 +124,12 @@ ContentRendererPepperHostFactory::CreateResourceHost(
       ppapi::PPB_ImageData_Shared::ImageDataType image_type =
           ppapi::PPB_ImageData_Shared::PLATFORM;
 #if BUILDFLAG(IS_WIN)
+      // Win32K lockdown mitigations are enabled for Windows 8 and beyond.
       // We use the SIMPLE image data type as the PLATFORM image data type
       // calls GDI functions to create DIB sections etc which fail in Win32K
       // lockdown mode.
-      image_type = ppapi::PPB_ImageData_Shared::SIMPLE;
+      if (base::win::GetVersion() >= base::win::Version::WIN8)
+        image_type = ppapi::PPB_ImageData_Shared::SIMPLE;
 #endif
       scoped_refptr<PPB_ImageData_Impl> image_data(new PPB_ImageData_Impl(
           instance, image_type));
diff --git a/content/renderer/pepper/resource_creation_impl.cc b/content/renderer/pepper/resource_creation_impl.cc
index 7ec35f454a984..a232bc9581726 100644
--- a/content/renderer/pepper/resource_creation_impl.cc
+++ b/content/renderer/pepper/resource_creation_impl.cc
@@ -21,6 +21,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/command_line.h"
+#include "base/win/windows_version.h"
 #endif
 
 using ppapi::InputEventData;
@@ -112,17 +113,18 @@ PP_Resource ResourceCreationImpl::CreateImageData(PP_Instance instance,
                                                   const PP_Size* size,
                                                   PP_Bool init_to_zero) {
 #if BUILDFLAG(IS_WIN)
-  // We use the SIMPLE image data type as the PLATFORM image data type
+  // If Win32K lockdown mitigations are enabled for Windows 8 and beyond,
+  // we use the SIMPLE image data type as the PLATFORM image data type
   // calls GDI functions to create DIB sections etc which fail in Win32K
   // lockdown mode.
-  return CreateImageDataSimple(instance, format, size, init_to_zero);
-#else
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    return CreateImageDataSimple(instance, format, size, init_to_zero);
+#endif
   return PPB_ImageData_Impl::Create(instance,
                                     ppapi::PPB_ImageData_Shared::PLATFORM,
                                     format,
                                     *size,
                                     init_to_zero);
-#endif
 }
 
 PP_Resource ResourceCreationImpl::CreateImageDataSimple(
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 07bb68687683a..579b000b1e7c4 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -1203,6 +1203,8 @@ WindowOpenDisposition NavigationPolicyToDisposition(
     case blink::kWebNavigationPolicyNewWindow:
       return WindowOpenDisposition::NEW_WINDOW;
     case blink::kWebNavigationPolicyNewPopup:
+	  if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+         return WindowOpenDisposition::NEW_FOREGROUND_TAB;
       return WindowOpenDisposition::NEW_POPUP;
     case blink::kWebNavigationPolicyPictureInPicture:
       return WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
diff --git a/content/renderer/render_view_browsertest.cc b/content/renderer/render_view_browsertest.cc
index fb0d957ee5d88..245fcda505aba 100644
--- a/content/renderer/render_view_browsertest.cc
+++ b/content/renderer/render_view_browsertest.cc
@@ -124,6 +124,10 @@
 #include "third_party/blink/public/common/input/web_input_event.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_OZONE)
 #include "ui/events/keycodes/keyboard_code_conversion.h"
 #endif
@@ -3134,6 +3138,12 @@ TEST_F(RenderViewImplScaleFactorTest, ConvertViewportToWindow) {
 TEST_F(RenderViewImplScaleFactorTest,
        DISABLED_GetCompositionCharacterBoundsTest) {  // http://crbug.com/582016
   SetDeviceScaleFactor(1.f);
+#if BUILDFLAG(IS_WIN)
+  // http://crbug.com/508747
+  if (base::win::GetVersion() >= base::win::Version::WIN10)
+    return;
+#endif
+
   LoadHTML("<textarea id=\"test\"></textarea>");
   ExecuteJavaScriptForTests("document.getElementById('test').focus();");
 
diff --git a/content/renderer/renderer_blink_platform_impl.cc b/content/renderer/renderer_blink_platform_impl.cc
index 619323f485c6a..7fe31a29e46f6 100644
--- a/content/renderer/renderer_blink_platform_impl.cc
+++ b/content/renderer/renderer_blink_platform_impl.cc
@@ -127,6 +127,10 @@
 #include "content/common/android/sync_compositor_statics.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using blink::Platform;
 using blink::WebAudioDevice;
 using blink::WebAudioLatencyHint;
@@ -598,6 +602,22 @@ void RendererBlinkPlatformImpl::GetWebRTCRendererPreferences(
   *allow_mdns_obfuscation = true;
 }
 
+bool RendererBlinkPlatformImpl::IsWebRtcHWH264DecodingEnabled(
+    webrtc::VideoCodecType video_codec_type) {
+#if BUILDFLAG(IS_WIN)
+  // Do not use hardware decoding for H.264 on Win7, due to high latency.
+  // See https://crbug.com/webrtc/5717.
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnableWin7WebRtcHWH264Decoding) &&
+      video_codec_type == webrtc::kVideoCodecH264 &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    DVLOG(1) << "H.264 HW decoding is not supported on Win7";
+    return false;
+  }
+#endif  // BUILDFLAG(IS_WIN)
+  return true;
+}
+
 bool RendererBlinkPlatformImpl::IsWebRtcHWEncodingEnabled() {
   return !base::CommandLine::ForCurrentProcess()->HasSwitch(
       switches::kDisableWebRtcHWEncoding);
diff --git a/content/renderer/renderer_blink_platform_impl.h b/content/renderer/renderer_blink_platform_impl.h
index ecbcf12493f77..c3279cea45f70 100644
--- a/content/renderer/renderer_blink_platform_impl.h
+++ b/content/renderer/renderer_blink_platform_impl.h
@@ -158,6 +158,8 @@ class CONTENT_EXPORT RendererBlinkPlatformImpl : public BlinkPlatformImpl {
                                     uint16_t* udp_min_port,
                                     uint16_t* udp_max_port,
                                     bool* allow_mdns_obfuscation) override;
+  bool IsWebRtcHWH264DecodingEnabled(
+      webrtc::VideoCodecType video_coded_type) override;
   bool IsWebRtcHWEncodingEnabled() override;
   bool IsWebRtcHWDecodingEnabled() override;
   bool IsWebRtcSrtpEncryptedHeadersEnabled() override;
diff --git a/content/renderer/renderer_main.cc b/content/renderer/renderer_main.cc
index 4953e20861803..c7521519c31aa 100644
--- a/content/renderer/renderer_main.cc
+++ b/content/renderer/renderer_main.cc
@@ -94,6 +94,11 @@
 #include "mojo/public/cpp/bindings/lib/test_random_mojo_delays.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace content {
 namespace {
 
@@ -241,8 +246,18 @@ int RendererMain(MainFunctionParams parameters) {
   {
     content::ContentRendererClient* client = GetContentClient()->renderer();
     bool should_run_loop = true;
-    bool need_sandbox =
+#if BUILDFLAG(IS_WIN)
+    bool need_sandbox = true;
+    if(base::win::GetVersion() >= base::win::Version::WIN8) {
+	// Windows 8+ specific limitations required renderer sandbox disabled for GDI
+    need_sandbox = gfx::win::ShouldUseDirectWrite() &&
         !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+	}
+	else
+	need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#else
+    bool need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#endif
 
     if (!need_sandbox) {
       // The post-sandbox actions still need to happen at some point.
diff --git a/content/renderer/renderer_main_platform_delegate_win.cc b/content/renderer/renderer_main_platform_delegate_win.cc
index e7b8caa9ab118..45b9f2823affb 100644
--- a/content/renderer/renderer_main_platform_delegate_win.cc
+++ b/content/renderer/renderer_main_platform_delegate_win.cc
@@ -27,6 +27,18 @@
 #include "ui/gfx/win/direct_write.h"
 
 namespace content {
+namespace {
+
+// Windows-only skia sandbox support
+// These are used for GDI-path rendering.
+void SkiaPreCacheFont(const LOGFONT& logfont) {
+  RenderThread* render_thread = RenderThread::Get();
+  if (render_thread) {
+    render_thread->PreCacheFont(logfont);
+  }
+}
+
+}  // namespace
 
 RendererMainPlatformDelegate::RendererMainPlatformDelegate(
     const MainFunctionParams& parameters)
@@ -40,8 +52,16 @@ void RendererMainPlatformDelegate::PlatformInitialize() {
 
   // Be mindful of what resources you acquire here. They can be used by
   // malicious code if the renderer gets compromised.
-  bool no_sandbox =
-      command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+  bool no_sandbox =command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+
+  bool use_direct_write = gfx::win::ShouldUseDirectWrite();
+
+  if (use_direct_write) {
+      InitializeDWriteFontProxy();
+    } else {
+      SkTypeface_SetEnsureLOGFONTAccessibleProc(SkiaPreCacheFont);
+    }
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   if (!no_sandbox) {
     // ICU DateFormat class (used in base/time_format.cc) needs to get the
diff --git a/content/shell/browser/shell_content_browser_client.cc b/content/shell/browser/shell_content_browser_client.cc
index 3e0b86f6834c5..3762ae6ac5267 100644
--- a/content/shell/browser/shell_content_browser_client.cc
+++ b/content/shell/browser/shell_content_browser_client.cc
@@ -14,6 +14,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/cxx20_erase.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
@@ -62,7 +63,6 @@
 #include "content/public/browser/web_contents_view_delegate.h"
 #include "content/public/common/content_features.h"
 #include "content/public/common/content_switch_dependent_feature_overrides.h"
-#include "content/public/common/content_switches.h"
 #include "content/public/common/url_constants.h"
 #include "content/public/common/user_agent.h"
 #include "content/shell/browser/shell.h"
@@ -467,6 +467,11 @@ std::string ShellContentBrowserClient::GetDefaultDownloadName() {
   return "download";
 }
 
+base::FilePath ShellContentBrowserClient::GetFontLookupTableCacheDir() {
+  return browser_context()->GetPath().Append(
+      FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 std::unique_ptr<WebContentsViewDelegate>
 ShellContentBrowserClient::GetWebContentsViewDelegate(
     WebContents* web_contents) {
@@ -542,7 +547,7 @@ void ShellContentBrowserClient::OverrideWebkitPrefs(
     WebContents* web_contents,
     blink::web_pref::WebPreferences* prefs) {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode)) {
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag)) {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kDark;
   } else {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kLight;
diff --git a/content/shell/browser/shell_content_browser_client.h b/content/shell/browser/shell_content_browser_client.h
index 83253e9feb3eb..fc91dcc11ae5f 100644
--- a/content/shell/browser/shell_content_browser_client.h
+++ b/content/shell/browser/shell_content_browser_client.h
@@ -95,6 +95,7 @@ class ShellContentBrowserClient : public ContentBrowserClient {
       override;
   void OverrideWebkitPrefs(WebContents* web_contents,
                            blink::web_pref::WebPreferences* prefs) override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   std::unique_ptr<content::DevToolsManagerDelegate>
   CreateDevToolsManagerDelegate() override;
   void ExposeInterfacesToRenderer(
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index 54d7450544572..dd6c051111e0c 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -146,6 +146,12 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {}
+
 FakeFontCollection::~FakeFontCollection() = default;
 
 }  // namespace content
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index e5c7230ffcaad..3906ff44e64a6 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,11 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
  private:
   std::vector<FakeFont> fonts_;
diff --git a/content/web_test/browser/web_test_control_host.cc b/content/web_test/browser/web_test_control_host.cc
index 5b66607001fd5..e0e6e87d9affa 100644
--- a/content/web_test/browser/web_test_control_host.cc
+++ b/content/web_test/browser/web_test_control_host.cc
@@ -19,6 +19,7 @@
 #include "base/barrier_closure.h"
 #include "base/base64.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/contains.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
@@ -788,7 +789,7 @@ void WebTestControlHost::OverrideWebkitPrefs(
     ApplyWebTestDefaultPreferences(prefs);
   }
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode)) {
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag)) {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kDark;
   } else {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kLight;
diff --git a/crypto/unexportable_key_win.cc b/crypto/unexportable_key_win.cc
index 7e39e10de7be3..a3ad47adbfc54 100644
--- a/crypto/unexportable_key_win.cc
+++ b/crypto/unexportable_key_win.cc
@@ -367,6 +367,11 @@ class UnexportableKeyProviderWin : public UnexportableKeyProvider {
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if(!::LoadLibraryW(L"ncrypt.dll")) {
+		  return absl::nullopt;
+	  }
+
       if (FAILED(NCryptOpenStorageProvider(
               ScopedNCryptProvider::Receiver(provider).get(),
               MS_PLATFORM_CRYPTO_PROVIDER, /*flags=*/0))) {
@@ -386,6 +391,11 @@ class UnexportableKeyProviderWin : public UnexportableKeyProvider {
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if(!::LoadLibraryW(L"ncrypt.dll")) {
+		  return nullptr;
+	  }
+
       if (FAILED(NCryptOpenStorageProvider(
               ScopedNCryptProvider::Receiver(provider).get(),
               MS_PLATFORM_CRYPTO_PROVIDER, /*flags=*/0))) {
@@ -612,6 +622,11 @@ class VirtualUnexportableKeyProviderWin
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if(!::LoadLibraryW(L"ncrypt.dll")) {
+		  return absl::nullopt;
+	  }
+
       SECURITY_STATUS status = NCryptOpenStorageProvider(
           ScopedNCryptProvider::Receiver(provider).get(),
           MS_KEY_STORAGE_PROVIDER, /*dwFlags=*/0);
@@ -634,6 +649,11 @@ class VirtualUnexportableKeyProviderWin
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if(!::LoadLibraryW(L"ncrypt.dll")) {
+		  return nullptr;
+	  }
+
       SECURITY_STATUS status = NCryptOpenStorageProvider(
           ScopedNCryptProvider::Receiver(provider).get(),
           MS_KEY_STORAGE_PROVIDER, /*dwFlags=*/0);
diff --git a/device/bluetooth/bluetooth_adapter_winrt.cc b/device/bluetooth/bluetooth_adapter_winrt.cc
index a2ba812053fa5..195ec4ee6afe8 100644
--- a/device/bluetooth/bluetooth_adapter_winrt.cc
+++ b/device/bluetooth/bluetooth_adapter_winrt.cc
@@ -105,6 +105,11 @@ using ABI::Windows::Storage::Streams::IDataReaderStatics;
 using Microsoft::WRL::Callback;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 // Query string for powered Bluetooth radios. GUID Reference:
 // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/guid-bthport-device-interface
 // TODO(https://crbug.com/821766): Consider adding WindowsCreateStringReference
@@ -666,6 +671,14 @@ void BluetoothAdapterWinrt::InitForTests(
     ComPtr<IBluetoothAdapterStatics> bluetooth_adapter_statics,
     ComPtr<IDeviceInformationStatics> device_information_statics,
     ComPtr<IRadioStatics> radio_statics) {
+
+  if (!ResolveCoreWinRT()) {
+    CompleteInit(std::move(init_callback), std::move(bluetooth_adapter_statics),
+                 std::move(device_information_statics),
+                 std::move(radio_statics));
+    return;
+  }
+
   auto statics = PerformSlowInitTasks();
 
   // This allows any passed in values (which would be fakes) to replace
@@ -689,6 +702,8 @@ void BluetoothAdapterWinrt::InitForTests(
 BluetoothAdapterWinrt::StaticsInterfaces
 BluetoothAdapterWinrt::PerformSlowInitTasks() {
   base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
+  if (!ResolveCoreWinRT())
+    return BluetoothAdapterWinrt::StaticsInterfaces();
   ComPtr<IBluetoothAdapterStatics> adapter_statics;
   HRESULT hr = base::win::GetActivationFactory<
       IBluetoothAdapterStatics,
diff --git a/device/gamepad/wgi_data_fetcher_win.cc b/device/gamepad/wgi_data_fetcher_win.cc
index a215ae7f06fc7..5c685f7deea47 100644
--- a/device/gamepad/wgi_data_fetcher_win.cc
+++ b/device/gamepad/wgi_data_fetcher_win.cc
@@ -210,6 +210,11 @@ GamepadSource WgiDataFetcherWin::source() {
 
 void WgiDataFetcherWin::OnAddedToProvider() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!base::win::HStringReference::ResolveCoreWinRTStringDelayload()) {
+    initialization_state_ =
+        InitializationState::kCoreWinrtStringDelayLoadFailed;
+    return;
+  }
   HRESULT hr = get_activation_factory_function_(
       base::win::HStringReference(RuntimeClass_Windows_Gaming_Input_Gamepad)
           .Get(),
diff --git a/device/gamepad/wgi_data_fetcher_win.h b/device/gamepad/wgi_data_fetcher_win.h
index a5a27848749a2..450ad10130f76 100644
--- a/device/gamepad/wgi_data_fetcher_win.h
+++ b/device/gamepad/wgi_data_fetcher_win.h
@@ -36,6 +36,7 @@ class DEVICE_GAMEPAD_EXPORT WgiDataFetcherWin final
     kAddGamepadAddedFailed,
     kAddGamepadRemovedFailed,
     kRoGetActivationFactoryFailed,
+    kCoreWinrtStringDelayLoadFailed,
   };
 
   using Factory =
diff --git a/docs/README.md b/docs/README.md
index 6eadc1f036521..8b3a5b64761c0 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -1,20 +1,33 @@
-# Chromium docs
+# Supermium - an up-to-date, open-source browser for legacy Windows users
 
-This directory contains [chromium project](https://www.chromium.org/Home/)
-documentation in [Gitiles-flavored Markdown]. It is automatically
-[rendered by Gitiles].
+The aim of Supermium is to provide the latest Chromium features, support for rendering the web and security patches to users
+of Windows Vista (with extended kernel), Windows 7 and Windows 8.x.
 
-[Gitiles-flavored Markdown]: https://gerrit.googlesource.com/gitiles/+/master/Documentation/markdown.md
-[rendered by Gitiles]: https://chromium.googlesource.com/chromium/src/+/main/docs/
+Releases are expected every one to two months.
 
-**If you add new documents, please also add a link to them in the Document Index
-below.**
+# Support this and other legacy software projects at: http://paypal.me/win32420
 
-[TOC]
+# Future objectives
 
-## Creating Documentation
+-Maintaining support for Manifest v2
 
-### Guidelines
+-Supporting Windows Vista (without extended kernel)
+
+-Restoring GDI font rendering
+
+-Adding basic GUI to installer to allow user to pick an install directory
+
+-Adding trapezoidal tabs option
+
+-"ungoogled" mode
+
+# Future objectives of lower priority
+
+-Supporting Windows XP
+
+-SSE2 build
+
+Upstream README.md follows below:
 
 *   See the [Chromium Documentation Guidelines](documentation_guidelines.md)
     and the
@@ -470,4 +483,4 @@ a video series of interviews with Chromium software engineers.
 *   [Vanilla msysgit workflow](vanilla_msysgit_workflow.md) - A workflow for
     using mostly vanilla git on Windows.
 *   [Old Options](chrome_settings.md) - Pre-Material Design chrome://settings
-    notes.
+    notes.
\ No newline at end of file
diff --git a/gin/v8_initializer.cc b/gin/v8_initializer.cc
index 0b7fcb2ffd5e1..cf2cc3ac104b2 100644
--- a/gin/v8_initializer.cc
+++ b/gin/v8_initializer.cc
@@ -52,6 +52,10 @@
 #endif
 #endif  // V8_USE_EXTERNAL_STARTUP_DATA
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gin {
 
 namespace {
@@ -522,6 +526,22 @@ void V8Initializer::Initialize(IsolateHolder::ScriptMode mode,
   const size_t min_pool_size = partition_alloc::internal::
       PartitionAddressSpace::ConfigurablePoolMinSize();
   size_t pool_size = max_pool_size;
+#if BUILDFLAG(IS_WIN)
+  // On Windows prior to 8.1 we allocate a smaller Pool since reserving
+  // virtual memory is expensive on these OSes.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1) {
+    // The size chosen here should be synchronized with the size of the
+    // virtual memory reservation for the V8 sandbox on these platforms.
+    // Currently, that is 8GB, of which 4GB are used for V8's pointer
+    // compression region.
+    // TODO(saelo) give this constant a proper name and maybe move it
+    // somewhere else.
+    constexpr size_t kGB = 1ULL << 30;
+    pool_size = 8ULL * kGB;
+    DCHECK_LE(pool_size, max_pool_size);
+    DCHECK_GE(pool_size, min_pool_size);
+  }
+#endif
   // Try to reserve the maximum size of the pool at first, then keep halving
   // the size on failure until it succeeds.
   uintptr_t pool_base = 0;
diff --git a/google_apis/google_api_keys.cc b/google_apis/google_api_keys.cc
index 49c396d69d172..cf1b234fb616c 100644
--- a/google_apis/google_api_keys.cc
+++ b/google_apis/google_api_keys.cc
@@ -37,7 +37,7 @@
 #define DUMMY_API_TOKEN "dummytoken"
 
 #if !defined(GOOGLE_API_KEY)
-#define GOOGLE_API_KEY DUMMY_API_TOKEN
+#define GOOGLE_API_KEY "AIzaSyBOti4mM-6x9WDnZIjIeyEU21OpBXqWBgw"
 #endif
 
 #if !defined(GOOGLE_METRICS_SIGNING_KEY)
@@ -45,11 +45,11 @@
 #endif
 
 #if !defined(GOOGLE_CLIENT_ID_MAIN)
-#define GOOGLE_CLIENT_ID_MAIN DUMMY_API_TOKEN
+#define GOOGLE_CLIENT_ID_MAIN "77185425430.apps.googleusercontent.com"
 #endif
 
 #if !defined(GOOGLE_CLIENT_SECRET_MAIN)
-#define GOOGLE_CLIENT_SECRET_MAIN DUMMY_API_TOKEN
+#define GOOGLE_CLIENT_SECRET_MAIN "OTJgUOQcT7lO7GsGZq2G4IlT"
 #endif
 
 #if !defined(GOOGLE_CLIENT_ID_REMOTING)
diff --git a/gpu/config/gpu_driver_bug_list.json b/gpu/config/gpu_driver_bug_list.json
index e4176a963cdca..1689bcc6e8761 100644
--- a/gpu/config/gpu_driver_bug_list.json
+++ b/gpu/config/gpu_driver_bug_list.json
@@ -1142,6 +1142,50 @@
         "disable_program_disk_cache"
       ]
     },
+    {
+      "id": 26,
+      "description": "Disable use of Direct3D 11 on Windows Vista and lower",
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<=",
+          "value": "6.0"
+        }
+      },
+      "features": [
+        "disable_d3d11"
+      ]
+    },
+    {
+      "id": 149,
+      "description": "Direct composition flashes black initially on Win <10",
+      "cr_bugs": [588588],
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<",
+          "value": "10.0"
+        }
+      },
+      "features": [
+        "disable_direct_composition"
+      ]
+    },
+    {
+      "id": 170,
+      "description": "Zero copy DXGI video hangs on shutdown on Win < 8.1",
+      "cr_bugs": [621190],
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<",
+          "value": "8.1"
+        }
+      },
+      "features": [
+        "disable_dxgi_zero_copy_video"
+      ]
+    },
     {
       "id": 219,
       "description": "Zero-copy DXGI video hangs or displays incorrect colors on older AMD drivers",
diff --git a/gpu/config/gpu_info_collector_win.cc b/gpu/config/gpu_info_collector_win.cc
index b3fc392c7b8fc..14992248d8ac6 100644
--- a/gpu/config/gpu_info_collector_win.cc
+++ b/gpu/config/gpu_info_collector_win.cc
@@ -187,6 +187,9 @@ void CollectHardwareOverlayInfo(OverlayInfo* overlay_info) {
 bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
   TRACE_EVENT0("gpu", "CollectDriverInfoD3D");
 
+  if (!::GetProcAddress(::GetModuleHandleW(L"dxgi.dll"), "CreateDXGIFactory1"))
+    return false;
+
   Microsoft::WRL::ComPtr<IDXGIFactory1> dxgi_factory;
   HRESULT hr = ::CreateDXGIFactory1(IID_PPV_ARGS(&dxgi_factory));
   if (FAILED(hr))
diff --git a/gpu/config/software_rendering_list.json b/gpu/config/software_rendering_list.json
index 79ea316cf4c63..4254dcc172ff6 100644
--- a/gpu/config/software_rendering_list.json
+++ b/gpu/config/software_rendering_list.json
@@ -350,6 +350,21 @@
         "accelerated_video_decode"
       ]
     },
+    {
+      "id": 79,
+      "description": "Disable GPU on all Windows versions prior to and including Vista",
+      "cr_bugs": [315199],
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<=",
+          "value": "6.0"
+        }
+      },
+      "features": [
+        "all"
+      ]
+    },
     {
       "id": 68,
       "description": "VMware Fusion 4 has corrupt rendering on Windows",
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index b3c80d0943c74..2392d747f4107 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -231,6 +231,8 @@ source_set("audio") {
       "win/core_audio_util_win.h",
       "win/device_enumeration_win.cc",
       "win/device_enumeration_win.h",
+      "win/wavein_input_win.cc",
+      "win/wavein_input_win.h",
       "win/waveout_output_win.cc",
       "win/waveout_output_win.h",
     ]
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index 185790836e1b8..c20ada15e5e8f 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -235,6 +235,13 @@ bool InitializeUWPSupport() {
     // 10.0.10240.0.
     DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
 
+    if (!(base::win::ResolveCoreWinRTDelayload() &&
+          base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+      // Failed loading functions from combase.dll.
+      DLOG(WARNING) << "Failed to initialize WinRT/UWP";
+      return false;
+    }
+
     return true;
   }();
 
diff --git a/media/audio/win/audio_manager_win.cc b/media/audio/win/audio_manager_win.cc
index b160875beda79..2e27bcf22d3e5 100644
--- a/media/audio/win/audio_manager_win.cc
+++ b/media/audio/win/audio_manager_win.cc
@@ -28,6 +28,7 @@
 #include "media/audio/win/audio_low_latency_output_win.h"
 #include "media/audio/win/core_audio_util_win.h"
 #include "media/audio/win/device_enumeration_win.h"
+#include "media/audio/win/wavein_input_win.h"
 #include "media/audio/win/waveout_output_win.h"
 #include "media/base/audio_parameters.h"
 #include "media/base/channel_layout.h"
@@ -61,6 +62,13 @@ constexpr int kMaxOutputStreams = 50;
 // right drivers, but graceful error handling is needed.
 constexpr int kWinMaxChannels = 8;
 
+// We use 3 buffers for recording audio so that if a recording callback takes
+// some time to return we won't lose audio. More buffers while recording are
+// ok because they don't introduce any delay in recording, unlike in playback
+// where you first need to fill in that number of buffers before starting to
+// play.
+static const int kNumInputBuffers = 3;
+
 // Buffer size to use for input and output stream when a proper size can't be
 // determined from the system
 constexpr int kFallbackBufferSize = 2048;
@@ -157,24 +165,35 @@ void AudioManagerWin::InitializeOnAudioThread() {
   // callback to a WeakPtr: NotifyAllOutputDeviceChangeListeners() will be
   // posted to the audio thread instead of being run synchronously, since we use
   // BindPostTaskToCurrentDefault().
+  if (CoreAudioUtil::IsSupported()) {
   output_device_listener_ = std::make_unique<AudioDeviceListenerWin>(
       base::BindPostTaskToCurrentDefault(base::BindRepeating(
           &AudioManagerWin::NotifyAllOutputDeviceChangeListeners,
           weak_this_on_audio_thread_)));
+  }
 }
 
 void AudioManagerWin::GetAudioDeviceNamesImpl(bool input,
                                               AudioDeviceNames* device_names) {
   DCHECK(device_names->empty());
   // Enumerate all active audio-endpoint capture devices.
-  if (input)
-    GetInputDeviceNamesWin(device_names);
-  else
-    GetOutputDeviceNamesWin(device_names);
-
+  if (!CoreAudioUtil::IsSupported()) {
+    // Utilize the Wave API for Windows 2000/XP.
+    if (input)
+      GetInputDeviceNamesWinXP(device_names);
+    else
+      GetOutputDeviceNamesWinXP(device_names);
+  } else {
+    // Utilize the MMDevice API (part of Core Audio) for Vista and higher.
+    if (input)
+      GetInputDeviceNamesWin(device_names);
+    else
+      GetOutputDeviceNamesWin(device_names);
+  }
   if (!device_names->empty()) {
-    device_names->push_front(AudioDeviceName::CreateCommunications());
-
+	  if (CoreAudioUtil::IsSupported()) {
+		device_names->push_front(AudioDeviceName::CreateCommunications());
+	  }
     // Always add default device parameters as first element.
     device_names->push_front(AudioDeviceName::CreateDefault());
   }
@@ -192,18 +211,22 @@ void AudioManagerWin::GetAudioOutputDeviceNames(
 AudioParameters AudioManagerWin::GetInputStreamParameters(
     const std::string& device_id) {
   AudioParameters parameters;
-  HRESULT hr =
-      CoreAudioUtil::GetPreferredAudioParameters(device_id, false, &parameters);
+  HRESULT hr = E_FAIL;
+  if (CoreAudioUtil::IsSupported()) {
+	hr = CoreAudioUtil::GetPreferredAudioParameters(device_id, false, &parameters);
+  }
 
   if (FAILED(hr) || !parameters.IsValid()) {
+	if (CoreAudioUtil::IsSupported()) {
     LOG(WARNING) << "Unable to get preferred audio params for " << device_id
                  << " 0x" << std::hex << hr;
+	}
     // TODO(tommi): We appear to have callers to GetInputStreamParameters that
     // rely on getting valid audio parameters returned for an invalid or
     // unavailable device. We should track down those code paths (it is likely
     // that they actually don't need a real device but depend on the audio
     // code path somehow for a configuration - e.g. tab capture).
-    parameters = AudioParameters(AudioParameters::AUDIO_PCM_LINEAR,
+    parameters = AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
                                  ChannelLayoutConfig::Stereo(), 48000,
                                  kFallbackBufferSize);
   }
@@ -217,6 +240,11 @@ AudioParameters AudioManagerWin::GetInputStreamParameters(
 
 std::string AudioManagerWin::GetAssociatedOutputDeviceID(
     const std::string& input_device_id) {
+  if (!CoreAudioUtil::IsSupported()) {
+		    NOTIMPLEMENTED()
+        << "GetAssociatedOutputDeviceID is not supported on this OS";
+    return std::string();
+  }
   return CoreAudioUtil::GetMatchingOutputDeviceID(input_device_id);
 }
 
@@ -270,9 +298,14 @@ AudioOutputStream* AudioManagerWin::MakeLowLatencyOutputStream(
     return nullptr;
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceWaveAudio)) {
-    DLOG(WARNING) << "Forcing usage of Windows WaveXxx APIs";
-    return nullptr;
+          switches::kForceWaveAudio) || !CoreAudioUtil::IsSupported()) {
+		// Fall back to Windows Wave implementation on Windows XP or lower.
+		DLOG_IF(ERROR, !device_id.empty() &&
+						   device_id != AudioDeviceDescription::kDefaultDeviceId)
+			<< "Opening by device id not supported by PCMWaveOutAudioOutputStream";
+		DVLOG(1) << "Using WaveOut since WASAPI requires at least Vista.";
+		return new PCMWaveOutAudioOutputStream(
+			this, params, NumberOfWaveOutBuffers(), WAVE_MAPPER);
   }
 
   // Pass an empty string to indicate that we want the default device
@@ -305,7 +338,16 @@ AudioInputStream* AudioManagerWin::MakeLowLatencyInputStream(
     const std::string& device_id,
     const LogCallback& log_callback) {
   // Used for both AUDIO_PCM_LOW_LATENCY and AUDIO_PCM_LINEAR.
-  return new WASAPIAudioInputStream(this, params, device_id, log_callback);
+    AudioInputStream* stream = NULL;
+    if (!CoreAudioUtil::IsSupported()) {
+      // Fall back to Windows Wave implementation on Windows XP or lower.
+      DVLOG(1) << "Using WaveIn since WASAPI requires at least Vista.";
+      stream = CreatePCMWaveInAudioInputStream(params, device_id);
+    } else {
+      stream = new WASAPIAudioInputStream(this, params, device_id, log_callback);
+    }
+
+  return stream;
 }
 
 std::string AudioManagerWin::GetDefaultInputDeviceID() {
@@ -313,6 +355,8 @@ std::string AudioManagerWin::GetDefaultInputDeviceID() {
 }
 
 std::string AudioManagerWin::GetDefaultOutputDeviceID() {
+  if (!CoreAudioUtil::IsSupported())
+    return std::string();
   return CoreAudioUtil::GetDefaultOutputDeviceID();
 }
 
@@ -335,79 +379,91 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
   int min_buffer_size = 0;
   int max_buffer_size = 0;
 
-  if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio)) {
-    // TODO(rtoy): tune these values for best possible WebAudio
-    // performance. WebRTC works well at 48kHz and a buffer size of 480
-    // samples will be used for this case. Note that exclusive mode is
-    // experimental. This sample rate will be combined with a buffer size of
-    // 256 samples, which corresponds to an output delay of ~5.33ms.
-    sample_rate = 48000;
-    buffer_size = 256;
-    if (input_params.IsValid())
-      channel_layout_config = input_params.channel_layout_config();
-  } else {
-    AudioParameters params;
-    HRESULT hr = CoreAudioUtil::GetPreferredAudioParameters(
-        output_device_id.empty() ? GetDefaultOutputDeviceID()
-                                 : output_device_id,
-        true, &params);
-    if (FAILED(hr)) {
-      // This can happen when CoreAudio isn't supported or available
-      // (e.g. certain installations of Windows Server 2008 R2).
-      // Instead of returning the input_params, we'll return invalid
-      // AudioParameters to make sure that an attempt to create this output
-      // stream, won't succeed. This behavior is also consistent with
-      // GetInputStreamParameters.
-      DLOG(ERROR) << "GetPreferredAudioParameters failed: " << std::hex << hr;
-      return AudioParameters();
+  if (CoreAudioUtil::IsSupported()) {
+	  if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio)) {
+		// TODO(rtoy): tune these values for best possible WebAudio
+		// performance. WebRTC works well at 48kHz and a buffer size of 480
+		// samples will be used for this case. Note that exclusive mode is
+		// experimental. This sample rate will be combined with a buffer size of
+		// 256 samples, which corresponds to an output delay of ~5.33ms.
+		sample_rate = 48000;
+		buffer_size = 256;
+		if (input_params.IsValid())
+		  channel_layout_config = input_params.channel_layout_config();
+	  } else {
+		AudioParameters params;
+		HRESULT hr = CoreAudioUtil::GetPreferredAudioParameters(
+			output_device_id.empty() ? GetDefaultOutputDeviceID()
+									 : output_device_id,
+			true, &params);
+		if (FAILED(hr)) {
+		  // This can happen when CoreAudio isn't supported or available
+		  // (e.g. certain installations of Windows Server 2008 R2).
+		  // Instead of returning the input_params, we'll return invalid
+		  // AudioParameters to make sure that an attempt to create this output
+		  // stream, won't succeed. This behavior is also consistent with
+		  // GetInputStreamParameters.
+		  DLOG(ERROR) << "GetPreferredAudioParameters failed: " << std::hex << hr;
+		  return AudioParameters();
+		}
+		DVLOG(1) << params.AsHumanReadableString();
+		DCHECK(params.IsValid());
+
+		channel_layout_config = params.channel_layout_config();
+		buffer_size = params.frames_per_buffer();
+		sample_rate = params.sample_rate();
+		effects = params.effects();
+
+		AudioParameters::HardwareCapabilities hardware_capabilities =
+			params.hardware_capabilities().value_or(
+				AudioParameters::HardwareCapabilities());
+		min_buffer_size = hardware_capabilities.min_frames_per_buffer;
+		max_buffer_size = hardware_capabilities.max_frames_per_buffer;
+	  }
+
+	  if (input_params.IsValid()) {
+		// If the user has enabled checking supported channel layouts or we don't
+		// have a valid channel layout yet, try to use the input layout.  See bugs
+		// http://crbug.com/259165 and http://crbug.com/311906 for more details.
+		if (cmd_line->HasSwitch(switches::kTrySupportedChannelLayouts) ||
+			channel_layout_config.channel_layout() == CHANNEL_LAYOUT_UNSUPPORTED) {
+		  // Check if it is possible to open up at the specified input channel
+		  // layout but avoid checking if the specified layout is the same as the
+		  // hardware (preferred) layout. We do this extra check to avoid the
+		  // CoreAudioUtil::IsChannelLayoutSupported() overhead in most cases.
+		  if (input_params.channel_layout() !=
+			  channel_layout_config.channel_layout()) {
+			// TODO(henrika): Internally, IsChannelLayoutSupported does many of the
+			// operations that have already been done such as opening up a client
+			// and fetching the WAVEFORMATPCMEX format.  Ideally we should only do
+			// that once.  Then here, we can check the layout from the data we
+			// already hold.
+			if (CoreAudioUtil::IsChannelLayoutSupported(
+					output_device_id, eRender, eConsole,
+					input_params.channel_layout())) {
+			  // Open up using the same channel layout as the source if it is
+			  // supported by the hardware.
+			  channel_layout_config = input_params.channel_layout_config();
+			  DVLOG(1) << "Hardware channel layout is not used; using same layout"
+					   << " as the source instead ("
+					   << channel_layout_config.channel_layout() << ")";
+			}
+		  }
+		}
     }
-    DVLOG(1) << params.AsHumanReadableString();
-    DCHECK(params.IsValid());
-
-    channel_layout_config = params.channel_layout_config();
-    buffer_size = params.frames_per_buffer();
-    sample_rate = params.sample_rate();
-    effects = params.effects();
-
-    AudioParameters::HardwareCapabilities hardware_capabilities =
-        params.hardware_capabilities().value_or(
-            AudioParameters::HardwareCapabilities());
-    min_buffer_size = hardware_capabilities.min_frames_per_buffer;
-    max_buffer_size = hardware_capabilities.max_frames_per_buffer;
-  }
+    effects |= input_params.effects();
 
-  if (input_params.IsValid()) {
-    // If the user has enabled checking supported channel layouts or we don't
-    // have a valid channel layout yet, try to use the input layout.  See bugs
-    // http://crbug.com/259165 and http://crbug.com/311906 for more details.
-    if (cmd_line->HasSwitch(switches::kTrySupportedChannelLayouts) ||
-        channel_layout_config.channel_layout() == CHANNEL_LAYOUT_UNSUPPORTED) {
-      // Check if it is possible to open up at the specified input channel
-      // layout but avoid checking if the specified layout is the same as the
-      // hardware (preferred) layout. We do this extra check to avoid the
-      // CoreAudioUtil::IsChannelLayoutSupported() overhead in most cases.
-      if (input_params.channel_layout() !=
-          channel_layout_config.channel_layout()) {
-        // TODO(henrika): Internally, IsChannelLayoutSupported does many of the
-        // operations that have already been done such as opening up a client
-        // and fetching the WAVEFORMATPCMEX format.  Ideally we should only do
-        // that once.  Then here, we can check the layout from the data we
-        // already hold.
-        if (CoreAudioUtil::IsChannelLayoutSupported(
-                output_device_id, eRender, eConsole,
-                input_params.channel_layout())) {
-          // Open up using the same channel layout as the source if it is
-          // supported by the hardware.
-          channel_layout_config = input_params.channel_layout_config();
-          DVLOG(1) << "Hardware channel layout is not used; using same layout"
-                   << " as the source instead ("
-                   << channel_layout_config.channel_layout() << ")";
-        }
-      }
+    if (!CoreAudioUtil::IsSupported()) {
+      // If WASAPI isn't supported we'll fallback to WaveOut, which will take
+      // care of resampling and bits per sample changes.  By setting these
+      // equal to the input values, AudioOutputResampler will skip resampling
+      // and bit per sample differences (since the input parameters will match
+      // the output parameters).
+      buffer_size = input_params.frames_per_buffer();
+      sample_rate = input_params.sample_rate();
+	  channel_layout_config = input_params.channel_layout_config();
     }
 
-    effects |= input_params.effects();
-
     // Allow non-default buffer sizes if we have a valid min and max.
     if (min_buffer_size > 0 && max_buffer_size > 0) {
       buffer_size =
@@ -438,6 +494,23 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
   return params;
 }
 
+AudioInputStream* AudioManagerWin::CreatePCMWaveInAudioInputStream(
+    const AudioParameters& params,
+    const std::string& device_id) {
+  std::string xp_device_id = device_id;
+  if (device_id != AudioDeviceDescription::kDefaultDeviceId) {
+    xp_device_id = ConvertToWinXPInputDeviceId(device_id);
+    if (xp_device_id.empty()) {
+      DLOG(ERROR) << "Cannot find a waveIn device which matches the device ID "
+                  << device_id;
+      return NULL;
+    }
+  }
+
+  return new PCMWaveInAudioInputStream(this, params, kNumInputBuffers,
+                                       xp_device_id);
+}
+
 // static
 std::unique_ptr<AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
diff --git a/media/audio/win/audio_manager_win.h b/media/audio/win/audio_manager_win.h
index 0a53e62efa795..5417b2902a95f 100644
--- a/media/audio/win/audio_manager_win.h
+++ b/media/audio/win/audio_manager_win.h
@@ -74,6 +74,15 @@ class MEDIA_EXPORT AudioManagerWin : public AudioManagerBase {
   // Allow unit test to modify the utilized enumeration API.
   friend class AudioManagerTest;
 
+  // Returns a PCMWaveInAudioInputStream instance or NULL on failure.
+  // This method converts MMDevice-style device ID to WaveIn-style device ID if
+  // necessary.
+  // (Please see device_enumeration_win.h for more info about the two kinds of
+  // device IDs.)
+  AudioInputStream* CreatePCMWaveInAudioInputStream(
+      const AudioParameters& params,
+      const std::string& device_id);
+
   // Helper methods for performing expensive initialization tasks on the audio
   // thread instead of on the UI thread which AudioManager is constructed on.
   void InitializeOnAudioThread();
diff --git a/media/audio/win/device_enumeration_win.cc b/media/audio/win/device_enumeration_win.cc
index 11b1678768a10..75f9ac80ec71b 100644
--- a/media/audio/win/device_enumeration_win.cc
+++ b/media/audio/win/device_enumeration_win.cc
@@ -165,6 +165,54 @@ bool GetOutputDeviceNamesWinXP(AudioDeviceNames* device_names) {
                                  waveOutGetDevCapsW>(device_names);
 }
 
+std::string ConvertToWinXPInputDeviceId(const std::string& device_id) {
+  UINT number_of_active_devices = waveInGetNumDevs();
+  MMRESULT result = MMSYSERR_NOERROR;
+
+  UINT i = 0;
+  for (; i < number_of_active_devices; ++i) {
+    size_t size = 0;
+    // Get the size (including the terminating NULL) of the endpoint ID of the
+    // waveIn device.
+    result = waveInMessage(reinterpret_cast<HWAVEIN>(i),
+                           DRV_QUERYFUNCTIONINSTANCEIDSIZE,
+                           reinterpret_cast<DWORD_PTR>(&size), NULL);
+    if (result != MMSYSERR_NOERROR)
+      continue;
+
+    ScopedCoMem<WCHAR> id;
+    id.Reset(static_cast<WCHAR*>(CoTaskMemAlloc(size)));
+    if (!id)
+      continue;
+
+    // Get the endpoint ID string for this waveIn device.
+    result = waveInMessage(
+        reinterpret_cast<HWAVEIN>(i), DRV_QUERYFUNCTIONINSTANCEID,
+        reinterpret_cast<DWORD_PTR>(static_cast<WCHAR*>(id)), size);
+    if (result != MMSYSERR_NOERROR)
+      continue;
+
+    std::string utf8_id = base::WideToUTF8(static_cast<WCHAR*>(id));
+    // Check whether the endpoint ID string of this waveIn device matches that
+    // of the audio endpoint device.
+    if (device_id == utf8_id)
+      break;
+  }
+
+  // If a matching waveIn device was found, convert the unique endpoint ID
+  // string to a standard friendly name with max 32 characters.
+  if (i < number_of_active_devices) {
+    WAVEINCAPS capabilities;
+
+    result = waveInGetDevCaps(i, &capabilities, sizeof(capabilities));
+    if (result == MMSYSERR_NOERROR)
+      return base::WideToUTF8(capabilities.szPname);
+  }
+
+  return std::string();
+
+}
+
 std::string GetDeviceSuffixWin(const std::string& controller_id) {
   std::string suffix;
   if (controller_id.size() >= 21 && controller_id.substr(0, 8) == "USB\\VID_" &&
diff --git a/media/audio/win/device_enumeration_win.h b/media/audio/win/device_enumeration_win.h
index d6f73a8424496..0c3eed8ce4e03 100644
--- a/media/audio/win/device_enumeration_win.h
+++ b/media/audio/win/device_enumeration_win.h
@@ -28,8 +28,17 @@ bool GetOutputDeviceNamesWin(media::AudioDeviceNames* device_names);
 // Example record in the output list:
 // - device_name: "Microphone (Realtek High Defini".
 // - unique_id: "Microphone (Realtek High Defini" (same as friendly name).
+bool GetInputDeviceNamesWinXP(media::AudioDeviceNames* device_names);
 bool GetOutputDeviceNamesWinXP(media::AudioDeviceNames* device_names);
 
+// Converts an input device ID generated by |GetInputDeviceNamesWin()| to the
+// corresponding ID by |GetInputDeviceNamesWinXP()|. Returns an empty string on
+// failure.
+// Example input and output:
+// - input ID: "{0.0.1.00000000}.{8db6020f-18e3-4f25-b6f5-7726c9122574}"
+// - output ID: "Microphone (Realtek High Defini"
+std::string ConvertToWinXPInputDeviceId(const std::string& device_id);
+
 // Given a string |controller_id| with the controller ID of an audio device,
 // returns a string containing extra information about the device.
 // If the device is a USB device, the format of the returned string is
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/media/capture/video/win/video_capture_device_factory_win.cc
index 16841257c164d..578577652451a 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/media/capture/video/win/video_capture_device_factory_win.cc
@@ -303,6 +303,16 @@ bool DevicesInfoContainsDeviceId(const DevicesInfo& devices_info,
                         });
 }
 
+bool IsEnclosureLocationSupported() {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
+  return true;
+}
+
 // Returns a non DirectShow descriptor DevicesInfo with the provided name and
 // model.
 DevicesInfo::const_iterator FindNonDirectShowDeviceInfoByNameAndModel(
@@ -752,17 +762,23 @@ void VideoCaptureDeviceFactoryWin::GetDevicesInfo(
     devices_info = GetDevicesInfoDirectShow(devices_info);
   }
 
-  com_thread_.init_com_with_mta(true);
-  com_thread_.Start();
-  com_thread_data_ =
+  if (IsEnclosureLocationSupported()) {
+   com_thread_.init_com_with_mta(true);
+   com_thread_.Start();
+   com_thread_data_ =
       base::MakeRefCounted<VideoCaptureDeviceFactoryWin::ComThreadData>(
           weak_ptr_factory_.GetWeakPtr(), com_thread_.task_runner(),
           base::SingleThreadTaskRunner::GetCurrentDefault());
-  com_thread_.task_runner()->PostTask(
+   com_thread_.task_runner()->PostTask(
       FROM_HERE,
       base::BindOnce(
           &VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP,
           com_thread_data_, std::move(devices_info), std::move(callback)));
+
+  } else {
+    DeviceInfoReady(std::move(devices_info), std::move(callback));
+  }
+
 }
 
 void VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP(
diff --git a/media/cdm/win/media_foundation_cdm_module.cc b/media/cdm/win/media_foundation_cdm_module.cc
index 28fbd5d233a83..963314b8c0452 100644
--- a/media/cdm/win/media_foundation_cdm_module.cc
+++ b/media/cdm/win/media_foundation_cdm_module.cc
@@ -129,6 +129,10 @@ HRESULT MediaFoundationCdmModule::ActivateCdmFactory() {
     return kErrorLoadLibrary;
   }
 
+  // Initialization required to call base::win::ScopedHString::Create();
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Get function pointer to the activation factory.
   using GetActivationFactoryFunc =
       HRESULT(WINAPI*)(_In_ HSTRING activatible_class_id,
diff --git a/media/midi/midi_manager_winrt.cc b/media/midi/midi_manager_winrt.cc
index d5ce6175bffbf..5ee947135e9ee 100644
--- a/media/midi/midi_manager_winrt.cc
+++ b/media/midi/midi_manager_winrt.cc
@@ -822,6 +822,17 @@ void MidiManagerWinrt::InitializeOnComRunner() {
 
   DCHECK(service()->task_service()->IsOnTaskRunner(kComTaskRunner));
 
+  bool preload_success = base::win::ResolveCoreWinRTDelayload() &&
+                         ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!preload_success) {
+    service()->task_service()->PostBoundTask(
+        kDefaultTaskRunner,
+        base::BindOnce(&MidiManagerWinrt::CompleteInitialization,
+                       base::Unretained(this), Result::INITIALIZATION_ERROR));
+    return;
+  }
+
   port_manager_in_ = std::make_unique<MidiInPortManager>(this);
   port_manager_out_ = std::make_unique<MidiOutPortManager>(this);
 
diff --git a/media/renderers/win/media_foundation_protection_manager.cc b/media/renderers/win/media_foundation_protection_manager.cc
index cd4b85d979afa..cd27c6f07fd86 100644
--- a/media/renderers/win/media_foundation_protection_manager.cc
+++ b/media/renderers/win/media_foundation_protection_manager.cc
@@ -37,6 +37,9 @@ HRESULT MediaFoundationProtectionManager::RuntimeClassInitialize(
   task_runner_ = std::move(task_runner);
   waiting_cb_ = std::move(waiting_cb);
 
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Init an empty |property_set_| as MFMediaEngine could access it via
   // |get_Properties| before we populate it within SetPMPServer.
   base::win::ScopedHString property_set_id = base::win::ScopedHString::Create(
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
index da19df4f20b5d..ba05f58ae6762 100644
--- a/mojo/core/embedder/embedder.cc
+++ b/mojo/core/embedder/embedder.cc
@@ -28,6 +28,10 @@
 #include "mojo/core/node_controller.h"
 #include "mojo/public/c/system/thunks.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif // BUILDFLAG(IS_WIN)
+
 #if !BUILDFLAG(IS_NACL)
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
 #include "mojo/core/channel_linux.h"
@@ -86,7 +90,20 @@ void InitFeatures() {
 }
 
 void EnableMojoIpcz() {
-  g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+#if BUILDFLAG(IS_WIN)
+  // TODO(https://crbug.com/1299283): Sandboxed processes on Windows versions
+  // older than 8.1 require some extra (not yet implemented... err... never implemented) setup for ipcz to
+  // work properly. This is omitted for early experimentation.
+  const bool kIsIpczSupported =
+      base::win::GetVersion() >= base::win::Version::WIN8_1;
+#else
+  const bool kIsIpczSupported = true;
+#endif
+  if (kIsIpczSupported) {
+    g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+  }
+  else
+    g_mojo_ipcz_enabled.store(false, std::memory_order_release);
 }
 
 void Init(const Configuration& configuration) {
diff --git a/net/proxy_resolution/win/winhttp_status.h b/net/proxy_resolution/win/winhttp_status.h
index ae5f9ee08ba6a..975d714dab343 100644
--- a/net/proxy_resolution/win/winhttp_status.h
+++ b/net/proxy_resolution/win/winhttp_status.h
@@ -19,6 +19,9 @@ enum class WinHttpStatus {
   // Aborted by caller.
   kAborted,
 
+  // WinHttp binary failed to load.
+  kFunctionsNotLoaded,
+
   // WinHttpOpen() API failed.
   kWinHttpOpenFailed,
 
diff --git a/net/socket/ssl_client_socket_impl.cc b/net/socket/ssl_client_socket_impl.cc
index eeb27239bb883..f00690af09775 100644
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -298,7 +298,8 @@ class SSLClientSocketImpl::SSLContext {
     SSL_CTX_sess_set_new_cb(ssl_ctx_.get(), NewSessionCallback);
     SSL_CTX_set_timeout(ssl_ctx_.get(), 1 * 60 * 60 /* one hour */);
 
-    SSL_CTX_set_grease_enabled(ssl_ctx_.get(), 1);
+	int grease_mode = !base::CommandLine::ForCurrentProcess()->HasSwitch("disable-grease-tls");
+    SSL_CTX_set_grease_enabled(ssl_ctx_.get(), grease_mode);
 
     // Deduplicate all certificates minted from the SSL_CTX in memory.
     SSL_CTX_set0_buffer_pool(ssl_ctx_.get(), x509_util::GetBufferPool());
diff --git a/sandbox/policy/win/sandbox_warmup.cc b/sandbox/policy/win/sandbox_warmup.cc
index 1c5142a49ceb7..fa36708b609a6 100644
--- a/sandbox/policy/win/sandbox_warmup.cc
+++ b/sandbox/policy/win/sandbox_warmup.cc
@@ -18,48 +18,16 @@
 #include <NTSecAPI.h>
 #undef SystemFunction036
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace sandbox::policy {
 
-namespace {
-
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
-}  // namespace
-
 void WarmupRandomnessInfrastructure() {
   BYTE data[1];
-
-  if (base::FeatureList::IsEnabled(
-          sandbox::policy::features::kWinSboxWarmupProcessPrng)) {
-    // TODO(crbug.com/74242) Call a warmup function exposed by boringssl.
-    static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-    BOOL success = process_prng_fn(data, sizeof(data));
-    // ProcessPrng is documented to always return TRUE.
-    CHECK(success);
-  } else {
     // This loads advapi!SystemFunction036 which is forwarded to
     // cryptbase!SystemFunction036. This allows boringsll and Chrome to call
     // RtlGenRandom from within the sandbox. This has the unfortunate side
     // effect of opening a handle to \\Device\KsecDD which we will later close
     // in processes that do not need this.
     RtlGenRandom(data, sizeof(data));
-  }
 }
 
 }  // namespace sandbox::policy
diff --git a/sandbox/policy/win/sandbox_win.cc b/sandbox/policy/win/sandbox_win.cc
index 714422bd2d088..3780b5ab6033e 100644
--- a/sandbox/policy/win/sandbox_win.cc
+++ b/sandbox/policy/win/sandbox_win.cc
@@ -63,6 +63,7 @@
 #include "sandbox/win/src/app_container.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace sandbox {
 namespace policy {
@@ -180,16 +181,19 @@ bool AddWindowsFontsDir(TargetConfig* config) {
     return false;
   }
 
-  ResultCode result = config->AllowFileAccess(FileSemantics::kAllowReadonly,
-                                              directory.value().c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
-  std::wstring directory_str = directory.value() + L"\\*";
-  result = config->AllowFileAccess(FileSemantics::kAllowReadonly,
-                                   directory_str.c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
+  if (gfx::win::ShouldUseDirectWrite()) {
+	  ResultCode result =
+		  config->AllowFileAccess(FileSemantics::kAllowReadonly,
+						  directory.value().c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+
+	  std::wstring directory_str = directory.value() + L"\\*";
+	  result = config->AllowFileAccess(FileSemantics::kAllowReadonly,
+							   directory_str.c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+  }
 
   return true;
 }
@@ -257,6 +261,7 @@ std::wstring PrependWindowsSessionPath(const wchar_t* object) {
       {L"\\Sessions\\", base::NumberToWString(s_session_id), object});
 }
 
+
 // Adds the generic config rules to a sandbox TargetConfig.
 ResultCode AddGenericConfig(sandbox::TargetConfig* config) {
   DCHECK(!config->IsConfigured());
@@ -324,7 +329,9 @@ ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
 
   config->SetLockdownDefaultDacl();
 
-  result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  // Win8+ adds a device DeviceApi that we don't need.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
   if (result != SBOX_ALL_OK)
     return result;
 
@@ -582,6 +589,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
       MITIGATION_IMAGE_LOAD_NO_REMOTE | MITIGATION_IMAGE_LOAD_NO_LOW_LABEL |
       MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION | MITIGATION_KTM_COMPONENT;
 
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      mitigations &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
   // CET is enabled with the CETCOMPAT bit on chrome.exe so must be
   // disabled for processes we know are not compatible.
   if (!delegate->CetCompatible())
@@ -624,10 +637,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
         return result;
       }
     }
-    result = SandboxWin::AddWin32kLockdownPolicy(config);
-    if (result != SBOX_ALL_OK) {
-      return result;
-    }
+  if (gfx::win::ShouldUseDirectWrite()) {
+     result = SandboxWin::AddWin32kLockdownPolicy(config);
+     if (result != SBOX_ALL_OK) {
+       return result;
+     }
+  }
   }
 
   if (!delegate->DisableDefaultPolicy()) {
@@ -730,12 +745,18 @@ ResultCode LaunchWithoutSandbox(
   // on process shutdown, in which case TerminateProcess can fail. See
   // https://crbug.com/820996.
   if (delegate->ShouldUnsandboxedRunInJob()) {
+    BOOL in_job = true;
+    // Prior to Windows 8 nested jobs aren't possible.
+    if (base::win::GetVersion() >= base::win::Version::WIN8 ||
+        (::IsProcessInJob(::GetCurrentProcess(), nullptr, &in_job) &&
+         !in_job)) {
     static base::NoDestructor<base::win::ScopedHandle> job_object(
         CreateUnsandboxedJob());
     if (!job_object->is_valid()) {
       return SBOX_ERROR_CANNOT_INIT_JOB;
     }
     options.job_handle = job_object->get();
+    }
   }
 
   // Chromium binaries are marked as CET Compatible but some processes
@@ -823,6 +844,9 @@ ResultCode SandboxWin::AddAppContainerPolicy(TargetConfig* config,
 // static
 ResultCode SandboxWin::AddWin32kLockdownPolicy(TargetConfig* config) {
   DCHECK(!config->IsConfigured());
+  // Win32k Lockdown is supported on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return SBOX_ALL_OK;
   MitigationFlags flags = config->GetProcessMitigations();
   // Check not enabling twice. Should not happen.
   DCHECK_EQ(0U, flags & MITIGATION_WIN32K_DISABLE);
diff --git a/sandbox/win/src/app_container_base.cc b/sandbox/win/src/app_container_base.cc
index 8fd0b01040c31..5f32fcc4eb818 100644
--- a/sandbox/win/src/app_container_base.cc
+++ b/sandbox/win/src/app_container_base.cc
@@ -20,6 +20,18 @@ namespace sandbox {
 
 namespace {
 
+typedef decltype(::CreateAppContainerProfile) CreateAppContainerProfileFunc;
+
+typedef decltype(::DeriveAppContainerSidFromAppContainerName)
+    DeriveAppContainerSidFromAppContainerNameFunc;
+
+typedef decltype(::DeleteAppContainerProfile) DeleteAppContainerProfileFunc;
+
+typedef decltype(::GetAppContainerFolderPath) GetAppContainerFolderPathFunc;
+
+typedef decltype(
+    ::GetAppContainerRegistryLocation) GetAppContainerRegistryLocationFunc;
+
 struct FreeSidDeleter {
   inline void operator()(void* ptr) const { ::FreeSid(ptr); }
 };
@@ -30,8 +42,14 @@ struct FreeSidDeleter {
 AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
                                                   const wchar_t* display_name,
                                                   const wchar_t* description) {
-  PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::CreateAppContainerProfile(
+  static auto create_app_container_profile =
+      reinterpret_cast<CreateAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "CreateAppContainerProfile"));
+  if (!create_app_container_profile)
+    return nullptr;
+
+ PSID package_sid_ptr = nullptr;
+  HRESULT hr = create_app_container_profile(
       package_name, display_name, description, nullptr, 0, &package_sid_ptr);
   if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
     return Open(package_name);
@@ -47,9 +65,15 @@ AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
 
 // static
 AppContainerBase* AppContainerBase::Open(const wchar_t* package_name) {
+  static auto derive_app_container_sid =
+      reinterpret_cast<DeriveAppContainerSidFromAppContainerNameFunc*>(
+          GetProcAddress(GetModuleHandle(L"userenv"),
+                         "DeriveAppContainerSidFromAppContainerName"));
+  if (!derive_app_container_sid)
+    return nullptr;
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::DeriveAppContainerSidFromAppContainerName(package_name,
-                                                           &package_sid_ptr);
+  HRESULT hr = derive_app_container_sid(package_name, &package_sid_ptr);
   if (FAILED(hr))
     return nullptr;
 
@@ -71,7 +95,13 @@ AppContainerBase* AppContainerBase::CreateLowbox(const wchar_t* sid) {
 
 // static
 bool AppContainerBase::Delete(const wchar_t* package_name) {
-  return SUCCEEDED(::DeleteAppContainerProfile(package_name));
+  static auto delete_app_container_profile =
+      reinterpret_cast<DeleteAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "DeleteAppContainerProfile"));
+  if (!delete_app_container_profile)
+    return false;
+
+  return SUCCEEDED(delete_app_container_profile(package_name));
 }
 
 AppContainerBase::AppContainerBase(base::win::Sid& package_sid,
diff --git a/sandbox/win/src/broker_services.cc b/sandbox/win/src/broker_services.cc
index 08e1f13c4501e..1f391aa0069e9 100644
--- a/sandbox/win/src/broker_services.cc
+++ b/sandbox/win/src/broker_services.cc
@@ -454,7 +454,11 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   if (container)
     startup_info->SetAppContainer(container);
 
-  startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  // On Win10, jobs are associated via startup_info.
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      policy_base->HasJob()) {
+    startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  }
 
   if (!startup_info->BuildStartupInformation())
     return SBOX_ERROR_PROC_THREAD_ATTRIBUTES;
diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index a522652988a63..638dcd0c5513e 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -11,6 +11,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 
 namespace sandbox {
@@ -150,8 +151,11 @@ bool HandleCloserAgent::CloseHandles() {
     return true;
 
   std::optional<ProcessHandleMap> handle_map = GetCurrentProcessHandles();
-  if (!handle_map)
-    return false;
+  // Fallback for pre-Windows 8.1.
+  if (!handle_map) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN8_1);
+    handle_map = GetCurrentProcessHandlesWin7();
+  }
 
   for (const HandleMap::value_type& handle_to_close : handles_to_close_) {
     ProcessHandleMap::iterator result = handle_map->find(handle_to_close.first);
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index ee6c56e762753..ad04012dd4293 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -19,6 +19,7 @@
 #include "base/rand_util.h"
 #include "base/scoped_native_library.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
@@ -424,7 +425,39 @@ InterceptionManager::PatchClientFunctions(DllInterceptionData* thunks,
   patch.dll_data.num_thunks = 0;
   patch.dll_data.used_bytes = offsetof(DllInterceptionData, thunks);
 
-  ServiceResolverThunk thunk(child_->Process(), /*relaxed=*/true);
+  std::unique_ptr<ServiceResolverThunk> thunk;
+#if defined(_WIN64)
+  thunk = std::make_unique<ServiceResolverThunk>(child_->Process(), true);
+#else
+  DWORD base_code = 0;
+  DWORD bytes_read = 0;
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  base::win::Version real_os_version = os_info->Kernel32Version();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (real_os_version >= base::win::Version::WIN10)
+      thunk.reset(new Wow64W10ResolverThunk(child_->Process(), true));
+    else if (real_os_version >= base::win::Version::WIN8)
+      thunk.reset(new Wow64W8ResolverThunk(child_->Process(), true));
+    else {
+      thunk.reset(new Wow64ResolverThunk(child_->Process(), true));
+	  if(!::ReadProcessMemory(child_->Process(), ntdll_base, &base_code,
+			sizeof(base_code), &bytes_read)) {
+				if(::GetLastError() == ERROR_PARTIAL_COPY) {
+					::ResumeThread(child_->MainThread());
+					while(!::ReadProcessMemory(child_->Process(), ntdll_base, &base_code,
+						sizeof(base_code), &bytes_read)) {
+						;
+					}
+					::SuspendThread(child_->MainThread());
+					}
+			}
+	}
+  } else if (real_os_version >= base::win::Version::WIN8) {
+    thunk.reset(new Win8ResolverThunk(child_->Process(), true));
+  } else {
+    thunk.reset(new ServiceResolverThunk(child_->Process(), true));
+  }
+#endif
 
   patch.originals = {};
   for (auto interception : interceptions_) {
@@ -435,7 +468,7 @@ InterceptionManager::PatchClientFunctions(DllInterceptionData* thunks,
     if (INTERCEPTION_SERVICE_CALL != interception.type)
       return base::unexpected(SBOX_ERROR_BAD_PARAMS);
 
-    NTSTATUS ret = thunk.Setup(
+    NTSTATUS ret = thunk->Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
         &thunks->thunks[patch.dll_data.num_thunks],
diff --git a/sandbox/win/src/job.cc b/sandbox/win/src/job.cc
index 1bb579f1d1061..7f7d15f339c23 100644
--- a/sandbox/win/src/job.cc
+++ b/sandbox/win/src/job.cc
@@ -9,21 +9,24 @@
 #include <stddef.h>
 #include <utility>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/restricted_token.h"
 
 namespace sandbox {
 
-Job::Job() = default;
-Job::~Job() = default;
+Job::Job() : job_handle_(nullptr) {}
+
+Job::~Job() {}
 
 DWORD Job::Init(JobLevel security_level,
                 DWORD ui_exceptions,
                 size_t memory_limit) {
-  if (job_handle_.is_valid())
+  if (job_handle_.IsValid())
     return ERROR_ALREADY_INITIALIZED;
 
-  job_handle_.Set(::CreateJobObject(nullptr, nullptr));
-  if (!job_handle_.is_valid())
+  job_handle_.Set(::CreateJobObject(nullptr,  // No security attribute
+                                    nullptr));
+  if (!job_handle_.IsValid())
     return ::GetLastError();
 
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
@@ -63,6 +66,9 @@ DWORD Job::Init(JobLevel security_level,
       jeli.BasicLimitInformation.LimitFlags |=
           JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
       break;
+    }
+	case JobLevel::kNone: {
+      return ERROR_BAD_ARGUMENTS;
     }
   }
 
@@ -83,20 +89,42 @@ DWORD Job::Init(JobLevel security_level,
 }
 
 bool Job::IsValid() {
-  return job_handle_.is_valid();
+  return job_handle_.IsValid();
 }
 
 HANDLE Job::GetHandle() {
-  return job_handle_.get();
+  return job_handle_.Get();
+}
+
+DWORD Job::UserHandleGrantAccess(HANDLE handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::UserHandleGrantAccess(handle, job_handle_.Get(),
+                               true)) {  // Access allowed.
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+DWORD Job::AssignProcessToJob(HANDLE process_handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::AssignProcessToJobObject(job_handle_.Get(), process_handle))
+    return ::GetLastError();
+
+  return ERROR_SUCCESS;
 }
 
 DWORD Job::SetActiveProcessLimit(DWORD processes) {
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
 
-  if (!job_handle_.is_valid())
+  if (!job_handle_.IsValid())
     return ERROR_NO_DATA;
 
-  if (!::QueryInformationJobObject(job_handle_.get(),
+  if (!::QueryInformationJobObject(job_handle_.Get(),
                                    JobObjectExtendedLimitInformation, &jeli,
                                    sizeof(jeli), nullptr)) {
     return ::GetLastError();
@@ -104,7 +132,7 @@ DWORD Job::SetActiveProcessLimit(DWORD processes) {
   jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   jeli.BasicLimitInformation.ActiveProcessLimit = processes;
 
-  if (!::SetInformationJobObject(job_handle_.get(),
+  if (!::SetInformationJobObject(job_handle_.Get(),
                                  JobObjectExtendedLimitInformation, &jeli,
                                  sizeof(jeli))) {
     return ::GetLastError();
diff --git a/sandbox/win/src/job.h b/sandbox/win/src/job.h
index 31037e1b7aff7..a148179e108a5 100644
--- a/sandbox/win/src/job.h
+++ b/sandbox/win/src/job.h
@@ -15,7 +15,8 @@ enum class JobLevel;
 // Handles the creation of job objects based on a security profile.
 // Sample usage:
 //   Job job;
-//   job.Init(JobLevel::kLockdown, 0, 0);
+//   job.Init(JobLevel::kLockdown, nullptr);  //no job name
+//   job.AssignProcessToJob(process_handle);
 class Job {
  public:
   Job();
@@ -27,6 +28,7 @@ class Job {
 
   // Initializes and creates the job object. The security of the job is based
   // on the security_level parameter.
+  // job_name can be nullptr if the job is unnamed.
   // If the chosen profile has too many ui restrictions, you can disable some
   // by specifying them in the ui_exceptions parameters.
   // If the function succeeds, the return value is ERROR_SUCCESS. If the
@@ -34,6 +36,19 @@ class Job {
   // the error.
   DWORD Init(JobLevel security_level, DWORD ui_exceptions, size_t memory_limit);
 
+  // Assigns the process referenced by process_handle to the job.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD AssignProcessToJob(HANDLE process_handle);
+
+  // Grants access to "handle" to the job. All processes in the job can
+  // subsequently recognize and use the handle.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD UserHandleGrantAccess(HANDLE handle);
+
   // True if the job has been initialized and has a valid handle.
   bool IsValid();
 
diff --git a/sandbox/win/src/nt_internals.h b/sandbox/win/src/nt_internals.h
index 72d96b96f4fd4..c3dedf262abcf 100644
--- a/sandbox/win/src/nt_internals.h
+++ b/sandbox/win/src/nt_internals.h
@@ -162,7 +162,13 @@ typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN PVOID ThreadInformation,
     IN ULONG ThreadInformationLength);
 
+typedef struct _PROCESS_ACCESS_TOKEN {
+  HANDLE token;
+  HANDLE thread;
+} PROCESS_ACCESS_TOKEN;
+
 // Partial definition only for values not in PROCESS_INFO_CLASS.
+constexpr auto ProcessInformationAccessToken = static_cast<PROCESSINFOCLASS>(9);
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
 constexpr auto ProcessHandleTable = static_cast<PROCESSINFOCLASS>(58);
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 2b870c0ebd409..498d207d4249c 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -24,6 +24,7 @@
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/win_utils.h"
+#include "ui/gfx/win/direct_write.h"
 
 // These are missing in 10.0.19551.0 but are in 10.0.19041.0 and 10.0.20226.0.
 #ifndef PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_STRICT_MODE
@@ -44,22 +45,39 @@ namespace sandbox {
 
 namespace {
 
+// API defined in libloaderapi.h >= Win8. Also available in Vista/7 starting with KB2533623.
+// Known to be buggy on Vista, but not known to affect Chromium.
+using SetDefaultDllDirectoriesFunction = decltype(&SetDefaultDllDirectories);
+
+// APIs defined in processthreadsapi.h >= Win8.
+using SetProcessMitigationPolicyFunction =
+    decltype(&SetProcessMitigationPolicy);
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+using SetThreadInformationFunction = decltype(&SetThreadInformation);
+
 // Returns a two-element array of mitigation flags supported on this machine.
 const ULONG64* GetSupportedMitigations() {
   static ULONG64 mitigations[2] = {};
 
   // This static variable will only be initialized once.
   if (!mitigations[0] && !mitigations[1]) {
-    // NOTE: the two-element-sized input array is only supported on >= Win10
-    // RS2. If an earlier version, the second element will be left 0.
-    size_t mits_size =
-        (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
-            ? (sizeof(mitigations[0]) * 2)
-            : sizeof(mitigations[0]);
-    if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                      ProcessMitigationOptionsMask,
-                                      &mitigations, mits_size)) {
-      NOTREACHED();
+    GetProcessMitigationPolicyFunction get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+            ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (get_process_mitigation_policy) {
+      // NOTE: the two-element-sized input array is only supported on >= Win10
+      // RS2.
+      //       If an earlier version, the second element will be left 0.
+      size_t mits_size =
+          (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
+              ? (sizeof(mitigations[0]) * 2)
+              : sizeof(mitigations[0]);
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessMitigationOptionsMask,
+                                         &mitigations, mits_size)) {
+        NOTREACHED();
+      }
     }
   }
 
@@ -83,7 +101,14 @@ bool IsRunning32bitEmulatedOnArm64() {
 bool SetProcessMitigationPolicyInternal(PROCESS_MITIGATION_POLICY policy,
                                         PVOID lpBuffer,
                                         SIZE_T dwLength) {
-  PCHECK(::SetProcessMitigationPolicy(policy, lpBuffer, dwLength))
+  HMODULE module = ::GetModuleHandleA("kernel32.dll");
+  SetProcessMitigationPolicyFunction set_process_mitigation_policy_function =
+      reinterpret_cast<SetProcessMitigationPolicyFunction>(
+          ::GetProcAddress(module, "SetProcessMitigationPolicy"));
+  if (!set_process_mitigation_policy_function)
+    return false;
+
+  PCHECK(set_process_mitigation_policy_function(policy, lpBuffer, dwLength))
       << "SetProcessMitigationPolicy failed with Policy: " << policy;
 
   return true;
@@ -99,21 +124,35 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
 
   base::win::Version version = base::win::GetVersion();
 
-  if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+  #if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite())
+    flags &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_WIN32K_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+ if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+    HMODULE module = ::GetModuleHandleA("kernel32.dll");
+    SetDefaultDllDirectoriesFunction set_default_dll_directories =
+        reinterpret_cast<SetDefaultDllDirectoriesFunction>(
+            ::GetProcAddress(module, "SetDefaultDllDirectories"));
+
+    // Check for SetDefaultDllDirectories since it requires KB2533623.
+    if (set_default_dll_directories) {
 #if defined(COMPONENT_BUILD)
-    const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
+      const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
 #else
-    // In a non-component build, all DLLs will be loaded manually, or via
-    // manifest definition, so these flags can be stronger. This prevents DLL
-    // planting in the application directory.
-    const DWORD directory_flags =
-        LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
+      // In a non-component build, all DLLs will be loaded manually, or via
+      // manifest definition, so these flags can be stronger. This prevents DLL
+      // planting in the application directory.
+      const DWORD directory_flags =
+          LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
 #endif
-    if (!::SetDefaultDllDirectories(directory_flags)) {
-      return false;
-    }
+      if (!set_default_dll_directories(directory_flags)) {
+        return false;
+      }
 
-    applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+      applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+    }
   }
 
   // Set the heap to terminate on corruption
@@ -156,6 +195,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   }
 #endif
 
+  // This is all we can do in Win7 and below.
+  if (version < base::win::Version::WIN8)
+    return true;
+
   // Enable ASLR policies.
   if (flags & MITIGATION_RELOCATE_IMAGE) {
     PROCESS_MITIGATION_ASLR_POLICY policy = {};
@@ -219,6 +262,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_EXTENSION_POINT_DISABLE;
   }
 
+  if (version < base::win::Version::WIN8_1)
+    return true;
+
   // Enable dynamic code policies.
   if (!IsRunning32bitEmulatedOnArm64() &&
       (flags & MITIGATION_DYNAMIC_CODE_DISABLE)) {
@@ -235,6 +281,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
   }
 
+  if (version < base::win::Version::WIN10)
+    return true;
+
   // Enable font policies.
   if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
     PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
@@ -356,9 +405,20 @@ bool ApplyMitigationsToCurrentThread(MitigationFlags flags) {
   if (flags & MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD) {
     DWORD thread_policy = THREAD_DYNAMIC_CODE_ALLOW;
 
+   // NOTE: SetThreadInformation API only exists on >= Win8.  Dynamically
+    //       get function handle.
+    base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+    if (!dll.is_valid())
+      return false;
+    SetThreadInformationFunction set_thread_info_function =
+        reinterpret_cast<SetThreadInformationFunction>(
+            dll.GetFunctionPointer("SetThreadInformation"));
+    if (!set_thread_info_function)
+      return false;
+
     // NOTE: Must use the pseudo-handle here, a thread HANDLE won't work.
-    if (!::SetThreadInformation(::GetCurrentThread(), ThreadDynamicCodePolicy,
-                                &thread_policy, sizeof(thread_policy))) {
+    if (!set_thread_info_function(::GetCurrentThread(), ThreadDynamicCodePolicy,
+                                  &thread_policy, sizeof(thread_policy))) {
       return false;
     }
   }
@@ -379,8 +439,14 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
   *policy_value_1 = 0;
   *policy_value_2 = 0;
 
-#if defined(_WIN64) || defined(_M_IX86)
+#if defined(_WIN64)
   *size = sizeof(*policy_flags);
+#elif defined(_M_IX86)
+  // A 64-bit flags attribute is illegal on 32-bit Win 7.
+  if (version < base::win::Version::WIN8)
+    *size = sizeof(DWORD);
+  else
+    *size = sizeof(*policy_flags);
 #else
 #error This platform is not supported.
 #endif
@@ -398,53 +464,79 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
     *policy_value_1 |= PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE;
 #endif
 
-  if (flags & MITIGATION_RELOCATE_IMAGE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
-    if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+  // Win 7
+  if (version < base::win::Version::WIN8)
+    return;
+
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      *policy_value_1 &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+  // Everything >= Win8, do not return before the end of the function where
+  // the final policy bitmap is sanity checked against what is supported on this
+  // machine.  The API required to do so is only available since Win8.
+
+  // Mitigations >= Win8:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8) {
+    if (flags & MITIGATION_RELOCATE_IMAGE) {
       *policy_value_1 |=
-          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
+      if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+        *policy_value_1 |=
+            PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+      }
     }
-  }
 
-  if (flags & MITIGATION_HEAP_TERMINATE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HEAP_TERMINATE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_BOTTOM_UP_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_BOTTOM_UP_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_WIN32K_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_WIN32K_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+  // Mitigations >= Win8.1:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8_1) {
+    if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+  // Mitigations >= Win10:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN10) {
+    if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+    }
   }
 
   // Mitigations >= Win10 TH2:
@@ -557,6 +649,15 @@ void ConvertProcessMitigationsToComponentFilter(MitigationFlags flags,
 }
 
 MitigationFlags FilterPostStartupProcessMitigations(MitigationFlags flags) {
+  base::win::Version version = base::win::GetVersion();
+
+  // Windows 7.
+  if (version < base::win::Version::WIN8) {
+    return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER |
+                    MITIGATION_HEAP_TERMINATE);
+  }
+
+  // Windows 8 and above.
   return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER);
 }
 
diff --git a/sandbox/win/src/process_mitigations_unittest.cc b/sandbox/win/src/process_mitigations_unittest.cc
index 47eab9bbcd6df..54ce6d20df760 100644
--- a/sandbox/win/src/process_mitigations_unittest.cc
+++ b/sandbox/win/src/process_mitigations_unittest.cc
@@ -51,6 +51,22 @@ typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_2 {
 
 namespace {
 
+//------------------------------------------------------------------------------
+// Internal Defines & Functions
+//------------------------------------------------------------------------------
+
+// API defined in winbase.h.
+using GetProcessDEPPolicyFunction = decltype(&GetProcessDEPPolicy);
+
+// API defined in processthreadsapi.h.
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+GetProcessMitigationPolicyFunction get_process_mitigation_policy;
+
+// APIs defined in wingdi.h.
+using AddFontMemResourceExFunction = decltype(&AddFontMemResourceEx);
+using RemoveFontMemResourceExFunction = decltype(&RemoveFontMemResourceEx);
+
 //------------------------------------------------------------------------------
 // NonSystemFont test helper function.
 //
@@ -104,6 +120,13 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
   if (!test)
     return SBOX_TEST_INVALID_PARAMETER;
 
+  get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
+
   switch (test) {
     //--------------------------------------------------
     // MITIGATION_DEP
@@ -113,8 +136,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
 #if !defined(_WIN64)
       // DEP - always enabled on 64-bit.
       PROCESS_MITIGATION_DEP_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(), ProcessDEPPolicy,
-                                        &policy, sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDEPPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.Enable || !policy.Permanent)
@@ -128,9 +152,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_ASLR): {
       PROCESS_MITIGATION_ASLR_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessASLRPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessASLRPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.EnableForceRelocateImages || !policy.DisallowStrippedImages)
@@ -143,9 +167,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_STRICTHANDLE): {
       PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessStrictHandleCheckPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessStrictHandleCheckPolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.RaiseExceptionOnInvalidHandleReference ||
@@ -160,9 +184,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_WIN32K): {
       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessSystemCallDisablePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessSystemCallDisablePolicy,
+                                         &policy, sizeof(policy)))  {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisallowWin32kSystemCalls)
@@ -179,7 +203,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_EXTENSIONPOINT): {
       PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessExtensionPointDisablePolicy,
                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -194,7 +218,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODE): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -209,7 +233,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_NONSYSFONT): {
       PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessFontDisablePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -224,7 +248,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_MSSIGNED): {
       PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessSignaturePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -239,7 +263,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOREMOTE): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -254,7 +278,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOLOW): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -269,7 +293,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODEOPTOUT): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -284,7 +308,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADPREFERSYS32): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -309,7 +333,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDISABLED): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -325,7 +349,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDYNAMICAPIS): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -348,7 +372,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETSTRICT): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -389,7 +413,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     case (TESTPOLICY_PREANDPOSTSTARTUP): {
       // Both policies should be set now.
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -517,11 +541,18 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
       return SBOX_TEST_SUCCEEDED;
     }
   }
+
+  auto get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
   // Process failed to be created.
   // Note: GetLastError from CreateProcess returns 5, "ERROR_ACCESS_DENIED".
   // Validate the NoChildProcessCreation policy is applied.
   PROCESS_MITIGATION_CHILD_PROCESS_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+  if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                     ProcessChildProcessPolicy, &policy,
                                     sizeof(policy))) {
     return SBOX_TEST_NOT_FOUND;
@@ -892,10 +923,14 @@ TEST(ProcessMitigationsTest, CetDisablePolicy) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -932,10 +967,14 @@ TEST(ProcessMitigationsTest, CetAllowDynamicApis) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -970,10 +1009,14 @@ TEST(ProcessMitigationsTest, CetStrictMode) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
diff --git a/sandbox/win/src/restricted_token.cc b/sandbox/win/src/restricted_token.cc
index dd6710c471325..23197af98b2a3 100644
--- a/sandbox/win/src/restricted_token.cc
+++ b/sandbox/win/src/restricted_token.cc
@@ -16,6 +16,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/win/access_token.h"
 #include "base/win/security_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 
 namespace sandbox {
@@ -184,7 +185,7 @@ std::optional<base::win::AccessToken> RestrictedToken::CreateRestricted(
     return std::nullopt;
   }
 
-  if (lockdown_default_dacl_) {
+  if (lockdown_default_dacl_ && base::win::GetVersion() >= base::win::Version::VISTA) {
     // Don't add Restricted sid and also remove logon sid access.
     std::optional<base::win::Sid> logon_sid = new_token->LogonId();
     if (logon_sid.has_value()) {
@@ -217,7 +218,7 @@ std::optional<base::win::AccessToken> RestrictedToken::CreateRestricted(
     return std::nullopt;
   }
 
-  if (integrity_rid_.has_value()) {
+  if (integrity_rid_.has_value() && base::win::GetVersion() >= base::win::Version::VISTA) {
     if (!new_token->SetIntegrityLevel(*integrity_rid_)) {
       return std::nullopt;
     }
diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
index 9cefa097e1439..ec8d3b9f48ecf 100644
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -11,8 +11,10 @@
 #include "base/check.h"
 #include "base/notreached.h"
 #include "base/win/access_token.h"
+#include "base/win/scoped_handle.h"
 #include "base/win/security_descriptor.h"
 #include "sandbox/win/src/acl.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/security_level.h"
diff --git a/sandbox/win/src/sandbox_policy_diagnostic.cc b/sandbox/win/src/sandbox_policy_diagnostic.cc
index b6a5874adab7f..96a1ffe0e23f2 100644
--- a/sandbox/win/src/sandbox_policy_diagnostic.cc
+++ b/sandbox/win/src/sandbox_policy_diagnostic.cc
@@ -83,6 +83,8 @@ std::string GetJobLevelInEnglish(JobLevel job) {
       return "Interactive";
     case JobLevel::kUnprotected:
       return "Unprotected";
+    case JobLevel::kNone:
+      return "None";
   }
 }
 
diff --git a/sandbox/win/src/security_level.h b/sandbox/win/src/security_level.h
index 288d2baea917c..8c3c6b25ad2b0 100644
--- a/sandbox/win/src/security_level.h
+++ b/sandbox/win/src/security_level.h
@@ -95,6 +95,9 @@ enum TokenLevel {
 //  JobLevel        |General                            |Quota               |
 //                  |restrictions                       |restrictions        |
 // -----------------|---------------------------------- |--------------------|
+// kNone            | No job is assigned to the         | None               |
+//                  | sandboxed process.                |                    |
+// -----------------|---------------------------------- |--------------------|
 // kUnprotected     | None                              | *Kill on Job close.|
 // -----------------|---------------------------------- |--------------------|
 // kInteractive     | *Forbid system-wide changes using |                    |
@@ -120,7 +123,7 @@ enum TokenLevel {
 // In the context of the above table, 'user handles' refers to the handles of
 // windows, bitmaps, menus, etc. Files, treads and registry handles are kernel
 // handles and are not affected by the job level settings.
-enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected };
+enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected,  kNone };
 
 // These flags correspond to various process-level mitigations (eg. ASLR and
 // DEP). Most are implemented via UpdateProcThreadAttribute() plus flags for
diff --git a/sandbox/win/src/service_resolver.h b/sandbox/win/src/service_resolver.h
index dc74bd6e52539..97f828e3feeb0 100644
--- a/sandbox/win/src/service_resolver.h
+++ b/sandbox/win/src/service_resolver.h
@@ -53,23 +53,18 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   size_t GetThunkSize() const override;
 
   // Call this to set up ntdll_base_ which will allow for local patches.
-  void AllowLocalPatches();
+  virtual void AllowLocalPatches();
 
   // Verifies that the function specified by |target_name| in |target_module| is
   // a service and copies the data from that function into |thunk_storage|. If
   // |storage_bytes| is too small, then the method fails.
-  NTSTATUS CopyThunk(const void* target_module,
-                     const char* target_name,
-                     BYTE* thunk_storage,
-                     size_t storage_bytes,
-                     size_t* storage_used);
+  virtual NTSTATUS CopyThunk(const void* target_module,
+                             const char* target_name,
+                             BYTE* thunk_storage,
+                             size_t storage_bytes,
+                             size_t* storage_used);
 
-  // Checks if a target was patched correctly for a jump. This is only for use
-  // in testing in 32-bit builds. Will always return true on 64-bit builds. Set
-  // |thunk_storage| to the same pointer passed to Setup().
-  bool VerifyJumpTargetForTesting(void* thunk_storage) const;
-
- private:
+ protected:
   // The unit test will use this member to allow local patch on a buffer.
   HMODULE ntdll_base_;
 
@@ -87,15 +82,15 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   // Returns true if the code pointer by target_ corresponds to the expected
   // type of function. Saves that code on the first part of the thunk pointed
   // by local_thunk (should be directly accessible from the parent).
-  bool IsFunctionAService(void* local_thunk) const;
+  virtual bool IsFunctionAService(void* local_thunk) const;
 
   // Performs the actual patch of target_.
   // local_thunk must be already fully initialized, and the first part must
   // contain the original code. The real type of this buffer is ServiceFullThunk
   // (yes, private). remote_thunk (real type ServiceFullThunk), must be
   // allocated on the child, and will contain the thunk data, after this call.
-  // Returns the appropriate status code.
-  NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
+  // Returns the apropriate status code.
+  virtual NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
 
   // Provides basically the same functionality as IsFunctionAService but it
   // continues even if it does not recognize the function code. remote_thunk
@@ -107,6 +102,74 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   ULONG relative_jump_;
 };
 
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).
+class Wow64ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64ResolverThunk(const Wow64ResolverThunk&) = delete;
+  Wow64ResolverThunk& operator=(const Wow64ResolverThunk&) = delete;
+
+  ~Wow64ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 8.
+class Wow64W8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W8ResolverThunk(const Wow64W8ResolverThunk&) = delete;
+  Wow64W8ResolverThunk& operator=(const Wow64W8ResolverThunk&) = delete;
+
+  ~Wow64W8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on Windows 8.
+class Win8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Win8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Win8ResolverThunk(const Win8ResolverThunk&) = delete;
+  Win8ResolverThunk& operator=(const Win8ResolverThunk&) = delete;
+
+  ~Win8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 10.
+class Wow64W10ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W10ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W10ResolverThunk(const Wow64W10ResolverThunk&) = delete;
+  Wow64W10ResolverThunk& operator=(const Wow64W10ResolverThunk&) = delete;
+
+  ~Wow64W10ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_SERVICE_RESOLVER_H_
diff --git a/sandbox/win/src/service_resolver_32.cc b/sandbox/win/src/service_resolver_32.cc
index fcf0688800444..30094fab7def2 100644
--- a/sandbox/win/src/service_resolver_32.cc
+++ b/sandbox/win/src/service_resolver_32.cc
@@ -18,16 +18,43 @@ namespace {
 const BYTE kMovEax = 0xB8;
 const BYTE kMovEdx = 0xBA;
 const USHORT kMovEdxEsp = 0xD48B;
+const USHORT kCallPtrEdx = 0x12FF;
 const USHORT kCallEdx = 0xD2FF;
 const BYTE kCallEip = 0xE8;
 const BYTE kRet = 0xC2;
 const BYTE kRet2 = 0xC3;
 const USHORT kJmpEdx = 0xE2FF;
+const USHORT kXorEcx = 0xC933;
+const ULONG kLeaEdx = 0x0424548D;
+const ULONG kCallFs1 = 0xC015FF64;
+const USHORT kCallFs2 = 0;
+const BYTE kCallFs3 = 0;
+const BYTE kAddEsp1 = 0x83;
+const USHORT kAddEsp2 = 0x4C4;
 const BYTE kJmp32 = 0xE9;
 const USHORT kSysenter = 0x340F;
 
-// Service code for 32 bit Windows. Introduced in Windows 8.
-struct ServiceEntry32 {
+// Service code for 32 bit systems.
+// NOTE: on win2003 "call dword ptr [edx]" is "call edx".
+struct ServiceEntry {
+  // This struct contains roughly the following code:
+  // 00 mov     eax,25h
+  // 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
+  // 0a call    dword ptr [edx]
+  // 0c ret     2Ch
+  // 0f nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  BYTE mov_edx;         // = BA
+  ULONG stub;
+  USHORT call_ptr_edx;  // = FF 12
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for 32 bit Windows 8.
+struct ServiceEntryW8 {
   // This struct contains the following code:
   // 00 b825000000      mov     eax,25h
   // 05 e803000000      call    eip+3
@@ -48,13 +75,60 @@ struct ServiceEntry32 {
   USHORT nop;
 };
 
-// Service code for a 32 bit process under Wow64. Introduced in Windows 10.
-// Also used for the patching process.
-struct ServiceEntryWow64 {
+// Service code for a 32 bit process running on a 64 bit os.
+struct Wow64Entry {
+  // This struct may contain one of two versions of code:
+  // 1. For XP, Vista and 2K3:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 c22c00          ret     2Ch
+  //
+  // 2. For Windows 7:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 83c404          add     esp, 4
+  // 15 c22c00          ret     2Ch
+  //
+  // So we base the structure on the bigger one:
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  USHORT xor_ecx;       // = 33 C9
+  ULONG lea_edx;        // = 8D 54 24 04
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE add_esp1;        // = 83             or ret
+  USHORT add_esp2;      // = C4 04          or num_params
+  BYTE ret;             // = C2
+  USHORT num_params;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 8.
+struct Wow64EntryW8 {
+  // 00 b825000000      mov     eax, 25h
+  // 05 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 0b c22c00          ret     2Ch
+  // 0f 90              nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 10.
+struct Wow64EntryW10 {
   // 00 b828000000      mov     eax, 28h
   // 05 bab0d54877      mov     edx, 7748D5B0h
   // 09 ffd2            call    edx
-  // 0c c22800          ret     28h
+  // 0b c22800          ret     28h
   BYTE mov_eax;         // = B8
   ULONG service_id;
   BYTE mov_edx;         // = BA
@@ -62,86 +136,27 @@ struct ServiceEntryWow64 {
   USHORT call_edx;      // = FF D2
   BYTE ret;             // = C2
   USHORT num_params;
-  BYTE nop;
 };
 
 // Make sure that relaxed patching works as expected.
-const size_t kMinServiceSize = offsetof(ServiceEntryWow64, ret);
-// Maximum size of the entry, was the size of the Windows Vista WoW64 entry.
-// Keep this fixed for compatibility reasons.
-const size_t kMaxServiceSize = 24;
-static_assert(sizeof(ServiceEntry32) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntry32) < kMaxServiceSize,
-              "wrong maximum service length");
-static_assert(sizeof(ServiceEntryWow64) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntryWow64) < kMaxServiceSize,
-              "wrong maximum service length");
+const size_t kMinServiceSize = offsetof(ServiceEntry, ret);
+static_assert(sizeof(ServiceEntryW8) >= kMinServiceSize,
+              "wrong service length");
+static_assert(sizeof(Wow64Entry) >= kMinServiceSize, "wrong service length");
+static_assert(sizeof(Wow64EntryW8) >= kMinServiceSize, "wrong service length");
 
 struct ServiceFullThunk {
   union {
-    ServiceEntryWow64 original;
-    // Pad the entry to the maximum size.
-    char dummy[kMaxServiceSize];
+    ServiceEntry original;
+    ServiceEntryW8 original_w8;
+    Wow64Entry wow_64;
+    Wow64EntryW8 wow_64_w8;
   };
   int internal_thunk;  // Dummy member to the beginning of the internal thunk.
 };
 
 #pragma pack(pop)
 
-bool IsWow64Process() {
-  // We don't need to use IsWow64Process2 as this returns the expected result
-  // when running in the ARM64 x86 emulator.
-  BOOL is_wow64 = FALSE;
-  return ::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64;
-}
-
-bool IsFunctionAService32(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntry32 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
-      function_code.call_offset != 3 || kRet != function_code.ret_p ||
-      kMovEdxEsp != function_code.mov_edx_esp ||
-      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-
-  return true;
-}
-
-bool IsFunctionAServiceWow64(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntryWow64 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
-      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-  return true;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -210,14 +225,69 @@ NTSTATUS ServiceResolverThunk::CopyThunk(const void* target_module,
 }
 
 bool ServiceResolverThunk::IsFunctionAService(void* local_thunk) const {
-  static bool is_wow64 = IsWow64Process();
-  return is_wow64 ? IsFunctionAServiceWow64(process_, target_, local_thunk)
-                  : IsFunctionAService32(process_, target_, local_thunk);
+  ServiceEntry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      (kCallPtrEdx != function_code.call_ptr_edx &&
+       kCallEdx != function_code.call_ptr_edx) ||
+      kRet != function_code.ret) {
+    return false;
+  }
+
+  // Find the system call pointer if we don't already have it.
+  if (kCallEdx != function_code.call_ptr_edx) {
+    DWORD ki_system_call;
+    if (!::ReadProcessMemory(process_,
+                             reinterpret_cast<const void*>(function_code.stub),
+                             &ki_system_call, sizeof(ki_system_call), &read)) {
+      return false;
+    }
+
+    if (sizeof(ki_system_call) != read)
+      return false;
+
+    HMODULE module_1, module_2;
+    // last check, call_stub should point to a KiXXSystemCall function on ntdll
+    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                           reinterpret_cast<const wchar_t*>(ki_system_call),
+                           &module_1)) {
+      return false;
+    }
+
+    if (ntdll_base_) {
+      // This path is only taken when running the unit tests. We want to be
+      // able to patch a buffer in memory, so target_ is not inside ntdll.
+      module_2 = ntdll_base_;
+    } else {
+      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                             reinterpret_cast<const wchar_t*>(target_),
+                             &module_2))
+        return false;
+    }
+
+    if (module_1 != module_2)
+      return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
 }
 
 NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
                                             void* remote_thunk) {
-  ServiceEntryWow64 intercepted_code;
+  ServiceEntry intercepted_code;
   size_t bytes_to_write = sizeof(intercepted_code);
   ServiceFullThunk* full_local_thunk =
       reinterpret_cast<ServiceFullThunk*>(local_thunk);
@@ -230,15 +300,15 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   intercepted_code.mov_eax = kMovEax;
   intercepted_code.service_id = full_local_thunk->original.service_id;
   intercepted_code.mov_edx = kMovEdx;
-  intercepted_code.mov_edx_param =
-      reinterpret_cast<ULONG>(&full_remote_thunk->internal_thunk);
-  intercepted_code.call_edx = kJmpEdx;
+  intercepted_code.stub =
+       reinterpret_cast<ULONG>(&full_remote_thunk->internal_thunk);
+  intercepted_code.call_ptr_edx = kJmpEdx;
   bytes_to_write = kMinServiceSize;
 
   if (relative_jump_) {
     intercepted_code.mov_eax = kJmp32;
     intercepted_code.service_id = relative_jump_;
-    bytes_to_write = offsetof(ServiceEntryWow64, mov_edx);
+    bytes_to_write = offsetof(ServiceEntry, mov_edx);
   }
 
   // setup the thunk
@@ -274,7 +344,7 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
 
 bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
                                                 void* remote_thunk) {
-  ServiceEntryWow64 function_code;
+  ServiceEntry function_code;
   SIZE_T read;
   if (!::ReadProcessMemory(process_, target_, &function_code,
                            sizeof(function_code), &read)) {
@@ -310,18 +380,100 @@ bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
   return true;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(
-    void* thunk_storage) const {
-  const size_t kJmp32Size = 5;
-  ServiceEntryWow64* patched = static_cast<ServiceEntryWow64*>(target_);
-  if (kJmp32 != patched->mov_eax) {
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64Entry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kXorEcx != function_code.xor_ecx ||
+      kLeaEdx != function_code.lea_edx || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3) {
+    return false;
+  }
+
+  if ((kAddEsp1 == function_code.add_esp1 &&
+       kAddEsp2 == function_code.add_esp2 && kRet == function_code.ret) ||
+      kRet == function_code.add_esp1) {
+    // Save the verified code
+    memcpy(local_thunk, &function_code, sizeof(function_code));
+    return true;
+  }
+
+  return false;
+}
+
+bool Wow64W8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
     return false;
   }
 
-  ULONG source_addr = reinterpret_cast<ULONG>(target_);
-  ULONG target_addr = reinterpret_cast<ULONG>(thunk_storage);
-  return target_addr + kMaxServiceSize - kJmp32Size - source_addr ==
-         patched->service_id;
+if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3 || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
+}
+
+bool Win8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  ServiceEntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
+      function_code.call_offset != 3 || kRet != function_code.ret_p ||
+      kMovEdxEsp != function_code.mov_edx_esp ||
+      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
+}
+
+bool Wow64W10ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW10 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_64.cc b/sandbox/win/src/service_resolver_64.cc
index 33b91d04ad114..38e451da143a3 100644
--- a/sandbox/win/src/service_resolver_64.cc
+++ b/sandbox/win/src/service_resolver_64.cc
@@ -282,8 +282,4 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   return STATUS_SUCCESS;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(void*) const {
-  return true;
-}
-
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_unittest.cc b/sandbox/win/src/service_resolver_unittest.cc
index aa05e37c0c0e0..01d0fee18b17d 100644
--- a/sandbox/win/src/service_resolver_unittest.cc
+++ b/sandbox/win/src/service_resolver_unittest.cc
@@ -13,53 +13,98 @@
 
 #include "base/bit_cast.h"
 #include "base/memory/raw_ptr.h"
-#include "sandbox/win/src/nt_internals.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/resolver.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
 
+class ResolverThunkTest {
+ public:
+  virtual ~ResolverThunkTest() {}
+
+  virtual sandbox::ServiceResolverThunk* resolver() = 0;
+
+  // Sets the interception target to the desired address.
+  void set_target(void* target) { fake_target_ = target; }
+
+ protected:
+  // Holds the address of the fake target.
+  raw_ptr<void> fake_target_;
+};
+
 // This is the concrete resolver used to perform service-call type functions
 // inside ntdll.dll.
-class ServiceResolverTest : public sandbox::ServiceResolverThunk {
+template <typename T>
+class ResolverThunkTestImpl : public T, public ResolverThunkTest {
  public:
   // The service resolver needs a child process to write to.
-  explicit ServiceResolverTest(bool relaxed)
-      : sandbox::ServiceResolverThunk(::GetCurrentProcess(), relaxed) {}
+  explicit ResolverThunkTestImpl(bool relaxed)
+      : T(::GetCurrentProcess(), relaxed) {}
 
-  ServiceResolverTest(const ServiceResolverTest&) = delete;
-  ServiceResolverTest& operator=(const ServiceResolverTest&) = delete;
+  ResolverThunkTestImpl(const ResolverThunkTestImpl&) = delete;
+  ResolverThunkTestImpl& operator=(const ResolverThunkTestImpl&) = delete;
 
-  // Sets the interception target to the desired address.
-  void set_target(void* target) { fake_target_ = target; }
+  sandbox::ServiceResolverThunk* resolver() { return this; }
 
  protected:
   // Overrides Resolver::Init
-  NTSTATUS Init(const void* target_module,
-                const void* interceptor_module,
-                const char* target_name,
-                const char* interceptor_name,
-                const void* interceptor_entry_point,
-                void* thunk_storage,
-                size_t storage_bytes) final {
+  virtual NTSTATUS Init(const void* target_module,
+                        const void* interceptor_module,
+                        const char* target_name,
+                        const char* interceptor_name,
+                        const void* interceptor_entry_point,
+                        void* thunk_storage,
+                        size_t storage_bytes) {
     NTSTATUS ret = STATUS_SUCCESS;
-    ret = sandbox::ServiceResolverThunk::Init(
-        target_module, interceptor_module, target_name, interceptor_name,
-        interceptor_entry_point, thunk_storage, storage_bytes);
+    ret = T::Init(target_module, interceptor_module, target_name,
+                  interceptor_name, interceptor_entry_point, thunk_storage,
+                  storage_bytes);
     EXPECT_EQ(STATUS_SUCCESS, ret);
 
     this->target_ = fake_target_;
 
     return ret;
   }
-
-  // Holds the address of the fake target.
-  raw_ptr<void> fake_target_;
 };
 
+typedef ResolverThunkTestImpl<sandbox::ServiceResolverThunk> WinXpResolverTest;
+
+#if !defined(_WIN64)
+typedef ResolverThunkTestImpl<sandbox::Win8ResolverThunk> Win8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W8ResolverThunk>
+    Wow64W8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W10ResolverThunk>
+    Wow64W10ResolverTest;
+#endif
+
+const BYTE kJump32 = 0xE9;
+
+void CheckJump(void* source, void* target) {
+#pragma pack(push)
+#pragma pack(1)
+  struct Code {
+    BYTE jump;
+    ULONG delta;
+  };
+#pragma pack(pop)
+
+#if defined(_WIN64)
+  FAIL() << "Running 32-bit codepath";
+#else
+  Code* patched = reinterpret_cast<Code*>(source);
+  EXPECT_EQ(kJump32, patched->jump);
+
+  ULONG source_addr = base::bit_cast<ULONG>(source);
+  ULONG target_addr = base::bit_cast<ULONG>(target);
+  EXPECT_EQ(target_addr + 19 - source_addr, patched->delta);
+#endif
+}
+
 NTSTATUS PatchNtdllWithResolver(const char* function,
                                 bool relaxed,
-                                ServiceResolverTest& resolver) {
+                                ResolverThunkTest* thunk_test) {
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   EXPECT_TRUE(ntdll_base);
 
@@ -72,20 +117,21 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
   BYTE service[50];
   memcpy(service, target, sizeof(service));
 
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
-  resolver.AllowLocalPatches();
+  resolver->AllowLocalPatches();
 
-  NTSTATUS ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                                function_entry, thunk.get(), thunk_size, &used);
+  NTSTATUS ret =
+      resolver->Setup(ntdll_base, nullptr, function, nullptr, function_entry,
+                      thunk.get(), thunk_size, &used);
   if (NT_SUCCESS(ret)) {
-    const BYTE kJump32 = 0xE9;
     EXPECT_EQ(thunk_size, used);
     EXPECT_NE(0, memcmp(service, target, sizeof(service)));
     EXPECT_NE(kJump32, service[0]);
@@ -93,18 +139,30 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
     if (relaxed) {
       // It's already patched, let's patch again, and simulate a direct patch.
       service[0] = kJump32;
-      ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                           function_entry, thunk.get(), thunk_size, &used);
-      EXPECT_TRUE(resolver.VerifyJumpTargetForTesting(thunk.get()));
+      ret = resolver->Setup(ntdll_base, nullptr, function, nullptr,
+                            function_entry, thunk.get(), thunk_size, &used);
+      CheckJump(service, thunk.get());
     }
   }
 
   return ret;
 }
 
+std::unique_ptr<ResolverThunkTest> GetTestResolver(bool relaxed) {
+#if defined(_WIN64)
+  return std::make_unique<WinXpResolverTest>(relaxed);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  if (os_info->IsWowX86OnAMD64())
+    return std::make_unique<Wow64W10ResolverTest>(relaxed);
+
+  return std::make_unique<Win8ResolverTest>(relaxed);
+#endif
+}
+
 NTSTATUS PatchNtdll(const char* function, bool relaxed) {
-  ServiceResolverTest resolver(relaxed);
-  return PatchNtdllWithResolver(function, relaxed, resolver);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(relaxed);
+  return PatchNtdllWithResolver(function, relaxed, thunk_test.get());
 }
 
 TEST(ServiceResolverTest, PatchesServices) {
@@ -155,26 +213,26 @@ TEST(ServiceResolverTest, PatchesPatchedServices) {
 TEST(ServiceResolverTest, MultiplePatchedServices) {
 // We don't support "relaxed mode" for Win64 apps.
 #if !defined(_WIN64)
-  ServiceResolverTest thunk_test(true);
-  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
+  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateFile, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateMutant, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, LocalPatchesAllowed) {
-  ServiceResolverTest resolver(true);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
 
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   ASSERT_TRUE(ntdll_base);
@@ -187,25 +245,26 @@ TEST(ServiceResolverTest, LocalPatchesAllowed) {
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
   NTSTATUS ret = STATUS_UNSUCCESSFUL;
 
   // First try patching without having allowed local patches.
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_FALSE(NT_SUCCESS(ret));
 
   // Now allow local patches and check that things work.
-  resolver.AllowLocalPatches();
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  resolver->AllowLocalPatches();
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_EQ(STATUS_SUCCESS, ret);
 }
 
diff --git a/sandbox/win/src/startup_information_helper.cc b/sandbox/win/src/startup_information_helper.cc
index b7688c6b74d9c..dab303f872b1e 100644
--- a/sandbox/win/src/startup_information_helper.cc
+++ b/sandbox/win/src/startup_information_helper.cc
@@ -115,6 +115,8 @@ bool StartupInformationHelper::BuildStartupInformation() {
   if (!startup_info_.InitializeProcThreadAttributeList(expected_attributes))
     return false;
 
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
+
   if (mitigations_[0] || mitigations_[1]) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &mitigations_[0],
@@ -133,7 +135,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     }
     expected_attributes--;
   }
-
+  }
   if (restrict_child_process_creation_) {
     child_process_creation_ = PROCESS_CREATION_CHILD_PROCESS_RESTRICTED;
     if (!startup_info_.UpdateProcThreadAttribute(
@@ -159,7 +161,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     inherit_handles_ = true;
     expected_attributes--;
   }
-
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
   if (!job_handle_list_.empty()) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_JOB_LIST, &job_handle_list_[0],
@@ -191,6 +193,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
   }
 
   CHECK(expected_attributes == 0);
+  }
   return true;
 }
 
diff --git a/sandbox/win/src/target_services.cc b/sandbox/win/src/target_services.cc
index 603ed9bd8a725..dd06f131529a2 100644
--- a/sandbox/win/src/target_services.cc
+++ b/sandbox/win/src/target_services.cc
@@ -16,6 +16,7 @@
 #include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/win/access_token.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/handle_closer_agent.h"
@@ -115,6 +116,8 @@ bool WarmupWindowsLocales() {
 }
 
 bool SetProcessIntegrityLevel(IntegrityLevel integrity_level) {
+  if (base::win::GetVersion() < base::win::Version::VISTA)
+    return true;
   std::optional<DWORD> rid = GetIntegrityLevelRid(integrity_level);
   if (!rid) {
     // No mandatory level specified, we don't change it.
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index 6b34ade19b28f..dc3f2751ea554 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -571,6 +571,36 @@ std::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return handle_map;
 }
 
+std::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
+    return std::nullopt;
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 }  // namespace sandbox
 
 void ResolveNTFunctionPtr(const char* name, void* ptr) {
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index 0f62c23677133..bdf95cb2de733 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -115,6 +115,11 @@ void* GetProcessBaseAddress(HANDLE process);
 // use them.
 std::optional<ProcessHandleMap> GetCurrentProcessHandles();
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+std::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
 }  // namespace sandbox
 
 // Resolves a function name in NTDLL to a function pointer. The second parameter
diff --git a/services/device/geolocation/win/location_provider_winrt.cc b/services/device/geolocation/win/location_provider_winrt.cc
index 9406c2b456dd4..c5c1eb0b183a5 100644
--- a/services/device/geolocation/win/location_provider_winrt.cc
+++ b/services/device/geolocation/win/location_provider_winrt.cc
@@ -49,6 +49,11 @@ using Microsoft::WRL::ComPtr;
 // API which will trigger an update.
 constexpr double kDefaultMovementThresholdMeters = 1.0;
 
+bool IsWinRTSupported() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 template <typename F>
 absl::optional<DOUBLE> GetOptionalDouble(F&& getter) {
   DOUBLE value = 0;
@@ -460,6 +465,7 @@ std::unique_ptr<LocationProvider> NewSystemLocationProvider(
     GeolocationManager* geolocation_manager) {
   if (!base::FeatureList::IsEnabled(
           features::kWinrtGeolocationImplementation) ||
+	!IsWinRTSupported() ||
       !IsSystemLocationSettingEnabled()) {
     return nullptr;
   }
diff --git a/services/preferences/tracked/device_id_win.cc b/services/preferences/tracked/device_id_win.cc
index 48ce95f869c95..2cd6bfb10cc8e 100644
--- a/services/preferences/tracked/device_id_win.cc
+++ b/services/preferences/tracked/device_id_win.cc
@@ -10,11 +10,16 @@
 
 #include <memory>
 
+#include "base/command_line.h"
 #include "base/check.h"
 
 MachineIdStatus GetDeterministicMachineSpecificId(std::string* machine_id) {
   DCHECK(machine_id);
 
+if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-machine-id")) {
+    return MachineIdStatus::NOT_IMPLEMENTED;
+  }
+
   wchar_t computer_name[MAX_COMPUTERNAME_LENGTH + 1] = {};
   DWORD computer_name_size = std::size(computer_name);
 
diff --git a/services/proxy_resolver_win/BUILD.gn b/services/proxy_resolver_win/BUILD.gn
index ed4b004f06350..c3fa7ec452180 100644
--- a/services/proxy_resolver_win/BUILD.gn
+++ b/services/proxy_resolver_win/BUILD.gn
@@ -11,6 +11,8 @@ component("proxy_resolver_win") {
     "winhttp_api_wrapper.h",
     "winhttp_api_wrapper_impl.cc",
     "winhttp_api_wrapper_impl.h",
+    "winhttp_proxy_resolver_functions.cc",
+    "winhttp_proxy_resolver_functions.h",
   ]
 
   libs = [ "winhttp.lib" ]
diff --git a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
index 68801e4636cab..e22cdfbb1fa0e 100644
--- a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
+++ b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
@@ -15,6 +15,8 @@ EnumTraits<proxy_resolver_win::mojom::WinHttpStatus,
       return proxy_resolver_win::mojom::WinHttpStatus::kOk;
     case net::WinHttpStatus::kAborted:
       return proxy_resolver_win::mojom::WinHttpStatus::kAborted;
+   case net::WinHttpStatus::kFunctionsNotLoaded:
+      return proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded;
     case net::WinHttpStatus::kWinHttpOpenFailed:
       return proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed;
     case net::WinHttpStatus::kWinHttpSetTimeoutsFailed:
@@ -55,6 +57,9 @@ bool EnumTraits<proxy_resolver_win::mojom::WinHttpStatus, net::WinHttpStatus>::
     case proxy_resolver_win::mojom::WinHttpStatus::kAborted:
       *output = net::WinHttpStatus::kAborted;
       return true;
+    case proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded:
+      *output = net::WinHttpStatus::kFunctionsNotLoaded;
+      return true;
     case proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed:
       *output = net::WinHttpStatus::kWinHttpOpenFailed;
       return true;
diff --git a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
index c05d1f63d7d9b..ff3447e285e46 100644
--- a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
+++ b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
@@ -12,6 +12,7 @@ import "url/mojom/url.mojom";
 enum WinHttpStatus {
   kOk,
   kAborted,
+  kFunctionsNotLoaded,
   kWinHttpOpenFailed,
   kWinHttpSetTimeoutsFailed,
   kWinHttpSetStatusCallbackFailed,
diff --git a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
index 54baece710f7a..78e4538bd2ded 100644
--- a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
+++ b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
@@ -9,6 +9,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
 
 namespace proxy_resolver_win {
 
@@ -34,9 +35,9 @@ WinHttpAPIWrapperImpl::~WinHttpAPIWrapperImpl() {
 
 bool WinHttpAPIWrapperImpl::CallWinHttpOpen() {
   DCHECK_EQ(nullptr, session_handle_);
-  session_handle_ = ::WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY,
-                                  WINHTTP_NO_PROXY_NAME,
-                                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
+  session_handle_ =
+      WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME,
+                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
   return (session_handle_ != nullptr);
 }
 
@@ -45,16 +46,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetTimeouts(int resolve_timeout,
                                                    int send_timeout,
                                                    int receive_timeout) {
   DCHECK_NE(nullptr, session_handle_);
-  return (!!::WinHttpSetTimeouts(session_handle_, resolve_timeout,
-                                 connect_timeout, send_timeout,
-                                 receive_timeout));
+  return (!!WinHttpSetTimeouts(session_handle_, resolve_timeout,
+                               connect_timeout, send_timeout, receive_timeout));
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
     WINHTTP_STATUS_CALLBACK internet_callback) {
   DCHECK_NE(nullptr, session_handle_);
   const WINHTTP_STATUS_CALLBACK winhttp_status_callback =
-      ::WinHttpSetStatusCallback(
+      WinHttpSetStatusCallback(
           session_handle_, internet_callback,
           WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
               WINHTTP_CALLBACK_FLAG_GETPROXYFORURL_COMPLETE,
@@ -64,14 +64,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetIEProxyConfigForCurrentUser(
     WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* ie_proxy_config) {
-  return !!::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
+  return !!WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpCreateProxyResolver(
     HINTERNET* out_resolver_handle) {
   DCHECK_NE(nullptr, session_handle_);
   const DWORD result =
-      ::WinHttpCreateProxyResolver(session_handle_, out_resolver_handle);
+      WinHttpProxyResolverFunctions::GetInstance().create_proxy_resolver(
+          session_handle_, out_resolver_handle);
   return (result == ERROR_SUCCESS);
 }
 
@@ -83,25 +84,28 @@ bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyForUrlEx(
   const std::wstring wide_url(url.begin(), url.end());
   // TODO(https://crbug.com/1032820): Upgrade to WinHttpGetProxyForUrlEx2()
   // if there is a clear reason to do so.
-  const DWORD result = ::WinHttpGetProxyForUrlEx(
-      resolver_handle, wide_url.data(), autoproxy_options, context);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_for_url_ex(
+          resolver_handle, wide_url.data(), autoproxy_options, context);
   return (result == ERROR_IO_PENDING);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyResult(
     HINTERNET resolver_handle,
     WINHTTP_PROXY_RESULT* proxy_result) {
-  const DWORD result = ::WinHttpGetProxyResult(resolver_handle, proxy_result);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_result(
+          resolver_handle, proxy_result);
   return (result == ERROR_SUCCESS);
 }
 
 VOID WinHttpAPIWrapperImpl::CallWinHttpFreeProxyResult(
     WINHTTP_PROXY_RESULT* proxy_result) {
-  WinHttpFreeProxyResult(proxy_result);
+  WinHttpProxyResolverFunctions::GetInstance().free_proxy_result(proxy_result);
 }
 
 void WinHttpAPIWrapperImpl::CallWinHttpCloseHandle(HINTERNET internet_handle) {
-  ::WinHttpCloseHandle(internet_handle);
+  WinHttpCloseHandle(internet_handle);
 }
 
 void WinHttpAPIWrapperImpl::CloseSessionHandle() {
diff --git a/services/shape_detection/face_detection_provider_win.cc b/services/shape_detection/face_detection_provider_win.cc
index 59e9eb36d95a5..dbe49923cf948 100644
--- a/services/shape_detection/face_detection_provider_win.cc
+++ b/services/shape_detection/face_detection_provider_win.cc
@@ -49,6 +49,11 @@ BitmapPixelFormat GetPreferredPixelFormat(IFaceDetectorStatics* factory) {
 void FaceDetectionProviderWin::CreateFaceDetection(
     mojo::PendingReceiver<shape_detection::mojom::FaceDetection> receiver,
     shape_detection::mojom::FaceDetectorOptionsPtr options) {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
   ComPtr<IFaceDetectorStatics> factory;
   HRESULT hr = GetActivationFactory<
       IFaceDetectorStatics,
diff --git a/services/shape_detection/text_detection_impl_win.cc b/services/shape_detection/text_detection_impl_win.cc
index a442dced19ad6..ca4d116a84863 100644
--- a/services/shape_detection/text_detection_impl_win.cc
+++ b/services/shape_detection/text_detection_impl_win.cc
@@ -42,6 +42,13 @@ using Microsoft::WRL::ComPtr;
 // static
 void TextDetectionImpl::Create(
     mojo::PendingReceiver<mojom::TextDetection> receiver) {
+
+if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
+
   // Text Detection specification only supports Latin-1 text as documented in
   // https://wicg.github.io/shape-detection-api/text.html#text-detection-api.
   // TODO(junwei.fu): https://crbug.com/794097 consider supporting other Latin
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index 7501833779338..a06504d375c4e 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -437,6 +437,7 @@ component("skia") {
   if (is_win) {
     # See SK_TYPEFACE_FACTORY_DIRECTWRITE
     sources += [
+      "//third_party/skia/src/ports/SkFontHost_win.cpp",
       "//third_party/skia/src/ports/SkFontMgr_win_dw.cpp",
       "//third_party/skia/src/ports/SkOSFile_win.cpp",
       "//third_party/skia/src/ports/SkRemotableFontMgr_win_dw.cpp",
diff --git a/skia/ext/font_utils.cc b/skia/ext/font_utils.cc
index 3631af6cc9587..01b12a8de68a3 100644
--- a/skia/ext/font_utils.cc
+++ b/skia/ext/font_utils.cc
@@ -32,6 +32,7 @@
 #endif
 
 #if BUILDFLAG(IS_WIN)
+#include "base/command_line.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -68,7 +69,9 @@ static sk_sp<SkFontMgr> fontmgr_factory() {
   base::ComponentContextForProcess()->svc()->Connect(provider.NewRequest());
   return SkFontMgr_New_Fuchsia(std::move(provider));
 #elif BUILDFLAG(IS_WIN)
-  return SkFontMgr_New_DirectWrite();
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-direct-write"))
+	  return SkFontMgr_New_GDI();
+  return SkFontMgr_New_DirectWrite() ? SkFontMgr_New_DirectWrite() : SkFontMgr_New_GDI();
 #elif defined(SK_FONTMGR_FREETYPE_EMPTY_AVAILABLE)
   return SkFontMgr_New_Custom_Empty();
 #else
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index a66ddcf4d9031..c6ddb5b7e6061 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -20,6 +20,13 @@ struct DWriteFontStyle {
   uint8 font_stretch;
 };
 
+struct FallbackFamilyAndStyle {
+  string fallback_family_name;
+  uint16 weight;
+  uint8 width;
+  uint8 slant;
+};
+
 struct MapCharactersResult {
   uint32 family_index;
   mojo_base.mojom.String16 family_name;
@@ -28,6 +35,11 @@ struct MapCharactersResult {
   DWriteFontStyle font_style;
 };
 
+enum UniqueFontLookupMode {
+    kRetrieveTable,
+    kSingleLookups
+};
+
 interface DWriteFontProxy {
   // Locates the index of the specified font family within the system
   // collection.
@@ -51,14 +63,47 @@ interface DWriteFontProxy {
   GetFontFileHandles(uint32 family_index)
      => (array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
@@ -73,4 +118,18 @@ interface DWriteFontProxy {
                 uint32 reading_direction,
                 mojo_base.mojom.String16 base_family_name)
       => (MapCharactersResult out);
+
+  // For a given base family name, bcp47 language tag, and codepoint to look up,
+  // return a font family name that is available on the system to display the
+  // given codepoint. This internally calls Skia's
+  // SkFontMgr_DirectWrite::matchFamilyStyleCharacter which executes
+  // IDWriteTextLayout based fallback code, which cannot be run in the renderer
+  // due triggering loading the DWrite system font collection.
+  // Use only on Windows 8.0 and earlier - otherwise better fallback API is
+  // available through using a proxies IDWriteFontFallback.
+  [Sync]
+  FallbackFamilyAndStyleForCodepoint(string base_family_name,
+                                     string bcp47_language_tag,
+                                     uint32 codepoint)
+      => (FallbackFamilyAndStyle fallback_result);
 };
diff --git a/third_party/blink/public/platform/platform.h b/third_party/blink/public/platform/platform.h
index 52829e870d30a..ba31da5f16900 100644
--- a/third_party/blink/public/platform/platform.h
+++ b/third_party/blink/public/platform/platform.h
@@ -613,6 +613,11 @@ class BLINK_PLATFORM_EXPORT Platform {
                                             uint16_t* udp_max_port,
                                             bool* allow_mdns_obfuscation) {}
 
+  virtual bool IsWebRtcHWH264DecodingEnabled(
+      webrtc::VideoCodecType video_coded_type) {
+    return true;
+  }
+
   virtual bool IsWebRtcHWEncodingEnabled() { return true; }
 
   virtual bool IsWebRtcHWDecodingEnabled() { return true; }
diff --git a/third_party/blink/public/web/win/web_font_rendering.h b/third_party/blink/public/web/win/web_font_rendering.h
index 851b6c95d0c69..1c3135b59201f 100644
--- a/third_party/blink/public/web/win/web_font_rendering.h
+++ b/third_party/blink/public/web/win/web_font_rendering.h
@@ -18,6 +18,7 @@ class WebFontRenderingClient;
 
 class BLINK_EXPORT WebFontRendering {
  public:
+  static void setUseDirectWrite(bool);
   static void SetSkiaFontManager(sk_sp<SkFontMgr>);
   // Set an instance of |WebFontPrewarmer|. The instance must be kept alive
   // until the process exits.
@@ -34,6 +35,7 @@ class BLINK_EXPORT WebFontRendering {
                                    int32_t font_height);
   static void SetAntialiasedTextEnabled(bool);
   static void SetLCDTextEnabled(bool);
+  static void SetUseSkiaFontFallback(bool);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
index 178b04c75c258..de8cc3fcdc8ed 100644
--- a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
+++ b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
@@ -9,6 +9,12 @@
 
 namespace blink {
 
+// static
+void WebFontRendering::setUseDirectWrite(bool useDirectWrite)
+{
+    FontCache::setUseDirectWrite(useDirectWrite);
+}
+
 // static
 void WebFontRendering::SetSkiaFontManager(sk_sp<SkFontMgr> font_mgr) {
   FontCache::SetFontManager(std::move(font_mgr));
@@ -59,4 +65,9 @@ void WebFontRendering::SetLCDTextEnabled(bool enabled) {
   FontCache::SetLCDTextEnabled(enabled);
 }
 
+// static
+void WebFontRendering::SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+  FontCache::SetUseSkiaFontFallback(use_skia_font_fallback);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 17889a08bc6fb..3a5678361c3d6 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1640,6 +1640,8 @@ component("platform") {
     sources += [
       "fonts/win/dwrite_font_format_support.cc",
       "fonts/win/dwrite_font_format_support.h",
+      "fonts/win/fallback_family_style_cache_win.cc",
+      "fonts/win/fallback_family_style_cache_win.h",
       "fonts/win/font_cache_skia_win.cc",
       "fonts/win/font_fallback_win.cc",
       "fonts/win/font_fallback_win.h",
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index f2f90c197e28b..0344f989487a5 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -60,6 +60,7 @@
 #include "ui/gfx/font_list.h"
 
 #if BUILDFLAG(IS_WIN)
+#include <Windows.h>
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -78,8 +79,10 @@ float FontCache::device_scale_factor_ = 1.0;
 #endif
 
 #if BUILDFLAG(IS_WIN)
+bool FontCache::s_useDirectWrite = false;
 bool FontCache::antialiased_text_enabled_ = false;
 bool FontCache::lcd_text_enabled_ = false;
+bool FontCache::use_skia_font_fallback_ = false;
 static bool should_use_test_font_mgr = false;
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -90,13 +93,17 @@ FontCache& FontCache::Get() {
 FontCache::FontCache()
     : font_manager_(sk_ref_sp(static_font_manager_)),
       font_platform_data_cache_(FontPlatformDataCache::Create()),
-      font_data_cache_(FontDataCache::Create()) {
+      font_data_cache_(FontDataCache::Create()){
 #if BUILDFLAG(IS_WIN)
+  if(!s_useDirectWrite) {
+	  font_manager_ = SkFontMgr_New_GDI();
+  }
+
   if (!font_manager_ || should_use_test_font_mgr) {
     // This code path is only for unit tests. This SkFontMgr does not work in
     // sandboxed environments, but injecting this initialization code to all
     // unit tests isn't easy.
-    font_manager_ = SkFontMgr_New_DirectWrite();
+		font_manager_ = SkFontMgr_New_DirectWrite();
     // Set |is_test_font_mgr_| to capture if this is not happening in the
     // production code. crbug.com/561873
     is_test_font_mgr_ = true;
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index ecd92fe4b0cd3..efa1060c683b1 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -59,6 +59,11 @@
 #include "ui/gfx/font_fallback_linux.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+#endif
+
 class SkString;
 class SkTypeface;
 
@@ -197,8 +202,10 @@ class PLATFORM_EXPORT FontCache final {
 #if BUILDFLAG(IS_WIN)
   // TODO(https://crbug.com/808221) System font style configuration is not
   // related to FontCache. Move it somewhere else, e.g. to WebThemeEngine.
+  static bool useDirectWrite() { return s_useDirectWrite; }
   static bool AntialiasedTextEnabled() { return antialiased_text_enabled_; }
   static bool LcdTextEnabled() { return lcd_text_enabled_; }
+  static void setUseDirectWrite(bool useDirectWrite) { s_useDirectWrite = useDirectWrite; }
   static void SetAntialiasedTextEnabled(bool enabled) {
     antialiased_text_enabled_ = enabled;
   }
@@ -222,6 +229,13 @@ class PLATFORM_EXPORT FontCache final {
   static const AtomicString& StatusFontFamily() {
     return *status_font_family_name_;
   }
+  static void SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+    use_skia_font_fallback_ = use_skia_font_fallback;
+  }
+
+  // On Windows pre 8.1 establish a connection to the DWriteFontProxy service in
+  // order to retrieve family names for fallback lookup.
+  void EnsureServiceConnected();
 
   scoped_refptr<SimpleFontData> GetFallbackFamilyNameFromHardcodedChoices(
       const FontDescription&,
@@ -352,6 +366,7 @@ class PLATFORM_EXPORT FontCache final {
   static SkFontMgr* static_font_manager_;
 
 #if BUILDFLAG(IS_WIN)
+  static bool s_useDirectWrite;
   static WebFontPrewarmer* prewarmer_;
   static bool antialiased_text_enabled_;
   static bool lcd_text_enabled_;
@@ -362,10 +377,12 @@ class PLATFORM_EXPORT FontCache final {
   static int32_t small_caption_font_height_;
   static AtomicString* status_font_family_name_;
   static int32_t status_font_height_;
+  static bool use_skia_font_fallback_;
 
   // Windows creates an SkFontMgr for unit testing automatically. This flag is
   // to ensure it's not happening in the production from the crash log.
   bool is_test_font_mgr_ = false;
+  std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
index 275beac2b5d90..e2b1763bc7cf0 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
@@ -45,6 +45,9 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
 #include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
+#if BUILDFLAG(IS_WIN)
+#include "third_party/skia/include/ports/SkTypeface_win.h"
+#endif
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "v8/include/v8.h"
 
@@ -128,6 +131,34 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
   // now, going with a reasonable upper limit. Deduplication is
   // handled by Skia with priority given to the last occuring
   // assignment.
+  #if BUILDFLAG(IS_WIN)
+    if (!FontCache::useDirectWrite()) {
+        // FIXME: Skia currently renders synthetic bold and italics with
+        // hinting and without linear metrics on the windows GDI backend
+        // while the DirectWrite backend does the right thing. Using
+        // legacyCreateTypeface and specifying the bold/italics style allows
+        // for proper rendering of synthetic style. Once Skia has been
+        // updated this workaround will no longer be needed.
+        // http://crbug.com/332958
+        bool syntheticBold = bold && !return_typeface->isBold();
+        bool syntheticItalic = italic && !return_typeface->isItalic();
+        if (syntheticBold || syntheticItalic) {
+            SkString name;
+			sk_sp<SkFontMgr> font_mgr(SkFontMgr_New_GDI());
+            return_typeface->getFamilyName(&name);
+
+            SkFontStyle realStyle = return_typeface->fontStyle();
+            SkFontStyle syntheticStyle = SkFontStyle(
+                realStyle.weight() + (syntheticBold ? 200 : 0),
+                realStyle.width(),
+                syntheticItalic ? SkFontStyle::kItalic_Slant : realStyle.slant());
+            sk_sp<SkTypeface> typeface = font_mgr->legacyMakeTypeface(name.c_str(), syntheticStyle);
+            syntheticBold = false;
+            syntheticItalic = false;
+            return FontPlatformData(typeface, "", size, syntheticBold, syntheticItalic, text_rendering, resolved_font_features, orientation);
+        }
+    }
+  #endif
   FontFormatCheck::VariableFontSubType font_sub_type =
       FontFormatCheck::ProbeVariableFont(base_typeface_);
   bool synthetic_bold = bold;
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
index 5192a65c008ff..e01b47dc0f648 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
@@ -83,8 +83,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
 
   // Save first candidate to be returned if all other fonts fail, and we need
   // it to render the .notdef glyph.
-  if (!first_candidate_)
+  if (!first_candidate_) {
     first_candidate_ = candidate;
+  }
   return candidate;
 }
 
@@ -153,8 +154,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
   if (fallback_stage_ == kFirstCandidateForNotdefGlyph) {
     fallback_stage_ = kOutOfLuck;
-    if (!first_candidate_)
-      FontCache::CrashWithFontInfo(&font_description_);
+    if (!first_candidate_) {
+		FontCache::CrashWithFontInfo(&font_description_);
+	}
     return first_candidate_;
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
index fae5547d5ef83..4aa202fbc5640 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
@@ -116,6 +116,7 @@ FontPlatformData* FontPlatformDataCache::GetOrCreateFontPlatformData(
   FontPlatformData* const platform_data = GetOrCreateFontPlatformData(
       font_cache, font_description, create_by_alternate_family,
       AlternateFontName::kNoAlternate);
+
   if (!platform_data)
     return nullptr;
 
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index 1b7be19308566..3ea7a0003eac4 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -194,7 +194,6 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
                             AlternateFontName::kLastResort);
   }
 #endif
-
   DCHECK(font_platform_data);
   return FontDataFromFontPlatformData(font_platform_data, should_retain);
 }
@@ -220,7 +219,6 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   DCHECK_NE(family, font_family_names::kSystemUi);
   // convert the name to utf8
   name = family.Utf8();
-
 #if BUILDFLAG(IS_ANDROID)
   // If this is a locale-specific family, try looking up locale-specific
   // typeface first.
@@ -234,6 +232,12 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   // TODO(https://crbug.com/1425390: Assign FontCache::font_manager_ in the
   // ctor.
   auto font_manager = font_manager_ ? font_manager_ : skia::DefaultFontMgr();
+#if BUILDFLAG(IS_WIN)
+  if(!useDirectWrite()) {
+	return sk_sp<SkTypeface>(font_manager->legacyMakeTypeface(
+      name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
+  }
+#endif
   return sk_sp<SkTypeface>(font_manager->matchFamilyStyle(
       name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
 }
diff --git a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index 01e6acd3c8dbc..b7e2f9a024e08 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -42,6 +42,8 @@
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/trace_event/trace_event.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/web_font_prewarmer.h"
 #include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -247,30 +249,75 @@ scoped_refptr<SimpleFontData> FontCache::GetDWriteFallbackFamily(
       font_description, fallback_priority, codepoint);
   DCHECK(fallback_locale);
 
-  const std::string family_name = font_description.Family().FamilyName().Utf8();
+  // On Pre Windows 8.1 (where use_skia_font_fallback_ is false) we cannot call
+  // the Skia version, as there is no IDWriteFontFallback (which is
+  // proxyable). If no IDWriteFontFallback API exists in the DWrite Skia
+  // SkTypeface implemnetation it will proceed to call the layoutFallback method
+  // of SkTypeface DWrite implementation. This method we must not call in the
+  // renderer as it causes stability issues due to reaching a path that will try
+  // to load the system font collection in-process and thus load DLLs that are
+  // blocked in the renderer, see comment in dwrite_font_proxy_init_impl_win.cc
+  // InitializeDWriteFontProxy(). Hence, for Windows pre 8.1 we add a
+  // DWriteFontProxy code path to retrieve a family name as string for a
+  // character + language tag and call matchFamilyStyleCharacter on the browser
+  // side, where we can do that.
+  if (!use_skia_font_fallback_) {
+    String fallback_family;
+    SkFontStyle fallback_style;
+
+    if (UNLIKELY(!fallback_params_cache_)) {
+      fallback_params_cache_ = std::make_unique<FallbackFamilyStyleCache>();
+    }
 
-  Bcp47Vector locales;
-  locales.push_back(fallback_locale->LocaleForSkFontMgr());
-  sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
-      family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
-      locales.size(), codepoint));
+    fallback_params_cache_->Get(
+        font_description.GenericFamily(), fallback_locale->LocaleForSkFontMgr(),
+        fallback_priority, codepoint, &fallback_family, &fallback_style);
+    bool result_from_cache = !fallback_family.IsNull();
 
-  if (!typeface) {
-    return nullptr;
-  }
+    if (!result_from_cache) {
+        return nullptr;
+    }
+
+    FontFaceCreationParams create_by_family((AtomicString(fallback_family)));
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(fallback_style);
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+
+    if (!result_from_cache) {
+      fallback_params_cache_->Put(font_description.GenericFamily(),
+                                  fallback_locale->LocaleForSkFontMgr(),
+                                  fallback_priority, data->Typeface());
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  } else {
+    std::string family_name = font_description.Family().FamilyName().Utf8();
+
+    Bcp47Vector locales;
+    locales.push_back(fallback_locale->LocaleForSkFontMgr());
+    sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
+        family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+        locales.size(), codepoint));
+
+    if (!typeface)
+      return nullptr;
 
-  SkString skia_family;
-  typeface->getFamilyName(&skia_family);
-  FontDescription fallback_updated_font_description(font_description);
-  fallback_updated_font_description.UpdateFromSkiaFontStyle(
-      typeface->fontStyle());
-  const FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
-  FontPlatformData* data =
-      GetFontPlatformData(fallback_updated_font_description, create_by_family);
-  if (!data || !data->FontContainsCharacter(codepoint)) {
-    return nullptr;
+    SkString skia_family;
+    typeface->getFamilyName(&skia_family);
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(
+        typeface->fontStyle());
+    FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
   }
-  return FontDataFromFontPlatformData(data, kDoNotRetain);
+  NOTREACHED();
+  return nullptr;
 }
 
 // Given the desired base font, this will create a SimpleFontData for a specific
@@ -296,9 +343,10 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       GetFallbackFamilyNameFromHardcodedChoices(font_description, character,
                                                 fallback_priority);
 
-  // Fall through to running the API-based fallback.
+  // Fall through to running the API based fallback on Windows 8.1 and above
+  // where API fallback was previously available.
   if (RuntimeEnabledFeatures::LegacyWindowsDWriteFontFallbackEnabled() ||
-      !hardcoded_list_fallback_font) {
+      (!hardcoded_list_fallback_font && use_skia_font_fallback_)) {
     return GetDWriteFallbackFamily(font_description, character,
                                    fallback_priority);
   }
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
index fe7c9a5c819bd..12b8e76a39921 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
@@ -48,11 +48,19 @@ namespace blink {
 
 namespace {
 
+const char kArial[] = "Arial";
+const char kCourierNew[] = "Courier New";
+const char kTimesNewRoman[] = "Times New Roman";
+
 static inline bool IsFontPresent(const UChar* font_name,
                                  SkFontMgr* font_manager) {
   String family = font_name;
-  sk_sp<SkTypeface> tf(
-      font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle()));
+  sk_sp<SkTypeface> tf;
+  if(FontCache::useDirectWrite()) {
+	tf = font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle());
+  } else {
+	tf = font_manager->legacyMakeTypeface(family.Utf8().data(), SkFontStyle());
+  }
   if (!tf)
     return false;
 
@@ -538,4 +546,38 @@ const UChar* GetFallbackFamily(UChar32 character,
   return family;
 }
 
+bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& service,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  String base_family_name_approximation;
+  switch (generic_family) {
+    case FontDescription::kMonospaceFamily:
+      base_family_name_approximation = kCourierNew;
+      break;
+    case FontDescription::kSansSerifFamily:
+      base_family_name_approximation = kArial;
+      break;
+    default:
+      base_family_name_approximation = kTimesNewRoman;
+  }
+
+  mojom::blink::FallbackFamilyAndStylePtr fallback_family_and_style;
+  bool mojo_result = service->FallbackFamilyAndStyleForCodepoint(
+      base_family_name_approximation, bcp47_language_tag, character,
+      &fallback_family_and_style);
+
+  SECURITY_DCHECK(fallback_family);
+  SECURITY_DCHECK(fallback_style);
+  *fallback_family = fallback_family_and_style->fallback_family_name;
+  *fallback_style = SkFontStyle(
+      fallback_family_and_style->weight, fallback_family_and_style->width,
+      static_cast<SkFontStyle::Slant>(fallback_family_and_style->slant));
+  return mojo_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
index 6a51e150dc5b9..254eba78a3639 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
@@ -34,10 +34,13 @@
 #include <unicode/locid.h>
 #include <unicode/uscript.h>
 
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 class SkFontMgr;
 
@@ -55,6 +58,19 @@ PLATFORM_EXPORT const UChar* GetFallbackFamily(
     FontFallbackPriority,
     SkFontMgr* font_manager);
 
+// Return a font family that can render |character| based on what script
+// that characters belong to by performing an out of process lookup and using
+// system fallback API based on IDWriteTextLayout. This method is only to be
+// used on pre Windows 8.1, as otherwise IDWriteFontFallback API is available.
+PLATFORM_EXPORT bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& font_proxy,
+    String* fallback_family,
+    SkFontStyle* fallback_style);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_FALLBACK_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index f35e19882bc6c..3d3e1b1855192 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -11,6 +11,7 @@
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "skia/ext/font_utils.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
@@ -28,11 +29,14 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -45,6 +49,32 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  absl::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  sk_sp<SkFontMgr> mgr = skia::DefaultFontMgr();
+  return mgr->makeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -63,11 +93,52 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
-    EnsureServiceConnected();
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
+  }
+
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
   }
 
-  return true;
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -77,11 +148,66 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index 7b31b5af1cabc..abdf287af3677 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows Vista, 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,17 +32,32 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
+
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  absl::optional<bool> sync_available_;
+  absl::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
index a3aebc48df892..2b8cc22769a6d 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
@@ -500,6 +500,9 @@ std::unique_ptr<RTCVideoDecoderAdapter> RTCVideoDecoderAdapter::Create(
   const webrtc::VideoCodecType video_codec_type =
       webrtc::PayloadStringToCodecType(format.name);
 
+  if (!Platform::Current()->IsWebRtcHWH264DecodingEnabled(video_codec_type))
+    return nullptr;
+
   // Bail early for unknown codecs.
   if (WebRtcToMediaVideoCodec(video_codec_type) == media::VideoCodec::kUnknown)
     return nullptr;
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
index a6142fc23f148..ebf06eb9cf815 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
@@ -279,6 +279,9 @@ RTCVideoDecoderStreamAdapter::Create(
   const webrtc::VideoCodecType video_codec_type =
       webrtc::PayloadStringToCodecType(format.name);
 
+  if (!Platform::Current()->IsWebRtcHWH264DecodingEnabled(video_codec_type))
+    return nullptr;
+
   // Bail early for unknown codecs.
   if (WebRtcToMediaVideoCodec(video_codec_type) == media::VideoCodec::kUnknown)
     return nullptr;
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_win.cc b/third_party/crashpad/crashpad/client/crashpad_client_win.cc
index 9b52fcd0f4181..d3bfdbe614076 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_win.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_win.cc
@@ -456,7 +456,7 @@ bool StartHandlerProcess(
       initialize_proc_thread_attribute_list
           ? GET_FUNCTION(L"kernel32.dll", ::UpdateProcThreadAttribute)
           : nullptr;
-  if (!initialize_proc_thread_attribute_list || !update_proc_thread_attribute) {
+  if (!initialize_proc_thread_attribute_list || !update_proc_thread_attribute || !IsWindowsVistaOrGreater()) {
     // The OS doesn’t allow handle inheritance to be restricted, so the handler
     // will inherit every inheritable handle.
     creation_flags = 0;
diff --git a/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc b/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc
index 6c06165f6870b..071daa79d0e5e 100644
--- a/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc
+++ b/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc
@@ -287,10 +287,13 @@ void ProcessSnapshotWin::InitializeUnloadedModules() {
 #else
 #error port
 #endif
-
   ULONG* element_size;
   ULONG* element_count;
   void* event_trace_address;
+
+  if (!GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlGetUnloadEventTraceEx"))
+    return;
+
   RtlGetUnloadEventTraceEx(&element_size, &element_count, &event_trace_address);
 
   if (*element_size < sizeof(RTL_UNLOAD_EVENT_TRACE<Traits>)) {
diff --git a/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc b/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc
index 59a7bbdfbafb6..73da14d113644 100644
--- a/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc
+++ b/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc
@@ -151,15 +151,16 @@ HANDLE CreateNamedPipeInstance(const std::wstring& pipe_name,
   SECURITY_ATTRIBUTES* security_attributes_pointer = nullptr;
 
   if (first_instance) {
-    // Pre-Vista does not have integrity levels.
-    if (IsWindowsVistaOrGreater()) {
+    // Pre-Vista does not have integrity levels. But we still need the crashpad
+    // process to inherit the handle.
       memset(&security_attributes, 0, sizeof(security_attributes));
       security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
+	  if (IsWindowsVistaOrGreater()) {
       security_attributes.lpSecurityDescriptor =
           const_cast<void*>(GetSecurityDescriptorForNamedPipeInstance(nullptr));
+	  }
       security_attributes.bInheritHandle = TRUE;
       security_attributes_pointer = &security_attributes;
-    }
   }
 
   return CreateNamedPipe(
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 1147a6e268f64..cec02efe6a5d1 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -1156,6 +1156,7 @@ test("ui_base_unittests") {
     ]
     if (is_win) {
       sources += [
+        "ime/win/imm32_manager_unittest.cc",
         "ime/win/on_screen_keyboard_display_manager_unittest.cc",
         "ime/win/tsf_input_scope_unittest.cc",
         "ime/win/tsf_text_store_unittest.cc",
diff --git a/ui/base/ime/init/input_method_factory.cc b/ui/base/ime/init/input_method_factory.cc
index c99fd18826153..5d4a41a4d64c2 100644
--- a/ui/base/ime/init/input_method_factory.cc
+++ b/ui/base/ime/init/input_method_factory.cc
@@ -13,6 +13,7 @@
 #include "ui/gfx/switches.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "ui/base/ime/win/input_method_win_imm32.h"
 #include "ui/base/ime/win/input_method_win_tsf.h"
 #elif BUILDFLAG(IS_APPLE)
 #include "ui/base/ime/mac/input_method_mac.h"
@@ -53,7 +54,12 @@ std::unique_ptr<InputMethod> CreateInputMethod(
     return base::WrapUnique(new MockInputMethod(ime_key_event_dispatcher));
 
 #if BUILDFLAG(IS_WIN)
-  return std::make_unique<InputMethodWinTSF>(ime_key_event_dispatcher, widget);
+  if (base::FeatureList::IsEnabled(features::kTSFImeSupport)) {
+    return std::make_unique<InputMethodWinTSF>(ime_key_event_dispatcher,
+                                               widget);
+  }
+  return std::make_unique<InputMethodWinImm32>(ime_key_event_dispatcher,
+                                               widget);
 #elif BUILDFLAG(IS_APPLE)
   return std::make_unique<InputMethodMac>(ime_key_event_dispatcher);
 #elif BUILDFLAG(IS_OZONE)
diff --git a/ui/base/ime/win/BUILD.gn b/ui/base/ime/win/BUILD.gn
index 61d1e9b662430..1a2a40db4dae5 100644
--- a/ui/base/ime/win/BUILD.gn
+++ b/ui/base/ime/win/BUILD.gn
@@ -7,8 +7,12 @@ assert(is_win)
 component("win") {
   output_name = "ui_base_ime_win"
   sources = [
+    "imm32_manager.cc",
+    "imm32_manager.h",
     "input_method_win_base.cc",
     "input_method_win_base.h",
+    "input_method_win_imm32.cc",
+    "input_method_win_imm32.h",
     "input_method_win_tsf.cc",
     "input_method_win_tsf.h",
     "mock_tsf_bridge.cc",
@@ -37,4 +41,8 @@ component("win") {
     "//ui/base",
     "//ui/display",
   ]
+
+  libs = [ "imm32.lib" ]
+
+  ldflags = [ "/DELAYLOAD:imm32.dll" ]
 }
diff --git a/ui/base/ime/win/input_method_win_base.h b/ui/base/ime/win/input_method_win_base.h
index aeec7cbe8940d..d6ad5d11a5279 100644
--- a/ui/base/ime/win/input_method_win_base.h
+++ b/ui/base/ime/win/input_method_win_base.h
@@ -8,8 +8,8 @@
 #include <windows.h>
 
 #include "base/component_export.h"
-#include "base/i18n/rtl.h"
 #include "ui/base/ime/input_method_base.h"
+#include "ui/base/ime/win/imm32_manager.h"
 
 namespace ui {
 
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
index e079f9ccd09d2..ed9cb666ff09b 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
@@ -91,6 +91,11 @@ class OnScreenKeyboardDisplayManagerInputPane::VirtualKeyboardInputPane
     if (input_pane2_)
       return true;
 
+    if (!base::win::ResolveCoreWinRTDelayload() ||
+        !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+      return false;
+    }
+
     base::win::AssertComApartmentType(base::win::ComApartmentType::STA);
 
     base::win::ScopedHString input_pane_guid = base::win::ScopedHString::Create(
diff --git a/ui/base/ime/win/tsf_bridge.cc b/ui/base/ime/win/tsf_bridge.cc
index 8b3e5acd96ea1..944fde7fc17ed 100644
--- a/ui/base/ime/win/tsf_bridge.cc
+++ b/ui/base/ime/win/tsf_bridge.cc
@@ -16,6 +16,7 @@
 #include "base/threading/thread_local.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/scoped_variant.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ime/ime_key_event_dispatcher.h"
 #include "ui/base/ime/text_input_client.h"
 #include "ui/base/ime/win/mock_tsf_bridge.h"
@@ -196,6 +197,10 @@ TSFBridgeImpl::~TSFBridgeImpl() {
 
 HRESULT TSFBridgeImpl::Initialize() {
   DCHECK(base::CurrentUIThread::IsSet());
+
+// if (!features::IsUsingTSFForIME())
+ //    return E_FAIL;
+
   if (client_id_ != TF_CLIENTID_NULL) {
     DVLOG(1) << "Already initialized.";
     return S_OK;  // shouldn't return error code in this case.
@@ -716,6 +721,10 @@ HRESULT TSFBridge::Initialize() {
     return S_OK;
   }
 
+  // If we aren't supporting TSF early out.
+  if (!base::FeatureList::IsEnabled(features::kTSFImeSupport) || base::win::GetVersion() < base::win::Version::VISTA)
+    return E_FAIL;
+
   auto delegate = std::make_unique<TSFBridgeImpl>();
   HRESULT hr = delegate->Initialize();
   if (SUCCEEDED(hr)) {
@@ -729,6 +738,8 @@ void TSFBridge::InitializeForTesting() {
   if (!base::CurrentUIThread::IsSet()) {
     return;
   }
+  if (!base::FeatureList::IsEnabled(features::kTSFImeSupport))
+    return;
   ReplaceThreadLocalTSFBridge(std::make_unique<MockTSFBridge>());
 }
 
diff --git a/ui/base/ime/win/tsf_input_scope.cc b/ui/base/ime/win/tsf_input_scope.cc
index e2a79de6f846f..ea7ef9cc26f30 100644
--- a/ui/base/ime/win/tsf_input_scope.cc
+++ b/ui/base/ime/win/tsf_input_scope.cc
@@ -10,6 +10,7 @@
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
 #include "base/task/current_thread.h"
+#include "base/win/windows_version.h"
 
 namespace ui::tsf_inputscope {
 namespace {
@@ -108,6 +109,9 @@ typedef HRESULT (WINAPI *SetInputScopesFunc)(HWND window_handle,
                                              WCHAR*, /* unused */
                                              WCHAR* /* unused */);
 
+SetInputScopesFunc g_set_input_scopes = NULL;
+bool g_get_proc_done = false;
+
 InputScope ConvertTextInputTypeToInputScope(TextInputType text_input_type) {
   // Following mapping is based in IE10 on Windows 8.
   switch (text_input_type) {
@@ -149,6 +153,25 @@ InputScope ConvertTextInputModeToInputScope(TextInputMode text_input_mode) {
 
 }  // namespace
 
+void InitializeTsfForInputScopes() {
+  DCHECK(base::CurrentUIThread::IsSet());
+  // Thread safety is not required because this function is under UI thread.
+  if (!g_get_proc_done) {
+    g_get_proc_done = true;
+
+	// For stability reasons, we do not support Windows XP.
+    if (base::win::GetVersion() < base::win::Version::VISTA)
+      return;
+
+    HMODULE module = NULL;
+    if (GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_PIN, L"msctf.dll",
+        &module)) {
+      g_set_input_scopes = reinterpret_cast<SetInputScopesFunc>(
+          GetProcAddress(module, "SetInputScopes"));
+    }
+  }
+}
+
 std::vector<InputScope> GetInputScopes(TextInputType text_input_type,
                                        TextInputMode text_input_mode) {
   std::vector<InputScope> input_scopes;
@@ -178,4 +201,16 @@ ITfInputScope* CreateInputScope(TextInputType text_input_type,
   return new TSFInputScope(input_scopes);
 }
 
+void SetInputScopeForTsfUnawareWindow(HWND window_handle,
+                                      TextInputType text_input_type,
+                                      TextInputMode text_input_mode) {
+  if (!g_set_input_scopes)
+    return;
+
+  std::vector<InputScope> input_scopes = GetInputScopes(text_input_type,
+                                                        text_input_mode);
+  g_set_input_scopes(window_handle, &input_scopes[0], input_scopes.size(),
+                     NULL, 0, NULL, NULL);
+}
+
 }  // namespace ui::tsf_inputscope
diff --git a/ui/base/ime/win/tsf_input_scope.h b/ui/base/ime/win/tsf_input_scope.h
index f369f9a9341d9..e8c159f0844dc 100644
--- a/ui/base/ime/win/tsf_input_scope.h
+++ b/ui/base/ime/win/tsf_input_scope.h
@@ -16,6 +16,10 @@
 namespace ui {
 namespace tsf_inputscope {
 
+// Initializes the TSF for input scopes. It loads the tsf dll and get the
+// function pointer for setting the input scopes in TSF.
+COMPONENT_EXPORT(UI_BASE_IME_WIN) void InitializeTsfForInputScopes();
+
 // Returns InputScope list corresoponding to ui::TextInputType and
 // ui::TextInputMode.
 // This function is only used from following functions but declared for test.
@@ -34,6 +38,15 @@ ITfInputScope* CreateInputScope(TextInputType text_input_type,
                                 TextInputMode text_input_mode,
                                 bool should_do_learning);
 
+// A wrapper of the SetInputScopes API exported by msctf.dll.
+// http://msdn.microsoft.com/en-us/library/windows/desktop/ms629026.aspx
+// Does nothing on Windows XP in case TSF is disabled.
+// NOTE: For TSF-aware window, you should use ITfInputScope instead.
+COMPONENT_EXPORT(UI_BASE_IME_WIN)
+void SetInputScopeForTsfUnawareWindow(HWND window_handle,
+                                      TextInputType text_input_type,
+                                      TextInputMode text_input_mode);
+
 }  // namespace tsf_inputscope
 }  // namespace ui
 
diff --git a/ui/base/mojom/window_open_disposition_mojom_traits.h b/ui/base/mojom/window_open_disposition_mojom_traits.h
index 5d352b58257ef..cd238276358fc 100644
--- a/ui/base/mojom/window_open_disposition_mojom_traits.h
+++ b/ui/base/mojom/window_open_disposition_mojom_traits.h
@@ -5,6 +5,7 @@
 #ifndef UI_BASE_MOJOM_WINDOW_OPEN_DISPOSITION_MOJOM_TRAITS_H_
 #define UI_BASE_MOJOM_WINDOW_OPEN_DISPOSITION_MOJOM_TRAITS_H_
 
+#include "base/command_line.h"
 #include "base/notreached.h"
 #include "mojo/public/cpp/bindings/enum_traits.h"
 #include "ui/base/mojom/window_open_disposition.mojom.h"
@@ -30,6 +31,8 @@ struct EnumTraits<ui::mojom::WindowOpenDisposition, WindowOpenDisposition> {
       case WindowOpenDisposition::NEW_PICTURE_IN_PICTURE:
         return ui::mojom::WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
       case WindowOpenDisposition::NEW_POPUP:
+		if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+           return ui::mojom::WindowOpenDisposition::NEW_FOREGROUND_TAB;
         return ui::mojom::WindowOpenDisposition::NEW_POPUP;
       case WindowOpenDisposition::NEW_WINDOW:
         return ui::mojom::WindowOpenDisposition::NEW_WINDOW;
@@ -68,6 +71,8 @@ struct EnumTraits<ui::mojom::WindowOpenDisposition, WindowOpenDisposition> {
         return true;
       case ui::mojom::WindowOpenDisposition::NEW_POPUP:
         *out = WindowOpenDisposition::NEW_POPUP;
+		if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+           *out = WindowOpenDisposition::NEW_FOREGROUND_TAB;
         return true;
       case ui::mojom::WindowOpenDisposition::NEW_WINDOW:
         *out = WindowOpenDisposition::NEW_WINDOW;
diff --git a/ui/base/ui_base_features.cc b/ui/base/ui_base_features.cc
index 152122c117cdd..a4ed4dcebce1e 100644
--- a/ui/base/ui_base_features.cc
+++ b/ui/base/ui_base_features.cc
@@ -11,6 +11,10 @@
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/build_info.h"
 #endif
@@ -78,6 +82,14 @@ bool IsNotificationsIgnoreRequireInteractionEnabled() {
   return base::FeatureList::IsEnabled(kNotificationsIgnoreRequireInteraction);
 }
 
+// Enables using TSF (over IMM32) for IME.
+BASE_FEATURE(kTSFImeSupport, "TSFImeSupport", base::FEATURE_ENABLED_BY_DEFAULT);
+
+bool IsUsingTSFForIME() {
+  return base::win::GetVersion() >= base::win::Version::VISTA &&
+			base::FeatureList::IsEnabled(kTSFImeSupport);
+}
+
 BASE_FEATURE(kShortcutCustomizationApp,
              "ShortcutCustomizationApp",
              base::FEATURE_ENABLED_BY_DEFAULT);
@@ -253,9 +265,12 @@ BASE_FEATURE(kInputPaneOnScreenKeyboard,
 BASE_FEATURE(kPointerEventsForTouch,
              "PointerEventsForTouch",
              base::FEATURE_ENABLED_BY_DEFAULT);
+// Enables using TSF (over IMM32) for IME.
+BASE_FEATURE(kTSFImeSupport, "TSFImeSupport", base::FEATURE_ENABLED_BY_DEFAULT);
 
 bool IsUsingWMPointerForTouch() {
-  return base::FeatureList::IsEnabled(kPointerEventsForTouch);
+  return base::win::GetVersion() >= base::win::Version::WIN8 &&
+			base::FeatureList::IsEnabled(kPointerEventsForTouch);
 }
 
 #endif  // BUILDFLAG(IS_WIN)
@@ -592,6 +607,10 @@ BASE_FEATURE(kBubbleMetricsApi,
              "BubbleMetricsApi",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kThoriumCustomTabs,
+             "ThoriumCustomTabs",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
 #if BUILDFLAG(IS_MAC)
 // When enabled, images will be written to the system clipboard as both a TIFF
 // and a PNG (as opposed to just a TIFF). This requires encoding the sanitized
diff --git a/ui/base/ui_base_features.h b/ui/base/ui_base_features.h
index 67f99842c04e5..a8aac0c1e041f 100644
--- a/ui/base/ui_base_features.h
+++ b/ui/base/ui_base_features.h
@@ -27,6 +27,7 @@ COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kInputMethodSettingsUiUpdate);
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kWindowsScrollingPersonality);
+COMPONENT_EXPORT(UI_BASE_FEATURES) bool IsUsingTSFForIME();
 COMPONENT_EXPORT(UI_BASE_FEATURES) bool IsPercentBasedScrollingEnabled();
 COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kSystemCaptionStyle);
 COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kSystemKeyboardLock);
@@ -57,6 +58,7 @@ BASE_DECLARE_FEATURE(kInputPaneOnScreenKeyboard);
 COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kPointerEventsForTouch);
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kScreenPowerListenerForNativeWinOcclusion);
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kTSFImeSupport);
 
 // Returns true if the system should use WM_POINTER events for touch events.
 COMPONENT_EXPORT(UI_BASE_FEATURES) bool IsUsingWMPointerForTouch();
@@ -286,6 +288,9 @@ ChromeRefresh2023Level GetChromeRefresh2023Level();
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kBubbleMetricsApi);
 
+// Enables customization of the shape of the browser tabs.
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kThoriumCustomTabs);
+
 #if BUILDFLAG(IS_MAC)
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kMacClipboardWriteImageWithPng);
diff --git a/ui/display/win/screen_win.cc b/ui/display/win/screen_win.cc
index 6b6189a124e3f..a587fc488cebc 100644
--- a/ui/display/win/screen_win.cc
+++ b/ui/display/win/screen_win.cc
@@ -46,13 +46,47 @@ namespace {
 // resolved with Desktop Aura and WindowTreeHost.
 ScreenWin* g_instance = nullptr;
 
+bool IsProcessPerMonitorDpiAware() {
+  enum class PerMonitorDpiAware {
+    UNKNOWN = 0,
+    PER_MONITOR_DPI_UNAWARE,
+    PER_MONITOR_DPI_AWARE,
+  };
+  static PerMonitorDpiAware per_monitor_dpi_aware = PerMonitorDpiAware::UNKNOWN;
+  if (per_monitor_dpi_aware == PerMonitorDpiAware::UNKNOWN) {
+    per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_UNAWARE;
+    HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    if (shcore_dll) {
+      auto get_process_dpi_awareness_func =
+          reinterpret_cast<decltype(::GetProcessDpiAwareness)*>(
+              ::GetProcAddress(shcore_dll, "GetProcessDpiAwareness"));
+      if (get_process_dpi_awareness_func) {
+        PROCESS_DPI_AWARENESS awareness;
+        if (SUCCEEDED(get_process_dpi_awareness_func(nullptr, &awareness)) &&
+            awareness == PROCESS_PER_MONITOR_DPI_AWARE)
+          per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+      }
+    }
+  }
+  return per_monitor_dpi_aware == PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+}
+
 // Gets the DPI for a particular monitor.
 absl::optional<int> GetPerMonitorDPI(HMONITOR monitor) {
+  if (!IsProcessPerMonitorDpiAware())
+    return absl::nullopt;
+
+  static auto get_dpi_for_monitor_func = []() {
+    const HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    return reinterpret_cast<decltype(&::GetDpiForMonitor)>(
+        shcore_dll ? ::GetProcAddress(shcore_dll, "GetDpiForMonitor")
+                   : nullptr);
+  }();
   UINT dpi_x, dpi_y;
-  if (!SUCCEEDED(
-          ::GetDpiForMonitor(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y))) {
+  if (!get_dpi_for_monitor_func ||
+      !SUCCEEDED(
+          get_dpi_for_monitor_func(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y)))
     return absl::nullopt;
-  }
 
   DCHECK_EQ(dpi_x, dpi_y);
   return static_cast<int>(dpi_x);
diff --git a/ui/display/win/uwp_text_scale_factor.cc b/ui/display/win/uwp_text_scale_factor.cc
index f6867edea301e..2d2d18c212bca 100644
--- a/ui/display/win/uwp_text_scale_factor.cc
+++ b/ui/display/win/uwp_text_scale_factor.cc
@@ -52,6 +52,13 @@ bool g_default_instance_cleaned_up = false;
 bool CreateUiSettingsComObject(ComPtr<IUISettings2>& ptr) {
   DCHECK(!ptr);
 
+  // This is required setup before using ScopedHString.
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
   // Create the COM object.
   auto hstring = base::win::ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UISettings);
diff --git a/ui/gfx/canvas.h b/ui/gfx/canvas.h
index 8b2004767a03a..b6b331b1ef9e7 100644
--- a/ui/gfx/canvas.h
+++ b/ui/gfx/canvas.h
@@ -82,6 +82,9 @@ class GFX_EXPORT Canvas {
     // when rendering text onto a fully- or partially-transparent background
     // that will later be blended with another image.
     NO_SUBPIXEL_RENDERING = 1 << 9,
+
+	// Workaround for GDI offset rendering issues.
+	GDI_OFFSET_RENDERING = 1 << 10,
   };
 
   // Creates an empty canvas with image_scale of 1x.
diff --git a/ui/gfx/canvas_skia.cc b/ui/gfx/canvas_skia.cc
index 11d7121476942..3a3e0119c198c 100644
--- a/ui/gfx/canvas_skia.cc
+++ b/ui/gfx/canvas_skia.cc
@@ -235,6 +235,10 @@ void Canvas::DrawStringRectWithFlags(const std::u16string& text,
                      render_text.get());
     if (range.IsValid())
       render_text->ApplyStyle(TEXT_STYLE_UNDERLINE, true, range);
+
+    if(flags & GDI_OFFSET_RENDERING)
+		render_text->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+
     render_text->Draw(this);
   }
 
diff --git a/ui/gfx/font_render_params_win.cc b/ui/gfx/font_render_params_win.cc
index db0200908f88a..32d3b94a06fc8 100644
--- a/ui/gfx/font_render_params_win.cc
+++ b/ui/gfx/font_render_params_win.cc
@@ -15,6 +15,7 @@
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/font_util_win.h"
 #include "ui/gfx/win/singleton_hwnd_observer.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace gfx {
 
@@ -77,7 +78,8 @@ class CachedFontRenderParams {
     BOOL enabled = false;
     if (SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &enabled, 0) && enabled) {
       params_->antialiasing = true;
-      params_->subpixel_positioning = true;
+      // GDI does not support subpixel positioning.
+      params_->subpixel_positioning = win::IsDirectWriteEnabled();
 
       UINT type = 0;
       if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index cf08dd7f0a3ad..4d745ea654673 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -12,6 +12,7 @@
 
 #include "base/check_op.h"
 #include "base/command_line.h"
+#include "base/feature_list.h"
 #include "base/i18n/break_iterator.h"
 #include "base/i18n/char_iterator.h"
 #include "base/i18n/rtl.h"
@@ -32,6 +33,7 @@
 #include "third_party/skia/include/core/SkTextBlob.h"
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "third_party/skia/include/effects/SkGradientShader.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/size_conversions.h"
@@ -45,6 +47,10 @@
 #include "ui/gfx/text_utils.h"
 #include "ui/gfx/utf16_indexing.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -256,23 +262,25 @@ UChar32 ReplaceControlCharacter(UChar32 codepoint) {
     // Support Microsoft defined PUA on Windows.
     // see:
     // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
-    switch (codepoint) {
-      case 0xF093:  // ButtonA
-      case 0xF094:  // ButtonB
-      case 0xF095:  // ButtonY
-      case 0xF096:  // ButtonX
-      case 0xF108:  // LeftStick
-      case 0xF109:  // RightStick
-      case 0xF10A:  // TriggerLeft
-      case 0xF10B:  // TriggerRight
-      case 0xF10C:  // BumperLeft
-      case 0xF10D:  // BumperRight
-      case 0xF10E:  // Dpad
-      case 0xEECA:  // ButtonView2
-      case 0xEDE3:  // ButtonMenu
-        return codepoint;
-      default:
-        break;
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      switch (codepoint) {
+        case 0xF093:  // ButtonA
+        case 0xF094:  // ButtonB
+        case 0xF095:  // ButtonY
+        case 0xF096:  // ButtonX
+        case 0xF108:  // LeftStick
+        case 0xF109:  // RightStick
+        case 0xF10A:  // TriggerLeft
+        case 0xF10B:  // TriggerRight
+        case 0xF10C:  // BumperLeft
+        case 0xF10D:  // BumperRight
+        case 0xF10E:  // Dpad
+        case 0xEECA:  // ButtonView2
+        case 0xEDE3:  // ButtonMenu
+          return codepoint;
+        default:
+          break;
+      }
     }
 #endif
     const int8_t codepoint_category = u_charType(codepoint);
@@ -364,7 +372,7 @@ void SkiaTextRenderer::DrawPosText(const SkPoint* pos,
   static_assert(sizeof(*pos) == 2 * sizeof(*run_buffer.pos), "");
   memcpy(run_buffer.pos, pos, glyph_count * sizeof(*pos));
 
-  canvas_skia_->drawTextBlob(builder.make(), 0, 0, flags_);
+  canvas_skia_->drawTextBlob(builder.make(), 0, 0 + special_y_offset_, flags_);
 }
 
 void SkiaTextRenderer::DrawUnderline(int x,
@@ -997,7 +1005,7 @@ int RenderText::GetContentWidth() {
 int RenderText::GetBaseline() {
   if (baseline_ == kInvalidBaseline) {
     const int centering_height =
-        (vertical_alignment_ == ALIGN_MIDDLE)
+        (vertical_alignment_ == ALIGN_MIDDLE || vertical_alignment_ == ALIGN_SPECIAL || vertical_alignment_ == ALIGN_COMPACT)
             ? display_rect().height()
             : std::max(font_list().GetHeight(), min_line_height());
     baseline_ = DetermineBaselineCenteringText(centering_height, font_list());
@@ -1027,7 +1035,12 @@ void RenderText::Draw(Canvas* canvas, bool select_all) {
       draw_selections = GetAllSelections();
 
     DrawSelections(canvas, draw_selections);
+
     internal::SkiaTextRenderer renderer(canvas);
+
+	if (vertical_alignment_ == ALIGN_SPECIAL) {
+		renderer.SetSpecialYOffset(4); // This will push down the offending labels in GDI to the point that they will appear centred
+	}
     DrawVisualText(&renderer, draw_selections);
   }
 
@@ -1179,8 +1192,13 @@ Rect RenderText::GetCursorBounds(const SelectionModel& caret,
               base::ClampCeil(Clamp(xspan.GetMin()));
     }
   }
+
   Size line_size = gfx::ToCeiledSize(GetLineSizeF(caret));
   size_t line = GetLineContainingCaret(caret);
+
+  if (vertical_alignment_ == ALIGN_SPECIAL) {
+	  line_size.set_height(line_size.height() + 8);
+  }
   return Rect(ToViewPoint(PointF(x, 0), line), Size(width, line_size.height()));
 }
 
@@ -1861,6 +1879,8 @@ Vector2d RenderText::GetAlignmentOffset(size_t line_number) {
       offset.set_y(0);
       break;
     case ALIGN_MIDDLE:
+	case ALIGN_SPECIAL:
+	case ALIGN_COMPACT:
       if (multiline_)
         offset.set_y((display_rect_.height() - GetStringSize().height()) / 2);
       else
diff --git a/ui/gfx/render_text.h b/ui/gfx/render_text.h
index 5b3eda36fa332..6d691f7715052 100644
--- a/ui/gfx/render_text.h
+++ b/ui/gfx/render_text.h
@@ -73,6 +73,7 @@ class GFX_EXPORT SkiaTextRenderer {
                            bool subpixel_rendering_suppressed);
   void SetTypeface(sk_sp<SkTypeface> typeface);
   void SetTextSize(SkScalar size);
+  void SetSpecialYOffset(int y_offset) { special_y_offset_ = y_offset; }
   void SetForegroundColor(SkColor foreground);
   void SetShader(sk_sp<cc::PaintShader> shader);
   // TODO(vmpstr): Change this API to mimic SkCanvas::drawTextBlob instead.
@@ -89,6 +90,7 @@ class GFX_EXPORT SkiaTextRenderer {
   raw_ptr<cc::PaintCanvas> canvas_skia_;
   cc::PaintFlags flags_;
   SkFont font_;
+  int special_y_offset_ = 0;
 };
 
 struct TextToDisplayIndex {
@@ -1060,6 +1062,9 @@ class GFX_EXPORT RenderText {
 
   // Tell whether or not the |layout_text_| needs an update or is up to date.
   mutable bool layout_text_up_to_date_ = false;
+
+  // Offset of Y used for accurate font positioning in GDI.
+  int y_offset_;
 };
 
 }  // namespace gfx
diff --git a/ui/gfx/switches.cc b/ui/gfx/switches.cc
index 1bf6fffae1614..36866a98d1d24 100644
--- a/ui/gfx/switches.cc
+++ b/ui/gfx/switches.cc
@@ -9,6 +9,11 @@
 
 namespace switches {
 
+#if BUILDFLAG(IS_WIN)
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+#endif
+
 // Scale factor to apply to every animation duration. Must be >= 0.0. This will
 // only apply to LinearAnimation and its subclasses.
 const char kAnimationDurationScale[] = "animation-duration-scale";
diff --git a/ui/gfx/switches.h b/ui/gfx/switches.h
index 98697d908f507..d7ee70f862826 100644
--- a/ui/gfx/switches.h
+++ b/ui/gfx/switches.h
@@ -18,6 +18,10 @@ GFX_SWITCHES_EXPORT extern const char kEnableNativeGpuMemoryBuffers[];
 GFX_SWITCHES_EXPORT extern const char kForcePrefersReducedMotion[];
 GFX_SWITCHES_EXPORT extern const char kHeadless[];
 
+#if BUILDFLAG(IS_WIN)
+GFX_SWITCHES_EXPORT extern const char kDisableDirectWrite[];
+#endif
+
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 GFX_SWITCHES_EXPORT extern const char kX11Display[];
 GFX_SWITCHES_EXPORT extern const char kNoXshm[];
diff --git a/ui/gfx/text_constants.h b/ui/gfx/text_constants.h
index eaa6ea0c42037..275bd3708da69 100644
--- a/ui/gfx/text_constants.h
+++ b/ui/gfx/text_constants.h
@@ -70,6 +70,8 @@ enum VerticalAlignment {
   ALIGN_TOP = 0,  // Align the text's top edge with that of its display area.
   ALIGN_MIDDLE,   // Align the text's center with that of its display area.
   ALIGN_BOTTOM,   // Align the text's bottom edge with that of its display area.
+  ALIGN_SPECIAL,  // Special alignment, equivalent to ALIGN_MIDDLE, but for the GDI renderer.
+  ALIGN_COMPACT,  // Another special alignment for #compact-ui tabs.
 };
 
 // The directionality modes used to determine the base text direction.
diff --git a/ui/gfx/win/direct_write.cc b/ui/gfx/win/direct_write.cc
index cf0f70a55333a..24643275b66d5 100644
--- a/ui/gfx/win/direct_write.cc
+++ b/ui/gfx/win/direct_write.cc
@@ -8,10 +8,12 @@
 
 #include <string>
 
+#include "base/command_line.h"
 #include "base/debug/alias.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/font_utils.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
@@ -19,8 +21,22 @@
 namespace gfx {
 namespace win {
 
+GFX_EXPORT bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-direct-write");;
+}
+
 namespace {
 
+static bool dwrite_enabled = false;
+
 // Pointer to the global IDWriteFactory interface.
 IDWriteFactory* g_direct_write_factory = nullptr;
 
@@ -35,9 +51,24 @@ void SetDirectWriteFactory(IDWriteFactory* factory) {
 }  // anonymous namespace
 
 void CreateDWriteFactory(IDWriteFactory** factory) {
+  if (!gfx::win::ShouldUseDirectWrite())
+    return;
+
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
+
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
   Microsoft::WRL::ComPtr<IUnknown> factory_unknown;
+
   HRESULT hr =
-      DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+      dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                           &factory_unknown);
   if (FAILED(hr)) {
     base::debug::Alias(&hr);
@@ -56,12 +87,43 @@ void InitializeDirectWrite() {
 
   Microsoft::WRL::ComPtr<IDWriteFactory> factory;
   CreateDWriteFactory(&factory);
-  CHECK(!!factory);
+  if (factory == nullptr) {
+	  sk_sp<SkFontMgr> direct_write_font_mgr = SkFontMgr_New_GDI();
+	  skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
+	  return;
+  }
   SetDirectWriteFactory(factory.Get());
 
+// The skia call to create a new DirectWrite font manager instance can fail
+  // if we are unable to get the system font collection from the DirectWrite
+  // factory. The GetSystemFontCollection method in the IDWriteFactory
+  // interface fails with E_INVALIDARG on certain Windows 7 gold versions
+  // (6.1.7600.*).
   sk_sp<SkFontMgr> direct_write_font_mgr =
       SkFontMgr_New_DirectWrite(factory.Get());
-  CHECK(!!direct_write_font_mgr);
+
+  int iteration = 0;
+  if (!direct_write_font_mgr &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    // Windows (win7_rtm) may fail to map the service sections
+    // (crbug.com/956064).
+    constexpr int kMaxRetries = 5;
+    constexpr base::TimeDelta kRetrySleepTime = base::Microseconds(500);
+    while (iteration < kMaxRetries) {
+      base::PlatformThread::Sleep(kRetrySleepTime);
+      direct_write_font_mgr = SkFontMgr_New_DirectWrite(factory.Get());
+      if (direct_write_font_mgr)
+        break;
+      ++iteration;
+    }
+  }
+  if (!direct_write_font_mgr)
+    iteration = -1;
+  DCHECK(!!direct_write_font_mgr);
+  if (!direct_write_font_mgr)
+    direct_write_font_mgr = SkFontMgr_New_GDI();
+  else
+	dwrite_enabled = true;
 
   // Override the default skia font manager. This must be called before any
   // use of the skia font manager is done (e.g. before any call to
@@ -69,6 +131,10 @@ void InitializeDirectWrite() {
   skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
 }
 
+bool IsDirectWriteEnabled() {
+  return dwrite_enabled;
+}
+
 IDWriteFactory* GetDirectWriteFactory() {
   // Some unittests may access this accessor without any previous call to
   // |InitializeDirectWrite|. A call to |InitializeDirectWrite| after this
@@ -142,4 +208,4 @@ absl::optional<std::string> RetrieveLocalizedFontName(
 }
 
 }  // namespace win
-}  // namespace gfx
+}  // namespace gfx
\ No newline at end of file
diff --git a/ui/gfx/win/direct_write.h b/ui/gfx/win/direct_write.h
index 72022056d29c4..88839b7621ce2 100644
--- a/ui/gfx/win/direct_write.h
+++ b/ui/gfx/win/direct_write.h
@@ -14,9 +14,15 @@
 namespace gfx {
 namespace win {
 
+// Returns whether DirectWrite font rendering should be used.
+GFX_EXPORT bool ShouldUseDirectWrite();
+
 GFX_EXPORT void InitializeDirectWrite();
 
-// Creates a DirectWrite factory.
+// Returns true if we are using DirectWrite for font metrics and rendering.
+GFX_EXPORT bool IsDirectWriteEnabled();
+
+// Creates a DirectWrite factory, if using DirectWrite.
 GFX_EXPORT void CreateDWriteFactory(IDWriteFactory** factory);
 
 // Returns the global DirectWrite factory.
diff --git a/ui/native_theme/caption_style_win.cc b/ui/native_theme/caption_style_win.cc
index 2c27d56f29eaa..9c314a5185c7f 100644
--- a/ui/native_theme/caption_style_win.cc
+++ b/ui/native_theme/caption_style_win.cc
@@ -14,6 +14,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/color_utils.h"
@@ -172,8 +173,18 @@ std::string GetCssColorWithAlpha(CC::ClosedCaptionColor caption_color,
 
 absl::optional<CaptionStyle> InitializeFromSystemSettings() {
   TRACE_EVENT0("ui", "InitializeFromSystemSettings");
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
   DCHECK(base::FeatureList::IsEnabled(features::kSystemCaptionStyle));
 
+  // Need to do this check before using ScopedHString.
+  bool can_use_scoped_hstring =
+      base::win::ResolveCoreWinRTDelayload() &&
+      base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!can_use_scoped_hstring)
+    return absl::nullopt;
+
+
   base::win::ScopedHString closed_caption_properties_string =
       base::win::ScopedHString::Create(
           RuntimeClass_Windows_Media_ClosedCaptioning_ClosedCaptionProperties);
@@ -270,10 +281,12 @@ absl::optional<CaptionStyle> InitializeFromSystemSettings() {
 }  // namespace
 
 absl::optional<CaptionStyle> CaptionStyle::FromSystemSettings() {
-  if (base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
     return InitializeFromSystemSettings();
   }
-  // Return default CaptionStyle if kSystemCaptionStyle is not enabled.
+  // Return default CaptionStyle for pre Win10 versions since system settings
+  // don't allow caption styling.
   return absl::nullopt;
 }
 
diff --git a/ui/native_theme/native_theme.cc b/ui/native_theme/native_theme.cc
index 17c3b9f659a3b..5beb81eafe785 100644
--- a/ui/native_theme/native_theme.cc
+++ b/ui/native_theme/native_theme.cc
@@ -7,6 +7,7 @@
 #include <cstring>
 
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/functional/bind.h"
 #include "base/logging.h"
@@ -249,7 +250,7 @@ void NativeTheme::SetPreferredContrast(
 bool NativeTheme::IsForcedDarkMode() {
   static bool kIsForcedDarkMode =
       base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode);
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag);
   return kIsForcedDarkMode;
 }
 
diff --git a/ui/native_theme/native_theme_win.cc b/ui/native_theme/native_theme_win.cc
index 50647269ec84f..4633d10f74e6c 100644
--- a/ui/native_theme/native_theme_win.cc
+++ b/ui/native_theme/native_theme_win.cc
@@ -268,26 +268,61 @@ void NativeThemeWin::Paint(cc::PaintCanvas* canvas,
   if (rect.IsEmpty())
     return;
 
-  switch (part) {
-    case kMenuPopupGutter:
-      PaintMenuGutter(canvas, color_provider, rect);
-      return;
-    case kMenuPopupSeparator:
-      PaintMenuSeparator(canvas, color_provider,
-                         absl::get<MenuSeparatorExtraParams>(extra));
-      return;
-    case kMenuPopupBackground:
-      PaintMenuBackground(canvas, color_provider, rect);
-      return;
-    case kMenuItemBackground:
-      CommonThemePaintMenuItemBackground(this, color_provider, canvas, state,
-                                         rect,
-                                         absl::get<MenuItemExtraParams>(extra));
-      return;
-    default:
-      PaintIndirect(canvas, part, state, rect, extra);
-      return;
+  if(!base::CommandLine::ForCurrentProcess()->HasSwitch("native-ui-style")) {
+	  switch (part) {
+		case kMenuPopupGutter:
+		  PaintMenuGutter(canvas, color_provider, rect);
+		  return;
+		case kMenuPopupSeparator:
+		  PaintMenuSeparator(canvas, color_provider,
+							 absl::get<MenuSeparatorExtraParams>(extra));
+		  return;
+		case kMenuPopupBackground:
+		  PaintMenuBackground(canvas, color_provider, rect);
+		  return;
+		case kMenuItemBackground:
+		  CommonThemePaintMenuItemBackground(this, color_provider, canvas, state,
+											 rect,
+											 absl::get<MenuItemExtraParams>(extra));
+		  return;
+		default:
+		  break;
+	  }
+  }
+
+  PaintIndirect(canvas, part, state, rect, extra);
+  return;
+}
+
+HRESULT PaintMenuItemBackgroundClassic(
+    HDC hdc,
+    NativeThemeWin::State state,
+    const gfx::Rect& rect,
+    const NativeThemeWin::MenuItemExtraParams& extra) {
+  HANDLE handle = OpenThemeData(nullptr, L"MENU_POPUPBACKGROUND");
+  RECT rect_win = rect.ToRECT();
+  int state_id = MPI_NORMAL;
+  switch (state) {
+    case NativeThemeWin::kDisabled:
+      state_id = extra.is_selected ? MPI_DISABLEDHOT : MPI_DISABLED;
+      break;
+    case NativeThemeWin::kHovered:
+      state_id = MPI_HOT;
+      break;
+    case NativeThemeWin::kNormal:
+      break;
+    case NativeThemeWin::kPressed:
+    case NativeThemeWin::kNumStates:
+      NOTREACHED();
+      break;
   }
+
+  if (handle)
+    return DrawThemeBackground(handle, hdc, MENU_POPUPITEM, state_id, &rect_win, NULL);
+
+  if (extra.is_selected)
+    FillRect(hdc, &rect_win, GetSysColorBrush(COLOR_HIGHLIGHT));
+  return S_OK;
 }
 
 NativeThemeWin::NativeThemeWin(bool configure_web_instance,
@@ -512,6 +547,8 @@ void NativeThemeWin::PaintDirect(SkCanvas* destination_canvas,
       case kTextField:
         break;  // Handled entirely below.
       case kMenuItemBackground:
+	     PaintMenuItemBackgroundClassic(hdc, state, rect, absl::get<MenuItemExtraParams>(extra));
+		 return;
       case kMenuPopupBackground:
       case kMenuPopupGutter:
       case kMenuPopupSeparator:
@@ -921,6 +958,46 @@ void NativeThemeWin::PaintScrollbarArrowClassic(HDC hdc,
                                                 Part part,
                                                 State state,
                                                 RECT* rect) const {
+  static const int state_id_matrix[4][4] = {
+      {ABS_DOWNDISABLED, ABS_DOWNHOT, ABS_DOWNNORMAL, ABS_DOWNPRESSED},
+	  {ABS_LEFTDISABLED, ABS_LEFTHOT, ABS_LEFTNORMAL, ABS_LEFTPRESSED},
+	  {ABS_RIGHTDISABLED, ABS_RIGHTHOT, ABS_RIGHTNORMAL, ABS_RIGHTPRESSED},
+	  {ABS_UPDISABLED, ABS_UPHOT, ABS_UPNORMAL, ABS_UPPRESSED}
+  };
+  HANDLE handle = OpenThemeData(nullptr, L"SCROLLBAR");
+  if (handle) {
+    int index = part - kScrollbarDownArrow;
+    DCHECK(index >=0 && index < 4);
+    int state_id = state_id_matrix[index][state];
+
+    // Hovering means that the cursor is over the scroolbar, but not over the
+    // specific arrow itself.  We don't want to show it "hot" mode, but only
+    // in "hover" mode.
+	/*
+    if (state == kHovered && extra.is_hovering) {
+      switch (part) {
+        case kScrollbarDownArrow:
+          state_id = ABS_DOWNHOVER;
+          break;
+        case kScrollbarLeftArrow:
+          state_id = ABS_LEFTHOVER;
+          break;
+        case kScrollbarRightArrow:
+          state_id = ABS_RIGHTHOVER;
+          break;
+        case kScrollbarUpArrow:
+          state_id = ABS_UPHOVER;
+          break;
+        default:
+          NOTREACHED() << "Invalid part: " << part;
+          break;
+      }
+    }
+    */
+    DrawThemeBackground(handle, hdc, SBP_ARROWBTN, state_id, rect, NULL);
+	return;
+  }
+
   int classic_state = DFCS_SCROLLDOWN;
   switch (part) {
     case kScrollbarDownArrow:
@@ -954,7 +1031,8 @@ void NativeThemeWin::PaintScrollbarArrowClassic(HDC hdc,
       NOTREACHED();
       break;
   }
-  DrawFrameControl(hdc, rect, DFC_SCROLL, classic_state);
+
+  DrawFrameControl(hdc, rect, DFC_SCROLL, classic_state | DFCS_BUTTONPUSH);
 }
 
 void NativeThemeWin::PaintScrollbarTrackClassic(
diff --git a/ui/shell_dialogs/execute_select_file_win.cc b/ui/shell_dialogs/execute_select_file_win.cc
index 9361287ac3411..bd0eea9c913e0 100644
--- a/ui/shell_dialogs/execute_select_file_win.cc
+++ b/ui/shell_dialogs/execute_select_file_win.cc
@@ -4,6 +4,8 @@
 
 #include "ui/shell_dialogs/execute_select_file_win.h"
 
+#include <Windows.h>
+#include <commdlg.h>
 #include <shlobj.h>
 #include <wrl/client.h>
 
@@ -166,6 +168,216 @@ bool ConfigureDialog(IFileDialog* file_dialog,
          SetFilters(file_dialog, filter, filter_index);
 }
 
+// Configures a |file_dialog| object given the specified parameters.
+bool ConfigureDialog_Legacy(OPENFILENAME_NT4W* open_file_name,
+                     const std::u16string& title,
+					 const base::FilePath& default_path,
+                     const std::vector<FileFilterSpec>& filter,
+                     DWORD dialog_options) {
+  std::u16string filter_buffer;
+  open_file_name->lStructSize = sizeof(OPENFILENAME_NT4W);
+  // Set title.
+  if (!title.empty()) {
+    open_file_name->lpstrTitle = (LPCWSTR)title.c_str();
+  }
+
+  if (dialog_options & FOS_ALLOWMULTISELECT) {
+	open_file_name->Flags |= OFN_ALLOWMULTISELECT;
+  }
+
+  if (!default_path.empty()) {
+        open_file_name->lpstrInitialDir = (LPCWSTR)default_path.value().c_str();
+  }
+
+  if (filter.empty())
+    return true;
+
+  open_file_name->lpstrFilter = NULL;
+  filter_buffer.clear();
+
+ for (const auto& filter_spec : filter) {
+	std::u16string filter_str = filter_spec.extension_spec;
+    filter_buffer.append(filter_str);
+  }
+  filter_buffer.push_back(0);
+
+  PWSTR c_filter_buffer = (PWSTR) ::HeapAlloc(::GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WCHAR)*filter_buffer.length());
+
+  for (size_t i = 0; i < filter_buffer.length(); i++)
+  {
+	  c_filter_buffer[i] = filter_buffer.at(i);
+  }
+
+  open_file_name->lpstrFilter = c_filter_buffer;
+
+  return true;
+}
+
+struct SelectFolderDialogOptions {
+  const wchar_t* default_path;
+  bool is_upload;
+};
+
+int CALLBACK BrowseCallbackProc(HWND window,
+                                UINT message,
+                                LPARAM parameter,
+                                LPARAM data) {
+  if (message == BFFM_INITIALIZED) {
+    SelectFolderDialogOptions* options =
+        reinterpret_cast<SelectFolderDialogOptions*>(data);
+    if (options->is_upload) {
+      SendMessage(window, BFFM_SETOKTEXT, 0,
+                  reinterpret_cast<LPARAM>(
+                      l10n_util::GetStringUTF16(
+                          IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON)
+                          .c_str()));
+    }
+    if (options->default_path) {
+      SendMessage(window, BFFM_SETSELECTION, TRUE,
+                  reinterpret_cast<LPARAM>(options->default_path));
+    }
+  }
+  return 0;
+}
+
+// Runs a Folder selection dialog box, passes back the selected folder in |path|
+// and returns true if the user clicks OK. If the user cancels the dialog box
+// the value in |path| is not modified and returns false. Run on the dialog
+// thread.
+bool ExecuteFolder_Legacy(HWND owner,
+                           const std::u16string& title,
+                           const base::FilePath& default_path,
+                           std::vector<base::FilePath>* paths) {
+  base::FilePath result_path;
+  base::win::AssertComInitialized();
+  DCHECK(paths);
+  std::u16string new_title = title;
+  wchar_t dir_buffer[MAX_PATH + 1];
+
+  bool result = false;
+  BROWSEINFO browse_info = {};
+  browse_info.hwndOwner = owner;
+  browse_info.lpszTitle = (LPCWSTR)new_title.c_str();
+  browse_info.pszDisplayName = dir_buffer;
+  browse_info.ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS;
+
+  // If uploading or a default path was provided, update the BROWSEINFO
+  // and set the callback function for the dialog so the strings can be set in
+  // the callback.
+  SelectFolderDialogOptions dialog_options = {};
+  if (!default_path.empty())
+    dialog_options.default_path = default_path.value().c_str();
+  browse_info.ulFlags |= BIF_NONEWFOLDERBUTTON;
+
+  if (dialog_options.default_path) {
+    browse_info.lParam = reinterpret_cast<LPARAM>(&dialog_options);
+    browse_info.lpfn = &BrowseCallbackProc;
+  }
+
+  LPITEMIDLIST list = SHBrowseForFolderW(&browse_info);
+  BaseShellDialogImpl::DisableOwner(owner);
+  if (list) {
+    STRRET out_dir_buffer = {};
+    out_dir_buffer.uType = STRRET_WSTR;
+    Microsoft::WRL::ComPtr<IShellFolder> shell_folder;
+    if (SUCCEEDED(SHGetDesktopFolder(&shell_folder))) {
+      HRESULT hr = shell_folder->GetDisplayNameOf(list, SHGDN_FORPARSING,
+                                                  &out_dir_buffer);
+      if (SUCCEEDED(hr) && out_dir_buffer.uType == STRRET_WSTR) {
+        paths->push_back(base::FilePath(out_dir_buffer.pOleStr));
+        CoTaskMemFree(out_dir_buffer.pOleStr);
+        result = true;
+      } else {
+        // Use old way if we don't get what we want.
+        wchar_t old_out_dir_buffer[MAX_PATH + 1];
+        if (SHGetPathFromIDList(list, old_out_dir_buffer)) {
+          paths->push_back(base::FilePath(old_out_dir_buffer));
+          result = true;
+        }
+      }
+
+      // According to MSDN, Win2000 will not resolve shortcuts, so we do it
+      // ourselves.
+      base::win::ResolveShortcut(paths->at(0), &paths->at(0), nullptr);
+
+    }
+    CoTaskMemFree(list);
+  }
+  return result;
+}
+
+// static
+std::vector<std::tuple<std::u16string, std::u16string>>
+GetFilters(const OPENFILENAME* openfilename) {
+  std::vector<std::tuple<std::u16string, std::u16string>> filters;
+
+  const char16_t* display_string = (char16_t*)openfilename->lpstrFilter;
+  if (!display_string)
+    return filters;
+
+  while (*display_string) {
+    const char16_t* display_string_end = display_string;
+    while (*display_string_end)
+      ++display_string_end;
+    const char16_t* pattern = display_string_end + 1;
+    const char16_t* pattern_end = pattern;
+    while (*pattern_end)
+      ++pattern_end;
+    filters.push_back(
+        std::make_tuple(std::u16string(display_string, display_string_end),
+                  std::u16string(pattern, pattern_end)));
+    display_string = pattern_end + 1;
+  }
+
+  return filters;
+}
+
+// Given |extension|, if it's not empty, then remove the leading dot.
+std::wstring GetExtensionWithoutLeadingDot(const std::wstring& extension) {
+  DCHECK(extension.empty() || extension[0] == L'.');
+  return extension.empty() ? extension : extension.substr(1);
+}
+
+// This function takes the output of a SaveAs dialog: a filename, a filter and
+// the extension originally suggested to the user (shown in the dialog box) and
+// returns back the filename with the appropriate extension appended. If the
+// user requests an unknown extension and is not using the 'All files' filter,
+// the suggested extension will be appended, otherwise we will leave the
+// filename unmodified. |filename| should contain the filename selected in the
+// SaveAs dialog box and may include the path, |filter_selected| should be
+// '*.something', for example '*.*' or it can be blank (which is treated as
+// *.*). |suggested_ext| should contain the extension without the dot (.) in
+// front, for example 'jpg'.
+std::wstring AppendExtensionIfNeeded(const std::wstring& filename,
+                                     const std::wstring& filter_selected,
+                                     const std::wstring& suggested_ext) {
+  DCHECK(!filename.empty());
+  std::wstring return_value = filename;
+
+  // If we wanted a specific extension, but the user's filename deleted it or
+  // changed it to something that the system doesn't understand, re-append.
+  // Careful: Checking net::GetMimeTypeFromExtension() will only find
+  // extensions with a known MIME type, which many "known" extensions on Windows
+  // don't have.  So we check directly for the "known extension" registry key.
+  std::wstring file_extension(
+      GetExtensionWithoutLeadingDot(base::FilePath(filename).Extension()));
+  std::wstring key(L"." + file_extension);
+  if (!(filter_selected.empty() || filter_selected == L"*.*") &&
+      !base::win::RegKey(HKEY_CLASSES_ROOT, key.c_str(), KEY_READ).Valid() &&
+      file_extension != suggested_ext) {
+    if (return_value.back() != L'.')
+      return_value.append(L".");
+    return_value.append(suggested_ext);
+  }
+
+  // Strip any trailing dots, which Windows doesn't allow.
+  size_t index = return_value.find_last_not_of(L'.');
+  if (index < return_value.size() - 1)
+    return_value.resize(index + 1);
+
+  return return_value;
+}
+
 // Prompt the user for location to save a file.
 // Callers should provide the filter string, and also a filter index.
 // The parameter |index| indicates the initial index of filter description and
@@ -185,56 +397,144 @@ bool RunSaveFileDialog(HWND owner,
                        int* filter_index,
                        base::FilePath* path) {
   Microsoft::WRL::ComPtr<IFileSaveDialog> file_save_dialog;
+  bool use_legacy_dialogs = false;
+  OPENFILENAME_NT4W open_file_name = {0};
   if (FAILED(::CoCreateInstance(CLSID_FileSaveDialog, nullptr,
                                 CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARGS(&file_save_dialog)))) {
-    return false;
-  }
-
-  if (!ConfigureDialog(file_save_dialog.Get(), title, std::u16string(),
-                       default_path, filter, *filter_index, dialog_options)) {
-    return false;
+    use_legacy_dialogs = true;
   }
 
-  file_save_dialog->SetDefaultExtension(def_ext.c_str());
-
-  // This handler auto-closes the file dialog if its owner window is closed.
-  auto auto_close_dialog_event_handler =
-      std::make_unique<ScopedAutoCloseDialogEventHandler>(
-          owner, file_save_dialog.Get());
-
-  // Never consider the current scope as hung. The hang watching deadline (if
-  // any) is not valid since the user can take unbounded time to choose the
-  // file.
-  base::HangWatcher::InvalidateActiveExpectations();
-
-  HRESULT hr = file_save_dialog->Show(owner);
-  BaseShellDialogImpl::DisableOwner(owner);
-
-  // Remove the event handler regardless of the return value of Show().
-  auto_close_dialog_event_handler = nullptr;
-
-  if (FAILED(hr))
-    return false;
-
-  UINT file_type_index;
-  if (FAILED(file_save_dialog->GetFileTypeIndex(&file_type_index)))
-    return false;
-
-  *filter_index = static_cast<int>(file_type_index);
-
-  Microsoft::WRL::ComPtr<IShellItem> result;
-  if (FAILED(file_save_dialog->GetResult(&result)))
-    return false;
-
-  base::win::ScopedCoMem<wchar_t> display_name;
-  if (FAILED(result->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
-                                    &display_name))) {
-    return false;
+  if (!use_legacy_dialogs) {
+	  if (!ConfigureDialog(file_save_dialog.Get(), title, std::u16string(),
+						   default_path, filter, *filter_index, dialog_options)) {
+		return false;
+	  }
+	} else {
+	  ConfigureDialog_Legacy(&open_file_name, title, default_path, filter, dialog_options);
+   }
+  if (!use_legacy_dialogs) {
+	  file_save_dialog->SetDefaultExtension(def_ext.c_str());
+
+	  // This handler auto-closes the file dialog if its owner window is closed.
+	  auto auto_close_dialog_event_handler =
+		  std::make_unique<ScopedAutoCloseDialogEventHandler>(
+			  owner, file_save_dialog.Get());
+	  // Never consider the current scope as hung. The hang watching deadline (if
+	  // any) is not valid since the user can take unbounded time to choose the
+	  // file.
+      base::HangWatcher::InvalidateActiveExpectations();
+	  HRESULT hr = file_save_dialog->Show(owner);
+	  BaseShellDialogImpl::DisableOwner(owner);
+
+	  // Remove the event handler regardless of the return value of Show().
+	  auto_close_dialog_event_handler = nullptr;
+
+	  if (FAILED(hr))
+		return false;
+
+	  UINT file_type_index;
+	  if (FAILED(file_save_dialog->GetFileTypeIndex(&file_type_index)))
+		return false;
+
+	  *filter_index = static_cast<int>(file_type_index);
+
+	  Microsoft::WRL::ComPtr<IShellItem> result;
+	  if (FAILED(file_save_dialog->GetResult(&result)))
+		return false;
+
+	  base::win::ScopedCoMem<wchar_t> display_name;
+	  if (FAILED(result->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
+										&display_name))) {
+		return false;
+	  }
+
+	  *path = base::FilePath(display_name.get());
+	  return true;
+  } else {
+	  base::HangWatcher::InvalidateActiveExpectations();
+	  open_file_name.hwndOwner = owner;
+	  open_file_name.Flags |= OFN_OVERWRITEPROMPT | OFN_EXPLORER |
+							  OFN_ENABLESIZING | OFN_NOCHANGEDIR |
+						      OFN_PATHMUSTEXIST;
+      wchar_t filename_buffer [UNICODE_STRING_MAX_CHARS];
+	  filename_buffer[0] = L'\0';
+	  if (!default_path.empty()) {
+		base::FilePath suggested_file_name;
+		base::FilePath suggested_directory;
+		if (IsDirectory(default_path)) {
+		  suggested_directory = default_path;
+		} else {
+		  suggested_directory = default_path.DirName();
+		  suggested_file_name = default_path.BaseName();
+		  // If the default_path is a root directory, |suggested_file_name| will be
+		  // '\', and the call to GetSaveFileName below will fail.
+		  if (suggested_file_name.value() == L"\\")
+			suggested_file_name.clear();
+		}
+		  open_file_name.lpstrInitialDir = NULL;
+
+		  if (!suggested_directory.empty()) {
+		  open_file_name.lpstrInitialDir = suggested_directory.value().c_str();
+
+			  if (!suggested_file_name.empty()) {
+			  // The filename is ignored if no initial directory is supplied.
+				  base::wcslcpy(filename_buffer,
+								suggested_file_name.value().c_str(),
+								sizeof(filename_buffer));
+			  }
+		  }
+	  }
+	  open_file_name.lpstrFile = filename_buffer;
+	  open_file_name.nMaxFile = UNICODE_STRING_MAX_CHARS;
+      if (!filter.empty() && ((int)filter.size() - 1) < *filter_index) {
+            *filter_index = filter.size() - 1;
+          }
+	 // open_file_name.lpstrFilter =
+	//	  filter.empty() ? nullptr : (LPCWSTR)filter.at(*filter_index).extension_spec.c_str();
+	  open_file_name.nFilterIndex = *filter_index;
+	  open_file_name.lpstrDefExt = &def_ext[0];
+
+	  BOOL success = ::GetSaveFileNameW((OPENFILENAMEW*)&open_file_name);
+
+	  if(open_file_name.lpstrFilter) {
+		  ::HeapFree(::GetProcessHeap(), 0, (LPVOID)open_file_name.lpstrFilter);
+		  open_file_name.lpstrFilter = nullptr;
+	  }
+	  BaseShellDialogImpl::DisableOwner(owner);
+	  if (!success)
+		return false;
+
+	  // Return the user's choice.
+	  //*path = base::FilePath(open_file_name.lpstrFile);
+	  *filter_index = open_file_name.nFilterIndex;
+
+	  // Figure out what filter got selected. The filter index is 1-based.
+	  std::u16string filter_selected;
+	  if (*filter_index > 0) {
+		std::vector<std::tuple<std::u16string, std::u16string>> filters =
+			GetFilters((OPENFILENAMEW*)&open_file_name);
+		if (*filter_index > (long long)filters.size())
+		  NOTREACHED() << "Invalid filter index.";
+		else
+		  filter_selected = std::get<1>(filters[*filter_index - 1]);
+	  }
+
+	  // Get the extension that was suggested to the user (when the Save As dialog
+	  // was opened).
+	  std::wstring suggested_ext = GetExtensionWithoutLeadingDot(default_path.Extension());
+
+	  // If we can't get the extension from the default_path, we use the default
+	  // extension passed in. This is to cover cases like when saving a web page,
+	  // where we get passed in a name without an extension and a default extension
+	  // along with it.
+	  if (suggested_ext.empty())
+		suggested_ext.append(def_ext);
+
+	  *path = base::FilePath(
+		  AppendExtensionIfNeeded(base::FilePath(open_file_name.lpstrFile).value(), std::wstring(filter_selected.begin(), filter_selected.end()), suggested_ext));
+	  return true;
   }
-
-  *path = base::FilePath(display_name.get());
-  return true;
 }
 
 // Runs an Open file dialog box, with similar semantics for input parameters as
@@ -248,10 +548,12 @@ bool RunOpenFileDialog(HWND owner,
                        int* filter_index,
                        std::vector<base::FilePath>* paths) {
   Microsoft::WRL::ComPtr<IFileOpenDialog> file_open_dialog;
+  bool use_legacy_dialogs = false;
+  OPENFILENAME_NT4W open_file_name = {0};
   if (FAILED(::CoCreateInstance(CLSID_FileOpenDialog, nullptr,
                                 CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARGS(&file_open_dialog)))) {
-    return false;
+    use_legacy_dialogs = true;
   }
 
   // The FOS_FORCEFILESYSTEM option ensures that if the user enters a URL in the
@@ -260,64 +562,124 @@ bool RunOpenFileDialog(HWND owner,
   // GetOpenFileName API.
   dialog_options |= FOS_FORCEFILESYSTEM;
 
-  if (!ConfigureDialog(file_open_dialog.Get(), title, ok_button_label,
-                       default_path, filter, *filter_index, dialog_options)) {
-    return false;
+  if(!use_legacy_dialogs) {
+	  if (!ConfigureDialog(file_open_dialog.Get(), title, ok_button_label,
+						   default_path, filter, *filter_index, dialog_options)) {
+		return false;
+	  }
+  } else {
+	  if (dialog_options & FOS_PICKFOLDERS)
+		  return ExecuteFolder_Legacy(owner, title, default_path, paths);
+	  ConfigureDialog_Legacy(&open_file_name, title, default_path, filter, dialog_options);
   }
 
-  // This handler auto-closes the file dialog if its owner window is closed.
-  auto auto_close_dialog_event_handler =
-      std::make_unique<ScopedAutoCloseDialogEventHandler>(
-          owner, file_open_dialog.Get());
+  if (!use_legacy_dialogs) {
+          // This handler auto-closes the file dialog if its owner window is
+          // closed.
+      auto auto_close_dialog_event_handler =
+              std::make_unique<ScopedAutoCloseDialogEventHandler>(
+                  owner, file_open_dialog.Get());
 
-  // Never consider the current scope as hung. The hang watching deadline (if
-  // any) is not valid since the user can take unbounded time to choose the
-  // file.
-  base::HangWatcher::InvalidateActiveExpectations();
+	  // Never consider the current scope as hung. The hang watching deadline (if
+	  // any) is not valid since the user can take unbounded time to choose the
+	  // file.
+	  base::HangWatcher::InvalidateActiveExpectations();
 
-  HRESULT hr = file_open_dialog->Show(owner);
-  BaseShellDialogImpl::DisableOwner(owner);
+	  HRESULT hr = file_open_dialog->Show(owner);
+	  BaseShellDialogImpl::DisableOwner(owner);
 
-  // Remove the event handler regardless of the return value of Show().
-  auto_close_dialog_event_handler = nullptr;
+	  // Remove the event handler regardless of the return value of Show().
+	  auto_close_dialog_event_handler = nullptr;
 
-  if (FAILED(hr))
-    return false;
+	  if (FAILED(hr))
+		return false;
 
-  UINT file_type_index;
-  if (FAILED(file_open_dialog->GetFileTypeIndex(&file_type_index)))
-    return false;
+	  UINT file_type_index;
+	  if (FAILED(file_open_dialog->GetFileTypeIndex(&file_type_index)))
+		return false;
 
-  *filter_index = static_cast<int>(file_type_index);
+	  *filter_index = static_cast<int>(file_type_index);
 
-  Microsoft::WRL::ComPtr<IShellItemArray> selected_items;
-  if (FAILED(file_open_dialog->GetResults(&selected_items)))
-    return false;
+	  Microsoft::WRL::ComPtr<IShellItemArray> selected_items;
+	  if (FAILED(file_open_dialog->GetResults(&selected_items)))
+		return false;
 
-  DWORD result_count;
-  if (FAILED(selected_items->GetCount(&result_count)))
-    return false;
+	  DWORD result_count;
+	  if (FAILED(selected_items->GetCount(&result_count)))
+		return false;
 
-  DCHECK(result_count == 1 || (dialog_options & FOS_ALLOWMULTISELECT));
+	  DCHECK(result_count == 1 || (dialog_options & FOS_ALLOWMULTISELECT));
 
-  std::vector<base::FilePath> result(result_count);
-  for (DWORD i = 0; i < result_count; ++i) {
-    Microsoft::WRL::ComPtr<IShellItem> shell_item;
-    if (FAILED(selected_items->GetItemAt(i, &shell_item)))
-      return false;
+	  std::vector<base::FilePath> result(result_count);
+	  for (DWORD i = 0; i < result_count; ++i) {
+		Microsoft::WRL::ComPtr<IShellItem> shell_item;
+		if (FAILED(selected_items->GetItemAt(i, &shell_item)))
+		  return false;
 
-    base::win::ScopedCoMem<wchar_t> display_name;
-    if (FAILED(shell_item->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
-                                          &display_name))) {
-      return false;
-    }
+		base::win::ScopedCoMem<wchar_t> display_name;
+		if (FAILED(shell_item->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
+											  &display_name))) {
+		  return false;
+		}
 
-    result[i] = base::FilePath(display_name.get());
-  }
+		result[i] = base::FilePath(display_name.get());
+	  }
 
-  // Only modify the out parameter if the enumeration didn't fail.
-  *paths = std::move(result);
-  return !paths->empty();
+	  // Only modify the out parameter if the enumeration didn't fail.
+	  *paths = std::move(result);
+	  return !paths->empty();
+  } else {
+	  base::HangWatcher::InvalidateActiveExpectations();
+	  wchar_t filename_buffer [UNICODE_STRING_MAX_CHARS];
+	  filename_buffer[0] = '\0';
+	  open_file_name.hwndOwner = owner;
+	  open_file_name.lpstrFile = filename_buffer;
+	  open_file_name.nMaxFile = UNICODE_STRING_MAX_CHARS;
+	  open_file_name.Flags |= OFN_EXPLORER | OFN_HIDEREADONLY;
+	  bool success = ::GetOpenFileNameW((OPENFILENAMEW*)&open_file_name);
+	  BaseShellDialogImpl::DisableOwner(owner);
+
+	  if(open_file_name.lpstrFilter) {
+		  ::HeapFree(::GetProcessHeap(), 0, (LPVOID)open_file_name.lpstrFilter);
+		  open_file_name.lpstrFilter = nullptr;
+	  }
+
+	  if(success) {
+		  base::FilePath directory;
+          std::vector<base::FilePath> filenames;
+		  const wchar_t* selection = open_file_name.lpstrFile;
+		  // The return value of |open_file_name.lpstrFile| is dependent on the
+		  // value of the Multi-Select flag within |open_file_name|. If the flag is
+		  // not set the return value will be a single null-terminated wide string.
+		  // If it is set it will be more than one null-terminated wide string, itself
+		  // terminated by an empty null-terminated wide string.
+		  if (open_file_name.Flags & OFN_ALLOWMULTISELECT) {
+			while (*selection) {  // Empty string indicates end of list.
+			  filenames.push_back(base::FilePath(selection));
+			  // Skip over filename and null-terminator.
+			  selection += filenames.back().value().length() + 1;
+			}
+		  } else {
+			filenames.push_back(base::FilePath(selection));
+		  }
+		  if (filenames.size() == 1) {
+			// When there is one file, it contains the path and filename.
+			directory = filenames.at(0).DirName();
+			filenames.at(0) = filenames.at(0).BaseName();
+		  } else if (filenames.size() > 1) {
+			// Otherwise, the first string is the path, and the remainder are
+			// filenames.
+			directory = filenames.at(0);
+			filenames.erase(filenames.begin());
+		  }
+		 for (std::vector<base::FilePath>::iterator it = filenames.begin();
+			   it != filenames.end(); ++it) {
+			paths->push_back(directory.Append(*it));
+		  }
+	  }
+
+	   return !paths->empty();
+   }
 }
 
 // Runs a Folder selection dialog box, passes back the selected folder in |path|
diff --git a/ui/snapshot/snapshot_win.cc b/ui/snapshot/snapshot_win.cc
index 37b31f022ef3c..bdf1269919100 100644
--- a/ui/snapshot/snapshot_win.cc
+++ b/ui/snapshot/snapshot_win.cc
@@ -27,6 +27,7 @@ void GrabHwndSnapshot(HWND window_handle,
                       const gfx::Rect& snapshot_bounds_in_pixels,
                       const gfx::Rect& clip_rect_in_pixels,
                       gfx::Image* image) {
+  BOOL result = false;
   gfx::Rect snapshot_bounds_in_window =
       snapshot_bounds_in_pixels + clip_rect_in_pixels.OffsetFromOrigin();
   gfx::Size bitmap_size(snapshot_bounds_in_window.right(),
@@ -42,7 +43,31 @@ void GrabHwndSnapshot(HWND window_handle,
   // the window that are drawn using DirectComposition.
   UINT flags = PW_CLIENTONLY | PW_RENDERFULLCONTENT;
 
-  BOOL result = PrintWindow(window_handle, mem_hdc, flags);
+  if (base::win::GetVersion() >= base::win::Version::WIN8_1){
+	result = PrintWindow(window_handle, mem_hdc, flags);
+  }
+  else {
+	// PrintWindow does not work for pre-Windows 8.1. So we'll use BitBlt.
+	// Copying from the window's actual HDC doesn't work so let's just use the full screen HDC.
+	// When a snapshot is captured the focus should be on the browser window anyway.
+	HDC window_hdc = GetDC(NULL);
+
+	RECT window_rect;
+
+	memset(&window_rect, 0, sizeof(RECT));
+
+	result = GetWindowRect(window_handle, &window_rect);
+
+	 if (!result) {
+    PLOG(ERROR) << "Failed to get valid rect for snapshot area.";
+    return;
+    }
+	// The left of the snapshot "window" rect is offset by 8 pixels to remove a bit of the dark grey showing through.
+	result = BitBlt(mem_hdc, 0, 0, bitmap_size.width(), bitmap_size.height(),
+					window_hdc, window_rect.left + 8, window_rect.top, SRCCOPY);
+
+	DeleteDC(window_hdc);
+  }
   if (!result) {
     PLOG(ERROR) << "Failed to print window";
     return;
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 3600dd711ffdd..6d705c31a7027 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -764,6 +764,7 @@ component("views") {
       "accessibility/ax_widget_obj_wrapper.h",
       "accessibility/ax_window_obj_wrapper.h",
       "controls/native/native_view_host_aura.h",
+      "corewm/cursor_height_provider_win.h",
       "corewm/tooltip.h",
       "corewm/tooltip_controller.h",
       "corewm/tooltip_state_manager.h",
@@ -808,6 +809,13 @@ component("views") {
       "widget/window_reorderer.cc",
       "windows_stationarity_monitor_aura.cc",
     ]
+    if (is_win) {
+      public += [ "corewm/tooltip_win.h" ]
+      sources += [
+        "corewm/cursor_height_provider_win.cc",
+        "corewm/tooltip_win.cc",
+      ]
+    }
     if (!is_chromeos_ash) {
       sources += [
         "accessibility/views_ax_tree_manager.cc",
diff --git a/ui/views/controls/combobox/combobox.cc b/ui/views/controls/combobox/combobox.cc
index 43dbb0cbb9c04..323fedf58344d 100644
--- a/ui/views/controls/combobox/combobox.cc
+++ b/ui/views/controls/combobox/combobox.cc
@@ -52,6 +52,10 @@
 #include "ui/views/view_utils.h"
 #include "ui/views/widget/widget.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace views {
 
 namespace {
@@ -643,7 +647,14 @@ void Combobox::PaintIconAndText(gfx::Canvas* canvas) {
 
   gfx::Rect text_bounds(x, y, text_width, contents_height);
   AdjustBoundsForRTLUI(&text_bounds);
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled())
+	canvas->DrawStringRectWithFlags(text, font_list, text_color, text_bounds, gfx::Canvas::GDI_OFFSET_RENDERING);
+  else
+	canvas->DrawStringRect(text, font_list, text_color, text_bounds);
+  #else
   canvas->DrawStringRect(text, font_list, text_color, text_bounds);
+  #endif
 
   // Draw the arrow.
   // TODO(crbug.com/1392549): Replace placeholder spacing and color values for
diff --git a/ui/views/controls/label.cc b/ui/views/controls/label.cc
index bee3e8a14eb85..16ef9ce056c3b 100644
--- a/ui/views/controls/label.cc
+++ b/ui/views/controls/label.cc
@@ -11,6 +11,7 @@
 #include <limits>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/strings/string_split.h"
 #include "base/strings/utf_string_conversions.h"
@@ -39,6 +40,10 @@
 #include "ui/views/selection_controller.h"
 #include "ui/views/style/typography_provider.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace {
 
 // An enum giving different RenderText properties unique keys for the
@@ -805,7 +810,18 @@ int Label::GetFontListY() const {
 
 void Label::PaintText(gfx::Canvas* canvas) {
   MaybeBuildDisplayText();
-
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled()) {
+    if (text_context_ == style::CONTEXT_BUTTON || text_context_ == style::CONTEXT_LABEL ||
+			text_context_ == style::CONTEXT_BUTTON_MD)
+	  display_text_->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+    // The bookmark bar labels and some of the side text in the menus are CONTEXT_BUTTON.
+	// The "new tab" labels are CONTEXT_LABEL.
+	// Of note, some UI elements such as the placeholder text in the address bar were not being
+	// having the proper offset applied so the few elements that do not require offsets are
+	// singled out and the rest are given the 4px offset.
+  }
+  #endif
   if (display_text_)
     display_text_->Draw(canvas);
 
diff --git a/ui/views/controls/scrollbar/scroll_bar.cc b/ui/views/controls/scrollbar/scroll_bar.cc
index 9ecb251570e68..f4fe1907fdcef 100644
--- a/ui/views/controls/scrollbar/scroll_bar.cc
+++ b/ui/views/controls/scrollbar/scroll_bar.cc
@@ -438,6 +438,11 @@ void ScrollBar::TrackClicked() {
 
 void ScrollBar::ScrollContentsToOffset() {
   ScrollToPosition(contents_scroll_offset_);
+  // Safeguard against a divide-by-zero bug that happens when separating
+  // multiple tabs into separate windows.
+  contents_size_ = std::max(1, contents_size_);
+  viewport_size_ = std::max(1, viewport_size_);
+
   thumb_->SetPosition(CalculateThumbPosition(contents_scroll_offset_));
 }
 
@@ -459,6 +464,7 @@ int ScrollBar::CalculateThumbPosition(int contents_scroll_offset) const {
   if (viewport_size_ == contents_size_) {
     return 0;
   }
+
   return (contents_scroll_offset * thumb_max) /
          (contents_size_ - viewport_size_);
 }
diff --git a/ui/views/controls/textfield/textfield.cc b/ui/views/controls/textfield/textfield.cc
index 81d64b019fce3..82b3cde1d081e 100644
--- a/ui/views/controls/textfield/textfield.cc
+++ b/ui/views/controls/textfield/textfield.cc
@@ -82,6 +82,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/win_util.h"
+#include "ui/gfx/win/direct_write.h"
 #endif
 
 #if BUILDFLAG(IS_LINUX)
@@ -615,7 +616,11 @@ void Textfield::FitToLocalBounds() {
     // the vertical insets.
     bounds.Inset(gfx::Insets::TLBR(0, insets.left(), 0, insets.right()));
   }
-
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled()) {
+	   GetRenderText()->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+  }
+  #endif
   bounds.set_x(GetMirroredXForRect(bounds));
   GetRenderText()->SetDisplayRect(bounds);
   UpdateAfterChange(TextChangeType::kNone, true);
@@ -1821,6 +1826,7 @@ bool Textfield::ChangeTextDirectionAndLayoutAlignment(
       modes_match && GetHorizontalAlignment() == gfx::ALIGN_TO_HEAD;
   if (!dir_from_text && GetHorizontalAlignment() != gfx::ALIGN_CENTER)
     SetHorizontalAlignment(default_rtl ? gfx::ALIGN_RIGHT : gfx::ALIGN_LEFT);
+
   SchedulePaint();
   return true;
 }
@@ -2703,6 +2709,13 @@ void Textfield::PaintTextAndCursor(gfx::Canvas* canvas) {
     if (SkColorGetA(GetBackgroundColor()) != SK_AlphaOPAQUE)
       placeholder_text_draw_flags |= gfx::Canvas::NO_SUBPIXEL_RENDERING;
 
+    #if BUILDFLAG(IS_WIN)
+    if (!gfx::win::IsDirectWriteEnabled()) {
+	   render_text->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+	   placeholder_text_draw_flags |= gfx::Canvas::GDI_OFFSET_RENDERING;
+    }
+    #endif
+
     canvas->DrawStringRectWithFlags(
         GetPlaceholderText(), placeholder_font_list_.value_or(GetFontList()),
         placeholder_text_color_.value_or(
diff --git a/ui/views/views_features.cc b/ui/views/views_features.cc
index e4314c4d46b43..ea5fd1688e907 100644
--- a/ui/views/views_features.cc
+++ b/ui/views/views_features.cc
@@ -42,4 +42,9 @@ BASE_FEATURE(kWidgetLayering,
              "WidgetLayering",
              base::FEATURE_ENABLED_BY_DEFAULT);
 
+// When enabled, widgets inherit the theme from their parent widget.
+BASE_FEATURE(kInheritNativeThemeFromParentWidget,
+			 "InheritNativeThemeFromParentWidget",
+			 base::FEATURE_ENABLED_BY_DEFAULT);
+
 }  // namespace views::features
diff --git a/ui/views/views_features.h b/ui/views/views_features.h
index 0e01068424722..622765401a806 100644
--- a/ui/views/views_features.h
+++ b/ui/views/views_features.h
@@ -17,6 +17,7 @@ VIEWS_EXPORT BASE_DECLARE_FEATURE(kEnablePlatformHighContrastInkDrop);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kEnableViewPaintOptimization);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kKeyboardAccessibleTooltipInViews);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kWidgetLayering);
+VIEWS_EXPORT BASE_DECLARE_FEATURE(kInheritNativeThemeFromParentWidget);
 
 }  // namespace views::features
 
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
index d877d237b2c16..754512f583beb 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
@@ -8,6 +8,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/command_line.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -16,6 +17,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkRegion.h"
 #include "ui/aura/client/aura_constants.h"
@@ -43,6 +45,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/path_win.h"
 #include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/corewm/tooltip_win.h"
 #include "ui/views/views_features.h"
 #include "ui/views/views_switches.h"
 #include "ui/views/widget/desktop_aura/desktop_drag_drop_client_win.h"
@@ -130,7 +133,8 @@ DesktopWindowTreeHostWin::DesktopWindowTreeHostWin(
       drag_drop_client_(nullptr),
       should_animate_window_close_(false),
       pending_close_(false),
-      has_non_client_view_(false) {}
+      has_non_client_view_(false),
+      tooltip_(nullptr) {}
 
 DesktopWindowTreeHostWin::~DesktopWindowTreeHostWin() {
   desktop_native_widget_aura_->OnDesktopWindowTreeHostDestroyed(this);
@@ -230,7 +234,14 @@ void DesktopWindowTreeHostWin::OnActiveWindowChanged(bool active) {}
 void DesktopWindowTreeHostWin::OnWidgetInitDone() {}
 
 std::unique_ptr<corewm::Tooltip> DesktopWindowTreeHostWin::CreateTooltip() {
-  return std::make_unique<corewm::TooltipAura>();
+  bool force_legacy_tooltips =
+      (base::win::GetVersion() < base::win::Version::WIN8) || base::CommandLine::ForCurrentProcess()->HasSwitch("legacy-tooltips-win");
+  if (!force_legacy_tooltips)
+    return std::make_unique<corewm::TooltipAura>();
+
+  DCHECK(!tooltip_);
+  tooltip_ = new corewm::TooltipWin(GetAcceleratedWidget());
+  return base::WrapUnique(tooltip_.get());
 }
 
 std::unique_ptr<aura::client::DragDropClient>
@@ -1159,6 +1170,12 @@ void DesktopWindowTreeHostWin::HandlePaintAccelerated(
     compositor()->ScheduleRedrawRect(invalid_rect);
 }
 
+bool DesktopWindowTreeHostWin::HandleTooltipNotify(int w_param,
+                                                   NMHDR* l_param,
+                                                   LRESULT* l_result) {
+  return tooltip_ && tooltip_->HandleNotify(w_param, l_param, l_result);
+}
+
 void DesktopWindowTreeHostWin::HandleMenuLoop(bool in_menu_loop) {
   if (in_menu_loop) {
     tooltip_disabler_ = std::make_unique<wm::ScopedTooltipDisabler>(window());
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
index e963c861f7099..b72ed56d00917 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
@@ -38,6 +38,10 @@ class DesktopDragDropClientWin;
 class HWNDMessageHandler;
 class NonClientFrameView;
 
+namespace corewm {
+class TooltipWin;
+}
+
 namespace test {
 class DesktopWindowTreeHostWinTestApi;
 }
@@ -249,6 +253,9 @@ class VIEWS_EXPORT DesktopWindowTreeHostWin
   void HandleInputLanguageChange(DWORD character_set,
                                  HKL input_language_id) override;
   void HandlePaintAccelerated(const gfx::Rect& invalid_rect) override;
+  bool HandleTooltipNotify(int w_param,
+                           NMHDR* l_param,
+                           LRESULT* l_result) override;
   void HandleMenuLoop(bool in_menu_loop) override;
   bool PreHandleMSG(UINT message,
                     WPARAM w_param,
@@ -322,6 +329,10 @@ class VIEWS_EXPORT DesktopWindowTreeHostWin
   // True if the window should have the frame removed.
   bool remove_standard_frame_;
 
+  // Owned by TooltipController, but we need to forward events to it so we keep
+  // a reference.
+  raw_ptr<corewm::TooltipWin> tooltip_;
+
   // Visibility of the cursor. On Windows we can have multiple root windows and
   // the implementation of ::ShowCursor() is based on a counter, so making this
   // member static ensures that ::ShowCursor() is always called exactly once
diff --git a/ui/views/widget/widget.cc b/ui/views/widget/widget.cc
index 5093dee22b9da..15431b8de20e8 100644
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -11,6 +11,7 @@
 #include "base/auto_reset.h"
 #include "base/check_op.h"
 #include "base/containers/adapters.h"
+#include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
 #include "base/notreached.h"
@@ -2090,7 +2091,9 @@ const ui::NativeTheme* Widget::GetNativeTheme() const {
   if (native_theme_)
     return native_theme_;
 
-  if (parent_)
+if (base::FeatureList::IsEnabled(
+          features::kInheritNativeThemeFromParentWidget) &&
+      parent_)
     return parent_->GetNativeTheme();
 
 #if BUILDFLAG(IS_LINUX)
diff --git a/ui/views/widget/widget_interactive_uitest.cc b/ui/views/widget/widget_interactive_uitest.cc
index 1ba89332791a7..79771ccb861e3 100644
--- a/ui/views/widget/widget_interactive_uitest.cc
+++ b/ui/views/widget/widget_interactive_uitest.cc
@@ -18,6 +18,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/time/time.h"
 #include "base/timer/timer.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "ui/base/ime/input_method.h"
@@ -445,6 +446,11 @@ class TouchEventHandler : public ui::EventHandler {
 
 // TODO(dtapuska): Disabled due to it being flaky crbug.com/817531
 TEST_F(DesktopWidgetTestInteractive, DISABLED_TouchNoActivateWindow) {
+  // ui_controls::SendTouchEvents which uses InjectTouchInput API only works
+  // on Windows 8 and up.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   View* focusable_view = new View;
   focusable_view->SetFocusBehavior(View::FocusBehavior::ALWAYS);
   WidgetAutoclosePtr widget(CreateTopLevelNativeWidget());
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 36a6e980495ea..a499d9e470c26 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -30,6 +30,8 @@
 #include "base/win/dark_mode_support.h"
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
+#include "chrome/browser/win/titlebar_config.h"
 #include "services/tracing/public/cpp/perfetto/macros.h"
 #include "third_party/perfetto/protos/perfetto/trace/track_event/chrome_window_handle_event_info.pbzero.h"
 #include "third_party/skia/include/core/SkPath.h"
@@ -345,7 +347,8 @@ class HWNDMessageHandler::ScopedRedrawLock {
         hwnd_(owner_->hwnd()),
         should_lock_(owner_->IsVisible() && !owner->HasChildRenderingWindow() &&
                      ::IsWindow(hwnd_) && !owner_->IsHeadless() &&
-                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION))) {
+                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION) ||
+					  ShouldCustomDrawSystemTitlebar())) {
     if (should_lock_)
       owner_->LockUpdates();
   }
@@ -598,7 +601,8 @@ void HWNDMessageHandler::SetParentOrOwner(HWND new_parent) {
 }
 
 void HWNDMessageHandler::SetDwmFrameExtension(DwmFrameState state) {
-  if (!delegate_->HasFrame() && !is_translucent_) {
+  if (!delegate_->HasFrame() && !ShouldCustomDrawSystemTitlebar() &&
+	  !is_translucent_) {
     MARGINS m = {0, 0, 0, 0};
     if (state == DwmFrameState::kOn && !IsMaximized())
       m = {0, 0, 1, 0};
@@ -1864,7 +1868,8 @@ void HWNDMessageHandler::OnEnterSizeMove() {
 
 LRESULT HWNDMessageHandler::OnEraseBkgnd(HDC dc) {
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
+  if (!ShouldCustomDrawSystemTitlebar() &&
+	  delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
       needs_dwm_frame_clear_) {
     // This is necessary to avoid white flashing in the titlebar area around the
     // minimize/maximize/close buttons.
@@ -2090,8 +2095,12 @@ LRESULT HWNDMessageHandler::OnMouseRange(UINT message,
 LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
                                               WPARAM w_param,
                                               LPARAM l_param) {
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     return PA_NOACTIVATE;
   }
@@ -2099,18 +2108,30 @@ LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
   return -1;
 }
 
+
 LRESULT HWNDMessageHandler::OnPointerEvent(UINT message,
                                            WPARAM w_param,
                                            LPARAM l_param) {
+  // WM_POINTER is not supported on Windows 7.
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    SetMsgHandled(FALSE);
+    return -1;
+  }
+
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   POINTER_INPUT_TYPE pointer_type;
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
   // If the WM_POINTER messages are not sent from a stylus device, then we do
   // not handle them to make sure we do not change the current behavior of
   // touch and mouse inputs.
-  if (!::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type)) {
+  if (!get_pointer_type || !get_pointer_type(pointer_id, &pointer_type)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   // |HandlePointerEventTypePenClient| assumes all pen events happen on the
   // client area, so WM_NCPOINTER messages sent to it would eventually be
   // dropped and the native frame wouldn't be able to respond to pens.
@@ -2430,6 +2451,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
   // It's required to avoid some native painting artifacts from appearing when
   // the window is resized.
   if (!delegate_->HasNonClientView() || IsFrameSystemDrawn()) {
+	  if (!ShouldCustomDrawSystemTitlebar()) {
     // The default WM_NCPAINT handler under Aero Glass doesn't clear the
     // nonclient area, so it'll remain the default white color. That area is
     // invisible initially (covered by the window border) but can become
@@ -2452,6 +2474,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
     ::FillRect(dc, &dirty_region, brush);
     ::DeleteObject(brush);
     ::ReleaseDC(hwnd(), dc);
+	}
     SetMsgHandled(FALSE);
     return;
   }
@@ -2492,6 +2515,12 @@ LRESULT HWNDMessageHandler::OnNCUAHDrawFrame(UINT message,
   return 0;
 }
 
+LRESULT HWNDMessageHandler::OnNotify(int w_param, NMHDR* l_param) {
+  LRESULT l_result = 0;
+  SetMsgHandled(delegate_->HandleTooltipNotify(w_param, l_param, &l_result));
+  return l_result;
+}
+
 void HWNDMessageHandler::OnPaint(HDC dc) {
   // Call BeginPaint()/EndPaint() around the paint handling, as that seems
   // to do more to actually validate the window's drawing region. This only
@@ -2800,6 +2829,18 @@ LRESULT HWNDMessageHandler::OnTouchEvent(UINT message,
       POINT point;
       point.x = TOUCH_COORD_TO_PIXEL(input[i].x);
       point.y = TOUCH_COORD_TO_PIXEL(input[i].y);
+
+	  if (base::win::GetVersion() == base::win::Version::WIN7) {
+		  // Windows 7 sends touch events for NC area touches but Win8+ do not.
+		  // This code will be used to make Windows 7 ignore these touches as well.
+
+		  LPARAM l_param_ht = MAKELPARAM(point.x, point.y);
+		  LRESULT hittest = SendMessage(hwnd(), WM_NCHITTEST, 0, l_param_ht);
+
+		  if (hittest != HTCLIENT)
+			  return 0;
+	  }
+
       ScreenToClient(hwnd(), &point);
 
       last_touch_or_pen_message_time_ = ::GetMessageTime();
@@ -3443,12 +3484,18 @@ LRESULT HWNDMessageHandler::HandlePointerEventTypePenClient(UINT message,
                                                             WPARAM w_param,
                                                             LPARAM l_param) {
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerPenInfoFn = BOOL(WINAPI*)(UINT32, POINTER_PEN_INFO*);
   POINTER_PEN_INFO pointer_pen_info;
-  if (!GetPointerPenInfo(pointer_id, &pointer_pen_info)) {
+  static const auto get_pointer_pen_info =
+      reinterpret_cast<GetPointerPenInfoFn>(
+          base::win::GetUser32FunctionPointer("GetPointerPenInfo"));
+  if (!get_pointer_pen_info ||
+      !get_pointer_pen_info(pointer_id, &pointer_pen_info)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   return HandlePointerEventTypePen(message, pointer_id, pointer_pen_info);
 }
 
@@ -3474,7 +3521,6 @@ bool HWNDMessageHandler::IsSynthesizedMouseMessage(unsigned int message,
 }
 
 void HWNDMessageHandler::PerformDwmTransition() {
-  CHECK(IsFrameSystemDrawn());
 
   dwm_transition_desired_ = false;
   delegate_->HandleFrameChanged();
@@ -3485,7 +3531,8 @@ void HWNDMessageHandler::UpdateDwmFrame() {
   TRACE_EVENT0("ui", "HWNDMessageHandler::UpdateDwmFrame");
 
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets)) {
+  if (!ShouldCustomDrawSystemTitlebar() &&
+      delegate_->GetDwmFrameInsetsInPixels(&insets)) {
     MARGINS margins = {insets.left(), insets.right(), insets.top(),
                        insets.bottom()};
     DwmExtendFrameIntoClientArea(hwnd(), &margins);
diff --git a/ui/views/win/hwnd_message_handler.h b/ui/views/win/hwnd_message_handler.h
index 060b8b90c0479..c1f3e18e20c95 100644
--- a/ui/views/win/hwnd_message_handler.h
+++ b/ui/views/win/hwnd_message_handler.h
@@ -474,6 +474,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
     CR_MSG_WM_NCCREATE(OnNCCreate)
     CR_MSG_WM_NCHITTEST(OnNCHitTest)
     CR_MSG_WM_NCPAINT(OnNCPaint)
+    CR_MSG_WM_NOTIFY(OnNotify)
     CR_MSG_WM_PAINT(OnPaint)
     CR_MSG_WM_SETFOCUS(OnSetFocus)
     CR_MSG_WM_SETICON(OnSetIcon)
@@ -530,6 +531,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
   void OnNCPaint(HRGN rgn);
   LRESULT OnNCUAHDrawCaption(UINT message, WPARAM w_param, LPARAM l_param);
   LRESULT OnNCUAHDrawFrame(UINT message, WPARAM w_param, LPARAM l_param);
+  LRESULT OnNotify(int w_param, NMHDR* l_param);
   void OnPaint(HDC dc);
   LRESULT OnReflectedMessage(UINT message, WPARAM w_param, LPARAM l_param);
   LRESULT OnScrollMessage(UINT message, WPARAM w_param, LPARAM l_param);
diff --git a/ui/views/win/hwnd_message_handler_delegate.h b/ui/views/win/hwnd_message_handler_delegate.h
index fde18715e33ee..94dd1e636eb27 100644
--- a/ui/views/win/hwnd_message_handler_delegate.h
+++ b/ui/views/win/hwnd_message_handler_delegate.h
@@ -216,6 +216,11 @@ class VIEWS_EXPORT HWNDMessageHandlerDelegate {
   // Called to compel the delegate to paint |invalid_rect| accelerated.
   virtual void HandlePaintAccelerated(const gfx::Rect& invalid_rect) = 0;
 
+  // Called to forward a WM_NOTIFY message to the tooltip manager.
+  virtual bool HandleTooltipNotify(int w_param,
+                                   NMHDR* l_param,
+                                   LRESULT* l_result) = 0;
+
   // Invoked on entering/exiting a menu loop.
   virtual void HandleMenuLoop(bool in_menu_loop) = 0;
 
diff --git a/ui/views/win/pen_id_handler.cc b/ui/views/win/pen_id_handler.cc
index 3327d96ad2970..34fd76937b5da 100644
--- a/ui/views/win/pen_id_handler.cc
+++ b/ui/views/win/pen_id_handler.cc
@@ -39,7 +39,15 @@ class PenIdStatics {
     if (skip_initialization_) {
       return;
     }
+
     SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+    if(!base::win::ResolveCoreWinRTDelayload()){
+	  pen_device_statics_ = nullptr;
+	  pointer_point_statics_ = nullptr;
+	  return;
+    }
+
     base::win::AssertComInitialized();
     base::win::RoGetActivationFactory(
         base::win::HStringReference(
@@ -274,4 +282,4 @@ void PenIdHandler::InitPenIdStatics() {
       base::BindOnce(base::IgnoreResult(&PenIdStatics::GetInstance)));
 }
 
-}  // namespace views
+}  // namespace views
\ No newline at end of file
