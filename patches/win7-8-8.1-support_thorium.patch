diff --git a/README.md b/README.md
index 08f1a0445babd..f5f245da9dacb 100644
--- a/README.md
+++ b/README.md
@@ -1,21 +1,2 @@
-# ![Logo](chrome/app/theme/chromium/product_logo_64.png) Chromium
-
-Chromium is an open-source browser project that aims to build a safer, faster,
-and more stable way for all users to experience the web.
-
-The project's web site is https://www.chromium.org.
-
-To check out the source code locally, don't use `git clone`! Instead,
-follow [the instructions on how to get the code](docs/get_the_code.md).
-
-Documentation in the source is rooted in [docs/README.md](docs/README.md).
-
-Learn how to [Get Around the Chromium Source Code Directory Structure
-](https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code).
-
-For historical reasons, there are some small top level directories. Now the
-guidance is that new top level directories are for product (e.g. Chrome,
-Android WebView, Ash). Even if these products have multiple executables, the
-code should be in subdirectories of the product.
-
-If you found a bug, please file it at https://crbug.com/new.
+# Supermium + Thorium
+A compiler optimized, Chromium-based browser for Windows Vista (exkernel), 7 and 8.x.
diff --git a/base/BUILD.gn b/base/BUILD.gn
index 55479f4187323..1c23a35cbce6b 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -134,11 +134,6 @@ if (is_win) {
     ldflags = [
       # Linking with shcore.lib causes the shcore api forwarder dll to load.
       "/DELAYLOAD:api-ms-win-shcore-scaling-l1-1-1.dll",
-
-      # Linking with OneCore.lib causes the next three dlls to load.
-      "/DELAYLOAD:api-ms-win-core-realtime-l1-1-1.dll",
-      "/DELAYLOAD:api-ms-win-power-base-l1-1-0.dll",
-      "/DELAYLOAD:api-ms-win-power-setting-l1-1-0.dll",
       "/DELAYLOAD:cfgmgr32.dll",
       "/DELAYLOAD:powrprof.dll",
       "/DELAYLOAD:setupapi.dll",
@@ -1912,7 +1907,6 @@ component("base") {
     libs += [
       "cfgmgr32.lib",
       "ntdll.lib",
-      "onecore.lib",
       "powrprof.lib",
       "propsys.lib",
       "setupapi.lib",
diff --git a/base/allocator/partition_allocator/page_allocator_internals_win.h b/base/allocator/partition_allocator/page_allocator_internals_win.h
index 1ac45fbe20bd8..57f6d86a34330 100644
--- a/base/allocator/partition_allocator/page_allocator_internals_win.h
+++ b/base/allocator/partition_allocator/page_allocator_internals_win.h
@@ -5,6 +5,8 @@
 #ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 #define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 
+#include <versionhelpers.h>
+
 #include <cstdint>
 
 #include "base/allocator/partition_allocator/oom.h"
@@ -16,6 +18,17 @@
 
 namespace partition_alloc::internal {
 
+namespace {
+
+// On Windows, discarded pages are not returned to the system immediately and
+// not guaranteed to be zeroed when returned to the application.
+using DiscardVirtualMemoryFunction = DWORD(WINAPI*)(PVOID virtualAddress,
+                                                    SIZE_T size);
+DiscardVirtualMemoryFunction s_discard_virtual_memory =
+    reinterpret_cast<DiscardVirtualMemoryFunction>(-1);
+
+}  // namespace
+
 // |VirtualAlloc| will fail if allocation at the hint address is blocked.
 constexpr bool kHintIsAdvisory = false;
 std::atomic<int32_t> s_allocPageErrorCode{ERROR_SUCCESS};
@@ -224,12 +237,27 @@ bool TryRecommitSystemPagesInternal(
 }
 
 void DiscardSystemPagesInternal(uintptr_t address, size_t length) {
+  if (s_discard_virtual_memory ==
+      reinterpret_cast<DiscardVirtualMemoryFunction>(-1)) {
+    // DiscardVirtualMemory's minimum supported client is Windows 8.1 Update.
+    // So skip GetProcAddress("DiscardVirtualMemory") if windows version is
+    // smaller than Windows 8.1.
+    if (IsWindows8Point1OrGreater()) {
+      s_discard_virtual_memory =
+          reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+              GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+    } else {
+      s_discard_virtual_memory = nullptr;
+    }
+  }
+
   void* ptr = reinterpret_cast<void*>(address);
   // Use DiscardVirtualMemory when available because it releases faster than
   // MEM_RESET.
-  DWORD ret = DiscardVirtualMemory(ptr, length);
-  // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
-  // failure.
+  DWORD ret = 1;
+  if (s_discard_virtual_memory) {
+    ret = s_discard_virtual_memory(ptr, length);
+  }
   if (ret) {
     PA_CHECK(VirtualAllocWithRetry(ptr, length, MEM_RESET, PAGE_READWRITE));
   }
diff --git a/base/allocator/partition_allocator/partition_address_space.cc b/base/allocator/partition_allocator/partition_address_space.cc
index fe5ebd51f3af1..398e6a66b6797 100644
--- a/base/allocator/partition_allocator/partition_address_space.cc
+++ b/base/allocator/partition_allocator/partition_address_space.cc
@@ -43,6 +43,34 @@ namespace {
 
 #if BUILDFLAG(IS_WIN)
 
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+bool IsLegacyWindowsVersion() {
+  // Use ::RtlGetVersion instead of ::GetVersionEx or helpers from
+  // VersionHelpers.h because those alternatives change their behavior depending
+  // on whether or not the calling executable has a compatibility manifest
+  // resource. It's better for the allocator to not depend on that to decide the
+  // pool size.
+  // Assume legacy if ::RtlGetVersion is not available or it fails.
+  using RtlGetVersion = LONG(WINAPI*)(OSVERSIONINFOEX*);
+  const RtlGetVersion rtl_get_version = reinterpret_cast<RtlGetVersion>(
+      ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"), "RtlGetVersion"));
+  if (!rtl_get_version) {
+    return true;
+  }
+
+  OSVERSIONINFOEX version_info = {};
+  version_info.dwOSVersionInfoSize = sizeof(version_info);
+  if (rtl_get_version(&version_info) != ERROR_SUCCESS) {
+    return true;
+  }
+
+  // Anything prior to Windows 8.1 is considered legacy for the allocator.
+  // Windows 8.1 is major 6 with minor 3.
+  return version_info.dwMajorVersion < 6 ||
+         (version_info.dwMajorVersion == 6 && version_info.dwMinorVersion < 3);
+}
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+
 PA_NOINLINE void HandlePoolAllocFailureOutOfVASpace() {
   PA_NO_CODE_FOLDING();
   PA_CHECK(false);
@@ -66,9 +94,9 @@ PA_NOINLINE void HandlePoolAllocFailure() {
     // it must be VA space exhaustion.
     HandlePoolAllocFailureOutOfVASpace();
   } else if (alloc_page_error_code == ERROR_COMMITMENT_LIMIT) {
-    // Should not happen, since as of Windows 8.1+, reserving address space
-    // should not be charged against the commit limit, aside from a very small
-    // amount per 64kiB block. Keep this path anyway, to check in crash reports.
+    // On Windows <8.1, MEM_RESERVE increases commit charge to account for
+    // not-yet-committed PTEs needed to cover that VA space, if it was to be
+    // committed (see crbug.com/1101421#c16).
     HandlePoolAllocFailureOutOfCommitCharge();
   } else
 #endif  // BUILDFLAG(IS_WIN)
@@ -87,10 +115,7 @@ std::ptrdiff_t PartitionAddressSpace::brp_pool_shadow_offset_ = 0;
 #endif
 
 #if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
-#if !BUILDFLAG(IS_IOS)
-#error Dynamic pool size is only supported on iOS.
-#endif
-
+#if BUILDFLAG(IS_IOS)
 namespace {
 bool IsIOSTestProcess() {
   // On iOS, only applications with the extended virtual addressing entitlement
@@ -132,6 +157,15 @@ PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
 PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
   return IsIOSTestProcess() ? kBRPPoolSizeForIOSTestProcess : kBRPPoolSize;
 }
+#else
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
+  return IsLegacyWindowsVersion() ? kRegularPoolSizeForLegacyWindows
+                                  : kRegularPoolSize;
+}
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
+  return IsLegacyWindowsVersion() ? kBRPPoolSizeForLegacyWindows : kBRPPoolSize;
+}
+#endif  // BUILDFLAG(IS_IOS)
 #endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
 
 void PartitionAddressSpace::Init() {
diff --git a/base/allocator/partition_allocator/partition_address_space.h b/base/allocator/partition_allocator/partition_address_space.h
index 260842f02b7d3..352e314df0e32 100644
--- a/base/allocator/partition_allocator/partition_address_space.h
+++ b/base/allocator/partition_allocator/partition_address_space.h
@@ -276,6 +276,16 @@ class PA_COMPONENT_EXPORT(PARTITION_ALLOC) PartitionAddressSpace {
   static constexpr size_t kThreadIsolatedPoolSize = kGiB / 4;
   static_assert(base::bits::IsPowerOfTwo(kThreadIsolatedPoolSize));
 #endif
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+  // We can't afford pool sizes as large as kPoolMaxSize on Windows <8.1 (see
+  // crbug.com/1101421 and crbug.com/1217759).
+  static constexpr size_t kRegularPoolSizeForLegacyWindows = 1 * kGiB;
+  static constexpr size_t kBRPPoolSizeForLegacyWindows = 1 * kGiB;
+  static_assert(kRegularPoolSizeForLegacyWindows < kRegularPoolSize);
+  static_assert(kBRPPoolSizeForLegacyWindows < kBRPPoolSize);
+  static_assert(base::bits::IsPowerOfTwo(kRegularPoolSizeForLegacyWindows));
+  static_assert(base::bits::IsPowerOfTwo(kBRPPoolSizeForLegacyWindows));
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
   static constexpr size_t kConfigurablePoolMaxSize = kPoolMaxSize;
   static constexpr size_t kConfigurablePoolMinSize = 1 * kGiB;
   static_assert(kConfigurablePoolMinSize <= kConfigurablePoolMaxSize);
diff --git a/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc b/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
index c6071fa8b092f..cac35bc52ad53 100644
--- a/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
+++ b/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
@@ -8,36 +8,32 @@
 #include <stdint.h>
 #include <windows.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <limits>
 
 #include "base/allocator/partition_allocator/partition_alloc_base/check.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace partition_alloc::internal::base {
 
 void RandBytes(void* output, size_t output_length) {
-  // Import bcryptprimitives directly rather than cryptbase to avoid opening a
-  // handle to \\Device\KsecDD in the renderer.
-  // Note: we cannot use a magic static here as PA runs too early in process
-  // startup, but this should be safe as the process will be single-threaded
-  // when this first runs.
-  static decltype(&ProcessPrng) process_prng_fn = nullptr;
-  if (!process_prng_fn) {
-    HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-    PA_BASE_CHECK(hmod);
-    process_prng_fn = reinterpret_cast<decltype(&ProcessPrng)>(
-        GetProcAddress(hmod, "ProcessPrng"));
-    PA_BASE_CHECK(process_prng_fn);
+  char* output_ptr = static_cast<char*>(output);
+  while (output_length > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    PA_BASE_CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
   }
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  PA_BASE_CHECK(success);
+
 }
 
 }  // namespace partition_alloc::internal::base
diff --git a/base/allocator/partition_allocator/partition_alloc_config.h b/base/allocator/partition_allocator/partition_alloc_config.h
index bb6195f590759..224a3507195c7 100644
--- a/base/allocator/partition_allocator/partition_alloc_config.h
+++ b/base/allocator/partition_allocator/partition_alloc_config.h
@@ -32,7 +32,7 @@
 static_assert(sizeof(void*) == 8, "");
 #else
 static_assert(sizeof(void*) != 8, "");
-#endif  // PA_CONFIG(HAS_64_BITS_POINTERS)
+#endif  // BUILDFLAG(HAS_64_BITS_POINTERS)
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (defined(__ARM_NEON) || defined(__ARM_NEON__)) && defined(__ARM_FP)
@@ -41,18 +41,23 @@ static_assert(sizeof(void*) != 8, "");
 #define PA_CONFIG_STARSCAN_NEON_SUPPORTED() 0
 #endif
 
-#if BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#if BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) || BUILDFLAG(IS_WIN))
 // Allow PA to select an alternate pool size at run-time before initialization,
 // rather than using a single constexpr value.
 //
 // This is needed on iOS because iOS test processes can't handle large pools
 // (see crbug.com/1250788).
 //
+// This is needed on Windows, because OS versions <8.1 incur commit charge even
+// on reserved address space, thus don't handle large pools well (see
+// crbug.com/1101421 and crbug.com/1217759).
+//
 // This setting is specific to 64-bit, as 32-bit has a different implementation.
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 1
 #else
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 0
-#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) ||
+        // BUILDFLAG(IS_WIN))
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_ANDROID))
diff --git a/base/command_line.cc b/base/command_line.cc
index d762b168a9ccf..5bbdb4e86d69a 100644
--- a/base/command_line.cc
+++ b/base/command_line.cc
@@ -27,8 +27,8 @@
 #include <windows.h>
 
 #include <shellapi.h>
-
 #include "base/strings/string_util_win.h"
+#include "base/win/windows_version.h"
 #endif  // BUILDFLAG(IS_WIN)
 
 namespace base {
@@ -301,6 +301,7 @@ bool CommandLine::HasSwitch(StringPiece switch_string) const {
 }
 
 bool CommandLine::HasSwitch(const char switch_constant[]) const {
+
   return HasSwitch(StringPiece(switch_constant));
 }
 
diff --git a/base/features.cc b/base/features.cc
index b7dc8ce05d8ca..e03cfe3014b0e 100644
--- a/base/features.cc
+++ b/base/features.cc
@@ -37,7 +37,20 @@ BASE_FEATURE(kUseRustJsonParser,
              FEATURE_DISABLED_BY_DEFAULT);
 
 BASE_FEATURE(kJsonNegativeZero, "JsonNegativeZero", FEATURE_ENABLED_BY_DEFAULT);
+
+
+
+
 
+BASE_FEATURE(kIncognitoBrandConsistencyForDesktop,
+			"IncognitoBrandConsistencyForDesktop",
+			base::FEATURE_DISABLED_BY_DEFAULT);
+
+#if BUILDFLAG(IS_WIN)
+BASE_FEATURE(kForceGdi,
+             "ForceGdi",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+#endif
 #if BUILDFLAG(IS_ANDROID)
 // Force to enable LowEndDeviceMode partially on Android mid-range devices.
 // Such devices aren't considered low-end, but we'd like experiment with
diff --git a/base/features.h b/base/features.h
index 756445ec6bed3..134e418aa9af6 100644
--- a/base/features.h
+++ b/base/features.h
@@ -27,6 +27,13 @@ BASE_EXPORT BASE_DECLARE_FEATURE(kUseRustJsonParser);
 
 BASE_EXPORT BASE_DECLARE_FEATURE(kJsonNegativeZero);
 
+
+
+BASE_EXPORT BASE_DECLARE_FEATURE(kIncognitoBrandConsistencyForDesktop);
+
+#if BUILDFLAG(IS_WIN)
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceGdi);
+#endif
 #if BUILDFLAG(IS_ANDROID)
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOnMidRangeDevices);
 extern const BASE_EXPORT FeatureParam<bool>
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index d7b5fb20aeb34..490d00454b657 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -1104,11 +1104,37 @@ bool SetNonBlocking(int fd) {
   return false;
 }
 
+namespace {
+
+// ::PrefetchVirtualMemory() is only available on Windows 8 and above. Chrome
+// supports Windows 7, so we need to check for the function's presence
+// dynamically.
+using PrefetchVirtualMemoryPtr = decltype(&::PrefetchVirtualMemory);
+
+// Returns null if ::PrefetchVirtualMemory() is not available.
+PrefetchVirtualMemoryPtr GetPrefetchVirtualMemoryPtr() {
+  HMODULE kernel32_dll = ::GetModuleHandleA("kernel32.dll");
+  return reinterpret_cast<PrefetchVirtualMemoryPtr>(
+      GetProcAddress(kernel32_dll, "PrefetchVirtualMemory"));
+}
+
+}  // namespace
+
 bool PreReadFile(const FilePath& file_path,
                  bool is_executable,
                  int64_t max_bytes) {
   DCHECK_GE(max_bytes, 0);
 
+  // On Win8 and higher use ::PrefetchVirtualMemory(). This is better than a
+  // simple data file read, more from a RAM perspective than CPU. This is
+  // because reading the file as data results in double mapping to
+  // Image/executable pages for all pages of code executed.
+  static PrefetchVirtualMemoryPtr prefetch_virtual_memory =
+      GetPrefetchVirtualMemoryPtr();
+
+  if (prefetch_virtual_memory == nullptr)
+    return internal::PreReadFileSlow(file_path, max_bytes);
+
   if (max_bytes == 0) {
     // ::PrefetchVirtualMemory() fails when asked to read zero bytes.
     // base::MemoryMappedFile::Initialize() fails on an empty file.
@@ -1131,7 +1157,7 @@ bool PreReadFile(const FilePath& file_path,
   // simple data file read, more from a RAM perspective than CPU. This is
   // because reading the file as data results in double mapping to
   // Image/executable pages for all pages of code executed.
-  if (!::PrefetchVirtualMemory(::GetCurrentProcess(),
+  if (!prefetch_virtual_memory(::GetCurrentProcess(),
                                /*NumberOfEntries=*/1, &address_range,
                                /*Flags=*/0)) {
     return internal::PreReadFileSlow(file_path, max_bytes);
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index 23c95bad719c7..62a0b3c1f1d17 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -422,11 +422,23 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 #elif BUILDFLAG(IS_WIN)
   // On Windows, discarded pages are not returned to the system immediately and
   // not guaranteed to be zeroed when returned to the application.
+  using DiscardVirtualMemoryFunction =
+      DWORD(WINAPI*)(PVOID virtualAddress, SIZE_T size);
+  static DiscardVirtualMemoryFunction discard_virtual_memory =
+      reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+          GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+
   char* address = static_cast<char*>(shared_memory_mapping_.memory()) +
                   AlignToPageSize(sizeof(SharedState));
   size_t length = AlignToPageSize(mapped_size_);
 
-  DWORD ret = DiscardVirtualMemory(address, length);
+  // Use DiscardVirtualMemory when available because it releases faster than
+  // MEM_RESET.
+  DWORD ret = ERROR_NOT_SUPPORTED;
+  if (discard_virtual_memory) {
+    ret = discard_virtual_memory(address, length);
+  }
+
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret != ERROR_SUCCESS) {
diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index e387015249731..233ba25da5efe 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,7 +14,12 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
+
 
 namespace base::subtle {
 
@@ -73,6 +78,7 @@ HANDLE CreateFileMappingWithReducedPermissions(SECURITY_ATTRIBUTES* sa,
   HANDLE h = CreateFileMapping(INVALID_HANDLE_VALUE, sa, PAGE_READWRITE, 0,
                                static_cast<DWORD>(rounded_size), name);
   if (!h) {
+     LOG(ERROR) << "CreateFileMappingW failed with error " << GetLastError() << ".";
     return nullptr;
   }
 
@@ -211,6 +217,17 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(&rand_values, sizeof(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
diff --git a/base/message_loop/message_pump_win.cc b/base/message_loop/message_pump_win.cc
index 9425ad4ba5432..395d86b6fa45f 100644
--- a/base/message_loop/message_pump_win.cc
+++ b/base/message_loop/message_pump_win.cc
@@ -790,6 +790,7 @@ bool MessagePumpForIO::GetIOItem(DWORD timeout, IOItem* item) {
                                    &overlapped, timeout)) {
     if (!overlapped)
       return false;  // Nothing in the queue.
+
     item->error = GetLastError();
     item->bytes_transfered = 0;
   }
diff --git a/base/power_monitor/power_monitor_device_source_win.cc b/base/power_monitor/power_monitor_device_source_win.cc
index 4e7b6563bc229..3925a372ed509 100644
--- a/base/power_monitor/power_monitor_device_source_win.cc
+++ b/base/power_monitor/power_monitor_device_source_win.cc
@@ -32,8 +32,9 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
       power_event = PowerMonitorSource::POWER_STATE_EVENT;
       break;
     case PBT_APMRESUMEAUTOMATIC:  // Resume from suspend.
-      // We don't notify for PBT_APMRESUMESUSPEND
-      // because, if it occurs, it is always sent as a
+      //case PBT_APMRESUMESUSPEND:  // User-initiated resume from suspend.
+      // We don't notify for this latter event
+      // because if it occurs it is always sent as a
       // second event after PBT_APMRESUMEAUTOMATIC.
       power_event = PowerMonitorSource::RESUME_EVENT;
       break;
@@ -55,6 +56,28 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
   ProcessPowerEventHelper(power_event);
 }
 
+HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags) {
+  const auto register_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::RegisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "RegisterSuspendResumeNotification"));
+  if (!register_suspend_resume_notification_ptr)
+    return nullptr;
+
+  return register_suspend_resume_notification_ptr(hRecipient, Flags);
+}
+
+BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle) {
+  const auto unregister_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::UnregisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "UnregisterSuspendResumeNotification"));
+  if (!unregister_suspend_resume_notification_ptr)
+    return FALSE;
+
+  return unregister_suspend_resume_notification_ptr(Handle);
+}
+
 }  // namespace
 
 void PowerMonitorDeviceSource::PlatformInit() {
@@ -79,7 +102,7 @@ void PowerMonitorDeviceSource::PlatformDestroy() {
 // battery power.  Returns true if running on battery.
 bool PowerMonitorDeviceSource::IsOnBatteryPower() {
   SYSTEM_POWER_STATUS status;
-  if (!::GetSystemPowerStatus(&status)) {
+  if (!GetSystemPowerStatus(&status)) {
     DPLOG(ERROR) << "GetSystemPowerStatus failed";
     return false;
   }
@@ -92,7 +115,8 @@ int PowerMonitorDeviceSource::GetInitialSpeedLimit() {
   return PowerThermalObserver::kSpeedLimitMax;
 }
 
-PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
+PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow()
+    : instance_(NULL), message_hwnd_(NULL) {
   if (!CurrentUIThread::IsSet()) {
     // Creating this window in (e.g.) a renderer inhibits shutdown on Windows.
     // See http://crbug.com/230122. TODO(vandebo): http://crbug.com/236031
@@ -105,18 +129,21 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
       kWindowClassName,
       &base::win::WrappedWindowProc<
           PowerMonitorDeviceSource::PowerMessageWindow::WndProcThunk>,
-      0, 0, 0, nullptr, nullptr, nullptr, nullptr, nullptr, &window_class);
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL,
+      &window_class);
   instance_ = window_class.hInstance;
-  ATOM clazz = ::RegisterClassEx(&window_class);
+  ATOM clazz = RegisterClassEx(&window_class);
   DCHECK(clazz);
 
   message_hwnd_ =
-      ::CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, nullptr, WS_POPUP, 0,
-                       0, 0, 0, nullptr, nullptr, instance_, nullptr);
+      CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, NULL, WS_POPUP, 0, 0,
+                     0, 0, NULL, NULL, instance_, NULL);
   if (message_hwnd_) {
-    // On machines with modern standby calling RegisterSuspendResumeNotification
-    // is required in order to get the PBT_APMSUSPEND message.
-    power_notify_handle_ = ::RegisterSuspendResumeNotification(
+    // On machines with modern standby and Win8+, calling
+    // RegisterSuspendResumeNotification is required in order to get the
+    // PBT_APMSUSPEND message. The notification is no longer automatically
+    // fired.
+    power_notify_handle_ = base::RegisterSuspendResumeNotification(
         message_hwnd_, DEVICE_NOTIFY_WINDOW_HANDLE);
   }
 }
@@ -124,10 +151,10 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
 PowerMonitorDeviceSource::PowerMessageWindow::~PowerMessageWindow() {
   if (message_hwnd_) {
     if (power_notify_handle_)
-      ::UnregisterSuspendResumeNotification(power_notify_handle_);
+      base::UnregisterSuspendResumeNotification(power_notify_handle_);
 
-    ::DestroyWindow(message_hwnd_);
-    ::UnregisterClass(kWindowClassName, instance_);
+    DestroyWindow(message_hwnd_);
+    UnregisterClass(kWindowClassName, instance_);
   }
 }
 
diff --git a/base/process/launch_win.cc b/base/process/launch_win.cc
index 384c77134b692..383e0bf5361b5 100644
--- a/base/process/launch_win.cc
+++ b/base/process/launch_win.cc
@@ -260,7 +260,7 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
   win::StartupInformation startup_info_wrapper;
   STARTUPINFO* startup_info = startup_info_wrapper.startup_info();
   DWORD flags = 0;
-
+  //
   // Count extended attributes before reserving space.
   DWORD attribute_count = 0;
   // Count PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY.
@@ -272,15 +272,18 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
   // Count PROC_THREAD_ATTRIBUTE_HANDLE_LIST.
   if (!options.handles_to_inherit.empty())
     ++attribute_count;
-
-  // Reserve space for attributes.
-  if (attribute_count > 0) {
-    if (!startup_info_wrapper.InitializeProcThreadAttributeList(
-            attribute_count)) {
-      DPLOG(ERROR);
-      return Process();
-    }
-    flags |= EXTENDED_STARTUPINFO_PRESENT;
+
+
+  if (base::win::GetVersion() >= base::win::Version::VISTA) {
+	  // Reserve space for attributes.
+	  if (attribute_count > 0) {
+		if (!startup_info_wrapper.InitializeProcThreadAttributeList(
+				attribute_count)) {
+		  DPLOG(ERROR);
+		  return Process();
+		}
+		flags |= EXTENDED_STARTUPINFO_PRESENT;
+	  }
   }
 
   // Set PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY.
@@ -298,7 +301,11 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
 
   // Set PROC_THREAD_ATTRIBUTE_HANDLE_LIST.
   bool inherit_handles = options.inherit_mode == LaunchOptions::Inherit::kAll;
-  if (!options.handles_to_inherit.empty()) {
+  if (!options.handles_to_inherit.empty() &&
+	  base::win::GetVersion() < base::win::Version::VISTA) {
+	  inherit_handles = true;
+  }
+  if (!options.handles_to_inherit.empty() && base::win::GetVersion() >= base::win::Version::VISTA) {
     DCHECK_GT(attribute_count, 0u);
     DCHECK_EQ(options.inherit_mode, LaunchOptions::Inherit::kSpecific);
 
diff --git a/base/process/process_util_unittest.cc b/base/process/process_util_unittest.cc
index 306d850f6319c..9c59833f55bf3 100644
--- a/base/process/process_util_unittest.cc
+++ b/base/process/process_util_unittest.cc
@@ -829,11 +829,19 @@ TEST_F(ProcessUtilTest, LaunchAsUser) {
 }
 
 MULTIPROCESS_TEST_MAIN(ChildVerifiesCetDisabled) {
-  // Policy not defined for Win < Win10 20H1 but that's ok.
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
+  // Not available for Win7 but this process should still work.
+  if (!get_process_mitigation_policy)
+    return kSuccess;
+
+  // Policy not defined for Win < Win10 20H1 but that's also ok.
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-  if (GetProcessMitigationPolicy(GetCurrentProcess(),
-                                 ProcessUserShadowStackPolicy, &policy,
-                                 sizeof(policy))) {
+  if (get_process_mitigation_policy(GetCurrentProcess(),
+                                    ProcessUserShadowStackPolicy, &policy,
+                                    sizeof(policy))) {
     if (policy.EnableUserShadowStack)
       return 1;
   }
diff --git a/base/process/process_win.cc b/base/process/process_win.cc
index 9a414d886f779..917e2a9a18233 100644
--- a/base/process/process_win.cc
+++ b/base/process/process_win.cc
@@ -265,35 +265,12 @@ bool Process::SetPriority(Priority priority) {
   // priority inversion, and having a process put itself in background mode is
   // broken in Windows 11 22H2. So, it is no longer supported. See
   // https://crbug.com/1396155 for details.
+  // NOTE: NtSetInformationProcess call (SetProcessInformation really) using ProcessPowerThrottling class removed because it is useless before Windows 10.
   DCHECK(!is_current());
   const DWORD priority_class = priority == Priority::kBestEffort
                                    ? IDLE_PRIORITY_CLASS
                                    : NORMAL_PRIORITY_CLASS;
 
-  if (base::win::OSInfo::GetInstance()->version() >=
-          base::win::Version::WIN11 &&
-      FeatureList::IsEnabled(kUseEcoQoSForBackgroundProcess)) {
-    PROCESS_POWER_THROTTLING_STATE power_throttling;
-    RtlZeroMemory(&power_throttling, sizeof(power_throttling));
-    power_throttling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;
-
-    if (priority == Priority::kBestEffort) {
-      // Sets Eco QoS level.
-      power_throttling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-      power_throttling.StateMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-    } else {
-      // Uses system default.
-      power_throttling.ControlMask = 0;
-      power_throttling.StateMask = 0;
-    }
-    bool ret =
-        ::SetProcessInformation(Handle(), ProcessPowerThrottling,
-                                &power_throttling, sizeof(power_throttling));
-    if (ret == 0) {
-      DPLOG(ERROR) << "Setting process QoS policy fails";
-    }
-  }
-
   return (::SetPriorityClass(Handle(), priority_class) != 0);
 }
 
diff --git a/base/rand_util_win.cc b/base/rand_util_win.cc
index 549f4362af8b6..2d9a1633b564f 100644
--- a/base/rand_util_win.cc
+++ b/base/rand_util_win.cc
@@ -9,6 +9,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <atomic>
 #include <limits>
@@ -18,12 +25,6 @@
 #include "third_party/boringssl/src/include/openssl/crypto.h"
 #include "third_party/boringssl/src/include/openssl/rand.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace base {
 
 namespace internal {
@@ -53,18 +54,6 @@ bool UseBoringSSLForRandBytes() {
 
 namespace {
 
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
 void RandBytes(void* output, size_t output_length, bool avoid_allocation) {
   if (!avoid_allocation && internal::UseBoringSSLForRandBytes()) {
     // Ensure BoringSSL is initialized so it can use things like RDRAND.
@@ -74,10 +63,16 @@ void RandBytes(void* output, size_t output_length, bool avoid_allocation) {
     return;
   }
 
-  static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  CHECK(success);
+  char* output_ptr = static_cast<char*>(output);
+  while (output_length > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+  }
 }
 
 }  // namespace
diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 7e9dd368eb0ec..0fb94478eb47b 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -16,7 +16,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base {
@@ -329,8 +331,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
   }
 
   DCHECK(!scoped_environment || scoped_environment->Succeeded());
@@ -344,4 +356,4 @@ bool ThreadGroup::CurrentThreadHasGroup() {
 }
 
 }  // namespace internal
-}  // namespace base
+}  // namespace base
\ No newline at end of file
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index 83a1402780b0d..a7cdeb078197f 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -50,6 +50,13 @@ namespace {
 // Flag used to set thread priority to |THREAD_PRIORITY_LOWEST| for
 // |kUseThreadPriorityLowest| Feature.
 std::atomic<bool> g_use_thread_priority_lowest{false};
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
 // Flag used to map Compositing ThreadType |THREAD_PRIORITY_ABOVE_NORMAL| on the
 // UI thread for |kAboveNormalCompositingBrowserWin| Feature.
 std::atomic<bool> g_above_normal_compositing_browser{true};
@@ -236,7 +243,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -536,8 +546,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
     return ThreadPriorityForTest::kBackground;
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinDisplayPriority1:
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
index c6540592a5c18..f453dc2ed20cf 100644
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -646,11 +646,11 @@ TimeTicks::Clock TimeTicks::GetClock() {
 
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
-  ULONGLONG unbiased_interrupt_time;
-  QueryUnbiasedInterruptTimePrecise(&unbiased_interrupt_time);
+  LARGE_INTEGER unbiased_interrupt_time;
+  QueryPerformanceCounter(&unbiased_interrupt_time);
   // QueryUnbiasedInterruptTimePrecise gets the interrupt time in system time
   // units of 100 nanoseconds.
-  return LiveTicks() + Nanoseconds(unbiased_interrupt_time * 100);
+  return LiveTicks() + Nanoseconds(unbiased_interrupt_time.QuadPart * 100);
 }
 }  // namespace subtle
 
diff --git a/base/trace_event/trace_logging_minimal_win.cc b/base/trace_event/trace_logging_minimal_win.cc
index b0db1074d9ca9..490d7a082ecc7 100644
--- a/base/trace_event/trace_logging_minimal_win.cc
+++ b/base/trace_event/trace_logging_minimal_win.cc
@@ -10,6 +10,61 @@
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
 
+/*
+EventSetInformation configuration macros:
+
+TraceLogging works best if the EventSetInformation API can be used to notify
+ETW that the provider uses TraceLogging event encoding.
+
+The EventSetInformation API is available on Windows 8 and later. (It is also
+available on fully-patched Windows 7, but not on Windows 7 RTM).
+
+The TLM_HAVE_EVENT_SET_INFORMATION and TLM_EVENT_SET_INFORMATION macros can
+be set before compiling this file to  control how the TlmProvider class deals
+with the EventSetInformation API.
+
+If these macros are not set, the default behavior is to check the WINVER
+macro at compile time:
+
+- If WINVER is set to Windows 7 or before, TlmProvider will use GetProcAddress
+  to locate EventSetInformation, and then invoke it if present. This is less
+  efficient, but works on older versions of Windows.
+- If WINVER is set to Windows 8 or later, TlmProvider will directly invoke
+  EventSetInformation. This is more efficient, but the resulting application
+  will only work correctly on newer versions of Windows.
+
+If you need to run on Windows 7 RTM, but for some reason need to set WINVER to
+Windows 8 or higher, you can override the default behavior by defining
+TLM_HAVE_EVENT_SET_INFORMATION=2 when compiling this file.
+
+Details:
+- The TLM_EVENT_SET_INFORMATION macro can be set the name of a replacement
+  function that TlmProvider should use instead of EventSetInformation.
+- The TLM_HAVE_EVENT_SET_INFORMATION macro can be set to 0 (disable the use of
+  EventSetInformation), 1 (directly invoke EventSetInformation), or 2 (try to
+  locate EventSetInformation via GetProcAddress, and invoke if found).
+*/
+
+// This code needs to run on Windows 7 and this is magic which
+// removes static linking to EventSetInformation
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+
+#ifndef TLM_EVENT_SET_INFORMATION
+#define TLM_EVENT_SET_INFORMATION EventSetInformation
+#ifndef TLM_HAVE_EVENT_SET_INFORMATION
+#if WINVER < 0x0602 || !defined(EVENT_FILTER_TYPE_SCHEMATIZED)
+// Find "EventSetInformation" via GetModuleHandleExW+GetProcAddress
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+#else
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+#endif
+#elif !defined(TLM_HAVE_EVENT_SET_INFORMATION)
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+
 TlmProvider::~TlmProvider() {
   Unregister();
 }
@@ -20,7 +75,7 @@ TlmProvider::TlmProvider(const char* provider_name,
                          void* enable_callback_context) noexcept {
   ULONG status = Register(provider_name, provider_guid, enable_callback,
                           enable_callback_context);
-  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider resistration failure";
+  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider registration failure";
 }
 
 // Appends a nul-terminated string to a metadata block.
@@ -79,9 +134,42 @@ ULONG TlmProvider::Register(const char* provider_name,
   if (status != ERROR_SUCCESS)
     return status;
 
+#if TLM_HAVE_EVENT_SET_INFORMATION == 1
+
   // Best-effort, ignore failure.
-  return ::EventSetInformation(reg_handle_, EventProviderSetTraits,
-                               provider_metadata_, provider_metadata_size_);
+  status =
+      TLM_EVENT_SET_INFORMATION(reg_handle_, EventProviderSetTraits,
+                                provider_metadata_, provider_metadata_size_);
+
+#elif TLM_HAVE_EVENT_SET_INFORMATION == 2
+
+  HMODULE eventing_lib;
+  if (GetModuleHandleExW(0, L"api-ms-win-eventing-provider-l1-1-0.dll",
+                         &eventing_lib) ||
+      GetModuleHandleExW(0, L"advapi32.dll", &eventing_lib)) {
+    typedef ULONG(WINAPI * PFEventSetInformation)(
+        REGHANDLE reg_handle, EVENT_INFO_CLASS information_class,
+        PVOID event_information, ULONG information_length);
+    PFEventSetInformation event_set_information_ptr =
+        reinterpret_cast<decltype(&::EventSetInformation)>(
+            GetProcAddress(eventing_lib, "EventSetInformation"));
+    if (event_set_information_ptr) {
+      // Best-effort, ignore failure.
+      status = event_set_information_ptr(reg_handle_, EventProviderSetTraits,
+                                         provider_metadata_,
+                                         provider_metadata_size_);
+    }
+
+    FreeLibrary(eventing_lib);
+  }
+
+#else  // TLM_HAVE_EVENT_SET_INFORMATION == 0
+
+    // Make no attempt to invoke EventSetInformation.
+
+#endif  // TLM_HAVE_EVENT_SET_INFORMATION
+
+  return status;
 }
 
 bool TlmProvider::IsEnabled() const noexcept {
diff --git a/base/win/cet_shadow_stack_unittest.cc b/base/win/cet_shadow_stack_unittest.cc
index 8c58163cfbf44..cb73ea9e8e388 100644
--- a/base/win/cet_shadow_stack_unittest.cc
+++ b/base/win/cet_shadow_stack_unittest.cc
@@ -19,10 +19,14 @@ bool IsHardwareEnforcedShadowStacksEnabled() {
   if (base::win::GetVersion() < base::win::Version::WIN10_20H1)
     return false;
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return false;
   }
 
diff --git a/base/win/core_winrt_util.cc b/base/win/core_winrt_util.cc
index 25f5885bf2f40..3508cfe474bfd 100644
--- a/base/win/core_winrt_util.cc
+++ b/base/win/core_winrt_util.cc
@@ -3,17 +3,54 @@
 // found in the LICENSE file.
 
 #include "base/win/core_winrt_util.h"
+#include "base/threading/scoped_thread_priority.h"
 
 namespace base::win {
 
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoActivateInstance) GetRoActivateInstanceFunction() {
+  static decltype(&::RoActivateInstance) const function =
+      reinterpret_cast<decltype(&::RoActivateInstance)>(
+          LoadComBaseFunction("RoActivateInstance"));
+  return function;
+}
+
+decltype(&::RoGetActivationFactory) GetRoGetActivationFactoryFunction() {
+  static decltype(&::RoGetActivationFactory) const function =
+      reinterpret_cast<decltype(&::RoGetActivationFactory)>(
+          LoadComBaseFunction("RoGetActivationFactory"));
+  return function;
+}
+
+bool ResolveCoreWinRTDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+  return GetRoActivateInstanceFunction() && GetRoGetActivationFactoryFunction();
+}
+
 HRESULT RoGetActivationFactory(HSTRING class_id,
                                const IID& iid,
                                void** out_factory) {
-  return ::RoGetActivationFactory(class_id, iid, out_factory);
+  auto get_factory_func = GetRoGetActivationFactoryFunction();
+  if (!get_factory_func)
+    return E_FAIL;
+  return get_factory_func(class_id, iid, out_factory);
 }
 
 HRESULT RoActivateInstance(HSTRING class_id, IInspectable** instance) {
-  return ::RoActivateInstance(class_id, instance);
+  auto activate_instance_func = GetRoActivateInstanceFunction();
+  if (!activate_instance_func)
+    return E_FAIL;
+  return activate_instance_func(class_id, instance);
 }
 
 }  // namespace base::win
diff --git a/base/win/core_winrt_util.h b/base/win/core_winrt_util.h
index 3a6e0c9f3774c..c4a802c85d6ed 100644
--- a/base/win/core_winrt_util.h
+++ b/base/win/core_winrt_util.h
@@ -15,6 +15,8 @@
 
 namespace base::win {
 
+BASE_EXPORT bool ResolveCoreWinRTDelayload();
+
 // The following stubs are provided for when component build is enabled, in
 // order to avoid the propagation of delay-loading CoreWinRT to other modules.
 
diff --git a/base/win/hstring_reference.cc b/base/win/hstring_reference.cc
index b254fc64310a1..6b2b1a6290990 100644
--- a/base/win/hstring_reference.cc
+++ b/base/win/hstring_reference.cc
@@ -12,18 +12,54 @@
 #include "base/check_op.h"
 #include "base/numerics/safe_conversions.h"
 
-namespace base::win {
+namespace base {
+namespace {
+
+bool g_winrt_string_loaded = false;
+
+decltype(&::WindowsCreateStringReference) GetWindowsCreateStringReference() {
+  static auto const create_string_reference_func =
+      []() -> decltype(&::WindowsCreateStringReference) {
+    const HMODULE handle =
+        ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    if (handle) {
+      return reinterpret_cast<decltype(&::WindowsCreateStringReference)>(
+          ::GetProcAddress(handle, "WindowsCreateStringReference"));
+    }
+    return nullptr;
+  }();
+  return create_string_reference_func;
+}
+
+}  // namespace
+
+namespace win {
+
+// static
+bool HStringReference::ResolveCoreWinRTStringDelayload() {
+  g_winrt_string_loaded = GetWindowsCreateStringReference() != nullptr;
+  return g_winrt_string_loaded;
+}
 
 HStringReference::HStringReference(const wchar_t* str, size_t length) {
+
+  // This was added because otherwise, the checks below would consistently fail.
+  ResolveCoreWinRTStringDelayload();
+  DCHECK(g_winrt_string_loaded);
   // String must be null terminated for WindowsCreateStringReference.
   // nullptr str is OK so long as the length is 0.
   DCHECK(str ? str[length] == L'\0' : length == 0);
-  const HRESULT hr = ::WindowsCreateStringReference(
+  // If you nullptr crash here, you've failed to call
+  // ResolveCoreWinRTStringDelayLoad and check its return value.
+  const HRESULT hr = GetWindowsCreateStringReference()(
       str, checked_cast<UINT32>(length), &hstring_header_, &hstring_);
+  // All failure modes of WindowsCreateStringReference are handled gracefully
+  // but this class.
   DCHECK_EQ(hr, S_OK);
 }
 
 HStringReference::HStringReference(const wchar_t* str)
     : HStringReference(str, str ? wcslen(str) : 0) {}
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_reference.h b/base/win/hstring_reference.h
index 3cde4acef6f2e..2366a681e72c0 100644
--- a/base/win/hstring_reference.h
+++ b/base/win/hstring_reference.h
@@ -9,7 +9,8 @@
 
 #include "base/base_export.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 // HStringReference is an HSTRING representation of a null terminated
 // string backed by memory that outlives the HStringReference instance.
@@ -17,12 +18,31 @@ namespace base::win {
 // If you need an HSTRING class that manages its own memory, you should
 // use ScopedHString instead.
 //
+// Note that HStringReference requires certain functions that are only
+// available on Windows 8 and later, and that these functions need to be
+// delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using HStringReference.
+//
+// One-time Initialization for HStringReference:
+//
+//   const bool success = HStringReference::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // HStringReference can be used.
+//   } else {
+//     // Handle error.
+//   }
+//
 // Example use:
 //
 //   HStringReference string(L"abc");
 //
 class BASE_EXPORT HStringReference {
  public:
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  static bool ResolveCoreWinRTStringDelayload();
+
   HStringReference(const wchar_t* str, size_t len);
   explicit HStringReference(const wchar_t* str);
 
@@ -47,6 +67,7 @@ class BASE_EXPORT HStringReference {
   HSTRING_HEADER hstring_header_;
 };
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
 
 #endif  // BASE_WIN_HSTRING_REFERENCE_H_
diff --git a/base/win/hstring_reference_unittest.cc b/base/win/hstring_reference_unittest.cc
index 64fa91320a040..5761ea461574a 100644
--- a/base/win/hstring_reference_unittest.cc
+++ b/base/win/hstring_reference_unittest.cc
@@ -26,6 +26,8 @@ void VerifyHSTRINGEquals(HSTRING hstring, const wchar_t* test_string) {
 }  // namespace
 
 TEST(HStringReferenceTest, Init) {
+  EXPECT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
+
   const HStringReference string(kTestString);
   EXPECT_NE(string.Get(), nullptr);
   VerifyHSTRINGEquals(string.Get(), kTestString);
diff --git a/base/win/registry.cc b/base/win/registry.cc
index 7b9dcb90e627e..d24a4b0ede9d5 100644
--- a/base/win/registry.cc
+++ b/base/win/registry.cc
@@ -23,6 +23,7 @@
 #include "base/win/object_watcher.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 
 extern "C" NTSTATUS WINAPI NtDeleteKey(IN HANDLE KeyHandle);
 
@@ -87,8 +88,9 @@ bool RegKey::Watcher::StartWatching(HKEY key, ChangeCallback callback) {
   }
 
   DWORD filter = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
-                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY |
-                 REG_NOTIFY_THREAD_AGNOSTIC;
+                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY;
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    filter |= REG_NOTIFY_THREAD_AGNOSTIC;
   // Watch the registry key for a change of value.
   LONG result =
       RegNotifyChangeKeyValue(key, /*bWatchSubtree=*/TRUE, filter,
diff --git a/base/win/scoped_hstring.cc b/base/win/scoped_hstring.cc
index 042768f2b249e..6a8b7eff01b90 100644
--- a/base/win/scoped_hstring.cc
+++ b/base/win/scoped_hstring.cc
@@ -18,24 +18,88 @@
 
 namespace base {
 
+namespace {
+
+static bool g_load_succeeded = false;
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle =
+      ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::WindowsCreateString) GetWindowsCreateString() {
+  static decltype(&::WindowsCreateString) const function =
+      reinterpret_cast<decltype(&::WindowsCreateString)>(
+          LoadComBaseFunction("WindowsCreateString"));
+  return function;
+}
+
+decltype(&::WindowsDeleteString) GetWindowsDeleteString() {
+  static decltype(&::WindowsDeleteString) const function =
+      reinterpret_cast<decltype(&::WindowsDeleteString)>(
+          LoadComBaseFunction("WindowsDeleteString"));
+  return function;
+}
+
+decltype(&::WindowsGetStringRawBuffer) GetWindowsGetStringRawBuffer() {
+  static decltype(&::WindowsGetStringRawBuffer) const function =
+      reinterpret_cast<decltype(&::WindowsGetStringRawBuffer)>(
+          LoadComBaseFunction("WindowsGetStringRawBuffer"));
+  return function;
+}
+
+HRESULT WindowsCreateString(const wchar_t* src,
+                            uint32_t len,
+                            HSTRING* out_hstr) {
+  decltype(&::WindowsCreateString) create_string_func =
+      GetWindowsCreateString();
+  if (!create_string_func)
+    return E_FAIL;
+  return create_string_func(src, len, out_hstr);
+}
+
+HRESULT WindowsDeleteString(HSTRING hstr) {
+  decltype(&::WindowsDeleteString) delete_string_func =
+      GetWindowsDeleteString();
+  if (!delete_string_func)
+    return E_FAIL;
+  return delete_string_func(hstr);
+}
+
+const wchar_t* WindowsGetStringRawBuffer(HSTRING hstr, uint32_t* out_len) {
+  decltype(&::WindowsGetStringRawBuffer) get_string_raw_buffer_func =
+      GetWindowsGetStringRawBuffer();
+  if (!get_string_raw_buffer_func) {
+    *out_len = 0;
+    return nullptr;
+  }
+  return get_string_raw_buffer_func(hstr, out_len);
+}
+
+}  // namespace
+
 namespace internal {
 
 // static
 void ScopedHStringTraits::Free(HSTRING hstr) {
-  ::WindowsDeleteString(hstr);
+  base::WindowsDeleteString(hstr);
 }
 
 }  // namespace internal
 
 namespace win {
 
-ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {}
+ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {
+  DCHECK(g_load_succeeded);
+}
 
 // static
 ScopedHString ScopedHString::Create(WStringPiece str) {
+  DCHECK(g_load_succeeded);
   HSTRING hstr;
-  HRESULT hr = ::WindowsCreateString(str.data(),
-                                     checked_cast<UINT32>(str.length()), &hstr);
+  HRESULT hr = base::WindowsCreateString(
+      str.data(), checked_cast<UINT32>(str.length()), &hstr);
   if (SUCCEEDED(hr))
     return ScopedHString(hstr);
 
@@ -57,9 +121,21 @@ ScopedHString ScopedHString::Create(StringPiece str) {
 }
 
 // static
+bool ScopedHString::ResolveCoreWinRTStringDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+
+  static const bool load_succeeded = []() {
+    bool success = GetWindowsCreateString() && GetWindowsDeleteString() &&
+                   GetWindowsGetStringRawBuffer();
+    g_load_succeeded = success;
+    return success;
+  }();
+  return load_succeeded;
+}
+
 WStringPiece ScopedHString::Get() const {
   UINT32 length = 0;
-  const wchar_t* buffer = ::WindowsGetStringRawBuffer(get(), &length);
+  const wchar_t* buffer = base::WindowsGetStringRawBuffer(get(), &length);
   return WStringPiece(buffer, length);
 }
 
diff --git a/base/win/scoped_hstring.h b/base/win/scoped_hstring.h
index 95bc98bc2cf09..4ba6e23d08272 100644
--- a/base/win/scoped_hstring.h
+++ b/base/win/scoped_hstring.h
@@ -27,7 +27,21 @@ struct BASE_EXPORT ScopedHStringTraits {
 
 namespace win {
 
-// ScopedHString is a wrapper around an HSTRING.
+// ScopedHString is a wrapper around an HSTRING. Note that it requires certain
+// functions that are only available on Windows 8 and later, and that these
+// functions need to be delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using ScopedHString.
+//
+// One-time Initialization for ScopedHString:
+//
+//   bool success = ScopedHString::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // ScopeHString can be used.
+//   } else {
+//     // Handle error.
+//   }
 //
 // Example use:
 //
@@ -48,6 +62,9 @@ class BASE_EXPORT ScopedHString
   static ScopedHString Create(WStringPiece str);
   static ScopedHString Create(StringPiece str);
 
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  [[nodiscard]] static bool ResolveCoreWinRTStringDelayload();
+
   // Returns a view into the memory buffer managed by the instance. The returned
   // StringPiece is only valid during the lifetime of this ScopedHString
   // instance.
diff --git a/base/win/scoped_winrt_initializer.cc b/base/win/scoped_winrt_initializer.cc
index 4c93dcfabf658..85f83dab8192b 100644
--- a/base/win/scoped_winrt_initializer.cc
+++ b/base/win/scoped_winrt_initializer.cc
@@ -5,14 +5,61 @@
 #include "base/win/scoped_winrt_initializer.h"
 
 #include <roapi.h>
+#include <windows.h>
+
+#include <ostream>
 
 #include "base/check_op.h"
+#include "base/threading/scoped_thread_priority.h"
 #include "base/win/com_init_util.h"
+#include "base/win/core_winrt_util.h"
 
 namespace base::win {
 
+namespace {
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoInitialize) GetRoInitializeFunction() {
+  static decltype(&::RoInitialize) const function =
+      reinterpret_cast<decltype(&::RoInitialize)>(
+          LoadComBaseFunction("RoInitialize"));
+  return function;
+}
+
+decltype(&::RoUninitialize) GetRoUninitializeFunction() {
+  static decltype(&::RoUninitialize) const function =
+      reinterpret_cast<decltype(&::RoUninitialize)>(
+          LoadComBaseFunction("RoUninitialize"));
+  return function;
+}
+
+HRESULT CallRoInitialize(RO_INIT_TYPE init_type) {
+  auto ro_initialize_func = GetRoInitializeFunction();
+  if (!ro_initialize_func)
+    return E_FAIL;
+  return ro_initialize_func(init_type);
+}
+
+void CallRoUninitialize() {
+  auto ro_uninitialize_func = GetRoUninitializeFunction();
+  if (ro_uninitialize_func)
+    ro_uninitialize_func();
+}
+
+}  // namespace
+
 ScopedWinrtInitializer::ScopedWinrtInitializer()
-    : hr_(::RoInitialize(RO_INIT_MULTITHREADED)) {
+    : hr_(CallRoInitialize(RO_INIT_MULTITHREADED)) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 #if DCHECK_IS_ON()
   if (SUCCEEDED(hr_))
@@ -25,7 +72,7 @@ ScopedWinrtInitializer::ScopedWinrtInitializer()
 ScopedWinrtInitializer::~ScopedWinrtInitializer() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (SUCCEEDED(hr_))
-    ::RoUninitialize();
+    CallRoUninitialize();
 }
 
 bool ScopedWinrtInitializer::Succeeded() const {
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 0d81e7c0a268e..b65c2426fb443 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -38,6 +38,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/files/file_path.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
@@ -66,6 +67,21 @@ namespace base {
 namespace win {
 
 namespace {
+
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+
+bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch(kDisableDirectWrite);
+}
 
 // Sets the value of |property_key| to |property_value| in |property_store|.
 bool SetPropVariantValueForPropertyStore(
@@ -95,10 +111,40 @@ void __cdecl ForceCrashOnSigAbort(int) {
   *((volatile int*)nullptr) = 0x1337;
 }
 
-// Returns the current platform role. We use the PowerDeterminePlatformRoleEx
+// Returns the current platform role. We use the PowerDeterminePlatformRole
 // API for that.
 POWER_PLATFORM_ROLE GetPlatformRole() {
-  return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
+	return PowerDeterminePlatformRole();
+}
+
+// Because we used to support versions earlier than 8.1, we dynamically load
+// this function from user32.dll, so it won't fail to load in runtime.
+// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  if (!IsUser32AndGdi32Available())
+    return false;
+
+  static const auto set_process_dpi_awareness_func =
+      reinterpret_cast<decltype(&::SetProcessDpiAwareness)>(
+          GetUser32FunctionPointer("SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr))
+      return true;
+    DLOG_IF(ERROR, hr == E_ACCESSDENIED)
+        << "Access denied error from SetProcessDpiAwarenessInternal. "
+           "Function called twice, or manifest was used.";
+    NOTREACHED()
+        << "SetProcessDpiAwarenessInternal failed with unexpected error: "
+        << hr;
+    return false;
+  }
+
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
+
+  return false;
 }
 
 // Enable V2 per-monitor high-DPI support for the process. This will cause
@@ -238,10 +284,16 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
            IsDeviceUsedAsATablet(/*reason=*/nullptr);
   }
 
+  if (!ResolveCoreWinRTDelayload() ||
+      !ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
+
   ScopedHString view_settings_guid = ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UIViewSettings);
   Microsoft::WRL::ComPtr<IUIViewSettingsInterop> view_settings_interop;
-  HRESULT hr = ::RoGetActivationFactory(view_settings_guid.get(),
+  HRESULT hr = win::RoGetActivationFactory(view_settings_guid.get(),
                                         IID_PPV_ARGS(&view_settings_interop));
   if (FAILED(hr))
     return false;
@@ -606,8 +658,17 @@ bool IsJoinedToAzureAD() {
 bool IsUser32AndGdi32Available() {
   static auto is_user32_and_gdi32_available = []() {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
+	if (!ShouldUseDirectWrite())
+        return true;
+	  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
+    if(!get_process_mitigation_policy)
+		return true;
+
     PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
+    if (get_process_mitigation_policy(GetCurrentProcess(),
                                      ProcessSystemCallDisablePolicy, &policy,
                                      sizeof(policy))) {
       return policy.DisallowWin32kSystemCalls == 0;
@@ -673,7 +734,7 @@ void DisableFlicks(HWND hwnd) {
 }
 
 void EnableHighDPISupport() {
-  if (!IsUser32AndGdi32Available())
+  if (!IsUser32AndGdi32Available() || GetVersion() < Version::VISTA)
     return;
 
   // Enable per-monitor V2 if it is available (Win10 1703 or later).
@@ -682,7 +743,7 @@ void EnableHighDPISupport() {
 
   // Fall back to per-monitor DPI for older versions of Win10.
   PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
-  if (!::SetProcessDpiAwareness(process_dpi_awareness)) {
+  if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
     // For windows versions where SetProcessDpiAwareness fails, try its
     // predecessor.
     BOOL result = ::SetProcessDPIAware();
diff --git a/base/win/winrt_storage_util_unittest.cc b/base/win/winrt_storage_util_unittest.cc
index 5c54819e4b85a..8f3f64f29011a 100644
--- a/base/win/winrt_storage_util_unittest.cc
+++ b/base/win/winrt_storage_util_unittest.cc
@@ -21,6 +21,10 @@ namespace win {
 TEST(WinrtStorageUtilTest, CreateBufferFromData) {
   ScopedCOMInitializer com_initializer(ScopedCOMInitializer::kMTA);
 
+  if (!ResolveCoreWinRTDelayload()) {
+    return;
+  }
+
   const std::vector<uint8_t> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   Microsoft::WRL::ComPtr<ABI::Windows::Storage::Streams::IBuffer> buffer;
   ASSERT_HRESULT_SUCCEEDED(
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index db4ede8eb28c8..620168b95cc86 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -433,6 +433,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void BrowserURLHandlerCreated(content::BrowserURLHandler* handler) override;
   base::FilePath GetDefaultDownloadDirectory() override;
   std::string GetDefaultDownloadName() override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   base::FilePath GetShaderDiskCacheDirectory() override;
   base::FilePath GetGrShaderDiskCacheDirectory() override;
   base::FilePath GetGraphiteDawnDiskCacheDirectory() override;
diff --git a/chrome/browser/device_reauth/win/authenticator_win.cc b/chrome/browser/device_reauth/win/authenticator_win.cc
index 1d9342a94ad70..c12ef488478df 100644
--- a/chrome/browser/device_reauth/win/authenticator_win.cc
+++ b/chrome/browser/device_reauth/win/authenticator_win.cc
@@ -45,6 +45,11 @@ using ABI::Windows::Security::Credentials::UI::
     UserConsentVerifierAvailability_NotConfiguredForUser;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 BiometricAuthenticationStatusWin ConvertUserConsentVerifierAvailability(
     UserConsentVerifierAvailability availability) {
   switch (availability) {
@@ -93,6 +98,11 @@ void GetBiometricAvailabilityFromWindows(
   // (http://crbug/973868).
   SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
 
+  if (!ResolveCoreWinRT()) {
+    ReportCantCheckAvailability(thread, std::move(callback));
+    return;
+  }
+
   ComPtr<IUserConsentVerifierStatics> factory;
   HRESULT hr = base::win::GetActivationFactory<
       IUserConsentVerifierStatics,
diff --git a/chrome/browser/download/chrome_download_manager_delegate.cc b/chrome/browser/download/chrome_download_manager_delegate.cc
index 27d85fc9bd95d..2f8a36dcfda41 100644
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -55,6 +55,7 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pdf_util.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
@@ -1564,7 +1565,10 @@ void ChromeDownloadManagerDelegate::OnDownloadTargetDetermined(
     DownloadItemModel model(item);
     model.DetermineAndSetShouldPreferOpeningInBrowser(
         target_info->target_path, target_info->is_filetype_handled_safely);
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableDownloadUpload)) {
+
     model.SetDangerLevel(target_info->danger_level);
+	}
   }
   if (ShouldBlockFile(item, target_info->danger_type)) {
     MaybeReportDangerousDownloadBlocked(
@@ -1643,6 +1647,10 @@ bool ChromeDownloadManagerDelegate::IsOpenInBrowserPreferreredForFile(
 bool ChromeDownloadManagerDelegate::ShouldBlockFile(
     download::DownloadItem* item,
     download::DownloadDangerType danger_type) const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableDownloadUpload)) {
+
+	  return false;
+  }
   // Chrome-initiated background downloads should not be blocked.
   if (item && !item->RequireSafetyChecks()) {
     return false;
diff --git a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
index cfe13c30f9758..204edde196be8 100644
--- a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
+++ b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
@@ -88,6 +88,11 @@ class WebAccountSupportFinder
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
 
+    if (!base::win::ResolveCoreWinRTDelayload())
+      return;  // Unsupported.
+    if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+      return;  // Unsupported.
+
     // Get the `WebAuthenticationCoreManager`.
     ComPtr<IWebAuthenticationCoreManagerStatics> auth_manager;
     HRESULT hresult = base::win::GetActivationFactory<
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index 60d6876953def..03db4e06e94b8 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -1775,6 +1775,11 @@
     "owners": [ "cros-networking@google.com" ],
     "expiry_milestone": 121
   },
+  {
+    "name": "disable-download-upload",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disable-explicit-dma-fences",
     "owners": [ "chromeos-gfx@google.com" ],
@@ -1843,6 +1848,11 @@
     // workaround for some issues.
     "expiry_milestone": -1
   },
+  {
+    "name": "disable-windows-10-custom-titlebar",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disallow-doc-written-script-loads",
     "owners": [ "//chrome/browser/data_saver/OWNERS" ],
@@ -4621,6 +4631,16 @@
     "owners": [ "chromeos-camera-eng@google.com" ],
     "expiry_milestone": 120
   },
+  {
+    "name": "force-dark-mode",
+    "owners": [ "alex313031", "win32ss" ],
+    "expiry_milestone": -1
+  },
+  {
+    "name": "force-gdi",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "force-gpu-main-thread-to-normal-priority-drdc",
     "owners": [ "vikassoni", "lehoangquyen" ],
@@ -4682,6 +4702,11 @@
     // have no access to commandline flags.
     "expiry_milestone": -1
   },
+  {
+    "name": "disable-aero",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "forced-colors",
     "owners": [ "almaher@microsoft.com" ],
diff --git a/chrome/browser/flag-never-expire-list.json b/chrome/browser/flag-never-expire-list.json
index 5319a2eecd5d5..773fb3d2bd0af 100644
--- a/chrome/browser/flag-never-expire-list.json
+++ b/chrome/browser/flag-never-expire-list.json
@@ -30,10 +30,12 @@
   "disable-accelerated-video-decode",
   "disable-accelerated-video-encode",
   "disable-buffer-bw-compression",
+  "disable-download-upload",
   "disable-explicit-dma-fences",
   "disable-javascript-harmony-shipping",
   "disable-webrtc-hw-decoding",
   "disable-webrtc-hw-encoding",
+  "disable-windows-10-custom-titlebar",
   "disallow-doc-written-script-loads",
   "enable-autofill-credit-card-upload",
   "enable-benchmarking",
@@ -77,12 +79,15 @@
   "extensions-on-chrome-urls",
   "external-navigation-debug-logs",
   "force-color-profile",
+  "force-dark-mode",
   "force-effective-connection-type",
+  "force-gdi",
   "force-show-update-menu-badge",
   "force-startup-signin-promo",
   "force-text-direction",
   "force-ui-direction",
   "force-update-menu-type",
+  "disable-aero",
   "fullscreen-promos-manager-skip-internal-limits",
   "fullscreen-viewport-adjustment-experiment",
   "gesture-properties-dbus-service",
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index d33d6d04c130e..7cbd830715c4f 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -1093,6 +1093,10 @@ const char kDesktopPWAsWebBundlesName[] = "Desktop PWAs Web Bundles";
 const char kDesktopPWAsWebBundlesDescription[] =
     "Adds support for web bundles, making web apps able to be launched "
     "offline.";
+
+const char kDisableDownloadUploadName[] = "Disable Safe Browsing for Downloads and Download Sample Uploads";
+const char kDisableDownloadUploadDescription[] = "Disables prompts about unsafe or uncommon downloads, and "
+												  "prevents samples of downloads from being sent to Google.";
 
 const char kEnableTLS13EarlyDataName[] = "TLS 1.3 Early Data";
 const char kEnableTLS13EarlyDataDescription[] =
@@ -1747,6 +1751,18 @@ const char kDrawImmediatelyWhenInteractiveName[] =
 const char kDrawImmediatelyWhenInteractiveDescription[] =
     "Causes viz to activate and draw frames immediately during a touch "
     "interaction or scroll.";
+
+const char kIncognitoBrandConsistencyForDesktopName[] =
+    "Enable Incognito brand consistency in desktop.";
+const char kIncognitoBrandConsistencyForDesktopDescription[] =
+    "When enabled, removes any theme or background customization done by the "
+    "user on the Incognito UI.";
+
+const char kInheritNativeThemeFromParentWidgetName[] =
+    "Allow widgets to inherit native theme from its parent widget.";
+const char kInheritNativeThemeFromParentWidgetDescription[] =
+    "When enabled, secondary UIs like menus, dialogs etc would be in dark mode "
+    "when Incognito mode is open.";
 
 const char kFillingAcrossGroupedSitesName[] =
     "Password filling across grouped websites";
@@ -1779,6 +1795,14 @@ const char kForceTextDirectionDescription[] =
 const char kForceDirectionLtr[] = "Left-to-right";
 const char kForceDirectionRtl[] = "Right-to-left";
 
+const char kForceGdiName[] = "Force GDI font rendering";
+const char kForceGdiDescription[] =
+    "Use GDI font rendering in place of DirectWrite font rendering on Windows.";
+
+const char kDisableWindows10CustomTitlebarName[] = "Force disabling of Windows 10 custom titlebar";
+const char kDisableWindows10CustomTitlebarDescription[] =
+    "Disable the \"Windows 10\" custom titlebar to take advantage of Aero Glass fixes for Windows 7.";
+
 const char kForceUiDirectionName[] = "Force UI direction";
 const char kForceUiDirectionDescription[] =
     "Explicitly force the UI to left-to-right (LTR) or right-to-left (RTL) "
@@ -1935,6 +1959,10 @@ const char kHideIncognitoMediaMetadataName[] =
 const char kHideIncognitoMediaMetadataDescription[] =
     "When enabled, media metadata will be hidden from your OS' media player "
     "if you are in an Incognito session.";
+
+
+
+
 
 const char kTabAudioMutingName[] = "Tab audio muting UI control";
 const char kTabAudioMutingDescription[] =
@@ -2802,6 +2830,16 @@ const char kVmPerBootShaderCacheDescription[] =
 const char kAutoWebContentsDarkModeName[] = "Auto Dark Mode for Web Contents";
 const char kAutoWebContentsDarkModeDescription[] =
     "Automatically render all web contents using a dark theme.";
+
+
+
+
+
+
+const char kDisableAeroThemeName[] = "Disable Aero Window Frame Compositing";
+const char kDisableAeroThemeDescription[] =
+	"Use the classic Chromium theme designed to mimick \"Aero\" window controls. "
+	"Typically used when desktop composition is disabled or unavailable.";
 
 const char kForcedColorsName[] = "Forced Colors";
 const char kForcedColorsDescription[] =
@@ -7755,6 +7793,10 @@ const char kEnableBoundSessionCredentialsDescription[] =
     "prevent the usage of bound credentials outside of the user device.";
 #endif  // BUILDFLAG(ENABLE_BOUND_SESSION_CREDENTIALS)
 
+const char kThoriumCustomTabsName[] = "Thorium Trapezoidal Tabs UI";
+const char kThoriumCustomTabsDescription[] =
+	"Changes the look of browser tabs to appear with a trapezoidal shape, restoring the pre M72 tabstrip appearance.";
+
 // ============================================================================
 // Don't just add flags to the end, put them in the right section in
 // alphabetical order just like the header file.
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 89d8ca8a55114..80b3a9c62e440 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1591,6 +1591,18 @@ extern const char kParallelDownloadingDescription[];
 extern const char kPasswordGenerationExperimentName[];
 extern const char kPasswordGenerationExperimentDescription[];
 
+extern const char kDisableDownloadUploadName[];
+extern const char kDisableDownloadUploadDescription[];
+
+
+
+
+extern const char kForceGdiName[];
+extern const char kForceGdiDescription[];
+
+extern const char kDisableWindows10CustomTitlebarName[];
+extern const char kDisableWindows10CustomTitlebarDescription[];
+
 extern const char kBacklightOcrName[];
 extern const char kBacklightOcrDescription[];
 
@@ -1609,6 +1621,12 @@ extern const char kBookmarksRefreshDescription[];
 extern const char kAutoWebContentsDarkModeName[];
 extern const char kAutoWebContentsDarkModeDescription[];
 
+
+
+
+extern const char kDisableAeroThemeName[];
+extern const char kDisableAeroThemeDescription[];
+
 extern const char kForcedColorsName[];
 extern const char kForcedColorsDescription[];
 
@@ -4492,6 +4510,15 @@ extern const char kEnableBoundSessionCredentialsName[];
 extern const char kEnableBoundSessionCredentialsDescription[];
 #endif  // BUILDFLAG(ENABLE_BOUND_SESSION_CREDENTIALS)
 
+extern const char kThoriumCustomTabsName[];
+extern const char kThoriumCustomTabsDescription[];
+
+extern const char kIncognitoBrandConsistencyForDesktopName[];
+extern const char kIncognitoBrandConsistencyForDesktopDescription[];
+
+extern const char kInheritNativeThemeFromParentWidgetName[];
+extern const char kInheritNativeThemeFromParentWidgetDescription[];
+
 // ============================================================================
 // Don't just add flags to the end, put them in the right section in
 // alphabetical order. See top instructions for more.
diff --git a/chrome/browser/notifications/notification_platform_bridge_win.cc b/chrome/browser/notifications/notification_platform_bridge_win.cc
index 8b8e8e3c6195b..8a45dcc5babcb 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win.cc
@@ -708,7 +708,7 @@ class NotificationPlatformBridgeWinImpl
         InstallUtil::IsStartMenuShortcutWithActivatorGuidInstalled();
 
     int status = static_cast<int>(SetReadyCallbackStatus::kSuccess);
-    bool enabled = activator_registered && shortcut_installed;
+    bool enabled = base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload() && activator_registered && shortcut_installed;
 
     if (!enabled) {
       if (!shortcut_installed) {
@@ -719,6 +719,8 @@ class NotificationPlatformBridgeWinImpl
         status |= static_cast<int>(
             SetReadyCallbackStatus::kComServerMisconfiguration);
       }
+      if (!(base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload()))
+        status |= static_cast<int>(SetReadyCallbackStatus::kComNotInitialized);
     }
 
     LogSetReadyCallbackStatus(static_cast<SetReadyCallbackStatus>(status));
diff --git a/chrome/browser/notifications/win/notification_metrics.h b/chrome/browser/notifications/win/notification_metrics.h
index 8dfbaea83d66c..aab0938792430 100644
--- a/chrome/browser/notifications/win/notification_metrics.h
+++ b/chrome/browser/notifications/win/notification_metrics.h
@@ -137,8 +137,8 @@ enum class SetReadyCallbackStatus {
   kSuccess = 0,
   kShortcutMisconfiguration = 1 << 0,
   kComServerMisconfiguration = 1 << 1,
-  kComNotInitializedObsolete = 1 << 2,  // No longer possible w/ Win10+ only.
-  kMaxValue = kComNotInitializedObsolete,
+  kComNotInitialized = 1 << 2,
+  kMaxValue = kComNotInitialized,
 };
 
 // These values are persisted to logs. Entries should not be renumbered and
diff --git a/chrome/browser/obsolete_system/obsolete_system_win.cc b/chrome/browser/obsolete_system/obsolete_system_win.cc
index 689026a405de0..356efbd904b66 100644
--- a/chrome/browser/obsolete_system/obsolete_system_win.cc
+++ b/chrome/browser/obsolete_system/obsolete_system_win.cc
@@ -22,16 +22,12 @@ base::win::Version GetRealOSVersion() {
   return base::win::OSInfo::Kernel32Version();
 }
 
-bool IsObsoleteOsVersion() {
-  return GetRealOSVersion() < base::win::Version::WIN10;
-}
-
 }  // namespace
 
 namespace ObsoleteSystem {
 
 bool IsObsoleteNowOrSoon() {
-  return IsObsoleteOsVersion();
+  return false;
 }
 
 std::u16string LocalizedObsoleteString() {
@@ -52,7 +48,7 @@ bool IsEndOfTheLine() {
   // M109 was the last milestone to support Win 7/8/8.1, the last deprecated
   // Windows version. Future deprecations should update this to the last
   // milestone that supports the soon-to-be-deprecated Windows version.
-  return CHROME_VERSION_MAJOR >= 109;
+  return false;
 }
 
 const char* GetLinkURL() {
diff --git a/chrome/browser/sharing_hub/sharing_hub_features.cc b/chrome/browser/sharing_hub/sharing_hub_features.cc
index 57d5a500579aa..f9eeea2a3a7bc 100644
--- a/chrome/browser/sharing_hub/sharing_hub_features.cc
+++ b/chrome/browser/sharing_hub/sharing_hub_features.cc
@@ -69,7 +69,7 @@ bool HasPageAction(content::BrowserContext* context, bool is_popup_mode) {
 
 BASE_FEATURE(kDesktopScreenshots,
              "DesktopScreenshots",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+             base::FEATURE_ENABLED_BY_DEFAULT);
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS)
 void RegisterProfilePrefs(PrefRegistrySimple* registry) {
diff --git a/chrome/browser/themes/theme_helper.cc b/chrome/browser/themes/theme_helper.cc
index 43b03f9c3dce7..937a6d540de88 100644
--- a/chrome/browser/themes/theme_helper.cc
+++ b/chrome/browser/themes/theme_helper.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/themes/theme_service.h"
 
 #include "base/feature_list.h"
+#include "base/features.h"
 #include "base/no_destructor.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -116,6 +117,59 @@ base::RefCountedMemory* ThemeHelper::GetRawData(
   return data;
 }
 
+// For legacy reasons, the theme supplier requires the incognito variants of
+// color IDs.  This converts from normal to incognito IDs where they exist.
+int GetIncognitoId(int id) {
+  switch (id) {
+    case TP::COLOR_FRAME_ACTIVE:
+      return TP::COLOR_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_FRAME_INACTIVE:
+      return TP::COLOR_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_ACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_ACTIVE;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_INACTIVE;
+    default:
+      return id;
+  }
+}
+
+// static
+bool ThemeHelper::ShouldIgnoreThemeSupplier(
+    int id,
+    bool incognito,
+    const CustomThemeSupplier* theme_supplier) {
+  if (incognito && base::FeatureList::IsEnabled(
+                       base::features::kIncognitoBrandConsistencyForDesktop)) {
+    return true;
+  }
+  // The incognito NTP uses the default background color instead of any theme
+  // background color, unless the theme also sets a custom background image.
+  return incognito && (id == TP::COLOR_NTP_BACKGROUND) &&
+         !HasCustomImage(IDR_THEME_NTP_BACKGROUND, theme_supplier);
+}
+
+
+// static
+bool ThemeHelper::UseIncognitoColor(int id,
+                                    const CustomThemeSupplier* theme_supplier) {
+  // Incognito is disabled for any non-ignored custom theme colors so they apply
+  // atop a predictable state.
+  return ShouldIgnoreThemeSupplier(id, true, theme_supplier) ||
+         (!IsCustomTheme(theme_supplier) &&
+          (!theme_supplier || theme_supplier->CanUseIncognitoColors()));
+}
+
+
+
 color_utils::HSL ThemeHelper::GetTint(
     int id,
     bool incognito,
@@ -125,7 +179,7 @@ color_utils::HSL ThemeHelper::GetTint(
   if (theme_supplier && theme_supplier->GetTint(id, &hsl))
     return hsl;
 
-  return TP::GetDefaultTint(id, incognito, UseDarkModeColors(theme_supplier));
+  return TP::GetDefaultTint(id, incognito  && UseIncognitoColor(id, theme_supplier), UseDarkModeColors(theme_supplier));
 }
 
 gfx::ImageSkia* ThemeHelper::GetImageSkiaNamed(
diff --git a/chrome/browser/themes/theme_helper.h b/chrome/browser/themes/theme_helper.h
index 34a4c3501ca8b..8715be77976a6 100644
--- a/chrome/browser/themes/theme_helper.h
+++ b/chrome/browser/themes/theme_helper.h
@@ -93,10 +93,22 @@ class ThemeHelper {
 
  private:
   friend class theme_service_internal::ThemeServiceTest;
+
+  // Whether the default incognito color/tint for |id| should be used, if
+  // available.
+  static bool UseIncognitoColor(int id,
+                                const CustomThemeSupplier* theme_supplier);
 
   // Whether dark default colors/tints should be used, if available.
   static bool UseDarkModeColors(const CustomThemeSupplier* theme_supplier);
 
+  // Whether the color from |theme_supplier| (if any) should be ignored for
+  // the given |id| and |incognito| state.
+  static bool ShouldIgnoreThemeSupplier(
+      int id,
+      bool incognito,
+      const CustomThemeSupplier* theme_supplier);
+
   // Returns a cross platform image for an id.
   gfx::Image GetImageNamed(int id,
                            bool incognito,
diff --git a/chrome/browser/themes/theme_service.cc b/chrome/browser/themes/theme_service.cc
index d0e1d573c1fca..2e4b7f76f3e6d 100644
--- a/chrome/browser/themes/theme_service.cc
+++ b/chrome/browser/themes/theme_service.cc
@@ -11,6 +11,7 @@
 
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
+#include "base/features.h"
 #include "base/files/file_util.h"
 #include "base/functional/bind.h"
 #include "base/location.h"
@@ -237,7 +238,10 @@ base::RefCountedMemory* ThemeService::BrowserThemeProvider::GetRawData(
 
 CustomThemeSupplier* ThemeService::BrowserThemeProvider::GetThemeSupplier()
     const {
-  return incognito_ ? nullptr : delegate_->GetThemeSupplier();
+    bool should_ignore_theme_supplier =
+      incognito_ && base::FeatureList::IsEnabled(
+                        base::features::kIncognitoBrandConsistencyForDesktop);
+  return should_ignore_theme_supplier ? nullptr : delegate_->GetThemeSupplier();
 }
 
 // ThemeService ---------------------------------------------------------------
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index c6da605fb1f1e..0f5a06fe24912 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -8,6 +8,7 @@
 #include "base/functional/bind.h"
 #include "base/no_destructor.h"
 #include "base/win/windows_version.h"
+#include "chrome/browser/themes/browser_theme_pack.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/win/titlebar_config.h"
@@ -45,6 +46,13 @@ class FrameColorHelper {
   static FrameColorHelper* Get();
 
  private:
+  // Returns whether there is a custom image provided for the given id.
+  bool HasCustomImage(int id, const ui::ColorProviderKey& key) const;
+
+  // Returns true if colors from DWM can be used, i.e. this is a native frame
+  // on Windows 8+.
+  bool DwmColorsAllowed(const ui::ColorProviderKey& key) const;
+
   // Returns the Tint for the given |id|. If there is no tint, the identity tint
   // {-1, -1, -1} is returned and won't tint the color on which it is used.
   color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) const;
@@ -89,16 +97,22 @@ void FrameColorHelper::AddNativeChromeColors(
     return absl::nullopt;
   };
 
-  // When we're custom-drawing the titlebar we want to use either the colors
-  // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
-  // custom-drawing the titlebar we want to match the color Windows actually
-  // uses because some things (like the incognito icon) use this color to
-  // decide whether they should draw in light or dark mode. Incognito colors
-  // should be the same as non-incognito in all cases here.
-
-  constexpr SkColor kSystemMicaLightFrameColor =
+  if (DwmColorsAllowed(key)) {
+    // When we're custom-drawing the titlebar we want to use either the colors
+    // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
+    // custom-drawing the titlebar we want to match the color Windows actually
+    // uses because some things (like the incognito icon) use this color to
+    // decide whether they should draw in light or dark mode. Incognito colors
+    // should be the same as non-incognito in all cases here.
+
+    constexpr SkColor kSystemSolidLightFrameColor = SK_ColorWHITE;
+    constexpr SkColor kSystemSolidDarkInactiveFrameColor =
+        SkColorSetRGB(0x2B, 0x2B, 0x2B);
+
+    constexpr SkColor kSystemMicaLightFrameColor =
       SkColorSetRGB(0xE8, 0xE8, 0xE8);
-  constexpr SkColor kSystemMicaDarkFrameColor = SkColorSetRGB(0x20, 0x20, 0x20);
+    constexpr SkColor kSystemMicaDarkFrameColor = SkColorSetRGB(0x20, 0x20, 0x20);
+
 
   // Dwm colors should always be applied if present for pervasive accent colors
   // pre-refresh. With refresh enabled we should only attempt to paint
@@ -168,13 +182,37 @@ void FrameColorHelper::AddNativeChromeColors(
     mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
   }
 
-  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
-    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonInkDropFrameActive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
-    mixer[kColorNewTabButtonInkDropFrameInactive] =
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      mixer[ui::kColorFrameInactive] = {color.value()};
+    } else if (dwm_inactive_frame_color_) {
+      mixer[ui::kColorFrameInactive] = {dwm_inactive_frame_color_.value()};
+    } else if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemMicaDarkFrameColor
+                                            : kSystemMicaLightFrameColor};
+    } else if (!ShouldCustomDrawSystemTitlebar()) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemSolidDarkInactiveFrameColor
+                                            : kSystemSolidLightFrameColor};
+    } else if (dwm_frame_color_) {
+      mixer[ui::kColorFrameInactive] =
+          ui::HSLShift({dwm_frame_color_.value()},
+                       GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+    }
+
+    if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonInkDropFrameInactive] =
         ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
+      mixer[kColorNewTabButtonInkDropFrameActive] =
+          ui::GetColorWithMaxContrast(ui::kColorFrameActive);
+    }
+  } else {
+    if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE))
+      mixer[ui::kColorFrameActive] = {color.value()};
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE))
+      mixer[ui::kColorFrameInactive] = {color.value()};
   }
 }
 
@@ -197,6 +235,19 @@ FrameColorHelper* FrameColorHelper::Get() {
   return g_frame_color_helper.get();
 }
 
+bool FrameColorHelper::HasCustomImage(
+    int id,
+    const ui::ColorProviderKey& key) const {
+  return BrowserThemePack::IsPersistentImageID(id) && key.custom_theme &&
+         key.custom_theme->HasCustomImage(id);
+}
+
+bool FrameColorHelper::DwmColorsAllowed(
+    const ui::ColorProviderKey& key) const {
+  return (!ShouldCustomDrawSystemTitlebar() ||
+         !HasCustomImage(IDR_THEME_FRAME, key));
+}
+
 color_utils::HSL FrameColorHelper::GetTint(
     int id,
     const ui::ColorProviderKey& key) const {
diff --git a/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc b/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc
index 298ddbffdd8ed..b7538a3180c05 100644
--- a/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc
+++ b/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc
@@ -35,7 +35,6 @@ void ScreenshotCapturedBubbleController::ShowBubble(
   const gfx::Image& captured_image = image.image;
   ui::ScopedClipboardWriter(ui::ClipboardBuffer::kCopyPaste)
       .WriteImage(*captured_image.ToSkBitmap());
-
   Browser* browser = chrome::FindBrowserWithWebContents(&GetWebContents());
   browser->window()->ShowScreenshotCapturedBubble(&GetWebContents(),
                                                   captured_image);
diff --git a/chrome/browser/ui/tabs/tab_style.cc b/chrome/browser/ui/tabs/tab_style.cc
index aa9cd30374311..140fa117e6e7c 100644
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -118,7 +118,7 @@ int GM2TabStyle::GetMinimumInactiveWidth() const {
 }
 
 int GM2TabStyle::GetTabOverlap() const {
-  return GetBottomCornerRadius() * 2 + GetSeparatorSize().width();
+	return GetBottomCornerRadius() * 2 + GetSeparatorSize().width();
 }
 
 int GM2TabStyle::GetDragHandleExtension(int height) const {
@@ -126,8 +126,12 @@ int GM2TabStyle::GetDragHandleExtension(int height) const {
 }
 
 gfx::Size GM2TabStyle::GetSeparatorSize() const {
-  return gfx::Size(kGM2SeparatorThickness,
+  if (!base::FeatureList::IsEnabled(features::kThoriumCustomTabs)) {
+	return gfx::Size(kGM2SeparatorThickness,
                    GetLayoutConstant(TAB_SEPARATOR_HEIGHT));
+  }
+  else
+	  return gfx::Size(0, 0);
 }
 
 gfx::Insets GM2TabStyle::GetSeparatorMargins() const {
@@ -147,12 +151,12 @@ gfx::Size GM2TabStyle::GetPreviewImageSize() const {
 }
 
 int GM2TabStyle::GetTopCornerRadius() const {
-  return views::LayoutProvider::Get()->GetCornerRadiusMetric(
+	return views::LayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kHigh);
 }
 
 int GM2TabStyle::GetBottomCornerRadius() const {
-  return views::LayoutProvider::Get()->GetCornerRadiusMetric(
+	return views::LayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kHigh);
 }
 
@@ -206,10 +210,10 @@ int ChromeRefresh2023TabStyle::GetBottomCornerRadius() const {
 
 int ChromeRefresh2023TabStyle::GetTabOverlap() const {
   // The overlap removes the width and the margins of the separator.
-  const float total_separator_width = GetSeparatorMargins().left() +
-                                      GetSeparatorSize().width() +
-                                      GetSeparatorMargins().right();
-  return 2 * GetBottomCornerRadius() - total_separator_width;
+	const float total_separator_width = GetSeparatorMargins().left() +
+										GetSeparatorSize().width() +
+										GetSeparatorMargins().right();
+	return 2 * GetBottomCornerRadius() - total_separator_width;
 }
 
 gfx::Size ChromeRefresh2023TabStyle::GetSeparatorSize() const {
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
index ac17822240248..87d4c7ca95ede 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
@@ -465,6 +465,9 @@ void BrowserDesktopWindowTreeHostWin::PostHandleMSG(UINT message,
 }
 
 views::FrameMode BrowserDesktopWindowTreeHostWin::GetFrameMode() const {
+  if (browser_view_->GetIsWebAppType())
+	  return views::FrameMode::CUSTOM_DRAWN;
+
   const views::FrameMode system_frame_mode =
       ShouldBrowserCustomDrawTitlebar(browser_view_)
           ? views::FrameMode::SYSTEM_DRAWN_NO_CONTROLS
@@ -494,11 +497,13 @@ bool BrowserDesktopWindowTreeHostWin::ShouldUseNativeFrame() const {
   if (!browser_view_->browser())
     return false;
 
-  // We don't theme popup or app windows, so regardless of whether or not a
-  // theme is active for normal browser windows, we don't want to use the custom
-  // frame for popups/apps.
-  if (!browser_view_->GetIsNormalType())
-    return true;
+  // Use the custom frame where desired.
+  if (!browser_view_->GetIsNormalType()) {
+	 if(!browser_view_->GetIsWebAppType() && GetWidget()->GetThemeProvider()->ShouldUseNativeFrame())
+		return true;
+	 else
+		return false;
+  }
   // Otherwise, we use the native frame when we're told we should by the theme
   // provider (e.g. no custom theme is active).
   return GetWidget()->GetThemeProvider()->ShouldUseNativeFrame();
diff --git a/chrome/browser/ui/views/frame/browser_frame.cc b/chrome/browser/ui/views/frame/browser_frame.cc
index bb4b3821bcfda..c31be5f3400b2 100644
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -10,6 +10,7 @@
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/debug/leak_annotations.h"
+#include "base/features.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
 #include "build/build_config.h"
@@ -347,7 +348,8 @@ const ui::ThemeProvider* BrowserFrame::GetThemeProvider() const {
 ui::ColorProviderKey::ThemeInitializerSupplier* BrowserFrame::GetCustomTheme()
     const {
   // Do not return any custom theme if this is an incognito browser.
-  if (IsIncognitoBrowser()) {
+  if (IsIncognitoBrowser() && base::FeatureList::IsEnabled(
+            base::features::kIncognitoBrandConsistencyForDesktop)) {
     return nullptr;
   }
 
@@ -563,8 +565,20 @@ void BrowserFrame::SelectNativeTheme() {
   // of system theme (gtk, qt etc).
   ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
   if (IsIncognitoBrowser()) {
-    SetNativeTheme(native_theme);
-    return;
+    // If the flag is enabled, then no matter if we are using the default theme
+    // or not we always use the dark ui instance.
+      if (base::FeatureList::IsEnabled(
+            base::features::kIncognitoBrandConsistencyForDesktop)) {
+      SetNativeTheme(ui::NativeTheme::GetInstanceForDarkUI());
+      return;
+    }
+
+    // Flag is disabled, fallback to using dark theme only if the incognito
+    // profile is using a default theme.
+      if (ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile())
+            ->UsingDefaultTheme()) {
+        native_theme = ui::NativeTheme::GetInstanceForDarkUI();
+	}
   }
 
   // Ignore the system theme for web apps with window-controls-overlay as the
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.cc b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
index 769e7e8ac3b39..8579e6a095305 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
@@ -409,7 +409,7 @@ void BrowserFrameViewWin::ResetWindowControls() {
 void BrowserFrameViewWin::OnThemeChanged() {
   BrowserNonClientFrameView::OnThemeChanged();
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
@@ -649,24 +649,26 @@ bool BrowserFrameViewWin::ShouldShowWindowTitle(TitlebarType type) const {
 
 void BrowserFrameViewWin::TabletModeChanged() {
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
-void BrowserFrameViewWin::SetSystemMicaTitlebarAttributes() {
-  CHECK(SystemTitlebarCanUseMicaMaterial());
-
-  const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
-                        sizeof(dark_titlebar_enabled));
+void BrowserFrameViewWin::SetSystemTitlebarAttributes() {
+  if (SystemTitlebarSupportsDarkMode()) {
+    const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
+                          sizeof(dark_titlebar_enabled));
+  }
 
-  const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
-      browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
-                                           : DWMSBT_MAINWINDOW;
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
-                        sizeof(dwm_backdrop_type));
+  if (ShouldBrowserUseMicaTitlebar(browser_view())) {
+    const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
+        browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
+                                             : DWMSBT_MAINWINDOW;
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
+                          sizeof(dwm_backdrop_type));
+  }
 }
 
 SkColor BrowserFrameViewWin::GetTitlebarColor() const {
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.h b/chrome/browser/ui/views/frame/browser_frame_view_win.h
index d984437fca46f..bd9a8c6f72dfd 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.h
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.h
@@ -144,8 +144,8 @@ class BrowserFrameViewWin : public BrowserNonClientFrameView,
   // Called when the device enters or exits tablet mode.
   void TabletModeChanged();
 
-  // Sets DWM attributes for rendering the system-drawn Mica titlebar.
-  void SetSystemMicaTitlebarAttributes();
+  // Sets DWM attributes for rendering the system-drawn titlebar.
+  void SetSystemTitlebarAttributes();
 
   // Paint various sub-components of this view.
   void PaintTitlebar(gfx::Canvas* canvas) const;
diff --git a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
index 1bf912250ff05..e768404fabf43 100644
--- a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
+++ b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
@@ -65,6 +65,7 @@ ScreenshotCapturedBubble::ScreenshotCapturedBubble(
       image_(image),
       web_contents_(web_contents->GetWeakPtr()),
       profile_(profile) {
+
   SetButtons(ui::DIALOG_BUTTON_NONE);
   SetTitle(IDS_BROWSER_SHARING_SCREENSHOT_POST_CAPTURE_TITLE);
 }
diff --git a/chrome/browser/webshare/win/fake_storage_file_statics.cc b/chrome/browser/webshare/win/fake_storage_file_statics.cc
index 6308ccec3a576..f17033b2d1ec7 100644
--- a/chrome/browser/webshare/win/fake_storage_file_statics.cc
+++ b/chrome/browser/webshare/win/fake_storage_file_statics.cc
@@ -9,7 +9,6 @@
 #include <wrl/module.h>
 
 #include <memory>
-#include <string>
 #include <tuple>
 
 #include "base/functional/bind.h"
@@ -279,6 +278,13 @@ IFACEMETHODIMP FakeStorageFileStatics::CreateStreamedFileAsync(
     IStreamedFileDataRequestedHandler* data_requested,
     IRandomAccessStreamReference* thumbnail,
     IAsyncOperation<StorageFile*>** operation) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    ADD_FAILURE() << "Attempted to use FakeStorageFileStatics in an "
+                     "environment that doesn't support ScopedHStrings.";
+    return E_UNEXPECTED;
+  }
+
   auto fake_iasync_operation =
       Make<base::win::FakeIAsyncOperation<StorageFile*>>();
   HRESULT hr = fake_iasync_operation->QueryInterface(IID_PPV_ARGS(operation));
diff --git a/chrome/browser/webshare/win/share_operation.cc b/chrome/browser/webshare/win/share_operation.cc
index ef09f08ba9cf4..8747e21cbe552 100644
--- a/chrome/browser/webshare/win/share_operation.cc
+++ b/chrome/browser/webshare/win/share_operation.cc
@@ -370,6 +370,13 @@ void ShareOperation::Run(blink::mojom::ShareService::ShareCallback callback) {
   DCHECK(!callback_);
   callback_ = std::move(callback);
 
+  // Ensure that the required WinRT functionality is available/loaded.
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    Complete(blink::mojom::ShareError::INTERNAL_ERROR);
+    return;
+  }
+
   // If the corresponding web_contents have already been cleaned up, cancel
   // the operation.
   if (!web_contents_) {
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
index 15f2def437648..021f9f2b55471 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
@@ -40,6 +40,12 @@ HRESULT GetDataTransferManagerHandles(
     HWND hwnd,
     IDataTransferManagerInterop** data_transfer_manager_interop,
     IDataTransferManager** data_transfer_manager) {
+
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return E_FAIL;
+  }
+
   // IDataTransferManagerInterop is semi-hidden behind a CloakedIid
   // structure on the DataTransferManager, excluding it from things
   // used by RoGetActivationFactory like GetIids(). Because of this,
diff --git a/chrome/browser/win/titlebar_config.cc b/chrome/browser/win/titlebar_config.cc
index f088a7071b1e0..48729bce514dd 100644
--- a/chrome/browser/win/titlebar_config.cc
+++ b/chrome/browser/win/titlebar_config.cc
@@ -4,28 +4,55 @@
 
 #include "chrome/browser/win/titlebar_config.h"
 
+#include <Windows.h>
+#include "base/command_line.h"
 #include "base/win/windows_version.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/common/chrome_switches.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/native_theme/native_theme.h"
 
-// Allows the titlebar to be drawn by the system using the Mica material
-// on Windows 11, version 22H2 and above.
-BASE_FEATURE(kWindows11MicaTitlebar,
-             "Windows11MicaTitlebar",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+bool ShouldCustomDrawSystemTitlebar() {
+  // Some extra code added here because those with pre-win8 and no DWM will have to fallback on the custom titlebar.
+  BOOL result = FALSE;
+
+  typedef HRESULT(WINAPI* DwmIsCompositionEnabledFunc)(BOOL* enabled);
+  DwmIsCompositionEnabledFunc func_ = nullptr;
+
+  HMODULE dwmapi_library_ = LoadLibraryW(L"dwmapi.dll");
+  if (dwmapi_library_) {
+    func_ = reinterpret_cast<DwmIsCompositionEnabledFunc>(
+        GetProcAddress(dwmapi_library_, "DwmIsCompositionEnabled"));
+  }
+  else
+	  return true;
+
+  if (func_) {
+	  func_(&result);
+  }
+  else
+	  return true;
+  // Cache flag lookup.
+  static const bool custom_titlebar_disabled =
+      base::CommandLine::InitializedForCurrentProcess() &&
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableWindows10CustomTitlebar);
+
+  return (!custom_titlebar_disabled &&
+         base::win::GetVersion() >= base::win::Version::WIN10) || !result;
+}
 
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view) {
-  return !ShouldDefaultThemeUseMicaTitlebar() ||
-         !ThemeServiceFactory::GetForProfile(browser_view->GetProfile())
-              ->UsingSystemTheme() ||
+
+  return ShouldCustomDrawSystemTitlebar() ||
          (!browser_view->browser()->is_type_normal() &&
           !browser_view->browser()->is_type_popup() &&
           !browser_view->browser()->is_type_devtools());
 }
 
+
 bool ShouldDefaultThemeUseMicaTitlebar() {
   return SystemTitlebarCanUseMicaMaterial() &&
          !ui::AccentColorObserver::Get()->use_dwm_frame_color() &&
@@ -34,6 +61,13 @@ bool ShouldDefaultThemeUseMicaTitlebar() {
 }
 
 bool SystemTitlebarCanUseMicaMaterial() {
-  return base::win::GetVersion() >= base::win::Version::WIN11_22H2 &&
-         base::FeatureList::IsEnabled(kWindows11MicaTitlebar);
+  return false;
+}
+
+bool ShouldBrowserUseMicaTitlebar(class BrowserView *) {
+  return false;
+}
+
+bool SystemTitlebarSupportsDarkMode() {
+  return base::win::GetVersion() >= base::win::Version::WIN11;
 }
diff --git a/chrome/browser/win/titlebar_config.h b/chrome/browser/win/titlebar_config.h
index 48f413792d5aa..596d9ad041c21 100644
--- a/chrome/browser/win/titlebar_config.h
+++ b/chrome/browser/win/titlebar_config.h
@@ -10,10 +10,18 @@
 class BrowserView;
 
 BASE_DECLARE_FEATURE(kWindows11MicaTitlebar);
+BASE_DECLARE_FEATURE(kDisableAeroTheme);
 
 // Returns whether we should custom draw the titlebar for a browser window.
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view);
 
+// Returns whether we should always custom draw the system title bar.
+bool ShouldCustomDrawSystemTitlebar();
+
+// Returns whether we should use the Mica titlebar material for a browser
+// window.
+bool ShouldBrowserUseMicaTitlebar(BrowserView* browser_view);
+
 // Returns whether we should use the Mica titlebar in standard browser windows
 // using the default theme.
 bool ShouldDefaultThemeUseMicaTitlebar();
@@ -22,4 +30,7 @@ bool ShouldDefaultThemeUseMicaTitlebar();
 // material.
 bool SystemTitlebarCanUseMicaMaterial();
 
+// Returns whether the system-drawn titlebar can be drawn in dark mode.
+bool SystemTitlebarSupportsDarkMode();
+
 #endif  // CHROME_BROWSER_WIN_TITLEBAR_CONFIG_H_
diff --git a/chrome/chrome_elf/chrome_elf_security.cc b/chrome/chrome_elf/chrome_elf_security.cc
index ea44babfb52ea..045b3a6221712 100644
--- a/chrome/chrome_elf/chrome_elf_security.cc
+++ b/chrome/chrome_elf/chrome_elf_security.cc
@@ -82,6 +82,7 @@ class ExtensionPointDisableSet {
 }  // namespace
 
 void EarlyBrowserSecurity() {
+  typedef decltype(SetProcessMitigationPolicy)* SetProcessMitigationPolicyFunc;
   // This function is called from within DllMain.
   // Don't do anything naughty while we have the loader lock.
   NTSTATUS ret_val = STATUS_SUCCESS;
@@ -105,12 +106,20 @@ void EarlyBrowserSecurity() {
 
   nt::CloseRegKey(handle);
 
-  // Disable extension points (legacy hooking) in this process.
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  policy.DisableExtensionPoints = true;
-  SetProcessMitigationPolicy(ProcessExtensionPointDisablePolicy, &policy,
-                             sizeof(policy));
-  ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+  if (::IsWindows8OrGreater()) {
+    SetProcessMitigationPolicyFunc set_process_mitigation_policy =
+        reinterpret_cast<SetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "SetProcessMitigationPolicy"));
+    if (set_process_mitigation_policy) {
+      // Disable extension points in this process.
+      // (Legacy hooking.)
+      PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+      policy.DisableExtensionPoints = true;
+      set_process_mitigation_policy(ProcessExtensionPointDisablePolicy, &policy,
+                                    sizeof(policy));
+      ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+    }
+  }
 
   return;
 }
diff --git a/chrome/chrome_elf/chrome_elf_util_unittest.cc b/chrome/chrome_elf/chrome_elf_util_unittest.cc
index 5ee09effb6e03..3af5789ad6185 100644
--- a/chrome/chrome_elf/chrome_elf_util_unittest.cc
+++ b/chrome/chrome_elf/chrome_elf_util_unittest.cc
@@ -4,6 +4,8 @@
 
 #include <windows.h>
 
+#include <versionhelpers.h>  // windows.h must be before.
+
 #include <tuple>
 
 #include "base/test/test_reg_util_win.h"
@@ -37,14 +39,28 @@ bool SetExtensionPointEnabledFlag(bool creation) {
 }
 
 bool IsSecuritySet() {
-  // Check that extension points are disabled. (Legacy hooking.)
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                    ProcessExtensionPointDisablePolicy, &policy,
-                                    sizeof(policy))) {
-    return false;
+  typedef decltype(GetProcessMitigationPolicy)* GetProcessMitigationPolicyFunc;
+
+  // Check the settings from EarlyBrowserSecurity().
+  if (::IsWindows8OrGreater()) {
+    GetProcessMitigationPolicyFunc get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (!get_process_mitigation_policy)
+      return false;
+
+    // Check that extension points are disabled.
+    // (Legacy hooking.)
+    PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+    if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                       ProcessExtensionPointDisablePolicy,
+                                       &policy, sizeof(policy)))
+      return false;
+
+    return policy.DisableExtensionPoints;
   }
-  return policy.DisableExtensionPoints;
+
+  return true;
 }
 
 void RegRedirect(nt::ROOT_KEY key,
@@ -70,6 +86,9 @@ void CancelRegRedirect(nt::ROOT_KEY key) {
 }
 
 TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
+
+  if (!::IsWindows8OrGreater())
+    return;
   // We should validate the exe version isn't used for this test
   elf_security::ValidateExeForTesting(true);
 
@@ -78,6 +97,8 @@ TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
 }
 
 TEST(ChromeElfUtilTest, BrowserProcessSecurityTest) {
+  if (!::IsWindows8OrGreater())
+    return;
   // Set up registry override for this test.
   registry_util::RegistryOverrideManager override_manager;
   ASSERT_NO_FATAL_FAILURE(RegRedirect(nt::HKCU, &override_manager));
diff --git a/chrome/chrome_elf/hook_util/hook_util.cc b/chrome/chrome_elf/hook_util/hook_util.cc
index ce309c8b6888b..96ab0afa9bbf3 100644
--- a/chrome/chrome_elf/hook_util/hook_util.cc
+++ b/chrome/chrome_elf/hook_util/hook_util.cc
@@ -8,6 +8,9 @@
 #include <versionhelpers.h>  // windows.h must be before
 
 #include "base/win/pe_image.h"
+#include "chrome/chrome_elf/nt_registry/nt_registry.h"  // utils
+#include "sandbox/win/src/internal_types.h"
+#include "sandbox/win/src/service_resolver.h"
 
 namespace {
 
@@ -194,6 +197,44 @@ DWORD RemoveIATHook(void* intercept_function,
 
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed) {
+  // Create a thunk via the appropriate ServiceResolver instance.
+  sandbox::ServiceResolverThunk* thunk = nullptr;
+
+  // No hooking on unsupported OS versions.
+  if (!::IsWindows7OrGreater())
+    return thunk;
+
+  // Pseudo-handle, no need to close.
+  HANDLE current_process = ::GetCurrentProcess();
+
+#if defined(_WIN64)
+  // ServiceResolverThunk can handle all the formats in 64-bit (instead only
+  // handling one like it does in 32-bit versions).
+  thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+#else
+  BOOL is_wow64 = FALSE;
+  if (::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64) {
+    if (::IsWindows10OrGreater())
+      thunk = new sandbox::Wow64W10ResolverThunk(current_process, relaxed);
+    else if (::IsWindows8OrGreater())
+      thunk = new sandbox::Wow64W8ResolverThunk(current_process, relaxed);
+    else
+      thunk = new sandbox::Wow64ResolverThunk(current_process, relaxed);
+  } else if (::IsWindows8OrGreater()) {
+    thunk = new sandbox::Win8ResolverThunk(current_process, relaxed);
+  } else {
+    thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+  }
+#endif
+
+  return thunk;
+}
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/hook_util/hook_util.h b/chrome/chrome_elf/hook_util/hook_util.h
index 9070b9d93a6f0..687042ec330c7 100644
--- a/chrome/chrome_elf/hook_util/hook_util.h
+++ b/chrome/chrome_elf/hook_util/hook_util.h
@@ -7,8 +7,20 @@
 
 #include <windows.h>
 
+namespace sandbox {
+class ServiceResolverThunk;
+}
+
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+// Creates a |ServiceResolverThunk| based on the OS version. Ownership of the
+// resulting thunk is passed to the caller.
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed);
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 203854c109335..c287212aa9e7a 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -776,7 +776,15 @@ const char kRelauncherProcessDMGDevice[] = "dmg-device";
 const char kMakeChromeDefault[] = "make-chrome-default";
 #endif  // BUILDFLAG(IS_MAC)
 
+const char kDisableDownloadUpload[] = "disable-download-upload";
+
+
+
 #if BUILDFLAG(IS_WIN)
+// Disables custom-drawing the window titlebar on Windows 10.
+const char kDisableWindows10CustomTitlebar[] =
+    "disable-windows10-custom-titlebar";
+
 // Force-enables the profile shortcut manager. This is needed for tests since
 // they use a custom-user-data-dir which disables this.
 const char kEnableProfileShortcutManager[] = "enable-profile-shortcut-manager";
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index 3939a1c43cff2..d2db193cad1a6 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -246,7 +246,11 @@ extern const char kRelauncherProcessDMGDevice[];
 extern const char kMakeChromeDefault[];
 #endif  // BUILDFLAG(IS_MAC)
 
+extern const char kDisableDownloadUpload[];
+
+
 #if BUILDFLAG(IS_WIN)
+extern const char kDisableWindows10CustomTitlebar[];
 extern const char kEnableProfileShortcutManager[];
 extern const char kFromInstaller[];
 extern const char kHideIcons[];
diff --git a/chrome/installer/setup/install.cc b/chrome/installer/setup/install.cc
index e5d72ffd39ded..baf105aaf9f48 100644
--- a/chrome/installer/setup/install.cc
+++ b/chrome/installer/setup/install.cc
@@ -28,6 +28,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_params.h"
@@ -135,6 +136,7 @@ void ExecuteAndLogShortcutOperation(
   // For Start Menu shortcut creation on versions of Win10 that support
   // pinning, record whether or not the installer pinned Chrome.
   if (location == ShellUtil::SHORTCUT_LOCATION_START_MENU_ROOT &&
+      base::win::GetVersion() >= base::win::Version::WIN10 &&
       CanPinShortcutToTaskbar()) {
     SetInstallerPinnedChromeToTaskbar(properties.pin_to_taskbar && pinned);
   }
diff --git a/chrome/installer/util/install_util.cc b/chrome/installer/util/install_util.cc
index 5efc79e743383..1bf0bf47f68e4 100644
--- a/chrome/installer/util/install_util.cc
+++ b/chrome/installer/util/install_util.cc
@@ -242,10 +242,10 @@ base::Version InstallUtil::GetCriticalUpdateVersion() {
 }
 
 bool InstallUtil::IsOSSupported() {
-  // We do not support anything prior to Windows 10.
+  // We do not support anything prior to Windows Vista.
   VLOG(1) << base::SysInfo::OperatingSystemName() << ' '
           << base::SysInfo::OperatingSystemVersion();
-  return base::win::GetVersion() >= base::win::Version::WIN10;
+  return base::win::GetVersion() >= base::win::Version::VISTA;
 }
 
 void InstallUtil::AddInstallerResultItems(bool system_install,
diff --git a/chrome/installer/util/shell_util.cc b/chrome/installer/util/shell_util.cc
index 7f20d494956cd..b2fc2f967de55 100644
--- a/chrome/installer/util/shell_util.cc
+++ b/chrome/installer/util/shell_util.cc
@@ -297,12 +297,13 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
     entries->back()->set_removal_flag(RegistryEntry::RemovalFlag::VALUE);
   }
 
-  // The following entries are required but do not depend on the DelegateExecute
-  // verb handler being set.
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
-  }
+  // The following entries are required as of Windows 8, but do not
+  // depend on the DelegateExecute verb handler being set.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
 
   // Add \Software\Classes\<prog_id>\Application entries
   std::wstring application_path(prog_id_path + ShellUtil::kRegApplication);
@@ -332,6 +333,7 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
         app_info.publisher_name));
   }
 }
+}
 
 // This method returns a list of all the registry entries that are needed to
 // register this installation's ProgIds and AppId.
@@ -744,11 +746,12 @@ bool QuickIsChromeRegisteredForMode(
   }
   reg_key += ShellUtil::kRegShellOpen;
 
-  // ProgId and shell integration registrations are allowed to reside in HKCU
-  // for user-level installs, and values there have priority over values in
-  // HKLM.
+  // ProgId registrations are allowed to reside in HKCU for user-level installs
+  // (and values there have priority over values in HKLM). The same is true for
+  // shell integration entries as of Windows 8.
   if (confirmation_level == CONFIRM_PROGID_REGISTRATION ||
-      confirmation_level == CONFIRM_SHELL_REGISTRATION) {
+      (confirmation_level == CONFIRM_SHELL_REGISTRATION &&
+       base::win::GetVersion() >= base::win::Version::WIN8)) {
     const RegKey key_hkcu(HKEY_CURRENT_USER, reg_key.c_str(), KEY_QUERY_VALUE);
     std::wstring hkcu_value;
     // If |reg_key| is present in HKCU, assert that it points to |chrome_exe|.
@@ -823,7 +826,9 @@ bool GetInstallationSpecificSuffix(const base::FilePath& chrome_exe,
 // be placed for this install. As of Windows 8 everything can go in HKCU for
 // per-user installs.
 HKEY DetermineRegistrationRoot(bool is_per_user) {
-  return is_per_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
+    return is_per_user && base::win::GetVersion() >= base::win::Version::WIN8
+             ? HKEY_CURRENT_USER
+             : HKEY_LOCAL_MACHINE;
 }
 
 // Associates Chrome with supported protocols and file associations. This should
@@ -1042,6 +1047,7 @@ ShellUtil::DefaultState ProbeProtocolHandlers(const base::FilePath& chrome_exe,
 // Returns true on success.
 bool GetAppShortcutsFolder(ShellUtil::ShellChange level, base::FilePath* path) {
   DCHECK(path);
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
 
   base::FilePath folder;
   if (!base::PathService::Get(base::DIR_APP_SHORTCUTS, &folder)) {
@@ -1419,6 +1425,7 @@ bool RegisterChromeBrowserImpl(const base::FilePath& chrome_exe,
 bool RegisterApplicationForProtocols(const std::vector<std::wstring>& protocols,
                                      const std::wstring& prog_id,
                                      const base::FilePath& chrome_exe) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
   std::vector<std::unique_ptr<RegistryEntry>> entries;
   ShellUtil::ApplicationInfo app_info =
       ShellUtil::GetApplicationInfoForProgId(prog_id);
@@ -1571,10 +1578,12 @@ bool ShellUtil::ShortcutLocationIsSupported(ShortcutLocation location) {
     case SHORTCUT_LOCATION_START_MENU_ROOT:                   // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_DIR_DEPRECATED:  // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR:        // Falls through.
-    case SHORTCUT_LOCATION_STARTUP:                           // Falls through.
-    case SHORTCUT_LOCATION_TASKBAR_PINS:                      // Falls through.
-    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+    case SHORTCUT_LOCATION_STARTUP:
       return true;
+    case SHORTCUT_LOCATION_TASKBAR_PINS:
+      return base::win::GetVersion() >= base::win::Version::WIN7;
+    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+      return base::win::GetVersion() >= base::win::Version::WIN8;
     default:
       NOTREACHED();
       return false;
@@ -2520,16 +2529,19 @@ bool ShellUtil::AddAppProtocolAssociations(
     if (!AddRegistryEntries(HKEY_CURRENT_USER, entries))
       success = false;
 
-    // Removing the existing user choice for a given protocol forces Windows to
-    // present a disambiguation dialog the next time this protocol is invoked
-    // from the OS.
-    std::unique_ptr<RegistryEntry> entry = GetProtocolUserChoiceEntry(protocol);
-    if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
-                                        WorkItem::kWow64Default, kRegProgId)) {
-      success = false;
+    // On Windows 10, removing the existing user choice for a given protocol
+    // forces Windows to present a disambiguation dialog the next time this
+    // protocol is invoked from the OS.
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      std::unique_ptr<RegistryEntry> entry =
+          GetProtocolUserChoiceEntry(protocol);
+      if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
+                                          WorkItem::kWow64Default,
+                                          kRegProgId)) {
+        success = false;
+      }
     }
   }
-
   return success;
 }
 
diff --git a/chrome/services/util_win/processor_metrics.cc b/chrome/services/util_win/processor_metrics.cc
index 29c5bb2dd47f4..8742d122b3879 100644
--- a/chrome/services/util_win/processor_metrics.cc
+++ b/chrome/services/util_win/processor_metrics.cc
@@ -7,7 +7,6 @@
 #include <objbase.h>
 #include <sysinfoapi.h>
 #include <wbemidl.h>
-#include <winbase.h>
 #include <wrl/client.h>
 
 #include "base/metrics/histogram_functions.h"
@@ -110,63 +109,36 @@ void RecordCetAvailability() {
           ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"),
                            "IsUserCetAvailableInEnvironment"));
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
   if (is_user_cet_available_in_environment) {
     available = is_user_cet_available_in_environment(
         USER_CET_ENVIRONMENT_WIN32_PROCESS);
   }
   base::UmaHistogramBoolean("Windows.CetAvailable", available);
 
-  if (available) {
+  if (available && get_process_mitigation_policy) {
     PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {0};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                     ProcessUserShadowStackPolicy, &policy,
-                                     sizeof(policy))) {
+    if (get_process_mitigation_policy(GetCurrentProcess(),
+                                      ProcessUserShadowStackPolicy, &policy,
+                                      sizeof(policy))) {
       base::UmaHistogramBoolean("Windows.CetEnabled",
                                 policy.EnableUserShadowStack);
     }
   }
 }
 
-void RecordEnclaveAvailabilityInternal(base::StringPiece type,
-                                       DWORD enclave_type) {
-  // This API does not appear to be exported from kernel32.dll on
-  // Windows 10.0.10240.
-  static auto is_enclave_type_supported_func =
-      reinterpret_cast<decltype(&IsEnclaveTypeSupported)>(::GetProcAddress(
-          ::GetModuleHandleW(L"kernel32.dll"), "IsEnclaveTypeSupported"));
-
-  bool is_supported = false;
-
-  if (is_enclave_type_supported_func) {
-    is_supported = is_enclave_type_supported_func(enclave_type);
-  }
-
-  base::UmaHistogramBoolean(
-      base::StrCat({"Windows.Enclave.", type, ".Available"}), is_supported);
-}
-
-void RecordEnclaveAvailability() {
-  RecordEnclaveAvailabilityInternal("SGX", ENCLAVE_TYPE_SGX);
-  RecordEnclaveAvailabilityInternal("SGX2", ENCLAVE_TYPE_SGX2);
-  RecordEnclaveAvailabilityInternal("VBS", ENCLAVE_TYPE_VBS);
-  RecordEnclaveAvailabilityInternal("VBSBasic", ENCLAVE_TYPE_VBS_BASIC);
-}
-
 void RecordProcessorMetrics() {
-  // These metrics do not require a WMI connection.
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+  ComPtr<IWbemServices> wmi_services;
+  if (!base::win::CreateLocalWmiConnection(true, &wmi_services))
+    return;
+  RecordProcessorMetricsFromWMI(wmi_services);
+  RecordHypervStatusFromWMI(wmi_services);
   RecordCetAvailability();
-  RecordEnclaveAvailability();
-
-  {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-    ComPtr<IWbemServices> wmi_services;
-    if (!base::win::CreateLocalWmiConnection(true, &wmi_services)) {
-      return;
-    }
-    RecordProcessorMetricsFromWMI(wmi_services);
-    RecordHypervStatusFromWMI(wmi_services);
-  }
 }
 
 }  // namespace
diff --git a/chrome/updater/net/network_fetcher_win.cc b/chrome/updater/net/network_fetcher_win.cc
index bc2127fedcd84..a985a08a8b622 100644
--- a/chrome/updater/net/network_fetcher_win.cc
+++ b/chrome/updater/net/network_fetcher_win.cc
@@ -20,9 +20,11 @@
 #include "base/sequence_checker.h"
 #include "base/strings/sys_string_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "chrome/updater/policy/service.h"
 #include "chrome/updater/util/util.h"
 #include "chrome/updater/util/win_util.h"
+#include "chrome/updater/win/scoped_impersonation.h"
 #include "chrome/updater/win/user_info.h"
 #include "components/update_client/network.h"
 #include "components/winhttp/network_fetcher.h"
@@ -33,6 +35,56 @@
 
 namespace updater {
 namespace {
+
+	std::wstring FromCharOrEmpty(const wchar_t* str) {
+  return str ? std::wstring(str) : std::wstring();
+}
+
+// Wrapper for WINHTTP_CURRENT_USER_IE_PROXY_CONFIG structure.
+// According to MSDN, callers must free strings with GlobalFree.
+class ScopedIeProxyConfig {
+ public:
+  ScopedIeProxyConfig();
+  ScopedIeProxyConfig(const ScopedIeProxyConfig&) = delete;
+  ScopedIeProxyConfig& operator=(const ScopedIeProxyConfig&) = delete;
+  ~ScopedIeProxyConfig();
+
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* receive() { return &ie_proxy_config_; }
+
+  bool auto_detect() const { return ie_proxy_config_.fAutoDetect; }
+  std::wstring auto_config_url() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszAutoConfigUrl);
+  }
+  std::wstring proxy() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxy);
+  }
+  std::wstring proxy_bypass() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxyBypass);
+  }
+
+ private:
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG ie_proxy_config_ = {};
+};
+
+ScopedIeProxyConfig::ScopedIeProxyConfig() {
+  ie_proxy_config_.fAutoDetect = false;
+  ie_proxy_config_.lpszAutoConfigUrl = nullptr;
+  ie_proxy_config_.lpszProxy = nullptr;
+  ie_proxy_config_.lpszProxyBypass = nullptr;
+}
+
+ScopedIeProxyConfig::~ScopedIeProxyConfig() {
+  if (ie_proxy_config_.lpszAutoConfigUrl)
+    ::GlobalFree(ie_proxy_config_.lpszAutoConfigUrl);
+
+  if (ie_proxy_config_.lpszProxy)
+    ::GlobalFree(ie_proxy_config_.lpszProxy);
+
+  if (ie_proxy_config_.lpszProxyBypass)
+    ::GlobalFree(ie_proxy_config_.lpszProxyBypass);
+}
+
+
 
 // Factory method for the proxy configuration strategy.
 scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
@@ -50,7 +102,32 @@ scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
 
   VLOG(1) << "Using the system configuration for proxy.";
 
-  return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+   const base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  const bool supports_automatic_proxy =
+      os_info->version() >= base::win::Version::WIN8_1;
+  if (supports_automatic_proxy) {
+    return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+  }
+
+  ScopedImpersonation impersonate_user;
+  if (IsLocalSystemUser()) {
+    VLOG(2) << "Running as SYSTEM, impersonate the current user.";
+    base::win::ScopedHandle user_token = GetUserTokenFromCurrentSessionId();
+    if (user_token.IsValid()) {
+      impersonate_user.Impersonate(user_token.Get());
+    }
+  }
+
+  ScopedIeProxyConfig ie_proxy_config;
+  if (::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config.receive())) {
+    return base::MakeRefCounted<winhttp::ProxyConfiguration>(winhttp::ProxyInfo{
+        ie_proxy_config.auto_detect(), ie_proxy_config.auto_config_url(),
+        ie_proxy_config.proxy(), ie_proxy_config.proxy_bypass()});
+  } else {
+    PLOG(ERROR) << "Failed to get proxy for current user";
+  }
+
+  return base::MakeRefCounted<winhttp::ProxyConfiguration>();
 }
 
 class NetworkFetcher : public update_client::NetworkFetcher {
diff --git a/chrome/updater/win/installer/installer.cc b/chrome/updater/win/installer/installer.cc
index 649d8af0f3cb0..7d1945fb57275 100644
--- a/chrome/updater/win/installer/installer.cc
+++ b/chrome/updater/win/installer/installer.cc
@@ -342,7 +342,7 @@ ProcessExitResult InstallerMain(HMODULE module) {
   CHECK(EnableSecureDllLoading());
   EnableProcessHeapMetadataProtection();
 
-  if (base::win::GetVersion() < base::win::Version::WIN10) {
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
     return ProcessExitResult(UNSUPPORTED_WINDOWS_VERSION);
   }
 
diff --git a/components/crash/core/app/crashpad.cc b/components/crash/core/app/crashpad.cc
index 9ea9021f16006..bc737d6b77bde 100644
--- a/components/crash/core/app/crashpad.cc
+++ b/components/crash/core/app/crashpad.cc
@@ -249,7 +249,6 @@ void SetUploadConsent(bool consent) {
     // if consent is present.
     enable_uploads = consent && !crash_reporter_client->IsRunningUnattended();
   }
-
   crashpad::Settings* settings = g_database->GetSettings();
   settings->SetUploadsEnabled(enable_uploads &&
                               crash_reporter_client->GetCollectStatsInSample());
diff --git a/components/download/internal/common/base_file_win.cc b/components/download/internal/common/base_file_win.cc
index afc97218f731b..fd8eddc7f2dc3 100644
--- a/components/download/internal/common/base_file_win.cc
+++ b/components/download/internal/common/base_file_win.cc
@@ -14,6 +14,7 @@
 
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/com_init_util.h"
+#include "base/win/windows_version.h"
 #include "components/download/public/common/download_interrupt_reasons_utils.h"
 #include "components/download/public/common/download_stats.h"
 
@@ -143,6 +144,212 @@ DownloadInterruptReason HRESULTToDownloadInterruptReason(HRESULT hr) {
   return DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
 }
 
+// Maps the result of a call to |SHFileOperation()| onto a
+// |DownloadInterruptReason|.
+//
+// These return codes are *old* (as in, DOS era), and specific to
+// |SHFileOperation()|.
+// They do not appear in any windows header.
+//
+// See http://msdn.microsoft.com/en-us/library/bb762164(VS.85).aspx.
+DownloadInterruptReason MapShFileOperationCodes(int code) {
+  DownloadInterruptReason result = DOWNLOAD_INTERRUPT_REASON_NONE;
+
+  // Check these pre-Win32 error codes first, then check for matches
+  // in Winerror.h.
+  // This switch statement should be kept in sync with the list of codes
+  // above.
+  switch (code) {
+    // Not a pre-Win32 error code; here so that this particular case shows up in
+    // our histograms. Unfortunately, it is used not just to signal actual
+    // ACCESS_DENIED errors, but many other errors as well. So we treat it as a
+    // transient error.
+    case ERROR_ACCESS_DENIED:  // Access is denied.
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // This isn't documented but returned from SHFileOperation. Sharing
+    // violations indicate that another process had the file open while we were
+    // trying to rename. Anti-virus is believed to be the cause of this error in
+    // the wild. Treated as a transient error on the assumption that the file
+    // will be made available for renaming at a later time.
+    case ERROR_SHARING_VIOLATION:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // This is also not a documented return value of SHFileOperation, but has
+    // been observed in the wild. We are treating it as a transient error based
+    // on the cases we have seen so far.  See http://crbug.com/368455.
+    case ERROR_INVALID_PARAMETER:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // The source and destination files are the same file.
+    // DE_SAMEFILE == 0x71
+    case 0x71:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The operation was canceled by the user, or silently canceled if the
+    // appropriate flags were supplied to SHFileOperation.
+    // DE_OPCANCELLED == 0x75
+    case 0x75:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Security settings denied access to the source.
+    // DE_ACCESSDENIEDSRC == 0x78
+    case 0x78:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source or destination path exceeded or would exceed MAX_PATH.
+    // DE_PATHTOODEEP == 0x79
+    case 0x79:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // The path in the source or destination or both was invalid.
+    // DE_INVALIDFILES == 0x7C
+    case 0x7C:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination path is an existing file.
+    // DE_FLDDESTISFILE == 0x7E
+    case 0x7E:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination path is an existing folder.
+    // DE_FILEDESTISFLD == 0x80
+    case 0x80:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The name of the file exceeds MAX_PATH.
+    // DE_FILENAMETOOLONG == 0x81
+    case 0x81:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // The destination is a read-only CD-ROM, possibly unformatted.
+    // DE_DEST_IS_CDROM == 0x82
+    case 0x82:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The destination is a read-only DVD, possibly unformatted.
+    // DE_DEST_IS_DVD == 0x83
+    case 0x83:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The destination is a writable CD-ROM, possibly unformatted.
+    // DE_DEST_IS_CDRECORD == 0x84
+    case 0x84:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The file involved in the operation is too large for the destination
+    // media or file system.
+    // DE_FILE_TOO_LARGE == 0x85
+    case 0x85:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE;
+      break;
+
+    // The source is a read-only CD-ROM, possibly unformatted.
+    // DE_SRC_IS_CDROM == 0x86
+    case 0x86:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source is a read-only DVD, possibly unformatted.
+    // DE_SRC_IS_DVD == 0x87
+    case 0x87:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source is a writable CD-ROM, possibly unformatted.
+    // DE_SRC_IS_CDRECORD == 0x88
+    case 0x88:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // MAX_PATH was exceeded during the operation.
+    // DE_ERROR_MAX == 0xB7
+    case 0xB7:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // An unspecified error occurred on the destination.
+    // XE_ERRORONDEST == 0x10000
+    case 0x10000:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Multiple file paths were specified in the source buffer, but only one
+    // destination file path.
+    // DE_MANYSRC1DEST == 0x72
+    case 0x72:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Rename operation was specified but the destination path is
+    // a different directory. Use the move operation instead.
+    // DE_DIFFDIR == 0x73
+    case 0x73:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The source is a root directory, which cannot be moved or renamed.
+    // DE_ROOTDIR == 0x74
+    case 0x74:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination is a subtree of the source.
+    // DE_DESTSUBTREE == 0x76
+    case 0x76:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The operation involved multiple destination paths,
+    // which can fail in the case of a move operation.
+    // DE_MANYDEST == 0x7A
+    case 0x7A:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The source and destination have the same parent folder.
+    // DE_DESTSAMETREE == 0x7D
+    case 0x7D:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // An unknown error occurred.  This is typically due to an invalid path in
+    // the source or destination.  This error does not occur on Windows Vista
+    // and later.
+    // DE_UNKNOWN_ERROR == 0x402
+    case 0x402:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Destination is a root directory and cannot be renamed.
+    // DE_ROOTDIR | ERRORONDEST == 0x10074
+    case 0x10074:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+  }
+
+  if (result != DOWNLOAD_INTERRUPT_REASON_NONE)
+    return result;
+
+  // If not one of the above codes, it should be a standard Windows error code.
+  return ConvertFileErrorToInterruptReason(
+      base::File::OSErrorToFileError(code));
+}
+
 class FileOperationProgressSink
     : public Microsoft::WRL::RuntimeClass<
           Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom>,
@@ -244,6 +451,35 @@ DownloadInterruptReason BaseFile::MoveFileAndAdjustPermissions(
     const base::FilePath& new_path) {
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
+
+  if(base::win::GetVersion() < base::win::Version::VISTA) {
+	  // The parameters to SHFileOperation must be terminated with 2 NULL chars.
+	  base::FilePath::StringType source = full_path_.value();
+	  base::FilePath::StringType target = new_path.value();
+
+	  source.append(1, L'\0');
+	  target.append(1, L'\0');
+
+	  SHFILEOPSTRUCT move_info = {nullptr};
+	  move_info.wFunc = FO_MOVE;
+	  move_info.pFrom = source.c_str();
+	  move_info.pTo = target.c_str();
+	  move_info.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOERRORUI |
+						 FOF_NOCONFIRMMKDIR | FOF_NOCOPYSECURITYATTRIBS;
+
+	  int result = SHFileOperation(&move_info);
+	  DownloadInterruptReason interrupt_reason = DOWNLOAD_INTERRUPT_REASON_NONE;
+
+	  if (result == 0 && move_info.fAnyOperationsAborted)
+		interrupt_reason = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+	  else if (result != 0)
+		interrupt_reason = MapShFileOperationCodes(result);
+
+	  if (interrupt_reason != DOWNLOAD_INTERRUPT_REASON_NONE)
+		return LogInterruptReason("SHFileOperation", result, interrupt_reason);
+
+	  return interrupt_reason;
+  }
 
   base::win::AssertComInitialized();
   Microsoft::WRL::ComPtr<IShellItem> original_path;
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index c957a691efcac..59bcdbb763bc2 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -88,13 +88,45 @@ int GetPreRS5UniversalApiContractVersion() {
     return 6;
   }
   // The list above should account for all Windows versions prior to
-  // RS5.
-  NOTREACHED();
+  // RS5. 0 represents all pre-Win10 releases.
   return 0;
 }
 
+int GetLegacyWindowsVersion() {
+// The User Agent Client Hints specification indicates that Windows 7 through 8.x
+// should be handled as having a major version of 0 while using the OS' minor version.
+// (i.e. Windows 7 is 0.1). This does not account for how to handle Windows Vista and below.
+// As a result, Vista will report as 0.60 and NT 5.x as 0.5x.
+// TODO: introduce UA-CH spoofer to avoid any undesirable impacts of having the "wrong" values in future.
+	const base::win::Version version = base::win::OSInfo::Kernel32Version();
+	if (version == base::win::Version::WIN8_1) {
+		return 3;
+	}
+	if (version == base::win::Version::WIN8) {
+		return 2;
+	}
+	if (version == base::win::Version::WIN7) {
+		return 1;
+	}
+	if (version == base::win::Version::VISTA) {
+		return 60;
+	}
+	if (version == base::win::Version::SERVER_2003) {
+		return 52;
+	}
+	if (version == base::win::Version::XP) {
+		return 51;
+	}
+	if (version == base::win::Version::PRE_XP) {
+		return 50;
+	}
+	return 0;
+}
+
 // Returns the UniversalApiContract version number, which is available for
-// Windows versions greater than RS5. Otherwise, returns 0.
+// Windows versions greater than RS5. Otherwise, returns a version value
+// representing the Windows version (non-zero major version for early Windows 10,
+// non-zero minor version for pre-Windows 10).
 const std::string& GetUniversalApiContractVersion() {
   // Do not use this for runtime environment detection logic. This method should
   // only be used to help populate the Sec-CH-UA-Platform client hint. If
@@ -108,6 +140,7 @@ const std::string& GetUniversalApiContractVersion() {
         if (base::win::OSInfo::Kernel32Version() <=
             base::win::Version::WIN10_RS4) {
           major_version = GetPreRS5UniversalApiContractVersion();
+		  minor_version = GetLegacyWindowsVersion();
         } else {
           base::win::RegKey version_key(
               HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
diff --git a/components/metrics/motherboard.cc b/components/metrics/motherboard.cc
index 4b2270d10a86d..e97bde5ddf5d1 100644
--- a/components/metrics/motherboard.cc
+++ b/components/metrics/motherboard.cc
@@ -16,6 +16,7 @@
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
 
+#include "base/scoped_native_library.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/scoped_bstr.h"
@@ -142,7 +143,19 @@ void ReadWin32Bios(const ComPtr<IWbemServices>& services,
 
 void ReadFirmwareType(absl::optional<Motherboard::BiosType>* bios_type) {
   FIRMWARE_TYPE firmware_type = FirmwareTypeUnknown;
-  if (::GetFirmwareType(&firmware_type)) {
+  // NOTE: GetFirmwareType API only exists on >= Win8.  Dynamically
+  //       get function handle.
+  using GetFirmwareTypeFunction = decltype(&GetFirmwareType);
+  base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+  if (!dll.is_valid())
+    return;
+  GetFirmwareTypeFunction get_firmware_type_function =
+      reinterpret_cast<GetFirmwareTypeFunction>(
+          dll.GetFunctionPointer("GetFirmwareType"));
+  if (!get_firmware_type_function)
+    return;
+
+  if (get_firmware_type_function(&firmware_type)) {
     if (firmware_type == FirmwareTypeBios) {
       *bios_type = Motherboard::BiosType::kLegacy;
     } else if (firmware_type == FirmwareTypeUefi) {
diff --git a/components/system_media_controls/win/system_media_controls_win.cc b/components/system_media_controls/win/system_media_controls_win.cc
index 8e6430f0832db..9291a58c2c003 100644
--- a/components/system_media_controls/win/system_media_controls_win.cc
+++ b/components/system_media_controls/win/system_media_controls_win.cc
@@ -9,11 +9,6 @@
 #include <wrl/client.h>
 #include <wrl/event.h>
 
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
 #include "base/strings/string_piece.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/core_winrt_util.h"
@@ -91,6 +86,11 @@ bool SystemMediaControlsWin::Initialize() {
 
   attempted_to_initialize_ = true;
 
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
   Microsoft::WRL::ComPtr<ISystemMediaTransportControlsInterop> interop;
   HRESULT hr = base::win::GetActivationFactory<
       ISystemMediaTransportControlsInterop,
diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index 6600e576a857f..6259f4a0754e9 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,6 +20,10 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,16 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
+#elif BUILDFLAG(IS_ANDROID)
+    // On Android we run a Finch experiment testing direct memory allocation.
+    config.force_direct_shared_memory_allocation = base::FeatureList::IsEnabled(
+        mojo::core::kMojoDirectSharedMemoryAndroid);
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 576f6e3b2ef21..471ef0a39818e 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2838,6 +2838,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/legacy_render_widget_host_win.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 0c63eb5ecf270..b62f9c6c8b994 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -193,6 +193,7 @@
 #include <windows.h>
 
 #include "base/threading/platform_thread_win.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
@@ -1002,6 +1003,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/installedapp/installed_app_provider_impl_win.cc b/content/browser/installedapp/installed_app_provider_impl_win.cc
index 252da4a57d373..4f379ef5a3d65 100644
--- a/content/browser/installedapp/installed_app_provider_impl_win.cc
+++ b/content/browser/installedapp/installed_app_provider_impl_win.cc
@@ -112,6 +112,13 @@ void FilterInstalledAppsForWin(
     std::vector<blink::mojom::RelatedApplicationPtr> related_apps,
     blink::mojom::InstalledAppProvider::FilterInstalledAppsCallback callback,
     const GURL frame_url) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload() ||
+      !base::win::ResolveCoreWinRTDelayload()) {
+    std::move(callback).Run(std::vector<blink::mojom::RelatedApplicationPtr>());
+    return;
+  }
+
   ComPtr<ILauncherStatics4> launcher_statics;
   HRESULT hr = base::win::RoActivateInstance(
       base::win::ScopedHString::Create(RuntimeClass_Windows_System_Launcher)
diff --git a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
index b141cfe3cc2e6..711838407f765 100644
--- a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
+++ b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
@@ -12,6 +12,7 @@
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox_policy.h"
@@ -34,8 +35,10 @@ bool PpapiPluginSandboxedProcessLauncherDelegate::InitializeConfig(
   // create the server side of Chrome pipes.
   sandbox::ResultCode result;
 #if !defined(NACL_WIN64)
+  // We don't support PPAPI win32k lockdown prior to Windows 10.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
   result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
-  if (result != sandbox::SBOX_ALL_OK) {
+  if (result != sandbox::SBOX_ALL_OK)
     return false;
   }
 #endif  // !defined(NACL_WIN64)
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index b04194c32a4d1..d760a109ff576 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,10 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +46,9 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
@@ -173,9 +181,12 @@ void DirectManipulationHelper::OnPointerHitTest(WPARAM w_param) {
   // For WM_POINTER, the pointer type will show the event from mouse.
   // For WM_POINTERACTIVATE, the pointer id will be different with the following
   // message.
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(pointer_id, &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     viewport_->SetContact(pointer_id);
   }
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..2547e1d5e893b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,771 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  if (!collection_) {
+    return;
+  }
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (UNLIKELY(slow_down_mode_for_testing == SlowDownMode::kDelayEachTask)) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (UNLIKELY(slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask) &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..cee91dd4e059b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index b7ee9276d64fc..116953d3ef8f9 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -36,6 +36,9 @@
 #include "third_party/abseil-cpp/absl/utility/utility.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/ports/SkTypeface_win.h"
 #include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/text_analysis_source.h"
 
@@ -446,6 +449,40 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -542,7 +579,52 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {
+  InitializeDirectWrite();
+  callback = mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+      std::move(callback),
+      blink::mojom::FallbackFamilyAndStyle::New("",
+                                                /* weight */ 0,
+                                                /* width */ 0,
+                                                /* slant */ 0));
+
+  if (!codepoint || !collection_ || !factory_)
+    return;
+
+  sk_sp<SkFontMgr> font_mgr(
+      SkFontMgr_New_DirectWrite(factory_.Get(), collection_.Get()));
+
+  if (!font_mgr)
+    return;
+
+  const char* bcp47_locales[] = {locale_name.c_str()};
+  int num_locales = locale_name.empty() ? 0 : 1;
+  const char** locales = locale_name.empty() ? nullptr : bcp47_locales;
+
+  sk_sp<SkTypeface> typeface(font_mgr->matchFamilyStyleCharacter(
+      base_family_name.c_str(), SkFontStyle(), locales, num_locales,
+      codepoint));
+
+  if (!typeface)
+    return;
+
+  SkString family_name;
+  typeface->getFamilyName(&family_name);
+
+  SkFontStyle font_style = typeface->fontStyle();
+
+  auto result_fallback_and_style = blink::mojom::FallbackFamilyAndStyle::New(
+      family_name.c_str(), font_style.weight(), font_style.width(),
+      font_style.slant());
+  std::move(callback).Run(std::move(result_fallback_and_style));
+}
+
 void DWriteFontProxyImpl::InitializeDirectWrite() {
+  HRESULT hr;
   if (direct_write_initialized_)
     return;
   direct_write_initialized_ = true;
@@ -556,20 +638,30 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
-  // Normally identical to factory_->GetSystemFontCollection() unless a
-  // sideloaded font has been added using SideLoadFontForTesting().
-  HRESULT hr = GetLocalFontCollection(factory3_, &collection_);
+  // On Windows 10 and up (or Vista exkernel/Windows 8.x with modified dwrite.dll from 1809)
+  // you can take advantage of the extended DirectWrite APIs to sideload local fonts in
+  // addition to system fonts. But if IDWriteFactory3 is unavailable, fall back to
+  // GetSystemFontCollection.
+  // TODO: make DirectWrite optional for the benefit of the NT 5 users.
+
+  if(factory3_  == nullptr) {
+  hr = factory_->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+  }
+  else {
+  hr = GetLocalFontCollection(factory3_, &collection_);
   DCHECK(SUCCEEDED(hr));
+  }
+
 
   if (!collection_) {
     return;
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index 421d471aaa6e1..3beaa0fb58fef 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_message_filter.h"
 #include "content/public/browser/browser_thread.h"
@@ -63,6 +64,20 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
   void InitializeDirectWrite();
 
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
index 5f8c1b00295ce..152f73280e000 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
@@ -25,6 +25,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
 #include "third_party/icu/source/common/unicode/umachine.h"
+#include "ui/gfx/test/font_fallback_test_data.h"
 
 namespace content {
 
@@ -182,6 +183,32 @@ TEST_F(DWriteFontProxyImplUnitTest, TestCustomFontFiles) {
   }
 }
 
+TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
+  for (auto& fallback_request : gfx::kGetFontFallbackTests) {
+    blink::mojom::FallbackFamilyAndStylePtr fallback_family_and_style;
+    UChar32 codepoint;
+    U16_GET(fallback_request.text.c_str(), 0, 0, fallback_request.text.size(),
+            codepoint);
+    dwrite_font_proxy().FallbackFamilyAndStyleForCodepoint(
+        "Times New Roman", fallback_request.language_tag, codepoint,
+        &fallback_family_and_style);
+
+    EXPECT_TRUE(base::Contains(fallback_request.fallback_fonts,
+                               fallback_family_and_style->fallback_family_name))
+        << "Did not find expected fallback font for language: "
+        << fallback_request.language_tag << ", codepoint U+" << std::hex
+        << codepoint << " DWrite returned font name: \""
+        << fallback_family_and_style->fallback_family_name << "\""
+        << ", expected: "
+        << base::JoinString(fallback_request.fallback_fonts, ", ");
+    EXPECT_EQ(fallback_family_and_style->weight, 400u);
+    EXPECT_EQ(fallback_family_and_style->width,
+              5u);  // SkFontStyle::Width::kNormal_Width
+    EXPECT_EQ(fallback_family_and_style->slant,
+              0u);  // SkFontStyle::Slant::kUpright_Slant
+  }
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 44922d6b9f7f7..4d7d83d3d7337 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3461,6 +3461,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kRendererWaitForJavaDebugger,
 #endif
 #if BUILDFLAG(IS_WIN)
+    switches::kDisableDirectWrite,
     switches::kDisableHighResTimer,
     switches::kTrySupportedChannelLayouts,
     switches::kRaiseTimerFrequency,
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
index a529ad9aac0b9..90c0ff972bda5 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
@@ -41,9 +41,19 @@ base::RepeatingCallback<mojo::PendingRemote<blink::mojom::DWriteFontProxy>(
 void CreateDirectWriteFactory(IDWriteFactory** factory) {
   // This shouldn't be necessary, but not having this causes breakage in
   // content_browsertests, and possibly other high-stress cases.
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+
+  HMODULE dwrite_dll = GetModuleHandleW(L"dwrite.dll");
+
   PatchServiceManagerCalls();
 
-  CHECK(SUCCEEDED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_ISOLATED,
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
+  CHECK(SUCCEEDED(dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_ISOLATED,
                                       __uuidof(IDWriteFactory),
                                       reinterpret_cast<IUnknown**>(factory))));
 }
@@ -53,7 +63,11 @@ void CreateDirectWriteFactory(IDWriteFactory** factory) {
 void InitializeDWriteFontProxy() {
   TRACE_EVENT0("dwrite,fonts", "InitializeDWriteFontProxy");
   mswr::ComPtr<IDWriteFactory> factory;
-
+  // Halt the init process if the DLL is not there.
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
+
   CreateDirectWriteFactory(&factory);
 
   if (!g_font_collection) {
@@ -79,7 +93,7 @@ void InitializeDWriteFontProxy() {
 
   skia::OverrideDefaultSkFontMgr(std::move(skia_font_manager));
 
-  DCHECK(g_font_fallback);
+  blink::WebFontRendering::SetUseSkiaFontFallback(g_font_fallback ? true : false);
 }
 
 void UninitializeDWriteFontProxy() {
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
index 163d1ecca00c1..0186a5a3d8b8d 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
@@ -52,8 +52,18 @@ class DWriteFontProxyUnitTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
-                        &factory);
+    using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+    if (!dwrite_dll)
+      return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+      return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+                               &factory);
 
     std::vector<wchar_t> font_path;
     font_path.resize(MAX_PATH);
diff --git a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
index 90a04f1deef7f..3f40491a80b7b 100644
--- a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
@@ -27,7 +27,17 @@ namespace {
 class FontFallbackUnitTest : public testing::Test {
  public:
   FontFallbackUnitTest() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+	DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+	if (!dwrite_create_factory_proc)
+		return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory_);
 
     factory_->CreateNumberSubstitution(DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE,
diff --git a/content/child/font_warmup_win_unittest.cc b/content/child/font_warmup_win_unittest.cc
index 051af55e65a2c..5a6cece424703 100644
--- a/content/child/font_warmup_win_unittest.cc
+++ b/content/child/font_warmup_win_unittest.cc
@@ -69,6 +69,16 @@ class GDIFontEmulationTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+	HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+		return;
     DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory);
   }
diff --git a/content/common/sandbox_init_win.cc b/content/common/sandbox_init_win.cc
index 498f60227d13e..724ce1120b720 100644
--- a/content/common/sandbox_init_win.cc
+++ b/content/common/sandbox_init_win.cc
@@ -17,6 +17,7 @@
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace content {
 
diff --git a/content/ppapi_plugin/ppapi_plugin_main.cc b/content/ppapi_plugin/ppapi_plugin_main.cc
index 89e84b2c25c52..8af071d123a33 100644
--- a/content/ppapi_plugin/ppapi_plugin_main.cc
+++ b/content/ppapi_plugin/ppapi_plugin_main.cc
@@ -172,7 +172,12 @@ int PpapiPluginMain(MainFunctionParams parameters) {
 #if BUILDFLAG(IS_WIN)
   if (!base::win::IsUser32AndGdi32Available())
     gfx::win::InitializeDirectWrite();
-  InitializeDWriteFontProxy();
+  bool use_direct_write = gfx::win::IsDirectWriteEnabled();
+  if (use_direct_write) {
+    InitializeDWriteFontProxy();
+  }
+
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   int antialiasing_enabled = 1;
   base::StringToInt(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index 5733e6d1ea77f..c72a6ec828e7b 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -744,6 +744,10 @@ std::string ContentBrowserClient::GetDefaultDownloadName() {
   return std::string();
 }
 
+base::FilePath ContentBrowserClient::GetFontLookupTableCacheDir() {
+  return base::FilePath();
+}
+
 base::FilePath ContentBrowserClient::GetShaderDiskCacheDirectory() {
   return base::FilePath();
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index 8b4b26ed9f976..fc1754dad223f 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1182,6 +1182,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // else we should do with the file.
   virtual std::string GetDefaultDownloadName();
 
+  // Returns the path to the font lookup table cache directory in which - on
+  // Windows 7 & 8 - we cache font name meta information to perform @font-face {
+  // src: local() } lookups.
+  virtual base::FilePath GetFontLookupTableCacheDir();
+
   // Returns the path to the browser shader disk cache root.
   virtual base::FilePath GetShaderDiskCacheDirectory();
 
diff --git a/content/renderer/renderer_main.cc b/content/renderer/renderer_main.cc
index 364f4b8c67b49..ce17776bcea93 100644
--- a/content/renderer/renderer_main.cc
+++ b/content/renderer/renderer_main.cc
@@ -93,6 +93,11 @@
 #include "mojo/public/cpp/bindings/lib/test_random_mojo_delays.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace content {
 namespace {
 
@@ -240,8 +245,18 @@ int RendererMain(MainFunctionParams parameters) {
   {
     content::ContentRendererClient* client = GetContentClient()->renderer();
     bool should_run_loop = true;
-    bool need_sandbox =
+#if BUILDFLAG(IS_WIN)
+    bool need_sandbox = true;
+    if(base::win::GetVersion() >= base::win::Version::WIN8) {
+	// Windows 8+ specific limitations required renderer sandbox disabled for GDI
+    need_sandbox = gfx::win::ShouldUseDirectWrite() &&
         !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+	}
+	else
+	need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#else
+    bool need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#endif
 
     if (!need_sandbox) {
       // The post-sandbox actions still need to happen at some point.
diff --git a/content/renderer/renderer_main_platform_delegate_win.cc b/content/renderer/renderer_main_platform_delegate_win.cc
index e7b8caa9ab118..430b6371d4f00 100644
--- a/content/renderer/renderer_main_platform_delegate_win.cc
+++ b/content/renderer/renderer_main_platform_delegate_win.cc
@@ -27,6 +27,18 @@
 #include "ui/gfx/win/direct_write.h"
 
 namespace content {
+namespace {
+
+// Windows-only skia sandbox support
+// These are used for GDI-path rendering.
+void SkiaPreCacheFont(const LOGFONT& logfont) {
+  RenderThread* render_thread = RenderThread::Get();
+  if (render_thread) {
+    render_thread->PreCacheFont(logfont);
+  }
+}
+
+}  // namespace
 
 RendererMainPlatformDelegate::RendererMainPlatformDelegate(
     const MainFunctionParams& parameters)
@@ -40,8 +52,16 @@ void RendererMainPlatformDelegate::PlatformInitialize() {
 
   // Be mindful of what resources you acquire here. They can be used by
   // malicious code if the renderer gets compromised.
-  bool no_sandbox =
-      command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+  bool no_sandbox = command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+
+  bool use_direct_write = gfx::win::ShouldUseDirectWrite();
+
+  if (use_direct_write) {
+      InitializeDWriteFontProxy();
+    } else {
+      SkTypeface_SetEnsureLOGFONTAccessibleProc(SkiaPreCacheFont);
+    }
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   if (!no_sandbox) {
     // ICU DateFormat class (used in base/time_format.cc) needs to get the
diff --git a/content/shell/browser/shell_content_browser_client.cc b/content/shell/browser/shell_content_browser_client.cc
index 0008e3c7c9600..95ebd524d0d67 100644
--- a/content/shell/browser/shell_content_browser_client.cc
+++ b/content/shell/browser/shell_content_browser_client.cc
@@ -14,6 +14,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/cxx20_erase.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
@@ -450,6 +451,11 @@ std::string ShellContentBrowserClient::GetDefaultDownloadName() {
   return "download";
 }
 
+base::FilePath ShellContentBrowserClient::GetFontLookupTableCacheDir() {
+  return browser_context()->GetPath().Append(
+      FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 std::unique_ptr<WebContentsViewDelegate>
 ShellContentBrowserClient::GetWebContentsViewDelegate(
     WebContents* web_contents) {
diff --git a/content/shell/browser/shell_content_browser_client.h b/content/shell/browser/shell_content_browser_client.h
index b33300b6da3ea..ae1480d23acc9 100644
--- a/content/shell/browser/shell_content_browser_client.h
+++ b/content/shell/browser/shell_content_browser_client.h
@@ -93,6 +93,7 @@ class ShellContentBrowserClient : public ContentBrowserClient {
       override;
   void OverrideWebkitPrefs(WebContents* web_contents,
                            blink::web_pref::WebPreferences* prefs) override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   std::unique_ptr<content::DevToolsManagerDelegate>
   CreateDevToolsManagerDelegate() override;
   void ExposeInterfacesToRenderer(
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index bed299f10f56f..3d1b5f57984d6 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -146,6 +146,12 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {}
+
 FakeFontCollection::~FakeFontCollection() = default;
 
 }  // namespace content
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index e5c7230ffcaad..3906ff44e64a6 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,11 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
  private:
   std::vector<FakeFont> fonts_;
diff --git a/device/bluetooth/bluetooth_adapter_winrt.cc b/device/bluetooth/bluetooth_adapter_winrt.cc
index a2ba812053fa5..195ec4ee6afe8 100644
--- a/device/bluetooth/bluetooth_adapter_winrt.cc
+++ b/device/bluetooth/bluetooth_adapter_winrt.cc
@@ -105,6 +105,11 @@ using ABI::Windows::Storage::Streams::IDataReaderStatics;
 using Microsoft::WRL::Callback;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 // Query string for powered Bluetooth radios. GUID Reference:
 // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/guid-bthport-device-interface
 // TODO(https://crbug.com/821766): Consider adding WindowsCreateStringReference
@@ -666,6 +671,14 @@ void BluetoothAdapterWinrt::InitForTests(
     ComPtr<IBluetoothAdapterStatics> bluetooth_adapter_statics,
     ComPtr<IDeviceInformationStatics> device_information_statics,
     ComPtr<IRadioStatics> radio_statics) {
+
+  if (!ResolveCoreWinRT()) {
+    CompleteInit(std::move(init_callback), std::move(bluetooth_adapter_statics),
+                 std::move(device_information_statics),
+                 std::move(radio_statics));
+    return;
+  }
+
   auto statics = PerformSlowInitTasks();
 
   // This allows any passed in values (which would be fakes) to replace
@@ -689,6 +702,8 @@ void BluetoothAdapterWinrt::InitForTests(
 BluetoothAdapterWinrt::StaticsInterfaces
 BluetoothAdapterWinrt::PerformSlowInitTasks() {
   base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
+  if (!ResolveCoreWinRT())
+    return BluetoothAdapterWinrt::StaticsInterfaces();
   ComPtr<IBluetoothAdapterStatics> adapter_statics;
   HRESULT hr = base::win::GetActivationFactory<
       IBluetoothAdapterStatics,
diff --git a/device/gamepad/wgi_data_fetcher_win.cc b/device/gamepad/wgi_data_fetcher_win.cc
index a215ae7f06fc7..5c685f7deea47 100644
--- a/device/gamepad/wgi_data_fetcher_win.cc
+++ b/device/gamepad/wgi_data_fetcher_win.cc
@@ -210,6 +210,11 @@ GamepadSource WgiDataFetcherWin::source() {
 
 void WgiDataFetcherWin::OnAddedToProvider() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!base::win::HStringReference::ResolveCoreWinRTStringDelayload()) {
+    initialization_state_ =
+        InitializationState::kCoreWinrtStringDelayLoadFailed;
+    return;
+  }
   HRESULT hr = get_activation_factory_function_(
       base::win::HStringReference(RuntimeClass_Windows_Gaming_Input_Gamepad)
           .Get(),
diff --git a/device/gamepad/wgi_data_fetcher_win.h b/device/gamepad/wgi_data_fetcher_win.h
index a5a27848749a2..450ad10130f76 100644
--- a/device/gamepad/wgi_data_fetcher_win.h
+++ b/device/gamepad/wgi_data_fetcher_win.h
@@ -36,6 +36,7 @@ class DEVICE_GAMEPAD_EXPORT WgiDataFetcherWin final
     kAddGamepadAddedFailed,
     kAddGamepadRemovedFailed,
     kRoGetActivationFactoryFailed,
+    kCoreWinrtStringDelayLoadFailed,
   };
 
   using Factory =
diff --git a/docs/README.md b/docs/README.md
index c1aaa629166a0..feefd6d75875c 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -1,20 +1,33 @@
-# Chromium docs
+# Supermium + Thorium - an up-to-date, open-source browser for legacy Windows users
 
-This directory contains [chromium project](https://www.chromium.org/Home/)
-documentation in [Gitiles-flavored Markdown]. It is automatically
-[rendered by Gitiles].
+The aim of Supermium is to provide the latest Chromium features, support for rendering the web and security patches to users
+of Windows Vista (with extended kernel), Windows 7 and Windows 8.x.
 
-[Gitiles-flavored Markdown]: https://gerrit.googlesource.com/gitiles/+/master/Documentation/markdown.md
-[rendered by Gitiles]: https://chromium.googlesource.com/chromium/src/+/main/docs/
+Releases are expected every one to two months.
 
-**If you add new documents, please also add a link to them in the Document Index
-below.**
+# Support this and other legacy software projects at: http://paypal.me/win32420
 
-[TOC]
+# Future objectives
 
-## Creating Documentation
+-Maintaining support for Manifest v2
 
-### Guidelines
+-Supporting Windows Vista (without extended kernel)
+
+-Restoring GDI font rendering
+
+-Adding basic GUI to installer to allow user to pick an install directory
+
+-Adding trapezoidal tabs option
+
+-"ungoogled" mode
+
+# Future objectives of lower priority
+
+-Supporting Windows XP
+
+-SSE2 build
+
+Upstream README.md follows below:
 
 *   See the [Chromium Documentation Guidelines](documentation_guidelines.md)
     and the
@@ -469,4 +482,4 @@ a video series of interviews with Chromium software engineers.
 *   [Vanilla msysgit workflow](vanilla_msysgit_workflow.md) - A workflow for
     using mostly vanilla git on Windows.
 *   [Old Options](chrome_settings.md) - Pre-Material Design chrome://settings
-    notes.
+    notes.
\ No newline at end of file
diff --git a/google_apis/google_api_keys.cc b/google_apis/google_api_keys.cc
index 49c396d69d172..cf1b234fb616c 100644
--- a/google_apis/google_api_keys.cc
+++ b/google_apis/google_api_keys.cc
@@ -37,7 +37,7 @@
 #define DUMMY_API_TOKEN "dummytoken"
 
 #if !defined(GOOGLE_API_KEY)
-#define GOOGLE_API_KEY DUMMY_API_TOKEN
+#define GOOGLE_API_KEY "AIzaSyBOti4mM-6x9WDnZIjIeyEU21OpBXqWBgw"
 #endif
 
 #if !defined(GOOGLE_METRICS_SIGNING_KEY)
@@ -45,11 +45,11 @@
 #endif
 
 #if !defined(GOOGLE_CLIENT_ID_MAIN)
-#define GOOGLE_CLIENT_ID_MAIN DUMMY_API_TOKEN
+#define GOOGLE_CLIENT_ID_MAIN "77185425430.apps.googleusercontent.com"
 #endif
 
 #if !defined(GOOGLE_CLIENT_SECRET_MAIN)
-#define GOOGLE_CLIENT_SECRET_MAIN DUMMY_API_TOKEN
+#define GOOGLE_CLIENT_SECRET_MAIN "OTJgUOQcT7lO7GsGZq2G4IlT"
 #endif
 
 #if !defined(GOOGLE_CLIENT_ID_REMOTING)
diff --git a/gpu/config/gpu_info_collector_win.cc b/gpu/config/gpu_info_collector_win.cc
index b3fc392c7b8fc..14992248d8ac6 100644
--- a/gpu/config/gpu_info_collector_win.cc
+++ b/gpu/config/gpu_info_collector_win.cc
@@ -187,6 +187,9 @@ void CollectHardwareOverlayInfo(OverlayInfo* overlay_info) {
 bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
   TRACE_EVENT0("gpu", "CollectDriverInfoD3D");
 
+  if (!::GetProcAddress(::GetModuleHandleW(L"dxgi.dll"), "CreateDXGIFactory1"))
+    return false;
+
   Microsoft::WRL::ComPtr<IDXGIFactory1> dxgi_factory;
   HRESULT hr = ::CreateDXGIFactory1(IID_PPV_ARGS(&dxgi_factory));
   if (FAILED(hr))
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index e938775a9f4ec..4986c1071faac 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -238,6 +238,8 @@ source_set("audio") {
       "win/core_audio_util_win.h",
       "win/device_enumeration_win.cc",
       "win/device_enumeration_win.h",
+      "win/wavein_input_win.cc",
+      "win/wavein_input_win.h",
       "win/waveout_output_win.cc",
       "win/waveout_output_win.h",
     ]
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index cb3f192994152..ab1a511b5df45 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -236,6 +236,13 @@ bool InitializeUWPSupport() {
     // 10.0.10240.0.
     DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
 
+    if (!(base::win::ResolveCoreWinRTDelayload() &&
+          base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+      // Failed loading functions from combase.dll.
+      DLOG(WARNING) << "Failed to initialize WinRT/UWP";
+      return false;
+    }
+
     return true;
   }();
 
diff --git a/media/audio/win/audio_manager_win.cc b/media/audio/win/audio_manager_win.cc
index b160875beda79..8e340c1065af6 100644
--- a/media/audio/win/audio_manager_win.cc
+++ b/media/audio/win/audio_manager_win.cc
@@ -28,6 +28,7 @@
 #include "media/audio/win/audio_low_latency_output_win.h"
 #include "media/audio/win/core_audio_util_win.h"
 #include "media/audio/win/device_enumeration_win.h"
+#include "media/audio/win/wavein_input_win.h"
 #include "media/audio/win/waveout_output_win.h"
 #include "media/base/audio_parameters.h"
 #include "media/base/channel_layout.h"
@@ -61,6 +62,13 @@ constexpr int kMaxOutputStreams = 50;
 // right drivers, but graceful error handling is needed.
 constexpr int kWinMaxChannels = 8;
 
+// We use 3 buffers for recording audio so that if a recording callback takes
+// some time to return we won't lose audio. More buffers while recording are
+// ok because they don't introduce any delay in recording, unlike in playback
+// where you first need to fill in that number of buffers before starting to
+// play.
+static const int kNumInputBuffers = 3;
+
 // Buffer size to use for input and output stream when a proper size can't be
 // determined from the system
 constexpr int kFallbackBufferSize = 2048;
@@ -157,24 +165,35 @@ void AudioManagerWin::InitializeOnAudioThread() {
   // callback to a WeakPtr: NotifyAllOutputDeviceChangeListeners() will be
   // posted to the audio thread instead of being run synchronously, since we use
   // BindPostTaskToCurrentDefault().
+  if (CoreAudioUtil::IsSupported()) {
   output_device_listener_ = std::make_unique<AudioDeviceListenerWin>(
       base::BindPostTaskToCurrentDefault(base::BindRepeating(
           &AudioManagerWin::NotifyAllOutputDeviceChangeListeners,
           weak_this_on_audio_thread_)));
+  }
 }
 
 void AudioManagerWin::GetAudioDeviceNamesImpl(bool input,
                                               AudioDeviceNames* device_names) {
   DCHECK(device_names->empty());
   // Enumerate all active audio-endpoint capture devices.
-  if (input)
-    GetInputDeviceNamesWin(device_names);
-  else
-    GetOutputDeviceNamesWin(device_names);
-
+  if (!CoreAudioUtil::IsSupported()) {
+    // Utilize the Wave API for Windows 2000/XP.
+    if (input)
+      GetInputDeviceNamesWinXP(device_names);
+    else
+      GetOutputDeviceNamesWinXP(device_names);
+  } else {
+    // Utilize the MMDevice API (part of Core Audio) for Vista and higher.
+    if (input)
+      GetInputDeviceNamesWin(device_names);
+    else
+      GetOutputDeviceNamesWin(device_names);
+  }
   if (!device_names->empty()) {
-    device_names->push_front(AudioDeviceName::CreateCommunications());
-
+	  if (CoreAudioUtil::IsSupported()) {
+		device_names->push_front(AudioDeviceName::CreateCommunications());
+	  }
     // Always add default device parameters as first element.
     device_names->push_front(AudioDeviceName::CreateDefault());
   }
@@ -192,18 +211,22 @@ void AudioManagerWin::GetAudioOutputDeviceNames(
 AudioParameters AudioManagerWin::GetInputStreamParameters(
     const std::string& device_id) {
   AudioParameters parameters;
-  HRESULT hr =
-      CoreAudioUtil::GetPreferredAudioParameters(device_id, false, &parameters);
+  HRESULT hr = E_FAIL;
+  if (CoreAudioUtil::IsSupported()) {
+	hr = CoreAudioUtil::GetPreferredAudioParameters(device_id, false, &parameters);
+  }
 
   if (FAILED(hr) || !parameters.IsValid()) {
+	if (CoreAudioUtil::IsSupported()) {
     LOG(WARNING) << "Unable to get preferred audio params for " << device_id
                  << " 0x" << std::hex << hr;
+	}
     // TODO(tommi): We appear to have callers to GetInputStreamParameters that
     // rely on getting valid audio parameters returned for an invalid or
     // unavailable device. We should track down those code paths (it is likely
     // that they actually don't need a real device but depend on the audio
     // code path somehow for a configuration - e.g. tab capture).
-    parameters = AudioParameters(AudioParameters::AUDIO_PCM_LINEAR,
+    parameters = AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
                                  ChannelLayoutConfig::Stereo(), 48000,
                                  kFallbackBufferSize);
   }
@@ -217,6 +240,11 @@ AudioParameters AudioManagerWin::GetInputStreamParameters(
 
 std::string AudioManagerWin::GetAssociatedOutputDeviceID(
     const std::string& input_device_id) {
+  if (!CoreAudioUtil::IsSupported()) {
+		    NOTIMPLEMENTED()
+        << "GetAssociatedOutputDeviceID is not supported on this OS";
+    return std::string();
+  }
   return CoreAudioUtil::GetMatchingOutputDeviceID(input_device_id);
 }
 
@@ -270,9 +298,14 @@ AudioOutputStream* AudioManagerWin::MakeLowLatencyOutputStream(
     return nullptr;
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceWaveAudio)) {
-    DLOG(WARNING) << "Forcing usage of Windows WaveXxx APIs";
-    return nullptr;
+          switches::kForceWaveAudio) || !CoreAudioUtil::IsSupported()) {
+		// Fall back to Windows Wave implementation on Windows XP or lower.
+		DLOG_IF(ERROR, !device_id.empty() &&
+						   device_id != AudioDeviceDescription::kDefaultDeviceId)
+			<< "Opening by device id not supported by PCMWaveOutAudioOutputStream";
+		DVLOG(1) << "Using WaveOut since WASAPI requires at least Vista.";
+		return new PCMWaveOutAudioOutputStream(
+			this, params, NumberOfWaveOutBuffers(), WAVE_MAPPER);
   }
 
   // Pass an empty string to indicate that we want the default device
@@ -305,7 +338,16 @@ AudioInputStream* AudioManagerWin::MakeLowLatencyInputStream(
     const std::string& device_id,
     const LogCallback& log_callback) {
   // Used for both AUDIO_PCM_LOW_LATENCY and AUDIO_PCM_LINEAR.
-  return new WASAPIAudioInputStream(this, params, device_id, log_callback);
+    AudioInputStream* stream = NULL;
+    if (!CoreAudioUtil::IsSupported()) {
+      // Fall back to Windows Wave implementation on Windows XP or lower.
+      DVLOG(1) << "Using WaveIn since WASAPI requires at least Vista.";
+      stream = CreatePCMWaveInAudioInputStream(params, device_id);
+    } else {
+      stream = new WASAPIAudioInputStream(this, params, device_id, log_callback);
+    }
+
+  return stream;
 }
 
 std::string AudioManagerWin::GetDefaultInputDeviceID() {
@@ -313,6 +355,8 @@ std::string AudioManagerWin::GetDefaultInputDeviceID() {
 }
 
 std::string AudioManagerWin::GetDefaultOutputDeviceID() {
+  if (!CoreAudioUtil::IsSupported())
+    return std::string();
   return CoreAudioUtil::GetDefaultOutputDeviceID();
 }
 
@@ -335,78 +379,90 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
   int min_buffer_size = 0;
   int max_buffer_size = 0;
 
-  if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio)) {
-    // TODO(rtoy): tune these values for best possible WebAudio
-    // performance. WebRTC works well at 48kHz and a buffer size of 480
-    // samples will be used for this case. Note that exclusive mode is
-    // experimental. This sample rate will be combined with a buffer size of
-    // 256 samples, which corresponds to an output delay of ~5.33ms.
-    sample_rate = 48000;
-    buffer_size = 256;
-    if (input_params.IsValid())
-      channel_layout_config = input_params.channel_layout_config();
-  } else {
-    AudioParameters params;
-    HRESULT hr = CoreAudioUtil::GetPreferredAudioParameters(
-        output_device_id.empty() ? GetDefaultOutputDeviceID()
-                                 : output_device_id,
-        true, &params);
-    if (FAILED(hr)) {
-      // This can happen when CoreAudio isn't supported or available
-      // (e.g. certain installations of Windows Server 2008 R2).
-      // Instead of returning the input_params, we'll return invalid
-      // AudioParameters to make sure that an attempt to create this output
-      // stream, won't succeed. This behavior is also consistent with
-      // GetInputStreamParameters.
-      DLOG(ERROR) << "GetPreferredAudioParameters failed: " << std::hex << hr;
-      return AudioParameters();
-    }
-    DVLOG(1) << params.AsHumanReadableString();
-    DCHECK(params.IsValid());
-
-    channel_layout_config = params.channel_layout_config();
-    buffer_size = params.frames_per_buffer();
-    sample_rate = params.sample_rate();
-    effects = params.effects();
-
-    AudioParameters::HardwareCapabilities hardware_capabilities =
-        params.hardware_capabilities().value_or(
-            AudioParameters::HardwareCapabilities());
-    min_buffer_size = hardware_capabilities.min_frames_per_buffer;
-    max_buffer_size = hardware_capabilities.max_frames_per_buffer;
-  }
-
-  if (input_params.IsValid()) {
-    // If the user has enabled checking supported channel layouts or we don't
-    // have a valid channel layout yet, try to use the input layout.  See bugs
-    // http://crbug.com/259165 and http://crbug.com/311906 for more details.
-    if (cmd_line->HasSwitch(switches::kTrySupportedChannelLayouts) ||
-        channel_layout_config.channel_layout() == CHANNEL_LAYOUT_UNSUPPORTED) {
-      // Check if it is possible to open up at the specified input channel
-      // layout but avoid checking if the specified layout is the same as the
-      // hardware (preferred) layout. We do this extra check to avoid the
-      // CoreAudioUtil::IsChannelLayoutSupported() overhead in most cases.
-      if (input_params.channel_layout() !=
-          channel_layout_config.channel_layout()) {
-        // TODO(henrika): Internally, IsChannelLayoutSupported does many of the
-        // operations that have already been done such as opening up a client
-        // and fetching the WAVEFORMATPCMEX format.  Ideally we should only do
-        // that once.  Then here, we can check the layout from the data we
-        // already hold.
-        if (CoreAudioUtil::IsChannelLayoutSupported(
-                output_device_id, eRender, eConsole,
-                input_params.channel_layout())) {
-          // Open up using the same channel layout as the source if it is
-          // supported by the hardware.
-          channel_layout_config = input_params.channel_layout_config();
-          DVLOG(1) << "Hardware channel layout is not used; using same layout"
-                   << " as the source instead ("
-                   << channel_layout_config.channel_layout() << ")";
-        }
-      }
+  if (CoreAudioUtil::IsSupported()) {
+	  if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio)) {
+		// TODO(rtoy): tune these values for best possible WebAudio
+		// performance. WebRTC works well at 48kHz and a buffer size of 480
+		// samples will be used for this case. Note that exclusive mode is
+		// experimental. This sample rate will be combined with a buffer size of
+		// 256 samples, which corresponds to an output delay of ~5.33ms.
+		sample_rate = 48000;
+		buffer_size = 256;
+		if (input_params.IsValid())
+		  channel_layout_config = input_params.channel_layout_config();
+	  } else {
+		AudioParameters params;
+		HRESULT hr = CoreAudioUtil::GetPreferredAudioParameters(
+			output_device_id.empty() ? GetDefaultOutputDeviceID()
+									 : output_device_id,
+			true, &params);
+		if (FAILED(hr)) {
+		  // This can happen when CoreAudio isn't supported or available
+		  // (e.g. certain installations of Windows Server 2008 R2).
+		  // Instead of returning the input_params, we'll return invalid
+		  // AudioParameters to make sure that an attempt to create this output
+		  // stream, won't succeed. This behavior is also consistent with
+		  // GetInputStreamParameters.
+		  DLOG(ERROR) << "GetPreferredAudioParameters failed: " << std::hex << hr;
+		  return AudioParameters();
+		}
+		DVLOG(1) << params.AsHumanReadableString();
+		DCHECK(params.IsValid());
+
+		channel_layout_config = params.channel_layout_config();
+		buffer_size = params.frames_per_buffer();
+		sample_rate = params.sample_rate();
+		effects = params.effects();
+
+		AudioParameters::HardwareCapabilities hardware_capabilities =
+			params.hardware_capabilities().value_or(
+				AudioParameters::HardwareCapabilities());
+		min_buffer_size = hardware_capabilities.min_frames_per_buffer;
+		max_buffer_size = hardware_capabilities.max_frames_per_buffer;
+	  }
+
+	  if (input_params.IsValid()) {
+		// If the user has enabled checking supported channel layouts or we don't
+		// have a valid channel layout yet, try to use the input layout.  See bugs
+		// http://crbug.com/259165 and http://crbug.com/311906 for more details.
+		if (cmd_line->HasSwitch(switches::kTrySupportedChannelLayouts) ||
+			channel_layout_config.channel_layout() == CHANNEL_LAYOUT_UNSUPPORTED) {
+		  // Check if it is possible to open up at the specified input channel
+		  // layout but avoid checking if the specified layout is the same as the
+		  // hardware (preferred) layout. We do this extra check to avoid the
+		  // CoreAudioUtil::IsChannelLayoutSupported() overhead in most cases.
+		  if (input_params.channel_layout() !=
+			  channel_layout_config.channel_layout()) {
+			// TODO(henrika): Internally, IsChannelLayoutSupported does many of the
+			// operations that have already been done such as opening up a client
+			// and fetching the WAVEFORMATPCMEX format.  Ideally we should only do
+			// that once.  Then here, we can check the layout from the data we
+			// already hold.
+			if (CoreAudioUtil::IsChannelLayoutSupported(
+					output_device_id, eRender, eConsole,
+					input_params.channel_layout())) {
+			  // Open up using the same channel layout as the source if it is
+			  // supported by the hardware.
+			  channel_layout_config = input_params.channel_layout_config();
+			  DVLOG(1) << "Hardware channel layout is not used; using same layout"
+					   << " as the source instead ("
+					   << channel_layout_config.channel_layout() << ")";
+			}
+		  }
+		}
     }
-
     effects |= input_params.effects();
+
+    if (!CoreAudioUtil::IsSupported()) {
+      // If WASAPI isn't supported we'll fallback to WaveOut, which will take
+      // care of resampling and bits per sample changes.  By setting these
+      // equal to the input values, AudioOutputResampler will skip resampling
+      // and bit per sample differences (since the input parameters will match
+      // the output parameters).
+      buffer_size = input_params.frames_per_buffer();
+      sample_rate = input_params.sample_rate();
+	  channel_layout_config = input_params.channel_layout_config();
+    }
 
     // Allow non-default buffer sizes if we have a valid min and max.
     if (min_buffer_size > 0 && max_buffer_size > 0) {
@@ -438,6 +494,23 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
   return params;
 }
 
+AudioInputStream* AudioManagerWin::CreatePCMWaveInAudioInputStream(
+    const AudioParameters& params,
+    const std::string& device_id) {
+  std::string xp_device_id = device_id;
+  if (device_id != AudioDeviceDescription::kDefaultDeviceId) {
+    xp_device_id = ConvertToWinXPInputDeviceId(device_id);
+    if (xp_device_id.empty()) {
+      DLOG(ERROR) << "Cannot find a waveIn device which matches the device ID "
+                  << device_id;
+      return NULL;
+    }
+  }
+
+  return new PCMWaveInAudioInputStream(this, params, kNumInputBuffers,
+                                       xp_device_id);
+}
+
 // static
 std::unique_ptr<AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
diff --git a/media/audio/win/audio_manager_win.h b/media/audio/win/audio_manager_win.h
index 0a53e62efa795..f0370bf026081 100644
--- a/media/audio/win/audio_manager_win.h
+++ b/media/audio/win/audio_manager_win.h
@@ -73,6 +73,15 @@ class MEDIA_EXPORT AudioManagerWin : public AudioManagerBase {
  private:
   // Allow unit test to modify the utilized enumeration API.
   friend class AudioManagerTest;
+
+  // Returns a PCMWaveInAudioInputStream instance or NULL on failure.
+  // This method converts MMDevice-style device ID to WaveIn-style device ID if
+  // necessary.
+  // (Please see device_enumeration_win.h for more info about the two kinds of
+  // device IDs.)
+  AudioInputStream* CreatePCMWaveInAudioInputStream(
+      const AudioParameters& params,
+      const std::string& device_id);
 
   // Helper methods for performing expensive initialization tasks on the audio
   // thread instead of on the UI thread which AudioManager is constructed on.
diff --git a/media/audio/win/device_enumeration_win.cc b/media/audio/win/device_enumeration_win.cc
index 11b1678768a10..b72c5e3a6385c 100644
--- a/media/audio/win/device_enumeration_win.cc
+++ b/media/audio/win/device_enumeration_win.cc
@@ -165,6 +165,54 @@ bool GetOutputDeviceNamesWinXP(AudioDeviceNames* device_names) {
                                  waveOutGetDevCapsW>(device_names);
 }
 
+std::string ConvertToWinXPInputDeviceId(const std::string& device_id) {
+  UINT number_of_active_devices = waveInGetNumDevs();
+  MMRESULT result = MMSYSERR_NOERROR;
+
+  UINT i = 0;
+  for (; i < number_of_active_devices; ++i) {
+    size_t size = 0;
+    // Get the size (including the terminating NULL) of the endpoint ID of the
+    // waveIn device.
+    result = waveInMessage(reinterpret_cast<HWAVEIN>(i),
+                           DRV_QUERYFUNCTIONINSTANCEIDSIZE,
+                           reinterpret_cast<DWORD_PTR>(&size), NULL);
+    if (result != MMSYSERR_NOERROR)
+      continue;
+
+    ScopedCoMem<WCHAR> id;
+    id.Reset(static_cast<WCHAR*>(CoTaskMemAlloc(size)));
+    if (!id)
+      continue;
+
+    // Get the endpoint ID string for this waveIn device.
+    result = waveInMessage(
+        reinterpret_cast<HWAVEIN>(i), DRV_QUERYFUNCTIONINSTANCEID,
+        reinterpret_cast<DWORD_PTR>(static_cast<WCHAR*>(id)), size);
+    if (result != MMSYSERR_NOERROR)
+      continue;
+
+    std::string utf8_id = base::WideToUTF8(static_cast<WCHAR*>(id));
+    // Check whether the endpoint ID string of this waveIn device matches that
+    // of the audio endpoint device.
+    if (device_id == utf8_id)
+      break;
+  }
+
+  // If a matching waveIn device was found, convert the unique endpoint ID
+  // string to a standard friendly name with max 32 characters.
+  if (i < number_of_active_devices) {
+    WAVEINCAPS capabilities;
+
+    result = waveInGetDevCaps(i, &capabilities, sizeof(capabilities));
+    if (result == MMSYSERR_NOERROR)
+      return base::WideToUTF8(capabilities.szPname);
+  }
+
+  return std::string();
+
+}
+
 std::string GetDeviceSuffixWin(const std::string& controller_id) {
   std::string suffix;
   if (controller_id.size() >= 21 && controller_id.substr(0, 8) == "USB\\VID_" &&
diff --git a/media/audio/win/device_enumeration_win.h b/media/audio/win/device_enumeration_win.h
index d6f73a8424496..0c3eed8ce4e03 100644
--- a/media/audio/win/device_enumeration_win.h
+++ b/media/audio/win/device_enumeration_win.h
@@ -28,8 +28,17 @@ bool GetOutputDeviceNamesWin(media::AudioDeviceNames* device_names);
 // Example record in the output list:
 // - device_name: "Microphone (Realtek High Defini".
 // - unique_id: "Microphone (Realtek High Defini" (same as friendly name).
+bool GetInputDeviceNamesWinXP(media::AudioDeviceNames* device_names);
 bool GetOutputDeviceNamesWinXP(media::AudioDeviceNames* device_names);
 
+// Converts an input device ID generated by |GetInputDeviceNamesWin()| to the
+// corresponding ID by |GetInputDeviceNamesWinXP()|. Returns an empty string on
+// failure.
+// Example input and output:
+// - input ID: "{0.0.1.00000000}.{8db6020f-18e3-4f25-b6f5-7726c9122574}"
+// - output ID: "Microphone (Realtek High Defini"
+std::string ConvertToWinXPInputDeviceId(const std::string& device_id);
+
 // Given a string |controller_id| with the controller ID of an audio device,
 // returns a string containing extra information about the device.
 // If the device is a USB device, the format of the returned string is
diff --git a/media/audio/win/wavein_input_win.cc b/media/audio/win/wavein_input_win.cc
new file mode 100644
index 0000000000000..3c42508274554
--- /dev/null
+++ b/media/audio/win/wavein_input_win.cc
@@ -0,0 +1,332 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/win/wavein_input_win.h"
+
+#include "base/logging.h"
+#include "base/time/time.h"
+#include "media/audio/audio_device_description.h"
+#include "media/audio/audio_io.h"
+#include "media/audio/win/audio_manager_win.h"
+#include "media/audio/win/device_enumeration_win.h"
+#include "media/base/audio_bus.h"
+
+namespace media {
+
+// Our sound buffers are allocated once and kept in a linked list using the
+// the WAVEHDR::dwUser variable. The last buffer points to the first buffer.
+static WAVEHDR* GetNextBuffer(WAVEHDR* current) {
+  return reinterpret_cast<WAVEHDR*>(current->dwUser);
+}
+
+constexpr SampleFormat kSampleFormat = kSampleFormatS16;
+
+PCMWaveInAudioInputStream::PCMWaveInAudioInputStream(
+    AudioManagerWin* manager,
+    const AudioParameters& params,
+    int num_buffers,
+    const std::string& device_id)
+    : state_(kStateEmpty),
+      manager_(manager),
+      callback_(NULL),
+      num_buffers_(num_buffers),
+      channels_(params.channels()),
+      device_id_(device_id),
+      wavein_(NULL),
+      buffer_(NULL),
+      audio_bus_(media::AudioBus::Create(params)) {
+  DCHECK_GT(num_buffers_, 0);
+  format_.wFormatTag = WAVE_FORMAT_PCM;
+  format_.nChannels = params.channels() > 2 ? 2 : params.channels();
+  format_.nSamplesPerSec = params.sample_rate();
+  format_.wBitsPerSample = SampleFormatToBitsPerChannel(kSampleFormat);
+  format_.cbSize = 0;
+  format_.nBlockAlign = (format_.nChannels * format_.wBitsPerSample) / 8;
+  format_.nAvgBytesPerSec = format_.nBlockAlign * format_.nSamplesPerSec;
+  buffer_size_ = params.frames_per_buffer() * format_.nBlockAlign;
+  // If we don't have a packet size we use 100ms.
+  if (!buffer_size_)
+    buffer_size_ = format_.nAvgBytesPerSec / 10;
+  // The event is auto-reset.
+  stopped_event_.Set(::CreateEventW(NULL, FALSE, FALSE, NULL));
+}
+
+PCMWaveInAudioInputStream::~PCMWaveInAudioInputStream() {
+  DCHECK(NULL == wavein_);
+}
+
+AudioInputStream::OpenOutcome PCMWaveInAudioInputStream::Open() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateEmpty)
+    return AudioInputStream::OpenOutcome::kFailed;
+  if (num_buffers_ < 2 || num_buffers_ > 10)
+    return AudioInputStream::OpenOutcome::kFailed;
+
+  // Convert the stored device id string into an unsigned integer
+  // corresponding to the selected device.
+  UINT device_id = WAVE_MAPPER;
+  if (!GetDeviceId(&device_id)) {
+    return AudioInputStream::OpenOutcome::kFailed;
+  }
+
+  // Open the specified input device for recording.
+  MMRESULT result = MMSYSERR_NOERROR;
+  result = ::waveInOpen(&wavein_, device_id, &format_,
+                        reinterpret_cast<DWORD_PTR>(WaveCallback),
+                        reinterpret_cast<DWORD_PTR>(this),
+                        CALLBACK_FUNCTION);
+  if (result != MMSYSERR_NOERROR)
+    return AudioInputStream::OpenOutcome::kFailed;
+
+  SetupBuffers();
+  state_ = kStateReady;
+  return AudioInputStream::OpenOutcome::kSuccess;
+}
+
+void PCMWaveInAudioInputStream::SetupBuffers() {
+  WAVEHDR* last = NULL;
+  WAVEHDR* first = NULL;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    uint32_t sz = sizeof(WAVEHDR) + buffer_size_;
+    buffer_ =  reinterpret_cast<WAVEHDR*>(new char[sz]);
+    buffer_->lpData = reinterpret_cast<char*>(buffer_) + sizeof(WAVEHDR);
+    buffer_->dwBufferLength = buffer_size_;
+    buffer_->dwBytesRecorded = 0;
+    buffer_->dwUser = reinterpret_cast<DWORD_PTR>(last);
+    buffer_->dwFlags = WHDR_DONE;
+    buffer_->dwLoops = 0;
+    if (ix == 0)
+      first = buffer_;
+    last = buffer_;
+    ::waveInPrepareHeader(wavein_, buffer_, sizeof(WAVEHDR));
+  }
+  // Fix the first buffer to point to the last one.
+  first->dwUser = reinterpret_cast<DWORD_PTR>(last);
+}
+
+void PCMWaveInAudioInputStream::FreeBuffers() {
+  WAVEHDR* current = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    WAVEHDR* next = GetNextBuffer(current);
+    if (current->dwFlags & WHDR_PREPARED)
+      ::waveInUnprepareHeader(wavein_, current, sizeof(WAVEHDR));
+    delete[] reinterpret_cast<char*>(current);
+    current = next;
+  }
+  buffer_ = NULL;
+}
+
+void PCMWaveInAudioInputStream::Start(AudioInputCallback* callback) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateReady)
+    return;
+
+  DCHECK(!callback_);
+  callback_ = callback;
+  state_ = kStateRecording;
+
+  WAVEHDR* buffer = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    QueueNextPacket(buffer);
+    buffer = GetNextBuffer(buffer);
+  }
+  buffer = buffer_;
+
+  MMRESULT result = ::waveInStart(wavein_);
+  if (result != MMSYSERR_NOERROR) {
+    HandleError(result);
+    state_ = kStateReady;
+    callback_ = NULL;
+  }
+}
+
+// Stopping is tricky. First, no buffer should be locked by the audio driver
+// or else the waveInReset() will deadlock and secondly, the callback should
+// not be inside the AudioInputCallback's OnData because waveInReset()
+// forcefully kills the callback thread.
+void PCMWaveInAudioInputStream::Stop() {
+  DVLOG(1) << "PCMWaveInAudioInputStream::Stop()";
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateRecording)
+    return;
+
+  bool already_stopped = false;
+  {
+    // Tell the callback that we're stopping.
+    // As a result, |stopped_event_| will be signaled in callback method.
+    base::AutoLock auto_lock(lock_);
+    already_stopped = (callback_ == NULL);
+    callback_ = NULL;
+  }
+
+  if (already_stopped)
+    return;
+
+  // Wait for the callback to finish, it will signal us when ready to be reset.
+  DWORD wait = ::WaitForSingleObject(stopped_event_.Get(), INFINITE);
+  DCHECK_EQ(wait, WAIT_OBJECT_0);
+
+  // Stop input and reset the current position to zero for |wavein_|.
+  // All pending buffers are marked as done and returned to the application.
+  MMRESULT res = ::waveInReset(wavein_);
+  DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+
+  state_ = kStateReady;
+}
+
+void PCMWaveInAudioInputStream::Close() {
+  DVLOG(1) << "PCMWaveInAudioInputStream::Close()";
+  DCHECK(thread_checker_.CalledOnValidThread());
+
+  // We should not call Close() while recording. Catch it with DCHECK and
+  // implement auto-stop just in case.
+  DCHECK_NE(state_, kStateRecording);
+  Stop();
+
+  if (wavein_) {
+    FreeBuffers();
+
+    // waveInClose() generates a WIM_CLOSE callback.  In case Start() was never
+    // called, force a reset to ensure close succeeds.
+    MMRESULT res = ::waveInReset(wavein_);
+    DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+    res = ::waveInClose(wavein_);
+    DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+    state_ = kStateClosed;
+    wavein_ = NULL;
+  }
+
+  // Tell the audio manager that we have been released. This can result in
+  // the manager destroying us in-place so this needs to be the last thing
+  // we do on this function.
+  manager_->ReleaseInputStream(this);
+}
+
+double PCMWaveInAudioInputStream::GetMaxVolume() {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  return 0.0;
+}
+
+void PCMWaveInAudioInputStream::SetVolume(double volume) {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+}
+
+double PCMWaveInAudioInputStream::GetVolume() {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  return 0.0;
+}
+
+bool PCMWaveInAudioInputStream::SetAutomaticGainControl(bool enabled) {
+  // TODO(henrika): Add AGC support when volume control has been added.
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool PCMWaveInAudioInputStream::GetAutomaticGainControl() {
+  // TODO(henrika): Add AGC support when volume control has been added.
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool PCMWaveInAudioInputStream::IsMuted() {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void PCMWaveInAudioInputStream::HandleError(MMRESULT error) {
+  DLOG(WARNING) << "PCMWaveInAudio error " << error;
+  if (callback_)
+    callback_->OnError();
+}
+
+void PCMWaveInAudioInputStream::QueueNextPacket(WAVEHDR *buffer) {
+  MMRESULT res = ::waveInAddBuffer(wavein_, buffer, sizeof(WAVEHDR));
+  if (res != MMSYSERR_NOERROR)
+    HandleError(res);
+}
+
+bool PCMWaveInAudioInputStream::GetDeviceId(UINT* device_index) {
+  // Deliver the default input device id (WAVE_MAPPER) if the default
+  // device has been selected.
+  if (device_id_ == AudioDeviceDescription::kDefaultDeviceId) {
+    *device_index = WAVE_MAPPER;
+    return true;
+  }
+
+  // Get list of all available and active devices.
+  AudioDeviceNames device_names;
+  if (!media::GetInputDeviceNamesWinXP(&device_names))
+    return false;
+
+  if (device_names.empty())
+    return false;
+
+  // Search the full list of devices and compare with the specified
+  // device id which was specified in the constructor. Stop comparing
+  // when a match is found and return the corresponding index.
+  UINT index = 0;
+  bool found_device = false;
+  AudioDeviceNames::const_iterator it = device_names.begin();
+  while (it != device_names.end()) {
+    if (it->unique_id.compare(device_id_) == 0) {
+      *device_index = index;
+      found_device = true;
+      break;
+    }
+    ++index;
+    ++it;
+  }
+
+  return found_device;
+}
+
+// Windows calls us back in this function when some events happen. Most notably
+// when it has an audio buffer with recorded data.
+void PCMWaveInAudioInputStream::WaveCallback(HWAVEIN hwi, UINT msg,
+                                             DWORD_PTR instance,
+                                             DWORD_PTR param1, DWORD_PTR) {
+  PCMWaveInAudioInputStream* obj =
+      reinterpret_cast<PCMWaveInAudioInputStream*>(instance);
+
+  // The lock ensures that Stop() can't be called during a callback.
+  base::AutoLock auto_lock(obj->lock_);
+
+  if (msg == WIM_DATA) {
+    // The WIM_DATA message is sent when waveform-audio data is present in
+    // the input buffer and the buffer is being returned to the application.
+    // The message can be sent when the buffer is full or after the
+    // waveInReset function is called.
+    if (obj->callback_) {
+      // TODO(henrika): the |volume| parameter is always set to zero since
+      // there is currently no support for controlling the microphone volume
+      // level.
+      WAVEHDR* buffer = reinterpret_cast<WAVEHDR*>(param1);
+      obj->audio_bus_->FromInterleaved<SignedInt16SampleTypeTraits>(
+          reinterpret_cast<int16_t*>(buffer->lpData), obj->audio_bus_->frames());
+      obj->callback_->OnData(obj->audio_bus_.get(), base::TimeTicks::Now(), 0.0, {});
+
+      // Queue the finished buffer back with the audio driver. Since we are
+      // reusing the same buffers we can get away without calling
+      // waveInPrepareHeader.
+      obj->QueueNextPacket(buffer);
+    } else {
+      // Main thread has called Stop() and set |callback_| to NULL and is
+      // now waiting to issue waveInReset which will kill this thread.
+      // We should not call AudioSourceCallback code anymore.
+      ::SetEvent(obj->stopped_event_.Get());
+    }
+  } else if (msg == WIM_CLOSE) {
+    // Intentionaly no-op for now.
+  } else if (msg == WIM_OPEN) {
+    // Intentionaly no-op for now.
+  }
+}
+
+void PCMWaveInAudioInputStream::SetOutputDeviceForAec(
+    const std::string& output_device_id) {
+  // Not supported. Do nothing.
+}
+
+
+}  // namespace media
\ No newline at end of file
diff --git a/media/audio/win/wavein_input_win.h b/media/audio/win/wavein_input_win.h
new file mode 100644
index 0000000000000..8ec6aaad6725c
--- /dev/null
+++ b/media/audio/win/wavein_input_win.h
@@ -0,0 +1,141 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
+#define MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
+
+#include <windows.h>
+#include <mmsystem.h>
+#include <stdint.h>
+
+#include <memory>
+#include <string>
+
+#include "base/compiler_specific.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/thread_checker.h"
+#include "base/win/scoped_handle.h"
+#include "media/audio/audio_io.h"
+#include "media/audio/audio_manager_base.h"
+#include "media/base/audio_parameters.h"
+
+// Put this in the declarations for a class to be uncopyable and unassignable.
+
+
+namespace media {
+
+class AudioBus;
+class AudioManagerWin;
+
+class PCMWaveInAudioInputStream : public  AudioInputStream {
+ public:
+  // The ctor takes all the usual parameters, plus |manager| which is the
+  // the audio manager who is creating this object and |device_id| which
+  // is provided by the operating system.
+  PCMWaveInAudioInputStream(AudioManagerWin* manager,
+                            const AudioParameters& params,
+                            int num_buffers,
+                            const std::string& device_id);
+  ~PCMWaveInAudioInputStream() override;
+
+  // Implementation of AudioInputStream.
+  OpenOutcome Open() override;
+  void Start(AudioInputCallback* callback) override;
+  void Stop() override;
+  void Close() override;
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  double GetMaxVolume() override;
+  void SetVolume(double volume) override;
+  double GetVolume() override;
+  bool SetAutomaticGainControl(bool enabled) override;
+  bool GetAutomaticGainControl() override;
+  bool IsMuted() override;
+  void SetOutputDeviceForAec(const std::string& output_device_id) override;
+
+ private:
+  enum State {
+    kStateEmpty,      // Initial state.
+    kStateReady,      // Device obtained and ready to record.
+    kStateRecording,  // Recording audio.
+    kStateStopping,   // Trying to stop, waiting for callback to finish.
+    kStateStopped,    // Stopped. Device was reset.
+    kStateClosed      // Device has been released.
+  };
+
+  // Allow unit tests to query the device ID.
+  friend class AudioManagerTest;
+
+  // Windows calls us back with the recorded audio data here. See msdn
+  // documentation for 'waveInProc' for details about the parameters.
+  static void CALLBACK WaveCallback(HWAVEIN hwi, UINT msg, DWORD_PTR instance,
+                                    DWORD_PTR param1, DWORD_PTR param2);
+
+  // If windows reports an error this function handles it and passes it to
+  // the attached AudioInputCallback::OnError().
+  void HandleError(MMRESULT error);
+
+  // Allocates and prepares the memory that will be used for recording.
+  void SetupBuffers();
+
+  // Deallocates the memory allocated in SetupBuffers.
+  void FreeBuffers();
+
+  // Sends a buffer to the audio driver for recording.
+  void QueueNextPacket(WAVEHDR* buffer);
+
+  // Converts the stored device id string into an unsigned integer which
+  // can be used by waveInOpen() to open the specified capture device.
+  bool GetDeviceId(UINT* device_index);
+
+  base::ThreadChecker thread_checker_;
+
+  // Reader beware. Visual C has stronger guarantees on volatile vars than
+  // most people expect. In fact, it has release semantics on write and
+  // acquire semantics on reads. See the msdn documentation.
+  volatile State state_;
+
+  // The audio manager that created this input stream. We notify it when
+  // we close so it can release its own resources.
+  AudioManagerWin* manager_;
+
+  // We use the callback mostly to periodically give the recorded audio data.
+  AudioInputCallback* callback_;
+
+  // The number of buffers of size |buffer_size_| each to use.
+  const int num_buffers_;
+
+  // The size in bytes of each audio buffer.
+  uint32_t buffer_size_;
+
+  // Channels, 1 or 2.
+  const int channels_;
+
+  // Contains the unique name of the selected endpoint device.
+  // Note that AudioDeviceDescription::kDefaultDeviceId represents the default
+  // device role and is not a valid ID as such.
+  std::string device_id_;
+
+  // Windows native structure to encode the format parameters.
+  WAVEFORMATEX format_;
+
+  // Handle to the instance of the wave device.
+  HWAVEIN wavein_;
+
+  // Pointer to the first allocated audio buffer. This object owns it.
+  WAVEHDR* buffer_;
+
+  // An event that is signaled when the callback thread is ready to stop.
+  base::win::ScopedHandle stopped_event_;
+
+  // Lock used to avoid conflicts when Stop() is called during a callback.
+  base::Lock lock_;
+
+  // Extra audio bus used for storage of deinterleaved data for the OnData
+  // callback.
+  std::unique_ptr<media::AudioBus> audio_bus_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
\ No newline at end of file
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/media/capture/video/win/video_capture_device_factory_win.cc
index f38fb0b766ab5..2221294f35c7b 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/media/capture/video/win/video_capture_device_factory_win.cc
@@ -302,6 +302,16 @@ bool DevicesInfoContainsDeviceId(const DevicesInfo& devices_info,
                         });
 }
 
+bool IsEnclosureLocationSupported() {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
+  return true;
+}
+
 // Returns a non DirectShow descriptor DevicesInfo with the provided name and
 // model.
 DevicesInfo::const_iterator FindNonDirectShowDeviceInfoByNameAndModel(
@@ -629,17 +639,23 @@ void VideoCaptureDeviceFactoryWin::GetDevicesInfo(
     devices_info = GetDevicesInfoDirectShow(devices_info);
   }
 
-  com_thread_.init_com_with_mta(true);
-  com_thread_.Start();
-  com_thread_data_ =
+  if (IsEnclosureLocationSupported()) {
+   com_thread_.init_com_with_mta(true);
+   com_thread_.Start();
+   com_thread_data_ =
       base::MakeRefCounted<VideoCaptureDeviceFactoryWin::ComThreadData>(
           weak_ptr_factory_.GetWeakPtr(), com_thread_.task_runner(),
           base::SingleThreadTaskRunner::GetCurrentDefault());
-  com_thread_.task_runner()->PostTask(
+   com_thread_.task_runner()->PostTask(
       FROM_HERE,
       base::BindOnce(
           &VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP,
           com_thread_data_, std::move(devices_info), std::move(callback)));
+
+  } else {
+    DeviceInfoReady(std::move(devices_info), std::move(callback));
+  }
+
 }
 
 void VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP(
diff --git a/media/cdm/win/media_foundation_cdm_module.cc b/media/cdm/win/media_foundation_cdm_module.cc
index 28fbd5d233a83..963314b8c0452 100644
--- a/media/cdm/win/media_foundation_cdm_module.cc
+++ b/media/cdm/win/media_foundation_cdm_module.cc
@@ -129,6 +129,10 @@ HRESULT MediaFoundationCdmModule::ActivateCdmFactory() {
     return kErrorLoadLibrary;
   }
 
+  // Initialization required to call base::win::ScopedHString::Create();
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Get function pointer to the activation factory.
   using GetActivationFactoryFunc =
       HRESULT(WINAPI*)(_In_ HSTRING activatible_class_id,
diff --git a/media/midi/midi_manager_winrt.cc b/media/midi/midi_manager_winrt.cc
index d5ce6175bffbf..5ee947135e9ee 100644
--- a/media/midi/midi_manager_winrt.cc
+++ b/media/midi/midi_manager_winrt.cc
@@ -822,6 +822,17 @@ void MidiManagerWinrt::InitializeOnComRunner() {
 
   DCHECK(service()->task_service()->IsOnTaskRunner(kComTaskRunner));
 
+  bool preload_success = base::win::ResolveCoreWinRTDelayload() &&
+                         ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!preload_success) {
+    service()->task_service()->PostBoundTask(
+        kDefaultTaskRunner,
+        base::BindOnce(&MidiManagerWinrt::CompleteInitialization,
+                       base::Unretained(this), Result::INITIALIZATION_ERROR));
+    return;
+  }
+
   port_manager_in_ = std::make_unique<MidiInPortManager>(this);
   port_manager_out_ = std::make_unique<MidiOutPortManager>(this);
 
diff --git a/media/renderers/win/media_foundation_protection_manager.cc b/media/renderers/win/media_foundation_protection_manager.cc
index cd4b85d979afa..cd27c6f07fd86 100644
--- a/media/renderers/win/media_foundation_protection_manager.cc
+++ b/media/renderers/win/media_foundation_protection_manager.cc
@@ -37,6 +37,9 @@ HRESULT MediaFoundationProtectionManager::RuntimeClassInitialize(
   task_runner_ = std::move(task_runner);
   waiting_cb_ = std::move(waiting_cb);
 
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Init an empty |property_set_| as MFMediaEngine could access it via
   // |get_Properties| before we populate it within SetPMPServer.
   base::win::ScopedHString property_set_id = base::win::ScopedHString::Create(
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
index da19df4f20b5d..ba05f58ae6762 100644
--- a/mojo/core/embedder/embedder.cc
+++ b/mojo/core/embedder/embedder.cc
@@ -28,6 +28,10 @@
 #include "mojo/core/node_controller.h"
 #include "mojo/public/c/system/thunks.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif // BUILDFLAG(IS_WIN)
+
 #if !BUILDFLAG(IS_NACL)
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
 #include "mojo/core/channel_linux.h"
@@ -86,7 +90,20 @@ void InitFeatures() {
 }
 
 void EnableMojoIpcz() {
-  g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+#if BUILDFLAG(IS_WIN)
+  // TODO(https://crbug.com/1299283): Sandboxed processes on Windows versions
+  // older than 8.1 require some extra (not yet implemented... err... never implemented) setup for ipcz to
+  // work properly. This is omitted for early experimentation.
+  const bool kIsIpczSupported =
+      base::win::GetVersion() >= base::win::Version::WIN8_1;
+#else
+  const bool kIsIpczSupported = true;
+#endif
+  if (kIsIpczSupported) {
+    g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+  }
+  else
+    g_mojo_ipcz_enabled.store(false, std::memory_order_release);
 }
 
 void Init(const Configuration& configuration) {
diff --git a/net/proxy_resolution/win/winhttp_status.h b/net/proxy_resolution/win/winhttp_status.h
index ae5f9ee08ba6a..975d714dab343 100644
--- a/net/proxy_resolution/win/winhttp_status.h
+++ b/net/proxy_resolution/win/winhttp_status.h
@@ -19,6 +19,9 @@ enum class WinHttpStatus {
   // Aborted by caller.
   kAborted,
 
+  // WinHttp binary failed to load.
+  kFunctionsNotLoaded,
+
   // WinHttpOpen() API failed.
   kWinHttpOpenFailed,
 
diff --git a/sandbox/policy/win/sandbox_warmup.cc b/sandbox/policy/win/sandbox_warmup.cc
index 1c5142a49ceb7..fa36708b609a6 100644
--- a/sandbox/policy/win/sandbox_warmup.cc
+++ b/sandbox/policy/win/sandbox_warmup.cc
@@ -18,48 +18,16 @@
 #include <NTSecAPI.h>
 #undef SystemFunction036
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace sandbox::policy {
 
-namespace {
-
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
-}  // namespace
-
 void WarmupRandomnessInfrastructure() {
   BYTE data[1];
-
-  if (base::FeatureList::IsEnabled(
-          sandbox::policy::features::kWinSboxWarmupProcessPrng)) {
-    // TODO(crbug.com/74242) Call a warmup function exposed by boringssl.
-    static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-    BOOL success = process_prng_fn(data, sizeof(data));
-    // ProcessPrng is documented to always return TRUE.
-    CHECK(success);
-  } else {
     // This loads advapi!SystemFunction036 which is forwarded to
     // cryptbase!SystemFunction036. This allows boringsll and Chrome to call
     // RtlGenRandom from within the sandbox. This has the unfortunate side
     // effect of opening a handle to \\Device\KsecDD which we will later close
     // in processes that do not need this.
     RtlGenRandom(data, sizeof(data));
-  }
 }
 
 }  // namespace sandbox::policy
diff --git a/sandbox/policy/win/sandbox_win.cc b/sandbox/policy/win/sandbox_win.cc
index fc31388dc3232..ed7dd8748b5a8 100644
--- a/sandbox/policy/win/sandbox_win.cc
+++ b/sandbox/policy/win/sandbox_win.cc
@@ -63,6 +63,7 @@
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace sandbox {
 namespace policy {
@@ -180,19 +181,20 @@ bool AddWindowsFontsDir(TargetConfig* config) {
   if (!base::PathService::Get(base::DIR_WINDOWS_FONTS, &directory)) {
     return false;
   }
-
-  ResultCode result =
-      config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
-                      directory.value().c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
-  std::wstring directory_str = directory.value() + L"\\*";
-  result = config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
-                           directory_str.c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
+
+  if (gfx::win::ShouldUseDirectWrite()) {
+	  ResultCode result =
+		  config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
+						  directory.value().c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+
+	  std::wstring directory_str = directory.value() + L"\\*";
+	  result = config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
+							   directory_str.c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+  }
   return true;
 }
 #endif  // !defined(NACL_WIN64)
@@ -260,6 +262,7 @@ std::wstring PrependWindowsSessionPath(const wchar_t* object) {
       {L"\\Sessions\\", base::NumberToWString(s_session_id), object});
 }
 
+
 // Adds the generic config rules to a sandbox TargetConfig.
 ResultCode AddGenericConfig(sandbox::TargetConfig* config) {
   DCHECK(!config->IsConfigured());
@@ -329,7 +332,9 @@ ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
 
   config->SetLockdownDefaultDacl();
 
-  result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  // Win8+ adds a device DeviceApi that we don't need.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
   if (result != SBOX_ALL_OK)
     return result;
 
@@ -580,6 +585,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
       MITIGATION_SEHOP | MITIGATION_NONSYSTEM_FONT_DISABLE |
       MITIGATION_IMAGE_LOAD_NO_REMOTE | MITIGATION_IMAGE_LOAD_NO_LOW_LABEL |
       MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION | MITIGATION_KTM_COMPONENT;
+
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      mitigations &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
 
   // CET is enabled with the CETCOMPAT bit on chrome.exe so must be
   // disabled for processes we know are not compatible.
@@ -623,10 +634,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
         return result;
       }
     }
-    result = SandboxWin::AddWin32kLockdownPolicy(config);
-    if (result != SBOX_ALL_OK) {
-      return result;
-    }
+  if (gfx::win::ShouldUseDirectWrite()) {
+     result = SandboxWin::AddWin32kLockdownPolicy(config);
+     if (result != SBOX_ALL_OK) {
+       return result;
+     }
+  }
   }
 
   if (!delegate->DisableDefaultPolicy()) {
@@ -731,12 +744,18 @@ ResultCode LaunchWithoutSandbox(
   // on process shutdown, in which case TerminateProcess can fail. See
   // https://crbug.com/820996.
   if (delegate->ShouldUnsandboxedRunInJob()) {
+    BOOL in_job = true;
+    // Prior to Windows 8 nested jobs aren't possible.
+    if (base::win::GetVersion() >= base::win::Version::WIN8 ||
+        (::IsProcessInJob(::GetCurrentProcess(), nullptr, &in_job) &&
+         !in_job)) {
     static base::NoDestructor<base::win::ScopedHandle> job_object(
         CreateUnsandboxedJob());
     if (!job_object->is_valid()) {
       return SBOX_ERROR_CANNOT_INIT_JOB;
     }
     options.job_handle = job_object->get();
+    }
   }
 
   // Chromium binaries are marked as CET Compatible but some processes
@@ -827,6 +846,10 @@ ResultCode SandboxWin::AddAppContainerPolicy(TargetConfig* config,
 ResultCode SandboxWin::AddWin32kLockdownPolicy(TargetConfig* config) {
   DCHECK(!config->IsConfigured());
 #if !defined(NACL_WIN64)
+  // Win32k Lockdown is supported on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return SBOX_ALL_OK;
+
   MitigationFlags flags = config->GetProcessMitigations();
   // Check not enabling twice. Should not happen.
   DCHECK_EQ(0U, flags & MITIGATION_WIN32K_DISABLE);
diff --git a/sandbox/win/src/app_container_base.cc b/sandbox/win/src/app_container_base.cc
index 37cc8fa8f8996..d966f133f185b 100644
--- a/sandbox/win/src/app_container_base.cc
+++ b/sandbox/win/src/app_container_base.cc
@@ -20,6 +20,18 @@ namespace sandbox {
 
 namespace {
 
+typedef decltype(::CreateAppContainerProfile) CreateAppContainerProfileFunc;
+
+typedef decltype(::DeriveAppContainerSidFromAppContainerName)
+    DeriveAppContainerSidFromAppContainerNameFunc;
+
+typedef decltype(::DeleteAppContainerProfile) DeleteAppContainerProfileFunc;
+
+typedef decltype(::GetAppContainerFolderPath) GetAppContainerFolderPathFunc;
+
+typedef decltype(
+    ::GetAppContainerRegistryLocation) GetAppContainerRegistryLocationFunc;
+
 struct FreeSidDeleter {
   inline void operator()(void* ptr) const { ::FreeSid(ptr); }
 };
@@ -30,8 +42,14 @@ struct FreeSidDeleter {
 AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
                                                   const wchar_t* display_name,
                                                   const wchar_t* description) {
-  PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::CreateAppContainerProfile(
+  static auto create_app_container_profile =
+      reinterpret_cast<CreateAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "CreateAppContainerProfile"));
+  if (!create_app_container_profile)
+    return nullptr;
+
+ PSID package_sid_ptr = nullptr;
+  HRESULT hr = create_app_container_profile(
       package_name, display_name, description, nullptr, 0, &package_sid_ptr);
   if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
     return Open(package_name);
@@ -47,9 +65,15 @@ AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
 
 // static
 AppContainerBase* AppContainerBase::Open(const wchar_t* package_name) {
+  static auto derive_app_container_sid =
+      reinterpret_cast<DeriveAppContainerSidFromAppContainerNameFunc*>(
+          GetProcAddress(GetModuleHandle(L"userenv"),
+                         "DeriveAppContainerSidFromAppContainerName"));
+  if (!derive_app_container_sid)
+    return nullptr;
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::DeriveAppContainerSidFromAppContainerName(package_name,
-                                                           &package_sid_ptr);
+  HRESULT hr = derive_app_container_sid(package_name, &package_sid_ptr);
   if (FAILED(hr))
     return nullptr;
 
@@ -71,7 +95,13 @@ AppContainerBase* AppContainerBase::CreateLowbox(const wchar_t* sid) {
 
 // static
 bool AppContainerBase::Delete(const wchar_t* package_name) {
-  return SUCCEEDED(::DeleteAppContainerProfile(package_name));
+  static auto delete_app_container_profile =
+      reinterpret_cast<DeleteAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "DeleteAppContainerProfile"));
+  if (!delete_app_container_profile)
+    return false;
+
+  return SUCCEEDED(delete_app_container_profile(package_name));
 }
 
 AppContainerBase::AppContainerBase(base::win::Sid& package_sid,
diff --git a/sandbox/win/src/broker_services.cc b/sandbox/win/src/broker_services.cc
index 9dfe4b3d8ba21..62ca137396f14 100644
--- a/sandbox/win/src/broker_services.cc
+++ b/sandbox/win/src/broker_services.cc
@@ -451,7 +451,11 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   if (container)
     startup_info->SetAppContainer(container);
 
-  startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  // On Win10, jobs are associated via startup_info.
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      policy_base->HasJob()) {
+    startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  }
 
   if (!startup_info->BuildStartupInformation())
     return SBOX_ERROR_PROC_THREAD_ATTRIBUTES;
diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index 11f19502adc0f..0c922b0599314 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
@@ -149,8 +150,11 @@ bool HandleCloserAgent::CloseHandles() {
     return true;
 
   absl::optional<ProcessHandleMap> handle_map = GetCurrentProcessHandles();
-  if (!handle_map)
-    return false;
+  // Fallback for pre-Windows 8.1.
+  if (!handle_map) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN8_1);
+    handle_map = GetCurrentProcessHandlesWin7();
+  }
 
   for (const HandleMap::value_type& handle_to_close : handles_to_close_) {
     ProcessHandleMap::iterator result = handle_map->find(handle_to_close.first);
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index f9f4f061aeec0..cbe8f418de703 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -19,6 +19,7 @@
 #include "base/rand_util.h"
 #include "base/scoped_native_library.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
@@ -422,12 +423,45 @@ ResultCode InterceptionManager::PatchClientFunctions(
     DllInterceptionData* dll_data) {
   DCHECK(thunks);
   DCHECK(dll_data);
 
   HMODULE ntdll_base = ::GetModuleHandle(kNtdllName);
   if (!ntdll_base)
     return SBOX_ERROR_NO_HANDLE;
 
-  ServiceResolverThunk thunk(child_->Process(), /*relaxed=*/true);
+  std::unique_ptr<ServiceResolverThunk> thunk;
+#if defined(_WIN64)
+  thunk = std::make_unique<ServiceResolverThunk>(child_->Process(), true);
+#else
+  DWORD base_code = 0;
+  DWORD bytes_read = 0;
+
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  base::win::Version real_os_version = os_info->Kernel32Version();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (real_os_version >= base::win::Version::WIN10)
+      thunk.reset(new Wow64W10ResolverThunk(child_->Process(), true));
+    else if (real_os_version >= base::win::Version::WIN8)
+      thunk.reset(new Wow64W8ResolverThunk(child_->Process(), true));
+    else {
+      thunk.reset(new Wow64ResolverThunk(child_->Process(), true));
+	  if(!::ReadProcessMemory(child_->Process(), ntdll_base, &base_code,
+			sizeof(base_code), &bytes_read)) {
+				if(::GetLastError() == ERROR_PARTIAL_COPY) {
+					::ResumeThread(child_->MainThread());
+					while(!::ReadProcessMemory(child_->Process(), ntdll_base, &base_code,
+						sizeof(base_code), &bytes_read)) {
+						;
+					}
+					::SuspendThread(child_->MainThread());
+					}
+			}
+	}
+  } else if (real_os_version >= base::win::Version::WIN8) {
+    thunk.reset(new Win8ResolverThunk(child_->Process(), true));
+  } else {
+    thunk.reset(new ServiceResolverThunk(child_->Process(), true));
+  }
+#endif
 
   for (auto interception : interceptions_) {
     const std::wstring ntdll(kNtdllName);
@@ -437,7 +471,7 @@ ResultCode InterceptionManager::PatchClientFunctions(
     if (INTERCEPTION_SERVICE_CALL != interception.type)
       return SBOX_ERROR_BAD_PARAMS;
 
-    NTSTATUS ret = thunk.Setup(
+    NTSTATUS ret = thunk->Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
         &thunks->thunks[dll_data->num_thunks],
diff --git a/sandbox/win/src/job.cc b/sandbox/win/src/job.cc
index 2dc76c19df5ba..f28b5bc5c00f3 100644
--- a/sandbox/win/src/job.cc
+++ b/sandbox/win/src/job.cc
@@ -9,21 +9,24 @@
 #include <stddef.h>
 #include <utility>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/restricted_token.h"
 
 namespace sandbox {
 
-Job::Job() = default;
-Job::~Job() = default;
+Job::Job() : job_handle_(nullptr) {}
+
+Job::~Job() {}
 
 DWORD Job::Init(JobLevel security_level,
                 DWORD ui_exceptions,
                 size_t memory_limit) {
-  if (job_handle_.is_valid())
+  if (job_handle_.IsValid())
     return ERROR_ALREADY_INITIALIZED;
 
-  job_handle_.Set(::CreateJobObject(nullptr, nullptr));
-  if (!job_handle_.is_valid())
+  job_handle_.Set(::CreateJobObject(nullptr,  // No security attribute
+                                    nullptr));
+  if (!job_handle_.IsValid())
     return ::GetLastError();
 
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
@@ -64,6 +67,9 @@ DWORD Job::Init(JobLevel security_level,
           JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
       break;
     }
+    case JobLevel::kNone: {
+      return ERROR_BAD_ARGUMENTS;
+    }
   }
 
   if (!::SetInformationJobObject(job_handle_.Get(),
@@ -83,20 +89,42 @@ DWORD Job::Init(JobLevel security_level,
 }
 
 bool Job::IsValid() {
-  return job_handle_.is_valid();
+  return job_handle_.IsValid();
 }
 
 HANDLE Job::GetHandle() {
-  return job_handle_.get();
+  return job_handle_.Get();
+}
+
+DWORD Job::UserHandleGrantAccess(HANDLE handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::UserHandleGrantAccess(handle, job_handle_.Get(),
+                               true)) {  // Access allowed.
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+DWORD Job::AssignProcessToJob(HANDLE process_handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::AssignProcessToJobObject(job_handle_.Get(), process_handle))
+    return ::GetLastError();
+
+  return ERROR_SUCCESS;
 }
 
 DWORD Job::SetActiveProcessLimit(DWORD processes) {
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
 
-  if (!job_handle_.is_valid())
+  if (!job_handle_.IsValid())
     return ERROR_NO_DATA;
 
-  if (!::QueryInformationJobObject(job_handle_.get(),
+  if (!::QueryInformationJobObject(job_handle_.Get(),
                                    JobObjectExtendedLimitInformation, &jeli,
                                    sizeof(jeli), nullptr)) {
     return ::GetLastError();
@@ -104,7 +132,7 @@ DWORD Job::SetActiveProcessLimit(DWORD processes) {
   jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   jeli.BasicLimitInformation.ActiveProcessLimit = processes;
 
-  if (!::SetInformationJobObject(job_handle_.get(),
+  if (!::SetInformationJobObject(job_handle_.Get(),
                                  JobObjectExtendedLimitInformation, &jeli,
                                  sizeof(jeli))) {
     return ::GetLastError();
diff --git a/sandbox/win/src/job.h b/sandbox/win/src/job.h
index 31037e1b7aff7..a148179e108a5 100644
--- a/sandbox/win/src/job.h
+++ b/sandbox/win/src/job.h
@@ -15,7 +15,8 @@ enum class JobLevel;
 // Handles the creation of job objects based on a security profile.
 // Sample usage:
 //   Job job;
-//   job.Init(JobLevel::kLockdown, 0, 0);
+//   job.Init(JobLevel::kLockdown, nullptr);  //no job name
+//   job.AssignProcessToJob(process_handle);
 class Job {
  public:
   Job();
@@ -27,6 +28,7 @@ class Job {
 
   // Initializes and creates the job object. The security of the job is based
   // on the security_level parameter.
+  // job_name can be nullptr if the job is unnamed.
   // If the chosen profile has too many ui restrictions, you can disable some
   // by specifying them in the ui_exceptions parameters.
   // If the function succeeds, the return value is ERROR_SUCCESS. If the
@@ -34,6 +36,19 @@ class Job {
   // the error.
   DWORD Init(JobLevel security_level, DWORD ui_exceptions, size_t memory_limit);
 
+  // Assigns the process referenced by process_handle to the job.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD AssignProcessToJob(HANDLE process_handle);
+
+  // Grants access to "handle" to the job. All processes in the job can
+  // subsequently recognize and use the handle.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD UserHandleGrantAccess(HANDLE handle);
+
   // True if the job has been initialized and has a valid handle.
   bool IsValid();
 
diff --git a/sandbox/win/src/nt_internals.h b/sandbox/win/src/nt_internals.h
index 72d96b96f4fd4..c3dedf262abcf 100644
--- a/sandbox/win/src/nt_internals.h
+++ b/sandbox/win/src/nt_internals.h
@@ -162,7 +162,13 @@ typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN PVOID ThreadInformation,
     IN ULONG ThreadInformationLength);
 
+typedef struct _PROCESS_ACCESS_TOKEN {
+  HANDLE token;
+  HANDLE thread;
+} PROCESS_ACCESS_TOKEN;
+
 // Partial definition only for values not in PROCESS_INFO_CLASS.
+constexpr auto ProcessInformationAccessToken = static_cast<PROCESSINFOCLASS>(9);
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
 constexpr auto ProcessHandleTable = static_cast<PROCESSINFOCLASS>(58);
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 79ca46ee037be..e1d295ee2717f 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -24,6 +24,7 @@
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/win_utils.h"
+#include "ui/gfx/win/direct_write.h"
 
 // These are missing in 10.0.19551.0 but are in 10.0.19041.0 and 10.0.20226.0.
 #ifndef PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_STRICT_MODE
@@ -44,22 +45,39 @@ namespace sandbox {
 
 namespace {
 
+// API defined in libloaderapi.h >= Win8. Also available in Vista/7 starting with KB2533623.
+// Known to be buggy on Vista, but not known to affect Chromium.
+using SetDefaultDllDirectoriesFunction = decltype(&SetDefaultDllDirectories);
+
+// APIs defined in processthreadsapi.h >= Win8.
+using SetProcessMitigationPolicyFunction =
+    decltype(&SetProcessMitigationPolicy);
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+using SetThreadInformationFunction = decltype(&SetThreadInformation);
+
 // Returns a two-element array of mitigation flags supported on this machine.
 const ULONG64* GetSupportedMitigations() {
   static ULONG64 mitigations[2] = {};
 
   // This static variable will only be initialized once.
   if (!mitigations[0] && !mitigations[1]) {
-    // NOTE: the two-element-sized input array is only supported on >= Win10
-    // RS2. If an earlier version, the second element will be left 0.
-    size_t mits_size =
-        (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
-            ? (sizeof(mitigations[0]) * 2)
-            : sizeof(mitigations[0]);
-    if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                      ProcessMitigationOptionsMask,
-                                      &mitigations, mits_size)) {
-      NOTREACHED();
+    GetProcessMitigationPolicyFunction get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+            ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (get_process_mitigation_policy) {
+      // NOTE: the two-element-sized input array is only supported on >= Win10
+      // RS2.
+      //       If an earlier version, the second element will be left 0.
+      size_t mits_size =
+          (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
+              ? (sizeof(mitigations[0]) * 2)
+              : sizeof(mitigations[0]);
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessMitigationOptionsMask,
+                                         &mitigations, mits_size)) {
+        NOTREACHED();
+      }
     }
   }
 
@@ -83,7 +101,14 @@ bool IsRunning32bitEmulatedOnArm64() {
 bool SetProcessMitigationPolicyInternal(PROCESS_MITIGATION_POLICY policy,
                                         PVOID lpBuffer,
                                         SIZE_T dwLength) {
-  PCHECK(::SetProcessMitigationPolicy(policy, lpBuffer, dwLength))
+  HMODULE module = ::GetModuleHandleA("kernel32.dll");
+  SetProcessMitigationPolicyFunction set_process_mitigation_policy_function =
+      reinterpret_cast<SetProcessMitigationPolicyFunction>(
+          ::GetProcAddress(module, "SetProcessMitigationPolicy"));
+  if (!set_process_mitigation_policy_function)
+    return false;
+
+  PCHECK(set_process_mitigation_policy_function(policy, lpBuffer, dwLength))
       << "SetProcessMitigationPolicy failed with Policy: " << policy;
 
   return true;
@@ -98,22 +123,36 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     return true;
 
   base::win::Version version = base::win::GetVersion();
-
-  if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+
+  #if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite())
+    flags &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_WIN32K_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+ if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+    HMODULE module = ::GetModuleHandleA("kernel32.dll");
+    SetDefaultDllDirectoriesFunction set_default_dll_directories =
+        reinterpret_cast<SetDefaultDllDirectoriesFunction>(
+            ::GetProcAddress(module, "SetDefaultDllDirectories"));
+
+    // Check for SetDefaultDllDirectories since it requires KB2533623.
+    if (set_default_dll_directories) {
 #if defined(COMPONENT_BUILD)
-    const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
+      const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
 #else
-    // In a non-component build, all DLLs will be loaded manually, or via
-    // manifest definition, so these flags can be stronger. This prevents DLL
-    // planting in the application directory.
-    const DWORD directory_flags =
-        LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
+      // In a non-component build, all DLLs will be loaded manually, or via
+      // manifest definition, so these flags can be stronger. This prevents DLL
+      // planting in the application directory.
+      const DWORD directory_flags =
+          LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
 #endif
-    if (!::SetDefaultDllDirectories(directory_flags)) {
-      return false;
-    }
+      if (!set_default_dll_directories(directory_flags)) {
+        return false;
+      }
 
-    applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+      applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+    }
   }
 
   // Set the heap to terminate on corruption
@@ -156,6 +195,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   }
 #endif
 
+  // This is all we can do in Win7 and below.
+  if (version < base::win::Version::WIN8)
+    return true;
+
   // Enable ASLR policies.
   if (flags & MITIGATION_RELOCATE_IMAGE) {
     PROCESS_MITIGATION_ASLR_POLICY policy = {};
@@ -219,6 +262,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_EXTENSION_POINT_DISABLE;
   }
 
+  if (version < base::win::Version::WIN8_1)
+    return true;
+
   // Enable dynamic code policies.
   if (!IsRunning32bitEmulatedOnArm64() &&
       (flags & MITIGATION_DYNAMIC_CODE_DISABLE)) {
@@ -235,6 +281,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
   }
 
+  if (version < base::win::Version::WIN10)
+    return true;
+
   // Enable font policies.
   if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
     PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
@@ -356,9 +405,20 @@ bool ApplyMitigationsToCurrentThread(MitigationFlags flags) {
   if (flags & MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD) {
     DWORD thread_policy = THREAD_DYNAMIC_CODE_ALLOW;
 
+   // NOTE: SetThreadInformation API only exists on >= Win8.  Dynamically
+    //       get function handle.
+    base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+    if (!dll.is_valid())
+      return false;
+    SetThreadInformationFunction set_thread_info_function =
+        reinterpret_cast<SetThreadInformationFunction>(
+            dll.GetFunctionPointer("SetThreadInformation"));
+    if (!set_thread_info_function)
+      return false;
+
     // NOTE: Must use the pseudo-handle here, a thread HANDLE won't work.
-    if (!::SetThreadInformation(::GetCurrentThread(), ThreadDynamicCodePolicy,
-                                &thread_policy, sizeof(thread_policy))) {
+    if (!set_thread_info_function(::GetCurrentThread(), ThreadDynamicCodePolicy,
+                                  &thread_policy, sizeof(thread_policy))) {
       return false;
     }
   }
@@ -379,8 +439,14 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
   *policy_value_1 = 0;
   *policy_value_2 = 0;
 
-#if defined(_WIN64) || defined(_M_IX86)
+#if defined(_WIN64)
   *size = sizeof(*policy_flags);
+#elif defined(_M_IX86)
+  // A 64-bit flags attribute is illegal on 32-bit Win 7.
+  if (version < base::win::Version::WIN8)
+    *size = sizeof(DWORD);
+  else
+    *size = sizeof(*policy_flags);
 #else
 #error This platform is not supported.
 #endif
@@ -398,53 +464,79 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
     *policy_value_1 |= PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE;
 #endif
 
-  if (flags & MITIGATION_RELOCATE_IMAGE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
-    if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+  // Win 7
+  if (version < base::win::Version::WIN8)
+    return;
+
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      *policy_value_1 &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+  // Everything >= Win8, do not return before the end of the function where
+  // the final policy bitmap is sanity checked against what is supported on this
+  // machine.  The API required to do so is only available since Win8.
+
+  // Mitigations >= Win8:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8) {
+    if (flags & MITIGATION_RELOCATE_IMAGE) {
       *policy_value_1 |=
-          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
+      if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+        *policy_value_1 |=
+            PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+      }
     }
-  }
 
-  if (flags & MITIGATION_HEAP_TERMINATE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HEAP_TERMINATE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_BOTTOM_UP_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_BOTTOM_UP_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_WIN32K_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_WIN32K_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+  // Mitigations >= Win8.1:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8_1) {
+    if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+  // Mitigations >= Win10:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN10) {
+    if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+    }
   }
 
   // Mitigations >= Win10 TH2:
@@ -557,6 +649,15 @@ void ConvertProcessMitigationsToComponentFilter(MitigationFlags flags,
 }
 
 MitigationFlags FilterPostStartupProcessMitigations(MitigationFlags flags) {
+  base::win::Version version = base::win::GetVersion();
+
+  // Windows 7.
+  if (version < base::win::Version::WIN8) {
+    return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER |
+                    MITIGATION_HEAP_TERMINATE);
+  }
+
+  // Windows 8 and above.
   return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER);
 }
 
diff --git a/sandbox/win/src/process_mitigations_unittest.cc b/sandbox/win/src/process_mitigations_unittest.cc
index 9db65890caaa0..2ac227bb2bf56 100644
--- a/sandbox/win/src/process_mitigations_unittest.cc
+++ b/sandbox/win/src/process_mitigations_unittest.cc
@@ -51,6 +51,22 @@ typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_2 {
 
 namespace {
 
+//------------------------------------------------------------------------------
+// Internal Defines & Functions
+//------------------------------------------------------------------------------
+
+// API defined in winbase.h.
+using GetProcessDEPPolicyFunction = decltype(&GetProcessDEPPolicy);
+
+// API defined in processthreadsapi.h.
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+GetProcessMitigationPolicyFunction get_process_mitigation_policy;
+
+// APIs defined in wingdi.h.
+using AddFontMemResourceExFunction = decltype(&AddFontMemResourceEx);
+using RemoveFontMemResourceExFunction = decltype(&RemoveFontMemResourceEx);
+
 //------------------------------------------------------------------------------
 // NonSystemFont test helper function.
 //
@@ -104,6 +120,13 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
   if (!test)
     return SBOX_TEST_INVALID_PARAMETER;
 
+  get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
+
   switch (test) {
     //--------------------------------------------------
     // MITIGATION_DEP
@@ -113,8 +136,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
 #if !defined(_WIN64)
       // DEP - always enabled on 64-bit.
       PROCESS_MITIGATION_DEP_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(), ProcessDEPPolicy,
-                                        &policy, sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDEPPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.Enable || !policy.Permanent)
@@ -128,9 +152,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_ASLR): {
       PROCESS_MITIGATION_ASLR_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessASLRPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessASLRPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.EnableForceRelocateImages || !policy.DisallowStrippedImages)
@@ -143,9 +167,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_STRICTHANDLE): {
       PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessStrictHandleCheckPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessStrictHandleCheckPolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.RaiseExceptionOnInvalidHandleReference ||
@@ -160,9 +184,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_WIN32K): {
       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessSystemCallDisablePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessSystemCallDisablePolicy,
+                                         &policy, sizeof(policy)))  {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisallowWin32kSystemCalls)
@@ -179,7 +203,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_EXTENSIONPOINT): {
       PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessExtensionPointDisablePolicy,
                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -194,7 +218,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODE): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -209,7 +233,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_NONSYSFONT): {
       PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessFontDisablePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -224,7 +248,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_MSSIGNED): {
       PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessSignaturePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -239,7 +263,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOREMOTE): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -254,7 +278,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOLOW): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -269,7 +293,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODEOPTOUT): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -284,7 +308,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADPREFERSYS32): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -309,7 +333,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDISABLED): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -325,7 +349,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDYNAMICAPIS): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -348,7 +372,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETSTRICT): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -388,7 +412,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     case (TESTPOLICY_PREANDPOSTSTARTUP): {
       // Both policies should be set now.
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -516,11 +540,18 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
       return SBOX_TEST_SUCCEEDED;
     }
   }
+
+  auto get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
   // Process failed to be created.
   // Note: GetLastError from CreateProcess returns 5, "ERROR_ACCESS_DENIED".
   // Validate the NoChildProcessCreation policy is applied.
   PROCESS_MITIGATION_CHILD_PROCESS_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+  if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                     ProcessChildProcessPolicy, &policy,
                                     sizeof(policy))) {
     return SBOX_TEST_NOT_FOUND;
@@ -893,10 +924,14 @@ TEST(ProcessMitigationsTest, CetDisablePolicy) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -933,10 +968,14 @@ TEST(ProcessMitigationsTest, CetAllowDynamicApis) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -971,10 +1010,14 @@ TEST(ProcessMitigationsTest, CetStrictMode) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
diff --git a/sandbox/win/src/restricted_token.cc b/sandbox/win/src/restricted_token.cc
index ffaa72573e68b..a35234c9b1eef 100644
--- a/sandbox/win/src/restricted_token.cc
+++ b/sandbox/win/src/restricted_token.cc
@@ -16,6 +16,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/win/access_token.h"
 #include "base/win/security_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 
 namespace sandbox {
@@ -184,7 +185,7 @@ absl::optional<base::win::AccessToken> RestrictedToken::CreateRestricted(
     return absl::nullopt;
   }
 
-  if (lockdown_default_dacl_) {
+  if (lockdown_default_dacl_ && base::win::GetVersion() >= base::win::Version::VISTA) {
     // Don't add Restricted sid and also remove logon sid access.
     absl::optional<base::win::Sid> logon_sid = new_token->LogonId();
     if (logon_sid.has_value()) {
@@ -217,7 +218,7 @@ absl::optional<base::win::AccessToken> RestrictedToken::CreateRestricted(
     return absl::nullopt;
   }
 
-  if (integrity_rid_.has_value()) {
+  if (integrity_rid_.has_value() && base::win::GetVersion() >= base::win::Version::VISTA) {
     if (!new_token->SetIntegrityLevel(*integrity_rid_)) {
       return absl::nullopt;
     }
diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
index 050d9d585a622..aa7ab4f0dda32 100644
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -10,8 +10,10 @@
 #include "base/check.h"
 #include "base/notreached.h"
 #include "base/win/access_token.h"
+#include "base/win/scoped_handle.h"
 #include "base/win/security_descriptor.h"
 #include "sandbox/win/src/acl.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/security_level.h"
diff --git a/sandbox/win/src/sandbox_policy_diagnostic.cc b/sandbox/win/src/sandbox_policy_diagnostic.cc
index 34bf5f551d783..6139c2e6d6793 100644
--- a/sandbox/win/src/sandbox_policy_diagnostic.cc
+++ b/sandbox/win/src/sandbox_policy_diagnostic.cc
@@ -83,6 +83,8 @@ std::string GetJobLevelInEnglish(JobLevel job) {
       return "Interactive";
     case JobLevel::kUnprotected:
       return "Unprotected";
+    case JobLevel::kNone:
+      return "None";
   }
 }
 
diff --git a/sandbox/win/src/security_level.h b/sandbox/win/src/security_level.h
index 288d2baea917c..8c3c6b25ad2b0 100644
--- a/sandbox/win/src/security_level.h
+++ b/sandbox/win/src/security_level.h
@@ -95,6 +95,9 @@ enum TokenLevel {
 //  JobLevel        |General                            |Quota               |
 //                  |restrictions                       |restrictions        |
 // -----------------|---------------------------------- |--------------------|
+// kNone            | No job is assigned to the         | None               |
+//                  | sandboxed process.                |                    |
+// -----------------|---------------------------------- |--------------------|
 // kUnprotected     | None                              | *Kill on Job close.|
 // -----------------|---------------------------------- |--------------------|
 // kInteractive     | *Forbid system-wide changes using |                    |
@@ -120,7 +123,7 @@ enum TokenLevel {
 // In the context of the above table, 'user handles' refers to the handles of
 // windows, bitmaps, menus, etc. Files, treads and registry handles are kernel
 // handles and are not affected by the job level settings.
-enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected };
+enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected,  kNone };
 
 // These flags correspond to various process-level mitigations (eg. ASLR and
 // DEP). Most are implemented via UpdateProcThreadAttribute() plus flags for
diff --git a/sandbox/win/src/service_resolver.h b/sandbox/win/src/service_resolver.h
index dc74bd6e52539..97f828e3feeb0 100644
--- a/sandbox/win/src/service_resolver.h
+++ b/sandbox/win/src/service_resolver.h
@@ -53,23 +53,18 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   size_t GetThunkSize() const override;
 
   // Call this to set up ntdll_base_ which will allow for local patches.
-  void AllowLocalPatches();
+  virtual void AllowLocalPatches();
 
   // Verifies that the function specified by |target_name| in |target_module| is
   // a service and copies the data from that function into |thunk_storage|. If
   // |storage_bytes| is too small, then the method fails.
-  NTSTATUS CopyThunk(const void* target_module,
-                     const char* target_name,
-                     BYTE* thunk_storage,
-                     size_t storage_bytes,
-                     size_t* storage_used);
+  virtual NTSTATUS CopyThunk(const void* target_module,
+                             const char* target_name,
+                             BYTE* thunk_storage,
+                             size_t storage_bytes,
+                             size_t* storage_used);
 
-  // Checks if a target was patched correctly for a jump. This is only for use
-  // in testing in 32-bit builds. Will always return true on 64-bit builds. Set
-  // |thunk_storage| to the same pointer passed to Setup().
-  bool VerifyJumpTargetForTesting(void* thunk_storage) const;
-
- private:
+ protected:
   // The unit test will use this member to allow local patch on a buffer.
   HMODULE ntdll_base_;
 
@@ -87,15 +82,15 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   // Returns true if the code pointer by target_ corresponds to the expected
   // type of function. Saves that code on the first part of the thunk pointed
   // by local_thunk (should be directly accessible from the parent).
-  bool IsFunctionAService(void* local_thunk) const;
+  virtual bool IsFunctionAService(void* local_thunk) const;
 
   // Performs the actual patch of target_.
   // local_thunk must be already fully initialized, and the first part must
   // contain the original code. The real type of this buffer is ServiceFullThunk
   // (yes, private). remote_thunk (real type ServiceFullThunk), must be
   // allocated on the child, and will contain the thunk data, after this call.
-  // Returns the appropriate status code.
-  NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
+  // Returns the apropriate status code.
+  virtual NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
 
   // Provides basically the same functionality as IsFunctionAService but it
   // continues even if it does not recognize the function code. remote_thunk
@@ -107,6 +102,74 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   ULONG relative_jump_;
 };
 
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).
+class Wow64ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64ResolverThunk(const Wow64ResolverThunk&) = delete;
+  Wow64ResolverThunk& operator=(const Wow64ResolverThunk&) = delete;
+
+  ~Wow64ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 8.
+class Wow64W8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W8ResolverThunk(const Wow64W8ResolverThunk&) = delete;
+  Wow64W8ResolverThunk& operator=(const Wow64W8ResolverThunk&) = delete;
+
+  ~Wow64W8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on Windows 8.
+class Win8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Win8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Win8ResolverThunk(const Win8ResolverThunk&) = delete;
+  Win8ResolverThunk& operator=(const Win8ResolverThunk&) = delete;
+
+  ~Win8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 10.
+class Wow64W10ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W10ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W10ResolverThunk(const Wow64W10ResolverThunk&) = delete;
+  Wow64W10ResolverThunk& operator=(const Wow64W10ResolverThunk&) = delete;
+
+  ~Wow64W10ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_SERVICE_RESOLVER_H_
diff --git a/sandbox/win/src/service_resolver_32.cc b/sandbox/win/src/service_resolver_32.cc
index cb43a3d053a74..dcf787f76f033 100644
--- a/sandbox/win/src/service_resolver_32.cc
+++ b/sandbox/win/src/service_resolver_32.cc
@@ -20,16 +20,43 @@ namespace {
 const BYTE kMovEax = 0xB8;
 const BYTE kMovEdx = 0xBA;
 const USHORT kMovEdxEsp = 0xD48B;
+const USHORT kCallPtrEdx = 0x12FF;
 const USHORT kCallEdx = 0xD2FF;
 const BYTE kCallEip = 0xE8;
 const BYTE kRet = 0xC2;
 const BYTE kRet2 = 0xC3;
 const USHORT kJmpEdx = 0xE2FF;
+const USHORT kXorEcx = 0xC933;
+const ULONG kLeaEdx = 0x0424548D;
+const ULONG kCallFs1 = 0xC015FF64;
+const USHORT kCallFs2 = 0;
+const BYTE kCallFs3 = 0;
+const BYTE kAddEsp1 = 0x83;
+const USHORT kAddEsp2 = 0x4C4;
 const BYTE kJmp32 = 0xE9;
 const USHORT kSysenter = 0x340F;
 
-// Service code for 32 bit Windows. Introduced in Windows 8.
-struct ServiceEntry32 {
+// Service code for 32 bit systems.
+// NOTE: on win2003 "call dword ptr [edx]" is "call edx".
+struct ServiceEntry {
+  // This struct contains roughly the following code:
+  // 00 mov     eax,25h
+  // 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
+  // 0a call    dword ptr [edx]
+  // 0c ret     2Ch
+  // 0f nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  BYTE mov_edx;         // = BA
+  ULONG stub;
+  USHORT call_ptr_edx;  // = FF 12
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for 32 bit Windows 8.
+struct ServiceEntryW8 {
   // This struct contains the following code:
   // 00 b825000000      mov     eax,25h
   // 05 e803000000      call    eip+3
@@ -50,13 +77,60 @@ struct ServiceEntry32 {
   USHORT nop;
 };
 
-// Service code for a 32 bit process under Wow64. Introduced in Windows 10.
-// Also used for the patching process.
-struct ServiceEntryWow64 {
+// Service code for a 32 bit process running on a 64 bit os.
+struct Wow64Entry {
+  // This struct may contain one of two versions of code:
+  // 1. For XP, Vista and 2K3:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 c22c00          ret     2Ch
+  //
+  // 2. For Windows 7:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 83c404          add     esp, 4
+  // 15 c22c00          ret     2Ch
+  //
+  // So we base the structure on the bigger one:
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  USHORT xor_ecx;       // = 33 C9
+  ULONG lea_edx;        // = 8D 54 24 04
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE add_esp1;        // = 83             or ret
+  USHORT add_esp2;      // = C4 04          or num_params
+  BYTE ret;             // = C2
+  USHORT num_params;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 8.
+struct Wow64EntryW8 {
+  // 00 b825000000      mov     eax, 25h
+  // 05 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 0b c22c00          ret     2Ch
+  // 0f 90              nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 10.
+struct Wow64EntryW10 {
   // 00 b828000000      mov     eax, 28h
   // 05 bab0d54877      mov     edx, 7748D5B0h
   // 09 ffd2            call    edx
-  // 0c c22800          ret     28h
+  // 0b c22800          ret     28h
   BYTE mov_eax;         // = B8
   ULONG service_id;
   BYTE mov_edx;         // = BA
@@ -64,86 +138,27 @@ struct ServiceEntryWow64 {
   USHORT call_edx;      // = FF D2
   BYTE ret;             // = C2
   USHORT num_params;
-  BYTE nop;
 };
 
 // Make sure that relaxed patching works as expected.
-const size_t kMinServiceSize = offsetof(ServiceEntryWow64, ret);
-// Maximum size of the entry, was the size of the Windows Vista WoW64 entry.
-// Keep this fixed for compatibility reasons.
-const size_t kMaxServiceSize = 24;
-static_assert(sizeof(ServiceEntry32) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntry32) < kMaxServiceSize,
-              "wrong maximum service length");
-static_assert(sizeof(ServiceEntryWow64) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntryWow64) < kMaxServiceSize,
-              "wrong maximum service length");
+const size_t kMinServiceSize = offsetof(ServiceEntry, ret);
+static_assert(sizeof(ServiceEntryW8) >= kMinServiceSize,
+              "wrong service length");
+static_assert(sizeof(Wow64Entry) >= kMinServiceSize, "wrong service length");
+static_assert(sizeof(Wow64EntryW8) >= kMinServiceSize, "wrong service length");
 
 struct ServiceFullThunk {
   union {
-    ServiceEntryWow64 original;
-    // Pad the entry to the maximum size.
-    char dummy[kMaxServiceSize];
+    ServiceEntry original;
+    ServiceEntryW8 original_w8;
+    Wow64Entry wow_64;
+    Wow64EntryW8 wow_64_w8;
   };
   int internal_thunk;  // Dummy member to the beginning of the internal thunk.
 };
 
 #pragma pack(pop)
 
-bool IsWow64Process() {
-  // We don't need to use IsWow64Process2 as this returns the expected result
-  // when running in the ARM64 x86 emulator.
-  BOOL is_wow64 = FALSE;
-  return ::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64;
-}
-
-bool IsFunctionAService32(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntry32 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
-      function_code.call_offset != 3 || kRet != function_code.ret_p ||
-      kMovEdxEsp != function_code.mov_edx_esp ||
-      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-
-  return true;
-}
-
-bool IsFunctionAServiceWow64(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntryWow64 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
-      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-  return true;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -212,14 +227,69 @@ NTSTATUS ServiceResolverThunk::CopyThunk(const void* target_module,
 }
 
 bool ServiceResolverThunk::IsFunctionAService(void* local_thunk) const {
-  static bool is_wow64 = IsWow64Process();
-  return is_wow64 ? IsFunctionAServiceWow64(process_, target_, local_thunk)
-                  : IsFunctionAService32(process_, target_, local_thunk);
+  ServiceEntry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      (kCallPtrEdx != function_code.call_ptr_edx &&
+       kCallEdx != function_code.call_ptr_edx) ||
+      kRet != function_code.ret) {
+    return false;
+  }
+
+  // Find the system call pointer if we don't already have it.
+  if (kCallEdx != function_code.call_ptr_edx) {
+    DWORD ki_system_call;
+    if (!::ReadProcessMemory(process_,
+                             base::bit_cast<const void*>(function_code.stub),
+                             &ki_system_call, sizeof(ki_system_call), &read)) {
+      return false;
+    }
+
+    if (sizeof(ki_system_call) != read)
+      return false;
+
+    HMODULE module_1, module_2;
+    // last check, call_stub should point to a KiXXSystemCall function on ntdll
+    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                           base::bit_cast<const wchar_t*>(ki_system_call),
+                           &module_1)) {
+      return false;
+    }
+
+    if (ntdll_base_) {
+      // This path is only taken when running the unit tests. We want to be
+      // able to patch a buffer in memory, so target_ is not inside ntdll.
+      module_2 = ntdll_base_;
+    } else {
+      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                             reinterpret_cast<const wchar_t*>(target_),
+                             &module_2))
+        return false;
+    }
+
+    if (module_1 != module_2)
+      return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
 }
 
 NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
                                             void* remote_thunk) {
-  ServiceEntryWow64 intercepted_code;
+  ServiceEntry intercepted_code;
   size_t bytes_to_write = sizeof(intercepted_code);
   ServiceFullThunk* full_local_thunk =
       reinterpret_cast<ServiceFullThunk*>(local_thunk);
@@ -232,15 +302,15 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   intercepted_code.mov_eax = kMovEax;
   intercepted_code.service_id = full_local_thunk->original.service_id;
   intercepted_code.mov_edx = kMovEdx;
-  intercepted_code.mov_edx_param =
+  intercepted_code.stub =
       base::bit_cast<ULONG>(&full_remote_thunk->internal_thunk);
-  intercepted_code.call_edx = kJmpEdx;
+  intercepted_code.call_ptr_edx = kJmpEdx;
   bytes_to_write = kMinServiceSize;
 
   if (relative_jump_) {
     intercepted_code.mov_eax = kJmp32;
     intercepted_code.service_id = relative_jump_;
-    bytes_to_write = offsetof(ServiceEntryWow64, mov_edx);
+    bytes_to_write = offsetof(ServiceEntry, mov_edx);
   }
 
   // setup the thunk
@@ -276,7 +346,7 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
 
 bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
                                                 void* remote_thunk) {
-  ServiceEntryWow64 function_code;
+  ServiceEntry function_code;
   SIZE_T read;
   if (!::ReadProcessMemory(process_, target_, &function_code,
                            sizeof(function_code), &read)) {
@@ -312,18 +382,100 @@ bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
   return true;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(
-    void* thunk_storage) const {
-  const size_t kJmp32Size = 5;
-  ServiceEntryWow64* patched = static_cast<ServiceEntryWow64*>(target_);
-  if (kJmp32 != patched->mov_eax) {
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64Entry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kXorEcx != function_code.xor_ecx ||
+      kLeaEdx != function_code.lea_edx || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3) {
+    return false;
+  }
+
+  if ((kAddEsp1 == function_code.add_esp1 &&
+       kAddEsp2 == function_code.add_esp2 && kRet == function_code.ret) ||
+      kRet == function_code.add_esp1) {
+    // Save the verified code
+    memcpy(local_thunk, &function_code, sizeof(function_code));
+    return true;
+  }
+
+  return false;
+}
+
+bool Wow64W8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
     return false;
   }
 
-  ULONG source_addr = base::bit_cast<ULONG>(target_);
-  ULONG target_addr = base::bit_cast<ULONG>(thunk_storage);
-  return target_addr + kMaxServiceSize - kJmp32Size - source_addr ==
-         patched->service_id;
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3 || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
+}
+
+bool Win8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  ServiceEntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
+      function_code.call_offset != 3 || kRet != function_code.ret_p ||
+      kMovEdxEsp != function_code.mov_edx_esp ||
+      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
+}
+
+bool Wow64W10ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW10 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_64.cc b/sandbox/win/src/service_resolver_64.cc
index 33b91d04ad114..38e451da143a3 100644
--- a/sandbox/win/src/service_resolver_64.cc
+++ b/sandbox/win/src/service_resolver_64.cc
@@ -282,8 +282,4 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   return STATUS_SUCCESS;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(void*) const {
-  return true;
-}
-
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_unittest.cc b/sandbox/win/src/service_resolver_unittest.cc
index aa05e37c0c0e0..01d0fee18b17d 100644
--- a/sandbox/win/src/service_resolver_unittest.cc
+++ b/sandbox/win/src/service_resolver_unittest.cc
@@ -13,53 +13,98 @@
 
 #include "base/bit_cast.h"
 #include "base/memory/raw_ptr.h"
-#include "sandbox/win/src/nt_internals.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/resolver.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
 
+class ResolverThunkTest {
+ public:
+  virtual ~ResolverThunkTest() {}
+
+  virtual sandbox::ServiceResolverThunk* resolver() = 0;
+
+  // Sets the interception target to the desired address.
+  void set_target(void* target) { fake_target_ = target; }
+
+ protected:
+  // Holds the address of the fake target.
+  raw_ptr<void> fake_target_;
+};
+
 // This is the concrete resolver used to perform service-call type functions
 // inside ntdll.dll.
-class ServiceResolverTest : public sandbox::ServiceResolverThunk {
+template <typename T>
+class ResolverThunkTestImpl : public T, public ResolverThunkTest {
  public:
   // The service resolver needs a child process to write to.
-  explicit ServiceResolverTest(bool relaxed)
-      : sandbox::ServiceResolverThunk(::GetCurrentProcess(), relaxed) {}
+  explicit ResolverThunkTestImpl(bool relaxed)
+      : T(::GetCurrentProcess(), relaxed) {}
 
-  ServiceResolverTest(const ServiceResolverTest&) = delete;
-  ServiceResolverTest& operator=(const ServiceResolverTest&) = delete;
+  ResolverThunkTestImpl(const ResolverThunkTestImpl&) = delete;
+  ResolverThunkTestImpl& operator=(const ResolverThunkTestImpl&) = delete;
 
-  // Sets the interception target to the desired address.
-  void set_target(void* target) { fake_target_ = target; }
+  sandbox::ServiceResolverThunk* resolver() { return this; }
 
  protected:
   // Overrides Resolver::Init
-  NTSTATUS Init(const void* target_module,
-                const void* interceptor_module,
-                const char* target_name,
-                const char* interceptor_name,
-                const void* interceptor_entry_point,
-                void* thunk_storage,
-                size_t storage_bytes) final {
+  virtual NTSTATUS Init(const void* target_module,
+                        const void* interceptor_module,
+                        const char* target_name,
+                        const char* interceptor_name,
+                        const void* interceptor_entry_point,
+                        void* thunk_storage,
+                        size_t storage_bytes) {
     NTSTATUS ret = STATUS_SUCCESS;
-    ret = sandbox::ServiceResolverThunk::Init(
-        target_module, interceptor_module, target_name, interceptor_name,
-        interceptor_entry_point, thunk_storage, storage_bytes);
+    ret = T::Init(target_module, interceptor_module, target_name,
+                  interceptor_name, interceptor_entry_point, thunk_storage,
+                  storage_bytes);
     EXPECT_EQ(STATUS_SUCCESS, ret);
 
     this->target_ = fake_target_;
 
     return ret;
   }
-
-  // Holds the address of the fake target.
-  raw_ptr<void> fake_target_;
 };
 
+typedef ResolverThunkTestImpl<sandbox::ServiceResolverThunk> WinXpResolverTest;
+
+#if !defined(_WIN64)
+typedef ResolverThunkTestImpl<sandbox::Win8ResolverThunk> Win8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W8ResolverThunk>
+    Wow64W8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W10ResolverThunk>
+    Wow64W10ResolverTest;
+#endif
+
+const BYTE kJump32 = 0xE9;
+
+void CheckJump(void* source, void* target) {
+#pragma pack(push)
+#pragma pack(1)
+  struct Code {
+    BYTE jump;
+    ULONG delta;
+  };
+#pragma pack(pop)
+
+#if defined(_WIN64)
+  FAIL() << "Running 32-bit codepath";
+#else
+  Code* patched = reinterpret_cast<Code*>(source);
+  EXPECT_EQ(kJump32, patched->jump);
+
+  ULONG source_addr = base::bit_cast<ULONG>(source);
+  ULONG target_addr = base::bit_cast<ULONG>(target);
+  EXPECT_EQ(target_addr + 19 - source_addr, patched->delta);
+#endif
+}
+
 NTSTATUS PatchNtdllWithResolver(const char* function,
                                 bool relaxed,
-                                ServiceResolverTest& resolver) {
+                                ResolverThunkTest* thunk_test) {
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   EXPECT_TRUE(ntdll_base);
 
@@ -72,20 +117,21 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
   BYTE service[50];
   memcpy(service, target, sizeof(service));
 
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
-  resolver.AllowLocalPatches();
+  resolver->AllowLocalPatches();
 
-  NTSTATUS ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                                function_entry, thunk.get(), thunk_size, &used);
+  NTSTATUS ret =
+      resolver->Setup(ntdll_base, nullptr, function, nullptr, function_entry,
+                      thunk.get(), thunk_size, &used);
   if (NT_SUCCESS(ret)) {
-    const BYTE kJump32 = 0xE9;
     EXPECT_EQ(thunk_size, used);
     EXPECT_NE(0, memcmp(service, target, sizeof(service)));
     EXPECT_NE(kJump32, service[0]);
@@ -93,18 +139,30 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
     if (relaxed) {
       // It's already patched, let's patch again, and simulate a direct patch.
       service[0] = kJump32;
-      ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                           function_entry, thunk.get(), thunk_size, &used);
-      EXPECT_TRUE(resolver.VerifyJumpTargetForTesting(thunk.get()));
+      ret = resolver->Setup(ntdll_base, nullptr, function, nullptr,
+                            function_entry, thunk.get(), thunk_size, &used);
+      CheckJump(service, thunk.get());
     }
   }
 
   return ret;
 }
 
+std::unique_ptr<ResolverThunkTest> GetTestResolver(bool relaxed) {
+#if defined(_WIN64)
+  return std::make_unique<WinXpResolverTest>(relaxed);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  if (os_info->IsWowX86OnAMD64())
+    return std::make_unique<Wow64W10ResolverTest>(relaxed);
+
+  return std::make_unique<Win8ResolverTest>(relaxed);
+#endif
+}
+
 NTSTATUS PatchNtdll(const char* function, bool relaxed) {
-  ServiceResolverTest resolver(relaxed);
-  return PatchNtdllWithResolver(function, relaxed, resolver);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(relaxed);
+  return PatchNtdllWithResolver(function, relaxed, thunk_test.get());
 }
 
 TEST(ServiceResolverTest, PatchesServices) {
@@ -155,26 +213,26 @@ TEST(ServiceResolverTest, PatchesPatchedServices) {
 TEST(ServiceResolverTest, MultiplePatchedServices) {
 // We don't support "relaxed mode" for Win64 apps.
 #if !defined(_WIN64)
-  ServiceResolverTest thunk_test(true);
-  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
+  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateFile, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateMutant, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, LocalPatchesAllowed) {
-  ServiceResolverTest resolver(true);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
 
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   ASSERT_TRUE(ntdll_base);
@@ -187,25 +245,26 @@ TEST(ServiceResolverTest, LocalPatchesAllowed) {
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
   NTSTATUS ret = STATUS_UNSUCCESSFUL;
 
   // First try patching without having allowed local patches.
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_FALSE(NT_SUCCESS(ret));
 
   // Now allow local patches and check that things work.
-  resolver.AllowLocalPatches();
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  resolver->AllowLocalPatches();
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_EQ(STATUS_SUCCESS, ret);
 }
 
diff --git a/sandbox/win/src/startup_information_helper.cc b/sandbox/win/src/startup_information_helper.cc
index b7688c6b74d9c..dab303f872b1e 100644
--- a/sandbox/win/src/startup_information_helper.cc
+++ b/sandbox/win/src/startup_information_helper.cc
@@ -115,6 +115,8 @@ bool StartupInformationHelper::BuildStartupInformation() {
   if (!startup_info_.InitializeProcThreadAttributeList(expected_attributes))
     return false;
 
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
+
   if (mitigations_[0] || mitigations_[1]) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &mitigations_[0],
@@ -133,7 +135,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     }
     expected_attributes--;
   }
-
+  }
   if (restrict_child_process_creation_) {
     child_process_creation_ = PROCESS_CREATION_CHILD_PROCESS_RESTRICTED;
     if (!startup_info_.UpdateProcThreadAttribute(
@@ -159,7 +161,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     inherit_handles_ = true;
     expected_attributes--;
   }
-
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
   if (!job_handle_list_.empty()) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_JOB_LIST, &job_handle_list_[0],
@@ -191,6 +193,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
   }
 
   CHECK(expected_attributes == 0);
+  }
   return true;
 }
 
diff --git a/sandbox/win/src/target_services.cc b/sandbox/win/src/target_services.cc
index 4429a2d58dd5d..3973e30c17803 100644
--- a/sandbox/win/src/target_services.cc
+++ b/sandbox/win/src/target_services.cc
@@ -15,6 +15,7 @@
 #include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/win/access_token.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/handle_closer_agent.h"
@@ -115,6 +116,8 @@ bool WarmupWindowsLocales() {
 }
 
 bool SetProcessIntegrityLevel(IntegrityLevel integrity_level) {
+  if (base::win::GetVersion() < base::win::Version::VISTA)
+    return true;
   absl::optional<DWORD> rid = GetIntegrityLevelRid(integrity_level);
   if (!rid) {
     // No mandatory level specified, we don't change it.
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index afdddac091985..35c9cf95fb772 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -570,6 +570,36 @@ absl::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return handle_map;
 }
 
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
+    return absl::nullopt;
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 }  // namespace sandbox
 
 void ResolveNTFunctionPtr(const char* name, void* ptr) {
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index e416d6cda9979..7f199feb9d8c1 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -115,6 +115,12 @@ void* GetProcessBaseAddress(HANDLE process);
 // use them.
 absl::optional<ProcessHandleMap> GetCurrentProcessHandles();
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
+
 }  // namespace sandbox
 
 // Resolves a function name in NTDLL to a function pointer. The second parameter
diff --git a/services/device/geolocation/win/location_provider_winrt.cc b/services/device/geolocation/win/location_provider_winrt.cc
index 2c2b868a5294a..86e517a332692 100644
--- a/services/device/geolocation/win/location_provider_winrt.cc
+++ b/services/device/geolocation/win/location_provider_winrt.cc
@@ -70,6 +70,11 @@ void RecordUmaEvent(WindowsRTLocationRequestEvent event) {
   base::UmaHistogramEnumeration("Windows.RT.LocationRequest.Event", event);
 }
 
+bool IsWinRTSupported() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 template <typename F>
 absl::optional<DOUBLE> GetOptionalDouble(F&& getter) {
   DOUBLE value = 0;
@@ -506,6 +511,7 @@ std::unique_ptr<LocationProvider> NewSystemLocationProvider(
     GeolocationManager* geolocation_manager) {
   if (!base::FeatureList::IsEnabled(
           features::kWinrtGeolocationImplementation) ||
+	!IsWinRTSupported() ||
       !IsSystemLocationSettingEnabled()) {
     return nullptr;
   }
diff --git a/services/proxy_resolver_win/BUILD.gn b/services/proxy_resolver_win/BUILD.gn
index ed4b004f06350..c3fa7ec452180 100644
--- a/services/proxy_resolver_win/BUILD.gn
+++ b/services/proxy_resolver_win/BUILD.gn
@@ -11,6 +11,8 @@ component("proxy_resolver_win") {
     "winhttp_api_wrapper.h",
     "winhttp_api_wrapper_impl.cc",
     "winhttp_api_wrapper_impl.h",
+    "winhttp_proxy_resolver_functions.cc",
+    "winhttp_proxy_resolver_functions.h",
   ]
 
   libs = [ "winhttp.lib" ]
diff --git a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
index 68801e4636cab..e22cdfbb1fa0e 100644
--- a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
+++ b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
@@ -15,6 +15,8 @@ EnumTraits<proxy_resolver_win::mojom::WinHttpStatus,
       return proxy_resolver_win::mojom::WinHttpStatus::kOk;
     case net::WinHttpStatus::kAborted:
       return proxy_resolver_win::mojom::WinHttpStatus::kAborted;
+   case net::WinHttpStatus::kFunctionsNotLoaded:
+      return proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded;
     case net::WinHttpStatus::kWinHttpOpenFailed:
       return proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed;
     case net::WinHttpStatus::kWinHttpSetTimeoutsFailed:
@@ -55,6 +57,9 @@ bool EnumTraits<proxy_resolver_win::mojom::WinHttpStatus, net::WinHttpStatus>::
     case proxy_resolver_win::mojom::WinHttpStatus::kAborted:
       *output = net::WinHttpStatus::kAborted;
       return true;
+    case proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded:
+      *output = net::WinHttpStatus::kFunctionsNotLoaded;
+      return true;
     case proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed:
       *output = net::WinHttpStatus::kWinHttpOpenFailed;
       return true;
diff --git a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
index c05d1f63d7d9b..ff3447e285e46 100644
--- a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
+++ b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
@@ -12,6 +12,7 @@ import "url/mojom/url.mojom";
 enum WinHttpStatus {
   kOk,
   kAborted,
+  kFunctionsNotLoaded,
   kWinHttpOpenFailed,
   kWinHttpSetTimeoutsFailed,
   kWinHttpSetStatusCallbackFailed,
diff --git a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
index 54baece710f7a..78e4538bd2ded 100644
--- a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
+++ b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
@@ -9,6 +9,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
 
 namespace proxy_resolver_win {
 
@@ -34,9 +35,9 @@ WinHttpAPIWrapperImpl::~WinHttpAPIWrapperImpl() {
 
 bool WinHttpAPIWrapperImpl::CallWinHttpOpen() {
   DCHECK_EQ(nullptr, session_handle_);
-  session_handle_ = ::WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY,
-                                  WINHTTP_NO_PROXY_NAME,
-                                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
+  session_handle_ =
+      WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME,
+                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
   return (session_handle_ != nullptr);
 }
 
@@ -45,16 +46,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetTimeouts(int resolve_timeout,
                                                    int send_timeout,
                                                    int receive_timeout) {
   DCHECK_NE(nullptr, session_handle_);
-  return (!!::WinHttpSetTimeouts(session_handle_, resolve_timeout,
-                                 connect_timeout, send_timeout,
-                                 receive_timeout));
+  return (!!WinHttpSetTimeouts(session_handle_, resolve_timeout,
+                               connect_timeout, send_timeout, receive_timeout));
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
     WINHTTP_STATUS_CALLBACK internet_callback) {
   DCHECK_NE(nullptr, session_handle_);
   const WINHTTP_STATUS_CALLBACK winhttp_status_callback =
-      ::WinHttpSetStatusCallback(
+      WinHttpSetStatusCallback(
           session_handle_, internet_callback,
           WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
               WINHTTP_CALLBACK_FLAG_GETPROXYFORURL_COMPLETE,
@@ -64,14 +64,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetIEProxyConfigForCurrentUser(
     WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* ie_proxy_config) {
-  return !!::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
+  return !!WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpCreateProxyResolver(
     HINTERNET* out_resolver_handle) {
   DCHECK_NE(nullptr, session_handle_);
   const DWORD result =
-      ::WinHttpCreateProxyResolver(session_handle_, out_resolver_handle);
+      WinHttpProxyResolverFunctions::GetInstance().create_proxy_resolver(
+          session_handle_, out_resolver_handle);
   return (result == ERROR_SUCCESS);
 }
 
@@ -83,25 +84,28 @@ bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyForUrlEx(
   const std::wstring wide_url(url.begin(), url.end());
   // TODO(https://crbug.com/1032820): Upgrade to WinHttpGetProxyForUrlEx2()
   // if there is a clear reason to do so.
-  const DWORD result = ::WinHttpGetProxyForUrlEx(
-      resolver_handle, wide_url.data(), autoproxy_options, context);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_for_url_ex(
+          resolver_handle, wide_url.data(), autoproxy_options, context);
   return (result == ERROR_IO_PENDING);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyResult(
     HINTERNET resolver_handle,
     WINHTTP_PROXY_RESULT* proxy_result) {
-  const DWORD result = ::WinHttpGetProxyResult(resolver_handle, proxy_result);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_result(
+          resolver_handle, proxy_result);
   return (result == ERROR_SUCCESS);
 }
 
 VOID WinHttpAPIWrapperImpl::CallWinHttpFreeProxyResult(
     WINHTTP_PROXY_RESULT* proxy_result) {
-  WinHttpFreeProxyResult(proxy_result);
+  WinHttpProxyResolverFunctions::GetInstance().free_proxy_result(proxy_result);
 }
 
 void WinHttpAPIWrapperImpl::CallWinHttpCloseHandle(HINTERNET internet_handle) {
-  ::WinHttpCloseHandle(internet_handle);
+  WinHttpCloseHandle(internet_handle);
 }
 
 void WinHttpAPIWrapperImpl::CloseSessionHandle() {
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
new file mode 100644
index 0000000000000..b00c5670bb517
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
@@ -0,0 +1,43 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+WinHttpProxyResolverFunctions::WinHttpProxyResolverFunctions() {
+  HMODULE winhttp_module =
+      LoadLibraryEx(L"winhttp.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  if (winhttp_module) {
+    create_proxy_resolver = reinterpret_cast<WinHttpCreateProxyResolverFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpCreateProxyResolver"));
+    get_proxy_for_url_ex = reinterpret_cast<WinHttpGetProxyForUrlExFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyForUrlEx"));
+    get_proxy_result = reinterpret_cast<WinHttpGetProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyResult"));
+    free_proxy_result = reinterpret_cast<WinHttpFreeProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpFreeProxyResult"));
+  }
+}
+
+// Never called due to base::NoDestructor.
+WinHttpProxyResolverFunctions::~WinHttpProxyResolverFunctions() = default;
+
+bool WinHttpProxyResolverFunctions::are_all_functions_loaded() const {
+  return create_proxy_resolver && get_proxy_for_url_ex && get_proxy_result &&
+         free_proxy_result;
+}
+
+// static
+const WinHttpProxyResolverFunctions&
+WinHttpProxyResolverFunctions::GetInstance() {
+  // This is a singleton for performance reasons. This avoids having to load
+  // proxy resolver functions multiple times.
+  static base::NoDestructor<WinHttpProxyResolverFunctions> instance;
+  return *instance;
+}
+
+}  // namespace proxy_resolver_win
\ No newline at end of file
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
new file mode 100644
index 0000000000000..768269019cd0e
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
@@ -0,0 +1,47 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+#define SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+
+#include <windows.h>
+#include <winhttp.h>
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+// Not all WinHttp APIs we'll be using exist in all versions of Windows.
+// Several only exist in Windows 8+. Thus, each function entry point must be
+// loaded dynamically.
+struct WinHttpProxyResolverFunctions {
+ public:
+  WinHttpProxyResolverFunctions(const WinHttpProxyResolverFunctions&) = delete;
+  WinHttpProxyResolverFunctions& operator=(
+      const WinHttpProxyResolverFunctions&) = delete;
+
+  bool are_all_functions_loaded() const;
+
+  static const WinHttpProxyResolverFunctions& GetInstance();
+
+  using WinHttpCreateProxyResolverFunc = decltype(WinHttpCreateProxyResolver)*;
+  using WinHttpGetProxyForUrlExFunc = decltype(WinHttpGetProxyForUrlEx)*;
+  using WinHttpGetProxyResultFunc = decltype(WinHttpGetProxyResult)*;
+  using WinHttpFreeProxyResultFunc = decltype(WinHttpFreeProxyResult)*;
+
+  WinHttpCreateProxyResolverFunc create_proxy_resolver = nullptr;
+  WinHttpGetProxyForUrlExFunc get_proxy_for_url_ex = nullptr;
+  WinHttpGetProxyResultFunc get_proxy_result = nullptr;
+  WinHttpFreeProxyResultFunc free_proxy_result = nullptr;
+
+ private:
+  friend class base::NoDestructor<WinHttpProxyResolverFunctions>;
+
+  WinHttpProxyResolverFunctions();
+  ~WinHttpProxyResolverFunctions();
+};
+
+}  // namespace proxy_resolver_win
+
+#endif  // SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
\ No newline at end of file
diff --git a/services/shape_detection/face_detection_provider_win.cc b/services/shape_detection/face_detection_provider_win.cc
index 59e9eb36d95a5..dbe49923cf948 100644
--- a/services/shape_detection/face_detection_provider_win.cc
+++ b/services/shape_detection/face_detection_provider_win.cc
@@ -49,6 +49,11 @@ BitmapPixelFormat GetPreferredPixelFormat(IFaceDetectorStatics* factory) {
 void FaceDetectionProviderWin::CreateFaceDetection(
     mojo::PendingReceiver<shape_detection::mojom::FaceDetection> receiver,
     shape_detection::mojom::FaceDetectorOptionsPtr options) {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
   ComPtr<IFaceDetectorStatics> factory;
   HRESULT hr = GetActivationFactory<
       IFaceDetectorStatics,
diff --git a/services/shape_detection/text_detection_impl_win.cc b/services/shape_detection/text_detection_impl_win.cc
index a442dced19ad6..ca4d116a84863 100644
--- a/services/shape_detection/text_detection_impl_win.cc
+++ b/services/shape_detection/text_detection_impl_win.cc
@@ -42,6 +42,13 @@ using Microsoft::WRL::ComPtr;
 // static
 void TextDetectionImpl::Create(
     mojo::PendingReceiver<mojom::TextDetection> receiver) {
+
+if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
+
   // Text Detection specification only supports Latin-1 text as documented in
   // https://wicg.github.io/shape-detection-api/text.html#text-detection-api.
   // TODO(junwei.fu): https://crbug.com/794097 consider supporting other Latin
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index b5d93532e6198..916749554634c 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -464,6 +464,7 @@ component("skia") {
   if (is_win) {
     # See SK_TYPEFACE_FACTORY_DIRECTWRITE
     sources += [
+      "//third_party/skia/src/ports/SkFontHost_win.cpp",
       "//third_party/skia/src/ports/SkFontMgr_win_dw.cpp",
       "//third_party/skia/src/ports/SkOSFile_win.cpp",
       "//third_party/skia/src/ports/SkRemotableFontMgr_win_dw.cpp",
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index a66ddcf4d9031..c6ddb5b7e6061 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -20,6 +20,13 @@ struct DWriteFontStyle {
   uint8 font_stretch;
 };
 
+struct FallbackFamilyAndStyle {
+  string fallback_family_name;
+  uint16 weight;
+  uint8 width;
+  uint8 slant;
+};
+
 struct MapCharactersResult {
   uint32 family_index;
   mojo_base.mojom.String16 family_name;
@@ -28,6 +35,11 @@ struct MapCharactersResult {
   DWriteFontStyle font_style;
 };
 
+enum UniqueFontLookupMode {
+    kRetrieveTable,
+    kSingleLookups
+};
+
 interface DWriteFontProxy {
   // Locates the index of the specified font family within the system
   // collection.
@@ -51,14 +63,47 @@ interface DWriteFontProxy {
   GetFontFileHandles(uint32 family_index)
      => (array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
@@ -73,4 +118,18 @@ interface DWriteFontProxy {
                 uint32 reading_direction,
                 mojo_base.mojom.String16 base_family_name)
       => (MapCharactersResult out);
+
+  // For a given base family name, bcp47 language tag, and codepoint to look up,
+  // return a font family name that is available on the system to display the
+  // given codepoint. This internally calls Skia's
+  // SkFontMgr_DirectWrite::matchFamilyStyleCharacter which executes
+  // IDWriteTextLayout based fallback code, which cannot be run in the renderer
+  // due triggering loading the DWrite system font collection.
+  // Use only on Windows 8.0 and earlier - otherwise better fallback API is
+  // available through using a proxies IDWriteFontFallback.
+  [Sync]
+  FallbackFamilyAndStyleForCodepoint(string base_family_name,
+                                     string bcp47_language_tag,
+                                     uint32 codepoint)
+      => (FallbackFamilyAndStyle fallback_result);
 };
diff --git a/third_party/blink/public/web/win/web_font_rendering.h b/third_party/blink/public/web/win/web_font_rendering.h
index 851b6c95d0c69..1c3135b59201f 100644
--- a/third_party/blink/public/web/win/web_font_rendering.h
+++ b/third_party/blink/public/web/win/web_font_rendering.h
@@ -18,6 +18,7 @@ class WebFontRenderingClient;
 
 class BLINK_EXPORT WebFontRendering {
  public:
+  static void setUseDirectWrite(bool);
   static void SetSkiaFontManager(sk_sp<SkFontMgr>);
   // Set an instance of |WebFontPrewarmer|. The instance must be kept alive
   // until the process exits.
@@ -34,6 +35,7 @@ class BLINK_EXPORT WebFontRendering {
                                    int32_t font_height);
   static void SetAntialiasedTextEnabled(bool);
   static void SetLCDTextEnabled(bool);
+  static void SetUseSkiaFontFallback(bool);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
index 178b04c75c258..de8cc3fcdc8ed 100644
--- a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
+++ b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
@@ -9,6 +9,12 @@
 
 namespace blink {
 
+// static
+void WebFontRendering::setUseDirectWrite(bool useDirectWrite)
+{
+    FontCache::setUseDirectWrite(useDirectWrite);
+}
+
 // static
 void WebFontRendering::SetSkiaFontManager(sk_sp<SkFontMgr> font_mgr) {
   FontCache::SetFontManager(std::move(font_mgr));
@@ -59,4 +65,9 @@ void WebFontRendering::SetLCDTextEnabled(bool enabled) {
   FontCache::SetLCDTextEnabled(enabled);
 }
 
+// static
+void WebFontRendering::SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+  FontCache::SetUseSkiaFontFallback(use_skia_font_fallback);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 8c710aafbf4a0..93419e64b7e00 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1630,6 +1630,8 @@ component("platform") {
     sources += [
       "fonts/win/dwrite_font_format_support.cc",
       "fonts/win/dwrite_font_format_support.h",
+      "fonts/win/fallback_family_style_cache_win.cc",
+      "fonts/win/fallback_family_style_cache_win.h",
       "fonts/win/font_cache_skia_win.cc",
       "fonts/win/font_fallback_win.cc",
       "fonts/win/font_fallback_win.h",
@@ -2215,7 +2217,10 @@ source_set("blink_platform_unittests_sources") {
   if (is_android) {
     sources += [ "fonts/android/font_cache_android_test.cc" ]
   } else if (is_win) {
-    sources += [ "text/locale_win_test.cc" ]
+    sources += [
+      "fonts/win/fallback_lru_cache_win_test.cc",
+      "text/locale_win_test.cc",
+    ]
   } else if (is_mac) {
     sources += [
       "fonts/mac/font_matcher_mac_test.mm",
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index 2d160f4de81ce..6ae70902e71ae 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -59,6 +59,7 @@
 #include "ui/gfx/font_list.h"
 
 #if BUILDFLAG(IS_WIN)
+#include <Windows.h>
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -77,8 +78,10 @@ float FontCache::device_scale_factor_ = 1.0;
 #endif
 
 #if BUILDFLAG(IS_WIN)
+bool FontCache::s_useDirectWrite = false;
 bool FontCache::antialiased_text_enabled_ = false;
 bool FontCache::lcd_text_enabled_ = false;
+bool FontCache::use_skia_font_fallback_ = false;
 static bool should_use_test_font_mgr = false;
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -91,11 +94,15 @@ FontCache::FontCache()
       font_platform_data_cache_(FontPlatformDataCache::Create()),
       font_data_cache_(FontDataCache::Create()) {
 #if BUILDFLAG(IS_WIN)
+  if(!s_useDirectWrite) {
+	  font_manager_ = SkFontMgr_New_GDI();
+  }
+
   if (!font_manager_ || should_use_test_font_mgr) {
     // This code path is only for unit tests. This SkFontMgr does not work in
     // sandboxed environments, but injecting this initialization code to all
     // unit tests isn't easy.
-    font_manager_ = SkFontMgr_New_DirectWrite();
+		font_manager_ = SkFontMgr_New_DirectWrite();
     // Set |is_test_font_mgr_| to capture if this is not happening in the
     // production code. crbug.com/561873
     is_test_font_mgr_ = true;
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index ae5cee24b4c49..7da0d5c0da219 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -38,6 +38,7 @@
 #include "base/gtest_prod_util.h"
 #include "base/memory/scoped_refptr.h"
 #include "build/build_config.h"
+#include "mojo/public/cpp/bindings/remote.h"
 #include "third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_client.h"
 #include "third_party/blink/renderer/platform/fonts/font_data_cache.h"
@@ -60,6 +61,11 @@
 #include "ui/gfx/font_fallback_linux.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+#endif
+
 class SkString;
 class SkTypeface;
 
@@ -197,8 +203,10 @@ class PLATFORM_EXPORT FontCache final {
 #if BUILDFLAG(IS_WIN)
   // TODO(https://crbug.com/808221) System font style configuration is not
   // related to FontCache. Move it somewhere else, e.g. to WebThemeEngine.
+  static bool useDirectWrite() { return s_useDirectWrite; }
   static bool AntialiasedTextEnabled() { return antialiased_text_enabled_; }
   static bool LcdTextEnabled() { return lcd_text_enabled_; }
+  static void setUseDirectWrite(bool useDirectWrite) { s_useDirectWrite = useDirectWrite; }
   static void SetAntialiasedTextEnabled(bool enabled) {
     antialiased_text_enabled_ = enabled;
   }
@@ -222,6 +230,13 @@ class PLATFORM_EXPORT FontCache final {
   static const AtomicString& StatusFontFamily() {
     return *status_font_family_name_;
   }
+  static void SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+    use_skia_font_fallback_ = use_skia_font_fallback;
+  }
+
+  // On Windows pre 8.1 establish a connection to the DWriteFontProxy service in
+  // order to retrieve family names for fallback lookup.
+  void EnsureServiceConnected();
 
   scoped_refptr<SimpleFontData> GetFallbackFamilyNameFromHardcodedChoices(
       const FontDescription&,
@@ -352,6 +367,7 @@ class PLATFORM_EXPORT FontCache final {
   static SkFontMgr* static_font_manager_;
 
 #if BUILDFLAG(IS_WIN)
+  static bool s_useDirectWrite;
   static WebFontPrewarmer* prewarmer_;
   static bool antialiased_text_enabled_;
   static bool lcd_text_enabled_;
@@ -362,10 +378,13 @@ class PLATFORM_EXPORT FontCache final {
   static int32_t small_caption_font_height_;
   static AtomicString* status_font_family_name_;
   static int32_t status_font_height_;
+  static bool use_skia_font_fallback_;
 
   // Windows creates an SkFontMgr for unit testing automatically. This flag is
   // to ensure it's not happening in the production from the crash log.
   bool is_test_font_mgr_ = false;
+  mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
index 2a1f2357dbe6c..05fbad33b180a 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
@@ -45,6 +45,9 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
 #include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
+#if BUILDFLAG(IS_WIN)
+#include "third_party/skia/include/ports/SkTypeface_win.h"
+#endif
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "v8/include/v8.h"
 
@@ -128,6 +131,34 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
   // now, going with a reasonable upper limit. Deduplication is
   // handled by Skia with priority given to the last occuring
   // assignment.
+  #if BUILDFLAG(IS_WIN)
+    if (!FontCache::useDirectWrite()) {
+        // FIXME: Skia currently renders synthetic bold and italics with
+        // hinting and without linear metrics on the windows GDI backend
+        // while the DirectWrite backend does the right thing. Using
+        // legacyCreateTypeface and specifying the bold/italics style allows
+        // for proper rendering of synthetic style. Once Skia has been
+        // updated this workaround will no longer be needed.
+        // http://crbug.com/332958
+        bool syntheticBold = bold && !return_typeface->isBold();
+        bool syntheticItalic = italic && !return_typeface->isItalic();
+        if (syntheticBold || syntheticItalic) {
+            SkString name;
+			sk_sp<SkFontMgr> font_mgr(SkFontMgr_New_GDI());
+            return_typeface->getFamilyName(&name);
+
+            SkFontStyle realStyle = return_typeface->fontStyle();
+            SkFontStyle syntheticStyle = SkFontStyle(
+                realStyle.weight() + (syntheticBold ? 200 : 0),
+                realStyle.width(),
+                syntheticItalic ? SkFontStyle::kItalic_Slant : realStyle.slant());
+            sk_sp<SkTypeface> typeface = font_mgr->legacyMakeTypeface(name.c_str(), syntheticStyle);
+            syntheticBold = false;
+            syntheticItalic = false;
+            return FontPlatformData(typeface, "", size, syntheticBold, syntheticItalic, text_rendering, resolved_font_features, orientation);
+        }
+    }
+  #endif
   FontFormatCheck::VariableFontSubType font_sub_type =
       FontFormatCheck::ProbeVariableFont(base_typeface_);
   bool synthetic_bold = bold;
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
index bb6625fe0df54..7f5945591bee8 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
@@ -83,8 +83,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
 
   // Save first candidate to be returned if all other fonts fail, and we need
   // it to render the .notdef glyph.
-  if (!first_candidate_)
+  if (!first_candidate_) {
     first_candidate_ = candidate;
+  }
   return candidate;
 }
 
@@ -153,8 +154,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
   if (fallback_stage_ == kFirstCandidateForNotdefGlyph) {
     fallback_stage_ = kOutOfLuck;
-    if (!first_candidate_)
-      FontCache::CrashWithFontInfo(&font_description_);
+    if (!first_candidate_) {
+		FontCache::CrashWithFontInfo(&font_description_);
+	}
     return first_candidate_;
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
index fae5547d5ef83..33cc33aaa4424 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
@@ -116,6 +116,7 @@ FontPlatformData* FontPlatformDataCache::GetOrCreateFontPlatformData(
   FontPlatformData* const platform_data = GetOrCreateFontPlatformData(
       font_cache, font_description, create_by_alternate_family,
       AlternateFontName::kNoAlternate);
+
   if (!platform_data)
     return nullptr;
 
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index 29d1d81729d81..5e3c4455d6ffd 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -193,7 +193,6 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
                             AlternateFontName::kLastResort);
   }
 #endif
-
   DCHECK(font_platform_data);
   return FontDataFromFontPlatformData(font_platform_data, should_retain);
 }
@@ -219,7 +218,6 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   DCHECK_NE(family, font_family_names::kSystemUi);
   // convert the name to utf8
   name = family.Utf8();
-
 #if BUILDFLAG(IS_ANDROID)
   // If this is a locale-specific family, try looking up locale-specific
   // typeface first.
@@ -233,6 +231,12 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   // TODO(https://crbug.com/1425390: Assign FontCache::font_manager_ in the
   // ctor.
   auto font_manager = font_manager_ ? font_manager_ : SkFontMgr::RefDefault();
+#if BUILDFLAG(IS_WIN)
+  if(!useDirectWrite()) {
+	return sk_sp<SkTypeface>(font_manager->legacyMakeTypeface(
+      name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
+  }
+#endif
   return sk_sp<SkTypeface>(font_manager->matchFamilyStyle(
       name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
 }
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
new file mode 100644
index 0000000000000..2e8c855270541
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
@@ -0,0 +1,90 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+
+namespace blink {
+
+namespace {
+
+const wtf_size_t kMaxCacheSlots = 16;
+
+String makeCacheKey(FontDescription::GenericFamilyType generic_family,
+                    String bcp47_language_tag,
+                    FontFallbackPriority fallback_priority) {
+  StringBuilder cache_key;
+  cache_key.Append(bcp47_language_tag);
+  cache_key.AppendNumber(
+      static_cast<
+          std::underlying_type<FontDescription::GenericFamilyType>::type>(
+          generic_family));
+  cache_key.AppendNumber(
+      static_cast<std::underlying_type<FontFallbackPriority>::type>(
+          fallback_priority));
+  return cache_key.ToString();
+}
+
+void getFallbackFamilyAndStyle(SkTypeface* typeface,
+                               String* fallback_family,
+                               SkFontStyle* fallback_style) {
+  SkString family;
+  typeface->getFamilyName(&family);
+  *fallback_family = family.c_str();
+
+  *fallback_style = typeface->fontStyle();
+}
+}  // namespace
+
+FallbackFamilyStyleCache::FallbackFamilyStyleCache()
+    : recent_fallback_fonts_(kMaxCacheSlots) {}
+
+void FallbackFamilyStyleCache::Put(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    SkTypeface* typeface) {
+  String cache_key =
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority);
+
+  auto it = recent_fallback_fonts_.Get(cache_key);
+  if (it != recent_fallback_fonts_.end()) {
+    it->second.insert(0, sk_ref_sp(typeface));
+  } else {
+    TypefaceVector typefaces;
+    typefaces.push_back(sk_ref_sp(typeface));
+    recent_fallback_fonts_.Put(std::move(cache_key), std::move(typefaces));
+  }
+}
+
+void FallbackFamilyStyleCache::Get(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    UChar32 character,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  auto it = recent_fallback_fonts_.Get(
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority));
+  if (it == recent_fallback_fonts_.end())
+    return;
+  TypefaceVector& typefaces = it->second;
+  for (wtf_size_t i = 0; i < typefaces.size(); ++i) {
+    sk_sp<SkTypeface>& typeface = typefaces.at(i);
+    if (typeface->unicharToGlyph(character)) {
+      getFallbackFamilyAndStyle(typeface.get(), fallback_family,
+                                fallback_style);
+      sk_sp<SkTypeface> tmp_typeface(typeface);
+      // For the vector of typefaces for this specific language tag, since this
+      // SkTypeface had a glyph, move it to the beginning to accelerate
+      // subsequent lookups.
+      typefaces.EraseAt(i);
+      typefaces.insert(0, std::move(tmp_typeface));
+      return;
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
new file mode 100644
index 0000000000000..72e27fa69b27f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
@@ -0,0 +1,59 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+
+#include "base/containers/lru_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+using TypefaceVector = Vector<sk_sp<SkTypeface>>;
+using FallbackLruCache = base::HashingLRUCache<String, TypefaceVector>;
+
+class FallbackFamilyStyleCache {
+  USING_FAST_MALLOC(FallbackFamilyStyleCache);
+
+ public:
+  FallbackFamilyStyleCache();
+  FallbackFamilyStyleCache(const FallbackFamilyStyleCache&) = delete;
+  FallbackFamilyStyleCache& operator=(const FallbackFamilyStyleCache&) = delete;
+
+  // Places a SkTypeface object in the cache for specified language tag and
+  // fallback priority, taking a reference on SkTypeface. Adds the |SkTypeface|
+  // to the beginning of a list of typefaces if previous |SkTypefaces| objects
+  // where added for this set of parameters. Note, the internal list of
+  // typefaces for a language tag and fallback priority is not checked for
+  // duplicates when adding a |typeface| object.
+  void Put(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           SkTypeface* typeface);
+
+  // Fetches a |fallback_family| and |fallback_style| for a given language tag,
+  // fallback priority and codepoint. Checks the internal cache for whether a
+  // fallback font with glyph coverage for |character| is available for the
+  // given parameters, then returns its family name and style.
+  void Get(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           UChar32 character,
+           String* fallback_family,
+           SkFontStyle* fallback_style);
+
+  // Empties the internal cache, deleting keys and unrefing the typefaces that
+  // were placed in the cache.
+  void Clear();
+
+ private:
+  FallbackLruCache recent_fallback_fonts_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
new file mode 100644
index 0000000000000..0363fdca92dde
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
@@ -0,0 +1,99 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace {
+
+const char kHanSimplifiedLocale[] = "zh-Hans";
+const size_t kLruCacheTestSize = 5;
+const char kFontFamilyNameArial[] = "Arial";
+const UChar32 kFirstCJKIdeograph = 0x4E00;
+const UChar32 kSecondCJKIdeograph = kFirstCJKIdeograph + 1;
+
+sk_sp<SkTypeface> fallbackForLocale(String locale, UChar32 codepoint) {
+  sk_sp<SkFontMgr> font_mgr = SkFontMgr::RefDefault();
+  std::string locale_string(locale.Ascii());
+  const char* locale_char = locale_string.c_str();
+  return sk_sp<SkTypeface>(font_mgr->matchFamilyStyleCharacter(
+      kFontFamilyNameArial, SkFontStyle(), &locale_char, 1, codepoint));
+}
+
+void fillCacheWithDummies(blink::FallbackLruCache& lru_cache,
+                          const char* format_string,
+                          size_t count) {
+  for (size_t i = 0; i < count; ++i) {
+    blink::TypefaceVector dummy_typefaces;
+    dummy_typefaces.push_back(
+        SkTypeface::MakeFromName(kFontFamilyNameArial, SkFontStyle()));
+    lru_cache.Put(String::Format(format_string, i), std::move(dummy_typefaces));
+  }
+}
+
+}  // namespace
+
+namespace blink {
+
+TEST(FallbackLruCacheTest, KeepChineseWhenFetched) {
+  // Put a Chinese font in the cache, add size - 1 more dummy fallback fonts so
+  // that the cache is full. Get() and verify typeface for Chinese to move them
+  // up to the top of the cache. Then fill again with size - 1 items and verify
+  // that Chinese is still in the cache. Then fill with # size items to evict
+  // the Chinese font and ensure it's gone.
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  TypefaceVector fallback_typefaces_zh;
+  fallback_typefaces_zh.push_back(
+      fallbackForLocale(kHanSimplifiedLocale, kFirstCJKIdeograph));
+  lru_cache.Put(kHanSimplifiedLocale, std::move(fallback_typefaces_zh));
+
+  EXPECT_EQ(lru_cache.size(), 1u);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", kLruCacheTestSize - 1);
+  auto it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  TypefaceVector& chinese_typefaces = it->second;
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(0x4E01));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_2nd_%zu",
+                       kLruCacheTestSize - 1);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  chinese_typefaces = it->second;
+  EXPECT_EQ(chinese_typefaces.size(), 1u);
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(kSecondCJKIdeograph));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_3rd_%zu", kLruCacheTestSize);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it == lru_cache.end());
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+}
+
+TEST(FallbackLruCacheTest, LargeFillAndClear) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", 1000);
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+  lru_cache.Clear();
+  EXPECT_EQ(lru_cache.size(), 0u);
+}
+
+TEST(FallbackLruCacheTest, KeyOverride) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "same_locale", 10);
+  EXPECT_EQ(lru_cache.size(), 1u);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index 01e6acd3c8dbc..3463aecd5cbbe 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -42,6 +42,8 @@
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/trace_event/trace_event.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/web_font_prewarmer.h"
 #include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -163,6 +165,13 @@ void FontCache::SetStatusFontMetrics(const AtomicString& family_name,
   status_font_height_ = EnsureMinimumFontHeightIfNeeded(font_height);
 }
 
+void FontCache::EnsureServiceConnected() {
+  if (service_)
+    return;
+  Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+      service_.BindNewPipeAndPassReceiver());
+}
+
 // TODO(https://crbug.com/976737): This function is deprecated and only intended
 // to run in parallel with the API based OOP font fallback calls to compare the
 // results and track them in UMA for a while until we decide to remove this
@@ -247,30 +256,90 @@ scoped_refptr<SimpleFontData> FontCache::GetDWriteFallbackFamily(
       font_description, fallback_priority, codepoint);
   DCHECK(fallback_locale);
 
-  const std::string family_name = font_description.Family().FamilyName().Utf8();
+  // On Pre Windows 8.1 (where use_skia_font_fallback_ is false) we cannot call
+  // the Skia version, as there is no IDWriteFontFallback (which is
+  // proxyable). If no IDWriteFontFallback API exists in the DWrite Skia
+  // SkTypeface implemnetation it will proceed to call the layoutFallback method
+  // of SkTypeface DWrite implementation. This method we must not call in the
+  // renderer as it causes stability issues due to reaching a path that will try
+  // to load the system font collection in-process and thus load DLLs that are
+  // blocked in the renderer, see comment in dwrite_font_proxy_init_impl_win.cc
+  // InitializeDWriteFontProxy(). Hence, for Windows pre 8.1 we add a
+  // DWriteFontProxy code path to retrieve a family name as string for a
+  // character + language tag and call matchFamilyStyleCharacter on the browser
+  // side, where we can do that.
+  if (!use_skia_font_fallback_) {
+    String fallback_family;
+    SkFontStyle fallback_style;
+
+    if (UNLIKELY(!fallback_params_cache_)) {
+      fallback_params_cache_ = std::make_unique<FallbackFamilyStyleCache>();
+    }
 
-  Bcp47Vector locales;
-  locales.push_back(fallback_locale->LocaleForSkFontMgr());
-  sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
-      family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
-      locales.size(), codepoint));
+    fallback_params_cache_->Get(
+        font_description.GenericFamily(), fallback_locale->LocaleForSkFontMgr(),
+        fallback_priority, codepoint, &fallback_family, &fallback_style);
+    bool result_from_cache = !fallback_family.IsNull();
 
-  if (!typeface) {
-    return nullptr;
-  }
+    if (!result_from_cache) {
+      EnsureServiceConnected();
+
+      // After Mojo IPC, on the browser side, this ultimately reaches
+      // Skia's matchFamilyStyleCharacter for Windows, which does not implement
+      // traversing the language tag stack but only processes the most important
+      // one, so we use FallbackLocaleForCharacter() to determine what locale to
+      // choose to achieve the best possible result.
+
+      if (!GetOutOfProcessFallbackFamily(
+              codepoint, font_description.GenericFamily(),
+              fallback_locale->LocaleForSkFontMgr(), fallback_priority,
+              service_, &fallback_family, &fallback_style))
+        return nullptr;
+
+      if (fallback_family.empty())
+        return nullptr;
+    }
+
+    FontFaceCreationParams create_by_family((AtomicString(fallback_family)));
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(fallback_style);
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+
+    if (!result_from_cache) {
+      fallback_params_cache_->Put(font_description.GenericFamily(),
+                                  fallback_locale->LocaleForSkFontMgr(),
+                                  fallback_priority, data->Typeface());
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  } else {
+    std::string family_name = font_description.Family().FamilyName().Utf8();
+
+    Bcp47Vector locales;
+    locales.push_back(fallback_locale->LocaleForSkFontMgr());
+    sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
+        family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+        locales.size(), codepoint));
+
+    if (!typeface)
+      return nullptr;
 
-  SkString skia_family;
-  typeface->getFamilyName(&skia_family);
-  FontDescription fallback_updated_font_description(font_description);
-  fallback_updated_font_description.UpdateFromSkiaFontStyle(
-      typeface->fontStyle());
-  const FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
-  FontPlatformData* data =
-      GetFontPlatformData(fallback_updated_font_description, create_by_family);
-  if (!data || !data->FontContainsCharacter(codepoint)) {
-    return nullptr;
+    SkString skia_family;
+    typeface->getFamilyName(&skia_family);
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(
+        typeface->fontStyle());
+    FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
   }
-  return FontDataFromFontPlatformData(data, kDoNotRetain);
+  NOTREACHED();
+  return nullptr;
 }
 
 // Given the desired base font, this will create a SimpleFontData for a specific
@@ -296,9 +365,10 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       GetFallbackFamilyNameFromHardcodedChoices(font_description, character,
                                                 fallback_priority);
 
-  // Fall through to running the API-based fallback.
+  // Fall through to running the API based fallback on Windows 8.1 and above
+  // where API fallback was previously available.
   if (RuntimeEnabledFeatures::LegacyWindowsDWriteFontFallbackEnabled() ||
-      !hardcoded_list_fallback_font) {
+      (!hardcoded_list_fallback_font && use_skia_font_fallback_)) {
     return GetDWriteFallbackFamily(font_description, character,
                                    fallback_priority);
   }
@@ -439,7 +509,7 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
 
   } else {
     typeface = CreateTypeface(font_description, creation_params, name);
-
+
     // For a family match, Windows will always give us a valid pointer here,
     // even if the face name is non-existent. We have to double-check and see if
     // the family name was really used.
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
index fe7c9a5c819bd..12b8e76a39921 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
@@ -48,11 +48,19 @@ namespace blink {
 
 namespace {
 
+const char kArial[] = "Arial";
+const char kCourierNew[] = "Courier New";
+const char kTimesNewRoman[] = "Times New Roman";
+
 static inline bool IsFontPresent(const UChar* font_name,
                                  SkFontMgr* font_manager) {
   String family = font_name;
-  sk_sp<SkTypeface> tf(
-      font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle()));
+  sk_sp<SkTypeface> tf;
+  if(FontCache::useDirectWrite()) {
+	tf = font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle());
+  } else {
+	tf = font_manager->legacyMakeTypeface(family.Utf8().data(), SkFontStyle());
+  }
   if (!tf)
     return false;
 
@@ -538,4 +546,38 @@ const UChar* GetFallbackFamily(UChar32 character,
   return family;
 }
 
+bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& service,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  String base_family_name_approximation;
+  switch (generic_family) {
+    case FontDescription::kMonospaceFamily:
+      base_family_name_approximation = kCourierNew;
+      break;
+    case FontDescription::kSansSerifFamily:
+      base_family_name_approximation = kArial;
+      break;
+    default:
+      base_family_name_approximation = kTimesNewRoman;
+  }
+
+  mojom::blink::FallbackFamilyAndStylePtr fallback_family_and_style;
+  bool mojo_result = service->FallbackFamilyAndStyleForCodepoint(
+      base_family_name_approximation, bcp47_language_tag, character,
+      &fallback_family_and_style);
+
+  SECURITY_DCHECK(fallback_family);
+  SECURITY_DCHECK(fallback_style);
+  *fallback_family = fallback_family_and_style->fallback_family_name;
+  *fallback_style = SkFontStyle(
+      fallback_family_and_style->weight, fallback_family_and_style->width,
+      static_cast<SkFontStyle::Slant>(fallback_family_and_style->slant));
+  return mojo_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
index 6a51e150dc5b9..254eba78a3639 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
@@ -34,10 +34,13 @@
 #include <unicode/locid.h>
 #include <unicode/uscript.h>
 
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 class SkFontMgr;
 
@@ -55,6 +58,19 @@ PLATFORM_EXPORT const UChar* GetFallbackFamily(
     FontFallbackPriority,
     SkFontMgr* font_manager);
 
+// Return a font family that can render |character| based on what script
+// that characters belong to by performing an out of process lookup and using
+// system fallback API based on IDWriteTextLayout. This method is only to be
+// used on pre Windows 8.1, as otherwise IDWriteFontFallback API is available.
+PLATFORM_EXPORT bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& font_proxy,
+    String* fallback_family,
+    SkFontStyle* fallback_style);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_FALLBACK_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index 3b1c3db022fd0..2f825c618b83e 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
@@ -26,11 +27,14 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -43,6 +47,31 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  absl::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  return SkTypeface::MakeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -60,11 +89,52 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
-    EnsureServiceConnected();
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
   }
 
-  return true;
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -74,11 +144,66 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index 7b31b5af1cabc..abdf287af3677 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows Vista, 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,17 +32,32 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
+
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  absl::optional<bool> sync_available_;
+  absl::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
index e079f9ccd09d2..ed9cb666ff09b 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
@@ -91,6 +91,11 @@ class OnScreenKeyboardDisplayManagerInputPane::VirtualKeyboardInputPane
     if (input_pane2_)
       return true;
 
+    if (!base::win::ResolveCoreWinRTDelayload() ||
+        !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+      return false;
+    }
+
     base::win::AssertComApartmentType(base::win::ComApartmentType::STA);
 
     base::win::ScopedHString input_pane_guid = base::win::ScopedHString::Create(
diff --git a/ui/base/ui_base_features.h b/ui/base/ui_base_features.h
index 595e592b9d6c6..f9313c29aafc8 100644
--- a/ui/base/ui_base_features.h
+++ b/ui/base/ui_base_features.h
@@ -287,6 +287,9 @@ ChromeRefresh2023Level GetChromeRefresh2023Level();
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kBubbleMetricsApi);
 
+// Enables customization of the shape of the browser tabs.
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kThoriumCustomTabs);
+
 #if !BUILDFLAG(IS_LINUX)
 COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kWebUiSystemFont);
 #endif
diff --git a/ui/display/win/screen_win.cc b/ui/display/win/screen_win.cc
index 773fbb8e90276..4cb727542c2f9 100644
--- a/ui/display/win/screen_win.cc
+++ b/ui/display/win/screen_win.cc
@@ -47,13 +47,47 @@ namespace {
 // resolved with Desktop Aura and WindowTreeHost.
 ScreenWin* g_instance = nullptr;
 
+bool IsProcessPerMonitorDpiAware() {
+  enum class PerMonitorDpiAware {
+    UNKNOWN = 0,
+    PER_MONITOR_DPI_UNAWARE,
+    PER_MONITOR_DPI_AWARE,
+  };
+  static PerMonitorDpiAware per_monitor_dpi_aware = PerMonitorDpiAware::UNKNOWN;
+  if (per_monitor_dpi_aware == PerMonitorDpiAware::UNKNOWN) {
+    per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_UNAWARE;
+    HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    if (shcore_dll) {
+      auto get_process_dpi_awareness_func =
+          reinterpret_cast<decltype(::GetProcessDpiAwareness)*>(
+              ::GetProcAddress(shcore_dll, "GetProcessDpiAwareness"));
+      if (get_process_dpi_awareness_func) {
+        PROCESS_DPI_AWARENESS awareness;
+        if (SUCCEEDED(get_process_dpi_awareness_func(nullptr, &awareness)) &&
+            awareness == PROCESS_PER_MONITOR_DPI_AWARE)
+          per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+      }
+    }
+  }
+  return per_monitor_dpi_aware == PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+}
+
 // Gets the DPI for a particular monitor.
 absl::optional<int> GetPerMonitorDPI(HMONITOR monitor) {
+  if (!IsProcessPerMonitorDpiAware())
+    return absl::nullopt;
+
+  static auto get_dpi_for_monitor_func = []() {
+    const HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    return reinterpret_cast<decltype(&::GetDpiForMonitor)>(
+        shcore_dll ? ::GetProcAddress(shcore_dll, "GetDpiForMonitor")
+                   : nullptr);
+  }();
   UINT dpi_x, dpi_y;
-  if (!SUCCEEDED(
-          ::GetDpiForMonitor(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y))) {
+  if (!get_dpi_for_monitor_func ||
+      !SUCCEEDED(
+          get_dpi_for_monitor_func(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y)))
     return absl::nullopt;
-  }
 
   DCHECK_EQ(dpi_x, dpi_y);
   return static_cast<int>(dpi_x);
diff --git a/ui/display/win/uwp_text_scale_factor.cc b/ui/display/win/uwp_text_scale_factor.cc
index f6867edea301e..2d2d18c212bca 100644
--- a/ui/display/win/uwp_text_scale_factor.cc
+++ b/ui/display/win/uwp_text_scale_factor.cc
@@ -52,6 +52,13 @@ bool g_default_instance_cleaned_up = false;
 bool CreateUiSettingsComObject(ComPtr<IUISettings2>& ptr) {
   DCHECK(!ptr);
 
+  // This is required setup before using ScopedHString.
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
   // Create the COM object.
   auto hstring = base::win::ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UISettings);
diff --git a/ui/gfx/font_render_params_win.cc b/ui/gfx/font_render_params_win.cc
index 4769c5853ee61..825b5f901c60e 100644
--- a/ui/gfx/font_render_params_win.cc
+++ b/ui/gfx/font_render_params_win.cc
@@ -12,6 +12,7 @@
 #include "base/memory/singleton.h"
 #include "base/win/registry.h"
 #include "ui/gfx/win/singleton_hwnd_observer.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace gfx {
 
@@ -83,7 +84,8 @@ class CachedFontRenderParams {
     BOOL enabled = false;
     if (SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &enabled, 0) && enabled) {
       params_->antialiasing = true;
-      params_->subpixel_positioning = true;
+      // GDI does not support subpixel positioning.
+      params_->subpixel_positioning = win::IsDirectWriteEnabled();
 
       UINT type = 0;
       if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index dab8c9be8d902..6bb60bd6a41c2 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -11,6 +11,7 @@
 
 #include "base/check_op.h"
 #include "base/command_line.h"
+#include "base/feature_list.h"
 #include "base/i18n/break_iterator.h"
 #include "base/i18n/char_iterator.h"
 #include "base/i18n/rtl.h"
@@ -31,6 +32,7 @@
 #include "third_party/skia/include/core/SkTextBlob.h"
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "third_party/skia/include/effects/SkGradientShader.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/size_conversions.h"
@@ -44,6 +46,10 @@
 #include "ui/gfx/text_utils.h"
 #include "ui/gfx/utf16_indexing.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -255,23 +261,25 @@ UChar32 ReplaceControlCharacter(UChar32 codepoint) {
     // Support Microsoft defined PUA on Windows.
     // see:
     // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
-    switch (codepoint) {
-      case 0xF093:  // ButtonA
-      case 0xF094:  // ButtonB
-      case 0xF095:  // ButtonY
-      case 0xF096:  // ButtonX
-      case 0xF108:  // LeftStick
-      case 0xF109:  // RightStick
-      case 0xF10A:  // TriggerLeft
-      case 0xF10B:  // TriggerRight
-      case 0xF10C:  // BumperLeft
-      case 0xF10D:  // BumperRight
-      case 0xF10E:  // Dpad
-      case 0xEECA:  // ButtonView2
-      case 0xEDE3:  // ButtonMenu
-        return codepoint;
-      default:
-        break;
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      switch (codepoint) {
+        case 0xF093:  // ButtonA
+        case 0xF094:  // ButtonB
+        case 0xF095:  // ButtonY
+        case 0xF096:  // ButtonX
+        case 0xF108:  // LeftStick
+        case 0xF109:  // RightStick
+        case 0xF10A:  // TriggerLeft
+        case 0xF10B:  // TriggerRight
+        case 0xF10C:  // BumperLeft
+        case 0xF10D:  // BumperRight
+        case 0xF10E:  // Dpad
+        case 0xEECA:  // ButtonView2
+        case 0xEDE3:  // ButtonMenu
+          return codepoint;
+        default:
+          break;
+      }
     }
 #endif
     const int8_t codepoint_category = u_charType(codepoint);
@@ -996,12 +1004,19 @@ int RenderText::GetContentWidth() {
 int RenderText::GetBaseline() {
   if (baseline_ == kInvalidBaseline) {
     const int centering_height =
-        (vertical_alignment_ == ALIGN_MIDDLE)
+        (vertical_alignment_ == ALIGN_MIDDLE || vertical_alignment_ == ALIGN_SPECIAL)
             ? display_rect().height()
             : std::max(font_list().GetHeight(), min_line_height());
     baseline_ = DetermineBaselineCenteringText(centering_height, font_list());
     if (vertical_alignment_ == ALIGN_BOTTOM)
       baseline_ += display_rect().height() - centering_height;
+	if (vertical_alignment_ == ALIGN_SPECIAL) {
+		if (base::FeatureList::IsEnabled(features::kChromeRefresh2023)) {
+			baseline_ *= 1.40; // This will push down the offending labels in GDI to the point that they will appear centred
+		}
+		else
+			baseline_ *= 1.30;
+	}
   }
   DCHECK_NE(kInvalidBaseline, baseline_);
   return baseline_;
@@ -1851,6 +1866,7 @@ Vector2d RenderText::GetAlignmentOffset(size_t line_number) {
       offset.set_y(0);
       break;
     case ALIGN_MIDDLE:
+	case ALIGN_SPECIAL:
       if (multiline_)
         offset.set_y((display_rect_.height() - GetStringSize().height()) / 2);
       else
diff --git a/ui/gfx/switches.cc b/ui/gfx/switches.cc
index 7a4c07887d822..8079de6c60522 100644
--- a/ui/gfx/switches.cc
+++ b/ui/gfx/switches.cc
@@ -8,6 +8,11 @@
 #include "build/build_config.h"
 
 namespace switches {
+
+#if BUILDFLAG(IS_WIN)
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+#endif
 
 // Scale factor to apply to every animation duration. Must be >= 0.0. This will
 // only apply to LinearAnimation and its subclasses.
diff --git a/ui/gfx/switches.h b/ui/gfx/switches.h
index fa6a82887fc5e..fb08789757b67 100644
--- a/ui/gfx/switches.h
+++ b/ui/gfx/switches.h
@@ -18,6 +18,10 @@ GFX_SWITCHES_EXPORT extern const char kEnableNativeGpuMemoryBuffers[];
 GFX_SWITCHES_EXPORT extern const char kForcePrefersReducedMotion[];
 GFX_SWITCHES_EXPORT extern const char kHeadless[];
 
+#if BUILDFLAG(IS_WIN)
+GFX_SWITCHES_EXPORT extern const char kDisableDirectWrite[];
+#endif
+
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 GFX_SWITCHES_EXPORT extern const char kX11Display[];
 GFX_SWITCHES_EXPORT extern const char kNoXshm[];
diff --git a/ui/gfx/text_constants.h b/ui/gfx/text_constants.h
index eaa6ea0c42037..d6eccb0842d51 100644
--- a/ui/gfx/text_constants.h
+++ b/ui/gfx/text_constants.h
@@ -70,6 +70,7 @@ enum VerticalAlignment {
   ALIGN_TOP = 0,  // Align the text's top edge with that of its display area.
   ALIGN_MIDDLE,   // Align the text's center with that of its display area.
   ALIGN_BOTTOM,   // Align the text's bottom edge with that of its display area.
+  ALIGN_SPECIAL,  // Special alignment, equivalent to ALIGN_MIDDLE, but for the GDI renderer.
 };
 
 // The directionality modes used to determine the base text direction.
diff --git a/ui/gfx/win/direct_write.cc b/ui/gfx/win/direct_write.cc
index 6e091a20069c0..e7c3bda983459 100644
--- a/ui/gfx/win/direct_write.cc
+++ b/ui/gfx/win/direct_write.cc
@@ -8,22 +8,43 @@
 
 #include <string>
 
+#include "base/command_line.h"
+#include "base/features.h"
 #include "base/debug/alias.h"
+#include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/fontmgr_default.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 
 namespace gfx {
 namespace win {
+
+GFX_EXPORT bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-direct-write");;
+}
 
 namespace {
 
+static bool dwrite_enabled = false;
+
 // Pointer to the global IDWriteFactory interface.
 IDWriteFactory* g_direct_write_factory = nullptr;
 
+
+
+
 void SetDirectWriteFactory(IDWriteFactory* factory) {
   DCHECK(!g_direct_write_factory);
   // We grab a reference on the DirectWrite factory. This reference is
@@ -35,9 +56,24 @@ void SetDirectWriteFactory(IDWriteFactory* factory) {
 }  // anonymous namespace
 
 void CreateDWriteFactory(IDWriteFactory** factory) {
+  if (!gfx::win::ShouldUseDirectWrite())
+    return;
+
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
+
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
   Microsoft::WRL::ComPtr<IUnknown> factory_unknown;
+
   HRESULT hr =
-      DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+      dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                           &factory_unknown);
   if (FAILED(hr)) {
     base::debug::Alias(&hr);
@@ -57,12 +93,45 @@ void InitializeDirectWrite() {
 
   Microsoft::WRL::ComPtr<IDWriteFactory> factory;
   CreateDWriteFactory(&factory);
-  CHECK(!!factory);
+  if (factory == nullptr) {
+	  sk_sp<SkFontMgr> direct_write_font_mgr = SkFontMgr_New_GDI();
+	  skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
+	  return;
+  }
   SetDirectWriteFactory(factory.Get());
 
+// The skia call to create a new DirectWrite font manager instance can fail
+  // if we are unable to get the system font collection from the DirectWrite
+  // factory. The GetSystemFontCollection method in the IDWriteFactory
+  // interface fails with E_INVALIDARG on certain Windows 7 gold versions
+  // (6.1.7600.*).
   sk_sp<SkFontMgr> direct_write_font_mgr =
       SkFontMgr_New_DirectWrite(factory.Get());
-  CHECK(!!direct_write_font_mgr);
+
+  int iteration = 0;
+  if (!direct_write_font_mgr &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    // Windows (win7_rtm) may fail to map the service sections
+    // (crbug.com/956064).
+    constexpr int kMaxRetries = 5;
+    constexpr base::TimeDelta kRetrySleepTime = base::Microseconds(500);
+    while (iteration < kMaxRetries) {
+      base::PlatformThread::Sleep(kRetrySleepTime);
+      direct_write_font_mgr = SkFontMgr_New_DirectWrite(factory.Get());
+      if (direct_write_font_mgr)
+        break;
+      ++iteration;
+    }
+  }
+  if (!direct_write_font_mgr)
+    iteration = -1;
+  base::UmaHistogramSparse("DirectWrite.Fonts.Gfx.InitializeLoopCount",
+                           iteration);
+  DCHECK(!!direct_write_font_mgr);
+  if (!direct_write_font_mgr)
+    direct_write_font_mgr = SkFontMgr_New_GDI();
+  else
+	dwrite_enabled = true;
 
   // Override the default skia font manager. This must be called before any
   // use of the skia font manager is done (e.g. before any call to
@@ -70,6 +139,10 @@ void InitializeDirectWrite() {
   skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
 }
 
+bool IsDirectWriteEnabled() {
+  return dwrite_enabled;
+}
+
 IDWriteFactory* GetDirectWriteFactory() {
   // Some unittests may access this accessor without any previous call to
   // |InitializeDirectWrite|. A call to |InitializeDirectWrite| after this
@@ -143,4 +216,4 @@ absl::optional<std::string> RetrieveLocalizedFontName(
 }
 
 }  // namespace win
-}  // namespace gfx
+}  // namespace gfx
\ No newline at end of file
diff --git a/ui/gfx/win/direct_write.h b/ui/gfx/win/direct_write.h
index 72022056d29c4..6185acdd2c2de 100644
--- a/ui/gfx/win/direct_write.h
+++ b/ui/gfx/win/direct_write.h
@@ -13,10 +13,16 @@
 
 namespace gfx {
 namespace win {
+
+// Returns whether DirectWrite font rendering should be used.
+GFX_EXPORT bool ShouldUseDirectWrite();
 
 GFX_EXPORT void InitializeDirectWrite();
 
-// Creates a DirectWrite factory.
+// Returns true if we are using DirectWrite for font metrics and rendering.
+GFX_EXPORT bool IsDirectWriteEnabled();
+
+// Creates a DirectWrite factory, if using DirectWrite.
 GFX_EXPORT void CreateDWriteFactory(IDWriteFactory** factory);
 
 // Returns the global DirectWrite factory.
diff --git a/ui/native_theme/caption_style_win.cc b/ui/native_theme/caption_style_win.cc
index 2c27d56f29eaa..9c314a5185c7f 100644
--- a/ui/native_theme/caption_style_win.cc
+++ b/ui/native_theme/caption_style_win.cc
@@ -14,6 +14,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/color_utils.h"
@@ -172,8 +173,18 @@ std::string GetCssColorWithAlpha(CC::ClosedCaptionColor caption_color,
 
 absl::optional<CaptionStyle> InitializeFromSystemSettings() {
   TRACE_EVENT0("ui", "InitializeFromSystemSettings");
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
   DCHECK(base::FeatureList::IsEnabled(features::kSystemCaptionStyle));
 
+  // Need to do this check before using ScopedHString.
+  bool can_use_scoped_hstring =
+      base::win::ResolveCoreWinRTDelayload() &&
+      base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!can_use_scoped_hstring)
+    return absl::nullopt;
+
+
   base::win::ScopedHString closed_caption_properties_string =
       base::win::ScopedHString::Create(
           RuntimeClass_Windows_Media_ClosedCaptioning_ClosedCaptionProperties);
@@ -270,10 +281,12 @@ absl::optional<CaptionStyle> InitializeFromSystemSettings() {
 }  // namespace
 
 absl::optional<CaptionStyle> CaptionStyle::FromSystemSettings() {
-  if (base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
     return InitializeFromSystemSettings();
   }
-  // Return default CaptionStyle if kSystemCaptionStyle is not enabled.
+  // Return default CaptionStyle for pre Win10 versions since system settings
+  // don't allow caption styling.
   return absl::nullopt;
 }
 
diff --git a/ui/snapshot/snapshot_win.cc b/ui/snapshot/snapshot_win.cc
index 74d600db1ea5e..d6b9e8fcadd25 100644
--- a/ui/snapshot/snapshot_win.cc
+++ b/ui/snapshot/snapshot_win.cc
@@ -5,7 +5,6 @@
 #include "ui/snapshot/snapshot_win.h"
 
 #include <memory>
-#include <utility>
 
 #include "base/functional/callback.h"
 #include "base/win/windows_version.h"
@@ -21,6 +20,17 @@
 #include "ui/snapshot/snapshot.h"
 #include "ui/snapshot/snapshot_aura.h"
 
+namespace {
+
+// Windows 8.1 is the first version that supports PW_RENDERFULLCONTENT.
+// Without that flag PrintWindow may not correctly capture what's actually
+// onscreen.
+bool UseAuraSnapshot() {
+  return (base::win::GetVersion() < base::win::Version::WIN8_1);
+}
+
+}  // namespace
+
 namespace ui {
 
 namespace internal {
@@ -29,6 +39,7 @@ bool GrabHwndSnapshot(HWND window_handle,
                       const gfx::Rect& snapshot_bounds_in_pixels,
                       const gfx::Rect& clip_rect_in_pixels,
                       gfx::Image* image) {
+  BOOL result = false;
   gfx::Rect snapshot_bounds_in_window =
       snapshot_bounds_in_pixels + clip_rect_in_pixels.OffsetFromOrigin();
   gfx::Size bitmap_size(snapshot_bounds_in_window.right(),
@@ -43,8 +54,32 @@ bool GrabHwndSnapshot(HWND window_handle,
   // but works starting in Windows 8.1. It allows for capturing the contents of
   // the window that are drawn using DirectComposition.
   UINT flags = PW_CLIENTONLY | PW_RENDERFULLCONTENT;
-
-  BOOL result = PrintWindow(window_handle, mem_hdc, flags);
+
+  if (base::win::GetVersion() >= base::win::Version::WIN8_1){
+	result = PrintWindow(window_handle, mem_hdc, flags);
+  }
+  else {
+	// PrintWindow does not work for pre-Windows 8.1. So we'll use BitBlt.
+	// Copying from the window's actual HDC doesn't work so let's just use the full screen HDC.
+	// When a snapshot is captured the focus should be on the browser window anyway.
+	HDC window_hdc = GetDC(NULL);
+
+	RECT window_rect;
+
+	memset(&window_rect, 0, sizeof(RECT));
+
+	result = GetWindowRect(window_handle, &window_rect);
+
+	 if (!result) {
+    PLOG(ERROR) << "Failed to get valid rect for snapshot area.";
+    return false;
+    }
+	// The left of the snapshot "window" rect is offset by 8 pixels to remove a bit of the dark grey showing through.
+	result = BitBlt(mem_hdc, 0, 0, bitmap_size.width(), bitmap_size.height(),
+					window_hdc, window_rect.left + 8, window_rect.top, SRCCOPY);
+
+	DeleteDC(window_hdc);
+  }
   if (!result) {
     PLOG(ERROR) << "Failed to print window";
     return false;
@@ -85,6 +120,11 @@ bool GrabViewSnapshot(gfx::NativeView view_handle,
 bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
                         const gfx::Rect& snapshot_bounds,
                         gfx::Image* image) {
+  if (UseAuraSnapshot()) {
+    // Not supported in Aura.  Callers should fall back to the async version.
+    return false;
+  }
+
   DCHECK(window_handle);
   gfx::Rect window_bounds = window_handle->GetBoundsInRootWindow();
   aura::WindowTreeHost* host = window_handle->GetHost();
@@ -109,6 +149,10 @@ bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
 void GrabWindowSnapshotAsync(gfx::NativeWindow window,
                              const gfx::Rect& source_rect,
                              GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(window, source_rect, std::move(callback));
+    return;
+  }
   gfx::Image image;
   GrabWindowSnapshot(window, source_rect, &image);
   std::move(callback).Run(image);
@@ -117,6 +161,10 @@ void GrabWindowSnapshotAsync(gfx::NativeWindow window,
 void GrabViewSnapshotAsync(gfx::NativeView view,
                            const gfx::Rect& source_rect,
                            GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(view, source_rect, std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
@@ -125,8 +173,13 @@ void GrabWindowSnapshotAndScaleAsync(gfx::NativeWindow window,
                                      const gfx::Rect& source_rect,
                                      const gfx::Size& target_size,
                                      GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAndScaleAsyncAura(window, source_rect, target_size,
+                                        std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/views/controls/label.cc b/ui/views/controls/label.cc
index a1a17ca0f4090..c45c6e5b98b4c 100644
--- a/ui/views/controls/label.cc
+++ b/ui/views/controls/label.cc
@@ -41,6 +41,10 @@
 #include "ui/views/style/typography.h"
 #include "ui/views/style/typography_provider.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace {
 
 // An enum giving different RenderText properties unique keys for the
@@ -1153,6 +1157,13 @@ void Label::Init(const std::u16string& text,
                  gfx::DirectionalityMode directionality_mode) {
   full_text_ = gfx::RenderText::CreateRenderText();
   full_text_->SetHorizontalAlignment(gfx::ALIGN_CENTER);
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled() &&
+  (text_context_ != style::CONTEXT_MENU && text_context_ != style::CONTEXT_DIALOG_TITLE)) {
+	  full_text_->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+  } // The bookmark bar labels and some of the side text in the menus are CONTEXT_BUTTON.
+	// The "new tab" labels are CONTEXT_LABEL.
+  #endif
   full_text_->SetFontList(font_list);
   full_text_->SetCursorEnabled(false);
   full_text_->SetWordWrapBehavior(gfx::TRUNCATE_LONG_WORDS);
diff --git a/ui/views/controls/scrollbar/scroll_bar.cc b/ui/views/controls/scrollbar/scroll_bar.cc
index da848fcdc1784..4184e62a9d93f 100644
--- a/ui/views/controls/scrollbar/scroll_bar.cc
+++ b/ui/views/controls/scrollbar/scroll_bar.cc
@@ -438,6 +438,11 @@ void ScrollBar::TrackClicked() {
 
 void ScrollBar::ScrollContentsToOffset() {
   ScrollToPosition(contents_scroll_offset_);
+  // Safeguard against a divide-by-zero bug that happens when separating
+  // multiple tabs into separate windows.
+  contents_size_ = std::max(1, contents_size_);
+  viewport_size_ = std::max(1, viewport_size_);
+
   thumb_->SetPosition(CalculateThumbPosition(contents_scroll_offset_));
 }
 
@@ -459,6 +464,7 @@ int ScrollBar::CalculateThumbPosition(int contents_scroll_offset) const {
   if (viewport_size_ == contents_size_) {
     return 0;
   }
+
   return (contents_scroll_offset * thumb_max) /
          (contents_size_ - viewport_size_);
 }
diff --git a/ui/views/controls/textfield/textfield.cc b/ui/views/controls/textfield/textfield.cc
index 562d300d13db4..b7ee33b25ef19 100644
--- a/ui/views/controls/textfield/textfield.cc
+++ b/ui/views/controls/textfield/textfield.cc
@@ -79,6 +79,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/win_util.h"
+#include "ui/gfx/win/direct_write.h"
 #endif
 
 #if BUILDFLAG(IS_LINUX)
@@ -615,6 +616,12 @@ void Textfield::FitToLocalBounds() {
   } else {
     // The text will draw with the correct vertical alignment if we don't apply
     // the vertical insets.
+
+	#if BUILDFLAG(IS_WIN)
+    if (!gfx::win::IsDirectWriteEnabled()) {
+	  GetRenderText()->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+	}
+	#endif
     bounds.Inset(gfx::Insets::TLBR(0, insets.left(), 0, insets.right()));
   }
 
@@ -1785,6 +1792,7 @@ bool Textfield::ChangeTextDirectionAndLayoutAlignment(
       modes_match && GetHorizontalAlignment() == gfx::ALIGN_TO_HEAD;
   if (!dir_from_text && GetHorizontalAlignment() != gfx::ALIGN_CENTER)
     SetHorizontalAlignment(default_rtl ? gfx::ALIGN_RIGHT : gfx::ALIGN_LEFT);
+
   SchedulePaint();
   return true;
 }
diff --git a/ui/views/views_features.cc b/ui/views/views_features.cc
index 9c296ba65e0b7..fb9aba323cdba 100644
--- a/ui/views/views_features.cc
+++ b/ui/views/views_features.cc
@@ -28,5 +28,9 @@ BASE_FEATURE(kEnableViewPaintOptimization,
 BASE_FEATURE(kWidgetLayering,
              "WidgetLayering",
              base::FEATURE_ENABLED_BY_DEFAULT);
+
+// When enabled, widgets inherit the theme from their parent widget.
+const base::Feature kInheritNativeThemeFromParentWidget{
+    "InheritNativeThemeFromParentWidget", base::FEATURE_ENABLED_BY_DEFAULT};
 
 }  // namespace views::features
diff --git a/ui/views/views_features.h b/ui/views/views_features.h
index 3aa4134a57bfd..1ce27ec6af709 100644
--- a/ui/views/views_features.h
+++ b/ui/views/views_features.h
@@ -15,6 +15,7 @@ namespace views::features {
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kEnablePlatformHighContrastInkDrop);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kEnableViewPaintOptimization);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kWidgetLayering);
+VIEWS_EXPORT BASE_DECLARE_FEATURE(kInheritNativeThemeFromParentWidget);
 
 }  // namespace views::features
 
diff --git a/ui/views/widget/widget.cc b/ui/views/widget/widget.cc
index 2f552f72074e3..c8f8615036096 100644
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -11,6 +11,7 @@
 #include "base/auto_reset.h"
 #include "base/check_op.h"
 #include "base/containers/adapters.h"
+#include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
 #include "base/notreached.h"
@@ -2058,7 +2059,9 @@ const ui::NativeTheme* Widget::GetNativeTheme() const {
   if (native_theme_)
     return native_theme_;
 
-  if (parent_)
+if (base::FeatureList::IsEnabled(
+          features::kInheritNativeThemeFromParentWidget) &&
+      parent_)
     return parent_->GetNativeTheme();
 
 #if BUILDFLAG(IS_LINUX)
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index f43aa724b2a8e..8956e92107f0a 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -29,6 +29,8 @@
 #include "base/win/dark_mode_support.h"
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
+#include "chrome/browser/win/titlebar_config.h"
 #include "services/tracing/public/cpp/perfetto/macros.h"
 #include "third_party/perfetto/protos/perfetto/trace/track_event/chrome_window_handle_event_info.pbzero.h"
 #include "third_party/skia/include/core/SkPath.h"
@@ -385,7 +387,8 @@ class HWNDMessageHandler::ScopedRedrawLock {
         hwnd_(owner_->hwnd()),
         should_lock_(owner_->IsVisible() && !owner->HasChildRenderingWindow() &&
                      ::IsWindow(hwnd_) && !owner_->IsHeadless() &&
-                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION))) {
+                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION) ||
+					  ShouldCustomDrawSystemTitlebar())) {
     if (should_lock_)
       owner_->LockUpdates();
   }
@@ -709,7 +712,8 @@ void HWNDMessageHandler::SetBounds(const gfx::Rect& bounds_in_pixels,
 }
 
 void HWNDMessageHandler::SetDwmFrameExtension(DwmFrameState state) {
-  if (!delegate_->HasFrame() && !is_translucent_) {
+  if (!delegate_->HasFrame() && !ShouldCustomDrawSystemTitlebar() &&
+	  !is_translucent_) {
     MARGINS m = {0, 0, 0, 0};
     if (state == DwmFrameState::kOn && !IsMaximized())
       m = {0, 0, 1, 0};
@@ -2010,7 +2014,8 @@ void HWNDMessageHandler::OnEnterSizeMove() {
 
 LRESULT HWNDMessageHandler::OnEraseBkgnd(HDC dc) {
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
+  if (!ShouldCustomDrawSystemTitlebar() &&
+	  delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
       needs_dwm_frame_clear_) {
     // This is necessary to avoid white flashing in the titlebar area around the
     // minimize/maximize/close buttons.
@@ -2236,8 +2241,12 @@ LRESULT HWNDMessageHandler::OnMouseRange(UINT message,
 LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
                                               WPARAM w_param,
                                               LPARAM l_param) {
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     return PA_NOACTIVATE;
   }
@@ -2245,18 +2254,24 @@ LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
   return -1;
 }
 
+
 LRESULT HWNDMessageHandler::OnPointerEvent(UINT message,
                                            WPARAM w_param,
                                            LPARAM l_param) {
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   POINTER_INPUT_TYPE pointer_type;
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
   // If the WM_POINTER messages are not sent from a stylus device, then we do
   // not handle them to make sure we do not change the current behavior of
   // touch and mouse inputs.
-  if (!::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type)) {
+  if (!get_pointer_type || !get_pointer_type(pointer_id, &pointer_type)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   // |HandlePointerEventTypePenClient| assumes all pen events happen on the
   // client area, so WM_NCPOINTER messages sent to it would eventually be
   // dropped and the native frame wouldn't be able to respond to pens.
@@ -2576,6 +2591,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
   // It's required to avoid some native painting artifacts from appearing when
   // the window is resized.
   if (!delegate_->HasNonClientView() || IsFrameSystemDrawn()) {
+	  if (!ShouldCustomDrawSystemTitlebar()) {
     // The default WM_NCPAINT handler under Aero Glass doesn't clear the
     // nonclient area, so it'll remain the default white color. That area is
     // invisible initially (covered by the window border) but can become
@@ -2598,6 +2614,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
     ::FillRect(dc, &dirty_region, brush);
     ::DeleteObject(brush);
     ::ReleaseDC(hwnd(), dc);
+	}
     SetMsgHandled(FALSE);
     return;
   }
@@ -2946,6 +2963,18 @@ LRESULT HWNDMessageHandler::OnTouchEvent(UINT message,
       POINT point;
       point.x = TOUCH_COORD_TO_PIXEL(input[i].x);
       point.y = TOUCH_COORD_TO_PIXEL(input[i].y);
+
+	  if (base::win::GetVersion() == base::win::Version::WIN7) {
+		  // Windows 7 sends touch events for NC area touches but Win8+ do not.
+		  // This code will be used to make Windows 7 ignore these touches as well.
+
+		  LPARAM l_param_ht = MAKELPARAM(point.x, point.y);
+		  LRESULT hittest = SendMessage(hwnd(), WM_NCHITTEST, 0, l_param_ht);
+
+		  if (hittest != HTCLIENT)
+			  return 0;
+	  }
+
       ScreenToClient(hwnd(), &point);
 
       last_touch_or_pen_message_time_ = ::GetMessageTime();
@@ -3589,12 +3618,18 @@ LRESULT HWNDMessageHandler::HandlePointerEventTypePenClient(UINT message,
                                                             WPARAM w_param,
                                                             LPARAM l_param) {
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerPenInfoFn = BOOL(WINAPI*)(UINT32, POINTER_PEN_INFO*);
   POINTER_PEN_INFO pointer_pen_info;
-  if (!GetPointerPenInfo(pointer_id, &pointer_pen_info)) {
+  static const auto get_pointer_pen_info =
+      reinterpret_cast<GetPointerPenInfoFn>(
+          base::win::GetUser32FunctionPointer("GetPointerPenInfo"));
+  if (!get_pointer_pen_info ||
+      !get_pointer_pen_info(pointer_id, &pointer_pen_info)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   return HandlePointerEventTypePen(message, pointer_id, pointer_pen_info);
 }
 
@@ -3620,7 +3655,6 @@ bool HWNDMessageHandler::IsSynthesizedMouseMessage(unsigned int message,
 }
 
 void HWNDMessageHandler::PerformDwmTransition() {
-  CHECK(IsFrameSystemDrawn());
 
   dwm_transition_desired_ = false;
   delegate_->HandleFrameChanged();
@@ -3631,7 +3665,8 @@ void HWNDMessageHandler::UpdateDwmFrame() {
   TRACE_EVENT0("ui", "HWNDMessageHandler::UpdateDwmFrame");
 
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets)) {
+  if (!ShouldCustomDrawSystemTitlebar() &&
+      delegate_->GetDwmFrameInsetsInPixels(&insets)) {
     MARGINS margins = {insets.left(), insets.right(), insets.top(),
                        insets.bottom()};
     DwmExtendFrameIntoClientArea(hwnd(), &margins);
diff --git a/ui/views/win/pen_id_handler.cc b/ui/views/win/pen_id_handler.cc
index 96826a9c5b271..94bbc3c3c8f94 100644
--- a/ui/views/win/pen_id_handler.cc
+++ b/ui/views/win/pen_id_handler.cc
@@ -38,7 +38,15 @@ class PenIdStatics {
     if (skip_initialization_) {
       return;
     }
+
     SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+    if(!base::win::ResolveCoreWinRTDelayload()){
+	  pen_device_statics_ = nullptr;
+	  pointer_point_statics_ = nullptr;
+	  return;
+    }
+
     base::win::AssertComInitialized();
     base::win::RoGetActivationFactory(
         base::win::HStringReference(
@@ -245,4 +253,4 @@ void PenIdHandler::InitPenIdStatics() {
       base::BindOnce(base::IgnoreResult(&PenIdStatics::GetInstance)));
 }
 
-}  // namespace views
+}  // namespace views
\ No newline at end of file
