diff --git a/README.md b/README.md
index 590f4c94f2067..7091f956b88b7 100644
--- a/README.md
+++ b/README.md
@@ -1,21 +1,36 @@
-# ![Logo](chrome/app/theme/chromium/product_logo_64.png) Chromium
+# Supermium + Thorium
+An up-to-date, compiler optimized Chromium-based web browser compatible with Windows XP, Vista, 7, 8, and 8.1.
 
-Chromium is an open-source browser project that aims to build a safer, faster,
-and more stable way for all users to experience the web.
+The Supermium web browser also provides the following features:
 
-The project's web site is https://www.chromium.org.
+-Aero Glass and Aero Glass-style titlebars instead of Windows 10-style ones (#disable-aero in chrome://flags for the latter)
 
-To check out the source code locally, don't use `git clone`! Instead,
-follow [the instructions on how to get the code](docs/get_the_code.md).
+-Turnaround for major vulnerability patches generally less than one week from upstream disclosure
 
-Documentation in the source is rooted in [docs/README.md](docs/README.md).
+-A functional sandbox for enhanced security
 
-Learn how to [Get Around the Chromium Source Code Directory
-Structure](https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code).
+-Google Sync
 
-For historical reasons, there are some small top level directories. Now the
-guidance is that new top level directories are for product (e.g. Chrome,
-Android WebView, Ash). Even if these products have multiple executables, the
-code should be in subdirectories of the product.
+-On Windows 7 and up, Widevine CDM support for viewing DRM content
 
-If you found a bug, please file it at https://crbug.com/new.
+-GDI font rendering, using #force-gdi in chrome://flags
+
+-Persistent dark mode on the browser's UI elements, using #force-dark-mode in chrome://flags
+
+-Custom tab options including trapezoidal tabs, transparent tabs, and outlined tabs
+
+-Many flags from ungoogled-chromium
+
+-Support for SSE2-only processors in the 32 bit build
+
+**Future support for:**
+
+-Windows 2000
+
+-Ungoogled Chromium features (in progress)
+
+-WebGPU for D3D9 renderer
+
+-Manifest V2 (once removed by Google)
+
+...and more! If there's a feature you want, which cannot be replicated by a Manifest v2/v3 extension, please ask!
diff --git a/base/BUILD.gn b/base/BUILD.gn
index c00c41bc2c7fd..2f4557aa18fde 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -135,11 +135,6 @@ if (is_win) {
     ldflags = [
       # Linking with shcore.lib causes the shcore api forwarder dll to load.
       "/DELAYLOAD:api-ms-win-shcore-scaling-l1-1-1.dll",
-
-      # Linking with OneCore.lib causes the next three dlls to load.
-      "/DELAYLOAD:api-ms-win-core-realtime-l1-1-1.dll",
-      "/DELAYLOAD:api-ms-win-power-base-l1-1-0.dll",
-      "/DELAYLOAD:api-ms-win-power-setting-l1-1-0.dll",
       "/DELAYLOAD:cfgmgr32.dll",
       "/DELAYLOAD:powrprof.dll",
       "/DELAYLOAD:setupapi.dll",
@@ -1921,7 +1916,6 @@ component("base") {
     libs += [
       "cfgmgr32.lib",
       "ntdll.lib",
-      "onecore.lib",
       "pdh.lib",
       "powrprof.lib",
       "propsys.lib",
diff --git a/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h b/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h
index 44ef45c3e325f..994060bee0a78 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/page_allocator_internals_win.h
@@ -16,6 +16,17 @@
 
 namespace partition_alloc::internal {
 
+namespace {
+
+// On Windows, discarded pages are not returned to the system immediately and
+// not guaranteed to be zeroed when returned to the application.
+using DiscardVirtualMemoryFunction = DWORD(WINAPI*)(PVOID virtualAddress,
+                                                    SIZE_T size);
+DiscardVirtualMemoryFunction s_discard_virtual_memory =
+    reinterpret_cast<DiscardVirtualMemoryFunction>(-1);
+
+}  // namespace
+
 // |VirtualAlloc| will fail if allocation at the hint address is blocked.
 constexpr bool kHintIsAdvisory = false;
 std::atomic<int32_t> s_allocPageErrorCode{ERROR_SUCCESS};
@@ -226,12 +237,20 @@ bool TryRecommitSystemPagesInternal(
 }
 
 void DiscardSystemPagesInternal(uintptr_t address, size_t length) {
+  if (s_discard_virtual_memory ==
+      reinterpret_cast<DiscardVirtualMemoryFunction>(-1)) {
+      s_discard_virtual_memory =
+          reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+              GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+  }
+
   void* ptr = reinterpret_cast<void*>(address);
   // Use DiscardVirtualMemory when available because it releases faster than
   // MEM_RESET.
-  DWORD ret = DiscardVirtualMemory(ptr, length);
-  // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
-  // failure.
+  DWORD ret = 1;
+  if (s_discard_virtual_memory) {
+    ret = s_discard_virtual_memory(ptr, length);
+  }
   if (ret) {
     PA_CHECK(VirtualAllocWithRetry(ptr, length, MEM_RESET, PAGE_READWRITE));
   }
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc
index 39e574a61a3eb..37ba12bfa8c46 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.cc
@@ -43,6 +43,34 @@ namespace {
 
 #if BUILDFLAG(IS_WIN)
 
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+bool IsLegacyWindowsVersion() {
+  // Use ::RtlGetVersion instead of ::GetVersionEx or helpers from
+  // VersionHelpers.h because those alternatives change their behavior depending
+  // on whether or not the calling executable has a compatibility manifest
+  // resource. It's better for the allocator to not depend on that to decide the
+  // pool size.
+  // Assume legacy if ::RtlGetVersion is not available or it fails.
+  using RtlGetVersion = LONG(WINAPI*)(OSVERSIONINFOEX*);
+  const RtlGetVersion rtl_get_version = reinterpret_cast<RtlGetVersion>(
+      ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"), "RtlGetVersion"));
+  if (!rtl_get_version) {
+    return true;
+  }
+
+  OSVERSIONINFOEX version_info = {};
+  version_info.dwOSVersionInfoSize = sizeof(version_info);
+  if (rtl_get_version(&version_info) != ERROR_SUCCESS) {
+    return true;
+  }
+
+  // Anything prior to Windows 8.1 is considered legacy for the allocator.
+  // Windows 8.1 is major 6 with minor 3.
+  return version_info.dwMajorVersion < 6 ||
+         (version_info.dwMajorVersion == 6 && version_info.dwMinorVersion < 3);
+}
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+
 PA_NOINLINE void HandlePoolAllocFailureOutOfVASpace() {
   PA_NO_CODE_FOLDING();
   PA_CHECK(false);
@@ -67,9 +95,9 @@ PA_NOINLINE void HandlePoolAllocFailure() {
     HandlePoolAllocFailureOutOfVASpace();
   } else if (alloc_page_error_code == ERROR_COMMITMENT_LIMIT ||
              alloc_page_error_code == ERROR_COMMITMENT_MINIMUM) {
-    // Should not happen, since as of Windows 8.1+, reserving address space
-    // should not be charged against the commit limit, aside from a very small
-    // amount per 64kiB block. Keep this path anyway, to check in crash reports.
+    // On Windows <8.1, MEM_RESERVE increases commit charge to account for
+    // not-yet-committed PTEs needed to cover that VA space, if it was to be
+    // committed (see crbug.com/1101421#c16).
     HandlePoolAllocFailureOutOfCommitCharge();
   } else
 #endif  // BUILDFLAG(IS_WIN)
@@ -88,10 +116,7 @@ std::ptrdiff_t PartitionAddressSpace::brp_pool_shadow_offset_ = 0;
 #endif
 
 #if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
-#if !BUILDFLAG(IS_IOS)
-#error Dynamic pool size is only supported on iOS.
-#endif
-
+#if BUILDFLAG(IS_IOS)
 namespace {
 bool IsIOSTestProcess() {
   // On iOS, only applications with the extended virtual addressing entitlement
@@ -133,6 +158,15 @@ PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
 PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
   return IsIOSTestProcess() ? kBRPPoolSizeForIOSTestProcess : kBRPPoolSize;
 }
+#else
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
+  return IsLegacyWindowsVersion() ? kRegularPoolSizeForLegacyWindows
+                                  : kRegularPoolSize;
+}
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
+  return IsLegacyWindowsVersion() ? kBRPPoolSizeForLegacyWindows : kBRPPoolSize;
+}
+#endif  // BUILDFLAG(IS_IOS)
 #endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
 
 void PartitionAddressSpace::Init() {
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h
index 0b115ee775d6d..046918e248fb7 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_address_space.h
@@ -276,6 +276,16 @@ class PA_COMPONENT_EXPORT(PARTITION_ALLOC) PartitionAddressSpace {
   static constexpr size_t kThreadIsolatedPoolSize = kGiB / 4;
   static_assert(std::has_single_bit(kThreadIsolatedPoolSize));
 #endif
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+  // We can't afford pool sizes as large as kPoolMaxSize on Windows <8.1 (see
+  // crbug.com/1101421 and crbug.com/1217759).
+  static constexpr size_t kRegularPoolSizeForLegacyWindows = 4 * kGiB;
+  static constexpr size_t kBRPPoolSizeForLegacyWindows = 4 * kGiB;
+  static_assert(kRegularPoolSizeForLegacyWindows < kRegularPoolSize);
+  static_assert(kBRPPoolSizeForLegacyWindows < kBRPPoolSize);
+  static_assert(std::has_single_bit(kRegularPoolSizeForLegacyWindows));
+  static_assert(std::has_single_bit(kBRPPoolSizeForLegacyWindows));
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
   static constexpr size_t kConfigurablePoolMaxSize = kPoolMaxSize;
   static constexpr size_t kConfigurablePoolMinSize = 1 * kGiB;
   static_assert(kConfigurablePoolMinSize <= kConfigurablePoolMaxSize);
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc
index fd1de0bd29861..c6d5a39bfe2e3 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/rand_util_win.cc
@@ -13,31 +13,27 @@
 
 #include "partition_alloc/partition_alloc_base/check.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
 
 namespace partition_alloc::internal::base {
 
 void RandBytes(void* output, size_t output_length) {
-  // Import bcryptprimitives directly rather than cryptbase to avoid opening a
-  // handle to \\Device\KsecDD in the renderer.
-  // Note: we cannot use a magic static here as PA runs too early in process
-  // startup, but this should be safe as the process will be single-threaded
-  // when this first runs.
-  static decltype(&ProcessPrng) process_prng_fn = nullptr;
-  if (!process_prng_fn) {
-    HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-    PA_BASE_CHECK(hmod);
-    process_prng_fn = reinterpret_cast<decltype(&ProcessPrng)>(
-        GetProcAddress(hmod, "ProcessPrng"));
-    PA_BASE_CHECK(process_prng_fn);
-  }
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  PA_BASE_CHECK(success);
+   char* output_ptr = static_cast<char*>(output);
+   while (output_length > 0) {
+   const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+   const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    PA_BASE_CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+}
+
 }
 
 }  // namespace partition_alloc::internal::base
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
index c6445f267971f..5e19e5f01869b 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
@@ -34,7 +34,7 @@
 static_assert(sizeof(void*) == 8, "");
 #else
 static_assert(sizeof(void*) != 8, "");
-#endif  // PA_CONFIG(HAS_64_BITS_POINTERS)
+#endif  // BUILDFLAG(HAS_64_BITS_POINTERS)
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (defined(__ARM_NEON) || defined(__ARM_NEON__)) && defined(__ARM_FP)
@@ -43,18 +43,23 @@ static_assert(sizeof(void*) != 8, "");
 #define PA_CONFIG_STARSCAN_NEON_SUPPORTED() 0
 #endif
 
-#if BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#if BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) || BUILDFLAG(IS_WIN))
 // Allow PA to select an alternate pool size at run-time before initialization,
 // rather than using a single constexpr value.
 //
 // This is needed on iOS because iOS test processes can't handle large pools
 // (see crbug.com/1250788).
 //
+// This is needed on Windows, because OS versions <8.1 incur commit charge even
+// on reserved address space, thus don't handle large pools well (see
+// crbug.com/1101421 and crbug.com/1217759).
+//
 // This setting is specific to 64-bit, as 32-bit has a different implementation.
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 1
 #else
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 0
-#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) ||
+        // BUILDFLAG(IS_WIN))
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_ANDROID))
diff --git a/base/command_line.cc b/base/command_line.cc
index 69e4303165259..da42a22ed2894 100644
--- a/base/command_line.cc
+++ b/base/command_line.cc
@@ -27,8 +27,8 @@
 #include <windows.h>
 
 #include <shellapi.h>
-
 #include "base/strings/string_util_win.h"
+#include "base/win/windows_version.h"
 #endif  // BUILDFLAG(IS_WIN)
 
 namespace base {
@@ -310,6 +310,7 @@ bool CommandLine::HasSwitch(StringPiece switch_string) const {
 }
 
 bool CommandLine::HasSwitch(const char switch_constant[]) const {
+
   return HasSwitch(StringPiece(switch_constant));
 }
 
diff --git a/base/features.cc b/base/features.cc
index 50cb76282689b..82151c93ffd3e 100644
--- a/base/features.cc
+++ b/base/features.cc
@@ -34,6 +34,20 @@ BASE_FEATURE(kUseRustJsonParser,
 
 BASE_FEATURE(kJsonNegativeZero, "JsonNegativeZero", FEATURE_ENABLED_BY_DEFAULT);
 
+
+
+
+
+BASE_FEATURE(kIncognitoBrandConsistencyForDesktop,
+			"IncognitoBrandConsistencyForDesktop",
+			base::FEATURE_DISABLED_BY_DEFAULT);
+
+#if BUILDFLAG(IS_WIN)
+BASE_FEATURE(kForceGdi,
+             "ForceGdi",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+#endif
+
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
 // Force to enable LowEndDeviceMode partially on Android 3Gb devices.
 // (see PartialLowEndModeOnMidRangeDevices below)
diff --git a/base/features.h b/base/features.h
index a80ac17fb20d1..6b050f7b8bc60 100644
--- a/base/features.h
+++ b/base/features.h
@@ -25,6 +25,14 @@ BASE_EXPORT BASE_DECLARE_FEATURE(kUseRustJsonParser);
 
 BASE_EXPORT BASE_DECLARE_FEATURE(kJsonNegativeZero);
 
+
+
+BASE_EXPORT BASE_DECLARE_FEATURE(kIncognitoBrandConsistencyForDesktop);
+
+#if BUILDFLAG(IS_WIN)
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceGdi);
+#endif
+
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOn3GbDevices);
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOnMidRangeDevices);
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index a12c3324abdba..1ee643a98148f 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -698,7 +698,7 @@ bool GetSecureSystemTemp(FilePath* temp) {
 
   CHECK(temp);
 
-  for (const auto key : {DIR_WINDOWS, DIR_PROGRAM_FILES}) {
+  for (const auto key : {DIR_WINDOWS, DIR_IE_INTERNET_CACHE, DIR_PROGRAM_FILES}) {
     FilePath secure_system_temp;
     if (!PathService::Get(key, &secure_system_temp)) {
       continue;
@@ -1118,11 +1118,37 @@ bool SetNonBlocking(int fd) {
   return false;
 }
 
+namespace {
+
+// ::PrefetchVirtualMemory() is only available on Windows 8 and above. Chrome
+// supports Windows 7, so we need to check for the function's presence
+// dynamically.
+using PrefetchVirtualMemoryPtr = decltype(&::PrefetchVirtualMemory);
+
+// Returns null if ::PrefetchVirtualMemory() is not available.
+PrefetchVirtualMemoryPtr GetPrefetchVirtualMemoryPtr() {
+  HMODULE kernel32_dll = ::GetModuleHandleA("kernel32.dll");
+  return reinterpret_cast<PrefetchVirtualMemoryPtr>(
+      GetProcAddress(kernel32_dll, "PrefetchVirtualMemory"));
+}
+
+}  // namespace
+
 bool PreReadFile(const FilePath& file_path,
                  bool is_executable,
                  int64_t max_bytes) {
   DCHECK_GE(max_bytes, 0);
 
+  // On Win8 and higher use ::PrefetchVirtualMemory(). This is better than a
+  // simple data file read, more from a RAM perspective than CPU. This is
+  // because reading the file as data results in double mapping to
+  // Image/executable pages for all pages of code executed.
+  static PrefetchVirtualMemoryPtr prefetch_virtual_memory =
+      GetPrefetchVirtualMemoryPtr();
+
+  if (prefetch_virtual_memory == nullptr)
+    return internal::PreReadFileSlow(file_path, max_bytes);
+
   if (max_bytes == 0) {
     // ::PrefetchVirtualMemory() fails when asked to read zero bytes.
     // base::MemoryMappedFile::Initialize() fails on an empty file.
@@ -1145,7 +1171,7 @@ bool PreReadFile(const FilePath& file_path,
   // simple data file read, more from a RAM perspective than CPU. This is
   // because reading the file as data results in double mapping to
   // Image/executable pages for all pages of code executed.
-  if (!::PrefetchVirtualMemory(::GetCurrentProcess(),
+  if (!prefetch_virtual_memory(::GetCurrentProcess(),
                                /*NumberOfEntries=*/1, &address_range,
                                /*Flags=*/0)) {
     return internal::PreReadFileSlow(file_path, max_bytes);
@@ -1155,7 +1181,7 @@ bool PreReadFile(const FilePath& file_path,
 
 bool PreventExecuteMapping(const FilePath& path) {
   if (!base::FeatureList::IsEnabled(
-          features::kEnforceNoExecutableFileHandles)) {
+          features::kEnforceNoExecutableFileHandles) || base::win::GetVersion() == base::win::Version::PRE_XP) {
     return true;
   }
 
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index ecba26075f008..2159171af8da0 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -422,11 +422,23 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 #elif BUILDFLAG(IS_WIN)
   // On Windows, discarded pages are not returned to the system immediately and
   // not guaranteed to be zeroed when returned to the application.
+  using DiscardVirtualMemoryFunction =
+      DWORD(WINAPI*)(PVOID virtualAddress, SIZE_T size);
+  static DiscardVirtualMemoryFunction discard_virtual_memory =
+      reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+          GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+
   char* address = static_cast<char*>(shared_memory_mapping_.memory()) +
                   AlignToPageSize(sizeof(SharedState));
   size_t length = AlignToPageSize(mapped_size_);
 
-  DWORD ret = DiscardVirtualMemory(address, length);
+  // Use DiscardVirtualMemory when available because it releases faster than
+  // MEM_RESET.
+  DWORD ret = ERROR_NOT_SUPPORTED;
+  if (discard_virtual_memory) {
+    ret = discard_virtual_memory(address, length);
+  }
+
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret != ERROR_SUCCESS) {
diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index 96986601f6282..ab0bda806704a 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,7 +14,12 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
+
 
 namespace base::subtle {
 
@@ -73,6 +78,7 @@ HANDLE CreateFileMappingWithReducedPermissions(SECURITY_ATTRIBUTES* sa,
   HANDLE h = CreateFileMapping(INVALID_HANDLE_VALUE, sa, PAGE_READWRITE, 0,
                                static_cast<DWORD>(rounded_size), name);
   if (!h) {
+     LOG(ERROR) << "CreateFileMappingW failed with error " << GetLastError() << ".";
     return nullptr;
   }
 
@@ -211,6 +217,17 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(&rand_values, sizeof(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
diff --git a/base/message_loop/message_pump_win.cc b/base/message_loop/message_pump_win.cc
index c30066f515f63..479ba2345565e 100644
--- a/base/message_loop/message_pump_win.cc
+++ b/base/message_loop/message_pump_win.cc
@@ -792,6 +792,7 @@ bool MessagePumpForIO::GetIOItem(DWORD timeout, IOItem* item) {
                                    &overlapped, timeout)) {
     if (!overlapped)
       return false;  // Nothing in the queue.
+
     item->error = GetLastError();
     item->bytes_transfered = 0;
   }
diff --git a/base/metrics/field_trial.cc b/base/metrics/field_trial.cc
index 103e6460442ef..3129ce529d94b 100644
--- a/base/metrics/field_trial.cc
+++ b/base/metrics/field_trial.cc
@@ -51,6 +51,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
+#include "base/win/windows_version.h"
 #endif
 
 #if BUILDFLAG(IS_FUCHSIA)
@@ -714,6 +715,12 @@ void FieldTrialList::CreateTrialsInChildProcess(const CommandLine& cmd_line,
                                                 uint32_t fd_key) {
   global_->create_trials_in_child_process_called_ = true;
 
+#if BUILDFLAG(IS_WIN)
+  if (win::GetVersion() < win::Version::VISTA) {
+    return;
+  }
+#endif
+
 #if BUILDFLAG(USE_BLINK)
   // TODO(crbug.com/867558): Change to a CHECK.
   if (cmd_line.HasSwitch(switches::kFieldTrialHandle)) {
diff --git a/base/power_monitor/power_monitor_device_source_win.cc b/base/power_monitor/power_monitor_device_source_win.cc
index 4e7b6563bc229..3925a372ed509 100644
--- a/base/power_monitor/power_monitor_device_source_win.cc
+++ b/base/power_monitor/power_monitor_device_source_win.cc
@@ -32,8 +32,9 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
       power_event = PowerMonitorSource::POWER_STATE_EVENT;
       break;
     case PBT_APMRESUMEAUTOMATIC:  // Resume from suspend.
-      // We don't notify for PBT_APMRESUMESUSPEND
-      // because, if it occurs, it is always sent as a
+      //case PBT_APMRESUMESUSPEND:  // User-initiated resume from suspend.
+      // We don't notify for this latter event
+      // because if it occurs it is always sent as a
       // second event after PBT_APMRESUMEAUTOMATIC.
       power_event = PowerMonitorSource::RESUME_EVENT;
       break;
@@ -55,6 +56,28 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
   ProcessPowerEventHelper(power_event);
 }
 
+HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags) {
+  const auto register_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::RegisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "RegisterSuspendResumeNotification"));
+  if (!register_suspend_resume_notification_ptr)
+    return nullptr;
+
+  return register_suspend_resume_notification_ptr(hRecipient, Flags);
+}
+
+BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle) {
+  const auto unregister_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::UnregisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "UnregisterSuspendResumeNotification"));
+  if (!unregister_suspend_resume_notification_ptr)
+    return FALSE;
+
+  return unregister_suspend_resume_notification_ptr(Handle);
+}
+
 }  // namespace
 
 void PowerMonitorDeviceSource::PlatformInit() {
@@ -79,7 +102,7 @@ void PowerMonitorDeviceSource::PlatformDestroy() {
 // battery power.  Returns true if running on battery.
 bool PowerMonitorDeviceSource::IsOnBatteryPower() {
   SYSTEM_POWER_STATUS status;
-  if (!::GetSystemPowerStatus(&status)) {
+  if (!GetSystemPowerStatus(&status)) {
     DPLOG(ERROR) << "GetSystemPowerStatus failed";
     return false;
   }
@@ -92,7 +115,8 @@ int PowerMonitorDeviceSource::GetInitialSpeedLimit() {
   return PowerThermalObserver::kSpeedLimitMax;
 }
 
-PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
+PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow()
+    : instance_(NULL), message_hwnd_(NULL) {
   if (!CurrentUIThread::IsSet()) {
     // Creating this window in (e.g.) a renderer inhibits shutdown on Windows.
     // See http://crbug.com/230122. TODO(vandebo): http://crbug.com/236031
@@ -105,18 +129,21 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
       kWindowClassName,
       &base::win::WrappedWindowProc<
           PowerMonitorDeviceSource::PowerMessageWindow::WndProcThunk>,
-      0, 0, 0, nullptr, nullptr, nullptr, nullptr, nullptr, &window_class);
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL,
+      &window_class);
   instance_ = window_class.hInstance;
-  ATOM clazz = ::RegisterClassEx(&window_class);
+  ATOM clazz = RegisterClassEx(&window_class);
   DCHECK(clazz);
 
   message_hwnd_ =
-      ::CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, nullptr, WS_POPUP, 0,
-                       0, 0, 0, nullptr, nullptr, instance_, nullptr);
+      CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, NULL, WS_POPUP, 0, 0,
+                     0, 0, NULL, NULL, instance_, NULL);
   if (message_hwnd_) {
-    // On machines with modern standby calling RegisterSuspendResumeNotification
-    // is required in order to get the PBT_APMSUSPEND message.
-    power_notify_handle_ = ::RegisterSuspendResumeNotification(
+    // On machines with modern standby and Win8+, calling
+    // RegisterSuspendResumeNotification is required in order to get the
+    // PBT_APMSUSPEND message. The notification is no longer automatically
+    // fired.
+    power_notify_handle_ = base::RegisterSuspendResumeNotification(
         message_hwnd_, DEVICE_NOTIFY_WINDOW_HANDLE);
   }
 }
@@ -124,10 +151,10 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
 PowerMonitorDeviceSource::PowerMessageWindow::~PowerMessageWindow() {
   if (message_hwnd_) {
     if (power_notify_handle_)
-      ::UnregisterSuspendResumeNotification(power_notify_handle_);
+      base::UnregisterSuspendResumeNotification(power_notify_handle_);
 
-    ::DestroyWindow(message_hwnd_);
-    ::UnregisterClass(kWindowClassName, instance_);
+    DestroyWindow(message_hwnd_);
+    UnregisterClass(kWindowClassName, instance_);
   }
 }
 
diff --git a/base/process/launch_win.cc b/base/process/launch_win.cc
index eca51fa33f7fc..af5924614ed2e 100644
--- a/base/process/launch_win.cc
+++ b/base/process/launch_win.cc
@@ -273,14 +273,17 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
   if (!options.handles_to_inherit.empty())
     ++attribute_count;
 
-  // Reserve space for attributes.
-  if (attribute_count > 0) {
-    if (!startup_info_wrapper.InitializeProcThreadAttributeList(
-            attribute_count)) {
-      DPLOG(ERROR);
-      return Process();
-    }
-    flags |= EXTENDED_STARTUPINFO_PRESENT;
+
+  if (base::win::GetVersion() >= base::win::Version::VISTA) {
+	  // Reserve space for attributes.
+	  if (attribute_count > 0) {
+		if (!startup_info_wrapper.InitializeProcThreadAttributeList(
+				attribute_count)) {
+		  DPLOG(ERROR);
+		  return Process();
+		}
+		flags |= EXTENDED_STARTUPINFO_PRESENT;
+	  }
   }
 
   // Set PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY.
@@ -298,7 +301,11 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
 
   // Set PROC_THREAD_ATTRIBUTE_HANDLE_LIST.
   bool inherit_handles = options.inherit_mode == LaunchOptions::Inherit::kAll;
-  if (!options.handles_to_inherit.empty()) {
+  if (!options.handles_to_inherit.empty() &&
+	  base::win::GetVersion() < base::win::Version::VISTA) {
+	  inherit_handles = true;
+  }
+  if (!options.handles_to_inherit.empty() && base::win::GetVersion() >= base::win::Version::VISTA) {
     DCHECK_GT(attribute_count, 0u);
     DCHECK_EQ(options.inherit_mode, LaunchOptions::Inherit::kSpecific);
 
diff --git a/base/process/process_util_unittest.cc b/base/process/process_util_unittest.cc
index 18bed2128814c..d563938dc4e2e 100644
--- a/base/process/process_util_unittest.cc
+++ b/base/process/process_util_unittest.cc
@@ -829,11 +829,19 @@ TEST_F(ProcessUtilTest, LaunchAsUser) {
 }
 
 MULTIPROCESS_TEST_MAIN(ChildVerifiesCetDisabled) {
-  // Policy not defined for Win < Win10 20H1 but that's ok.
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
+  // Not available for Win7 but this process should still work.
+  if (!get_process_mitigation_policy)
+    return kSuccess;
+
+  // Policy not defined for Win < Win10 20H1 but that's also ok.
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-  if (GetProcessMitigationPolicy(GetCurrentProcess(),
-                                 ProcessUserShadowStackPolicy, &policy,
-                                 sizeof(policy))) {
+  if (get_process_mitigation_policy(GetCurrentProcess(),
+                                    ProcessUserShadowStackPolicy, &policy,
+                                    sizeof(policy))) {
     if (policy.EnableUserShadowStack)
       return 1;
   }
diff --git a/base/process/process_win.cc b/base/process/process_win.cc
index 9a414d886f779..917e2a9a18233 100644
--- a/base/process/process_win.cc
+++ b/base/process/process_win.cc
@@ -265,35 +265,12 @@ bool Process::SetPriority(Priority priority) {
   // priority inversion, and having a process put itself in background mode is
   // broken in Windows 11 22H2. So, it is no longer supported. See
   // https://crbug.com/1396155 for details.
+  // NOTE: NtSetInformationProcess call (SetProcessInformation really) using ProcessPowerThrottling class removed because it is useless before Windows 10.
   DCHECK(!is_current());
   const DWORD priority_class = priority == Priority::kBestEffort
                                    ? IDLE_PRIORITY_CLASS
                                    : NORMAL_PRIORITY_CLASS;
 
-  if (base::win::OSInfo::GetInstance()->version() >=
-          base::win::Version::WIN11 &&
-      FeatureList::IsEnabled(kUseEcoQoSForBackgroundProcess)) {
-    PROCESS_POWER_THROTTLING_STATE power_throttling;
-    RtlZeroMemory(&power_throttling, sizeof(power_throttling));
-    power_throttling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;
-
-    if (priority == Priority::kBestEffort) {
-      // Sets Eco QoS level.
-      power_throttling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-      power_throttling.StateMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-    } else {
-      // Uses system default.
-      power_throttling.ControlMask = 0;
-      power_throttling.StateMask = 0;
-    }
-    bool ret =
-        ::SetProcessInformation(Handle(), ProcessPowerThrottling,
-                                &power_throttling, sizeof(power_throttling));
-    if (ret == 0) {
-      DPLOG(ERROR) << "Setting process QoS policy fails";
-    }
-  }
-
   return (::SetPriorityClass(Handle(), priority_class) != 0);
 }
 
diff --git a/base/rand_util_win.cc b/base/rand_util_win.cc
index 6aae763d98715..f1f21d13fba42 100644
--- a/base/rand_util_win.cc
+++ b/base/rand_util_win.cc
@@ -9,6 +9,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <atomic>
 #include <limits>
@@ -18,12 +25,6 @@
 #include "third_party/boringssl/src/include/openssl/crypto.h"
 #include "third_party/boringssl/src/include/openssl/rand.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace base {
 
 namespace internal {
@@ -53,18 +54,6 @@ bool UseBoringSSLForRandBytes() {
 
 namespace {
 
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
 void RandBytes(span<uint8_t> output, bool avoid_allocation) {
   if (!avoid_allocation && internal::UseBoringSSLForRandBytes()) {
     // Ensure BoringSSL is initialized so it can use things like RDRAND.
@@ -74,11 +63,18 @@ void RandBytes(span<uint8_t> output, bool avoid_allocation) {
     return;
   }
 
-  static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-  BOOL success =
-      process_prng_fn(static_cast<BYTE*>(output.data()), output.size());
-  // ProcessPrng is documented to always return TRUE.
-  CHECK(success);
+  unsigned char* output_ptr = output.data();
+  size_t output_size = output.size();
+  while (output_size > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_size, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    CHECK(success);
+    output_size -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+}
+
 }
 
 }  // namespace
diff --git a/base/sampling_heap_profiler/poisson_allocation_sampler.cc b/base/sampling_heap_profiler/poisson_allocation_sampler.cc
index 9c449e95ee85d..ea299d25f35ef 100644
--- a/base/sampling_heap_profiler/poisson_allocation_sampler.cc
+++ b/base/sampling_heap_profiler/poisson_allocation_sampler.cc
@@ -241,6 +241,7 @@ void PoissonAllocationSampler::DoRecordAllocation(
     size_t size,
     base::allocator::dispatcher::AllocationSubsystem type,
     const char* context) {
+
   ThreadLocalData* const thread_local_data = GetThreadLocalData();
 
   thread_local_data->accumulated_bytes += size;
diff --git a/base/system/sys_info_win.cc b/base/system/sys_info_win.cc
index 68626967de317..0c68025ebf605 100644
--- a/base/system/sys_info_win.cc
+++ b/base/system/sys_info_win.cc
@@ -153,6 +153,9 @@ int SysInfo::NumberOfProcessors() {
 
 // static
 int SysInfo::NumberOfEfficientProcessorsImpl() {
+  // No efficiency support before Windows 10.
+  if (win::GetVersion() < win::Version::WIN10)
+	  return 0;
   std::vector<BYTE> efficiency_classes = GetCoreEfficiencyClasses();
   if (efficiency_classes.empty())
     return 0;
diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 38888cf0448a9..a7423863f3716 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -17,7 +17,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base {
@@ -445,8 +447,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
 
     // TODO(crbug.com/1498668): rollback the change or replace it with a CHECK
     // before closing the bug.
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index b8a0d23a43f6c..52291c7803a6b 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -54,6 +54,13 @@ namespace {
 // Flag used to set thread priority to |THREAD_PRIORITY_LOWEST| for
 // |kUseThreadPriorityLowest| Feature.
 std::atomic<bool> g_use_thread_priority_lowest{false};
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
 // Flag used to map Compositing ThreadType |THREAD_PRIORITY_ABOVE_NORMAL| on the
 // UI thread for |kAboveNormalCompositingBrowserWin| Feature.
 std::atomic<bool> g_above_normal_compositing_browser{true};
@@ -244,7 +251,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -443,8 +453,12 @@ void SetCurrentThreadPriority(ThreadType thread_type,
     // Override the memory priority.
     MEMORY_PRIORITY_INFORMATION memory_priority{.MemoryPriority =
                                                     MEMORY_PRIORITY_NORMAL};
+	  static const auto set_thread_information_fn =
+      reinterpret_cast<decltype(&::SetThreadInformation)>(::GetProcAddress(
+          ::GetModuleHandle(L"kernel32.dll"), "SetThreadInformation"));
+      DCHECK(set_thread_information_fn);
     [[maybe_unused]] const BOOL memory_priority_success =
-        SetThreadInformation(thread_handle, ::ThreadMemoryPriority,
+        set_thread_information_fn(thread_handle, ::ThreadMemoryPriority,
                              &memory_priority, sizeof(memory_priority));
     DPLOG_IF(ERROR, !memory_priority_success)
         << "Set thread memory priority failed.";
@@ -467,6 +481,15 @@ void SetCurrentThreadPriority(ThreadType thread_type,
 
 void SetCurrentThreadQualityOfService(ThreadType thread_type) {
   // QoS and power throttling were introduced in Win10 1709.
+ if (win::GetVersion() < win::Version::WIN10_RS3) {
+    return;
+  }
+
+  static const auto set_thread_information_fn =
+      reinterpret_cast<decltype(&::SetThreadInformation)>(::GetProcAddress(
+          ::GetModuleHandle(L"kernel32.dll"), "SetThreadInformation"));
+  DCHECK(set_thread_information_fn);
+
   bool desire_ecoqos = false;
   switch (thread_type) {
     case ThreadType::kBackground:
@@ -489,11 +512,10 @@ void SetCurrentThreadQualityOfService(ThreadType thread_type) {
       .StateMask =
           desire_ecoqos ? THREAD_POWER_THROTTLING_EXECUTION_SPEED : 0ul,
   };
-  [[maybe_unused]] const BOOL success = ::SetThreadInformation(
+  [[maybe_unused]] const BOOL success = set_thread_information_fn(
       ::GetCurrentThread(), ::ThreadPowerThrottling,
       &thread_power_throttling_state, sizeof(thread_power_throttling_state));
-  // Failure is expected on versions of Windows prior to RS3.
-  DPLOG_IF(ERROR, !success && win::GetVersion() >= win::Version::WIN10_RS3)
+  DPLOG_IF(ERROR, !success)
       << "Failed to set EcoQoS to " << std::boolalpha << desire_ecoqos;
 }
 
@@ -548,8 +570,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
     return ThreadPriorityForTest::kBackground;
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinDisplayPriority1:
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
index c6540592a5c18..f453dc2ed20cf 100644
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -646,11 +646,11 @@ TimeTicks::Clock TimeTicks::GetClock() {
 
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
-  ULONGLONG unbiased_interrupt_time;
-  QueryUnbiasedInterruptTimePrecise(&unbiased_interrupt_time);
+  LARGE_INTEGER unbiased_interrupt_time;
+  QueryPerformanceCounter(&unbiased_interrupt_time);
   // QueryUnbiasedInterruptTimePrecise gets the interrupt time in system time
   // units of 100 nanoseconds.
-  return LiveTicks() + Nanoseconds(unbiased_interrupt_time * 100);
+  return LiveTicks() + Nanoseconds(unbiased_interrupt_time.QuadPart * 100);
 }
 }  // namespace subtle
 
diff --git a/base/trace_event/trace_logging_minimal_win.cc b/base/trace_event/trace_logging_minimal_win.cc
index 5d565fa73bedb..ec786bb990517 100644
--- a/base/trace_event/trace_logging_minimal_win.cc
+++ b/base/trace_event/trace_logging_minimal_win.cc
@@ -10,6 +10,62 @@
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
 
+/*
+EventSetInformation configuration macros:
+
+TraceLogging works best if the EventSetInformation API can be used to notify
+ETW that the provider uses TraceLogging event encoding.
+
+The EventSetInformation API is available on Windows 8 and later. (It is also
+available on fully-patched Windows 7, but not on Windows 7 RTM).
+
+The TLM_HAVE_EVENT_SET_INFORMATION and TLM_EVENT_SET_INFORMATION macros can
+be set before compiling this file to  control how the TlmProvider class deals
+with the EventSetInformation API.
+
+If these macros are not set, the default behavior is to check the WINVER
+macro at compile time:
+
+- If WINVER is set to Windows 7 or before, TlmProvider will use GetProcAddress
+  to locate EventSetInformation, and then invoke it if present. This is less
+  efficient, but works on older versions of Windows.
+- If WINVER is set to Windows 8 or later, TlmProvider will directly invoke
+  EventSetInformation. This is more efficient, but the resulting application
+  will only work correctly on newer versions of Windows.
+
+If you need to run on Windows 7 RTM, but for some reason need to set WINVER to
+Windows 8 or higher, you can override the default behavior by defining
+TLM_HAVE_EVENT_SET_INFORMATION=2 when compiling this file.
+
+Details:
+- The TLM_EVENT_SET_INFORMATION macro can be set the name of a replacement
+  function that TlmProvider should use instead of EventSetInformation.
+- The TLM_HAVE_EVENT_SET_INFORMATION macro can be set to 0 (disable the use of
+  EventSetInformation), 1 (directly invoke EventSetInformation), or 2 (try to
+  locate EventSetInformation via GetProcAddress, and invoke if found).
+*/
+
+// This code needs to run on Windows 7 and this is magic which
+// removes static linking to EventSetInformation
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+
+#ifndef TLM_EVENT_SET_INFORMATION
+#define TLM_EVENT_SET_INFORMATION EventSetInformation
+#ifndef TLM_HAVE_EVENT_SET_INFORMATION
+#if WINVER < 0x0602 || !defined(EVENT_FILTER_TYPE_SCHEMATIZED)
+// Find "EventSetInformation" via GetModuleHandleExW+GetProcAddress
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+#else
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+#endif
+#elif !defined(TLM_HAVE_EVENT_SET_INFORMATION)
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+
+
 TlmProvider::TlmProvider() noexcept = default;
 
 TlmProvider::~TlmProvider() {
@@ -22,7 +78,7 @@ TlmProvider::TlmProvider(const char* provider_name,
                              on_updated_callback) noexcept {
   ULONG status =
       Register(provider_name, provider_guid, std::move(on_updated_callback));
-  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider resistration failure";
+  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider registration failure";
 }
 
 // Appends a nul-terminated string to a metadata block.
@@ -83,9 +139,42 @@ ULONG TlmProvider::Register(const char* provider_name,
   if (status != ERROR_SUCCESS)
     return status;
 
+#if TLM_HAVE_EVENT_SET_INFORMATION == 1
+
   // Best-effort, ignore failure.
-  return ::EventSetInformation(reg_handle_, EventProviderSetTraits,
-                               provider_metadata_, provider_metadata_size_);
+  status =
+      TLM_EVENT_SET_INFORMATION(reg_handle_, EventProviderSetTraits,
+                                provider_metadata_, provider_metadata_size_);
+
+#elif TLM_HAVE_EVENT_SET_INFORMATION == 2
+
+  HMODULE eventing_lib;
+  if (GetModuleHandleExW(0, L"api-ms-win-eventing-provider-l1-1-0.dll",
+                         &eventing_lib) ||
+      GetModuleHandleExW(0, L"advapi32.dll", &eventing_lib)) {
+    typedef ULONG(WINAPI * PFEventSetInformation)(
+        REGHANDLE reg_handle, EVENT_INFO_CLASS information_class,
+        PVOID event_information, ULONG information_length);
+    PFEventSetInformation event_set_information_ptr =
+        reinterpret_cast<decltype(&::EventSetInformation)>(
+            GetProcAddress(eventing_lib, "EventSetInformation"));
+    if (event_set_information_ptr) {
+      // Best-effort, ignore failure.
+      status = event_set_information_ptr(reg_handle_, EventProviderSetTraits,
+                                         provider_metadata_,
+                                         provider_metadata_size_);
+    }
+
+    FreeLibrary(eventing_lib);
+  }
+
+#else  // TLM_HAVE_EVENT_SET_INFORMATION == 0
+
+    // Make no attempt to invoke EventSetInformation.
+
+#endif  // TLM_HAVE_EVENT_SET_INFORMATION
+
+  return status;
 }
 
 bool TlmProvider::IsEnabled() const noexcept {
diff --git a/base/win/cet_shadow_stack_unittest.cc b/base/win/cet_shadow_stack_unittest.cc
index 8c58163cfbf44..cb73ea9e8e388 100644
--- a/base/win/cet_shadow_stack_unittest.cc
+++ b/base/win/cet_shadow_stack_unittest.cc
@@ -19,10 +19,14 @@ bool IsHardwareEnforcedShadowStacksEnabled() {
   if (base::win::GetVersion() < base::win::Version::WIN10_20H1)
     return false;
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return false;
   }
 
diff --git a/base/win/core_winrt_util.cc b/base/win/core_winrt_util.cc
index 25f5885bf2f40..3508cfe474bfd 100644
--- a/base/win/core_winrt_util.cc
+++ b/base/win/core_winrt_util.cc
@@ -3,17 +3,54 @@
 // found in the LICENSE file.
 
 #include "base/win/core_winrt_util.h"
+#include "base/threading/scoped_thread_priority.h"
 
 namespace base::win {
 
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoActivateInstance) GetRoActivateInstanceFunction() {
+  static decltype(&::RoActivateInstance) const function =
+      reinterpret_cast<decltype(&::RoActivateInstance)>(
+          LoadComBaseFunction("RoActivateInstance"));
+  return function;
+}
+
+decltype(&::RoGetActivationFactory) GetRoGetActivationFactoryFunction() {
+  static decltype(&::RoGetActivationFactory) const function =
+      reinterpret_cast<decltype(&::RoGetActivationFactory)>(
+          LoadComBaseFunction("RoGetActivationFactory"));
+  return function;
+}
+
+bool ResolveCoreWinRTDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+  return GetRoActivateInstanceFunction() && GetRoGetActivationFactoryFunction();
+}
+
 HRESULT RoGetActivationFactory(HSTRING class_id,
                                const IID& iid,
                                void** out_factory) {
-  return ::RoGetActivationFactory(class_id, iid, out_factory);
+  auto get_factory_func = GetRoGetActivationFactoryFunction();
+  if (!get_factory_func)
+    return E_FAIL;
+  return get_factory_func(class_id, iid, out_factory);
 }
 
 HRESULT RoActivateInstance(HSTRING class_id, IInspectable** instance) {
-  return ::RoActivateInstance(class_id, instance);
+  auto activate_instance_func = GetRoActivateInstanceFunction();
+  if (!activate_instance_func)
+    return E_FAIL;
+  return activate_instance_func(class_id, instance);
 }
 
 }  // namespace base::win
diff --git a/base/win/core_winrt_util.h b/base/win/core_winrt_util.h
index 3a6e0c9f3774c..c4a802c85d6ed 100644
--- a/base/win/core_winrt_util.h
+++ b/base/win/core_winrt_util.h
@@ -15,6 +15,8 @@
 
 namespace base::win {
 
+BASE_EXPORT bool ResolveCoreWinRTDelayload();
+
 // The following stubs are provided for when component build is enabled, in
 // order to avoid the propagation of delay-loading CoreWinRT to other modules.
 
diff --git a/base/win/hstring_reference.cc b/base/win/hstring_reference.cc
index b254fc64310a1..6b2b1a6290990 100644
--- a/base/win/hstring_reference.cc
+++ b/base/win/hstring_reference.cc
@@ -12,18 +12,54 @@
 #include "base/check_op.h"
 #include "base/numerics/safe_conversions.h"
 
-namespace base::win {
+namespace base {
+namespace {
+
+bool g_winrt_string_loaded = false;
+
+decltype(&::WindowsCreateStringReference) GetWindowsCreateStringReference() {
+  static auto const create_string_reference_func =
+      []() -> decltype(&::WindowsCreateStringReference) {
+    const HMODULE handle =
+        ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    if (handle) {
+      return reinterpret_cast<decltype(&::WindowsCreateStringReference)>(
+          ::GetProcAddress(handle, "WindowsCreateStringReference"));
+    }
+    return nullptr;
+  }();
+  return create_string_reference_func;
+}
+
+}  // namespace
+
+namespace win {
+
+// static
+bool HStringReference::ResolveCoreWinRTStringDelayload() {
+  g_winrt_string_loaded = GetWindowsCreateStringReference() != nullptr;
+  return g_winrt_string_loaded;
+}
 
 HStringReference::HStringReference(const wchar_t* str, size_t length) {
+
+  // This was added because otherwise, the checks below would consistently fail.
+  ResolveCoreWinRTStringDelayload();
+  DCHECK(g_winrt_string_loaded);
   // String must be null terminated for WindowsCreateStringReference.
   // nullptr str is OK so long as the length is 0.
   DCHECK(str ? str[length] == L'\0' : length == 0);
-  const HRESULT hr = ::WindowsCreateStringReference(
+  // If you nullptr crash here, you've failed to call
+  // ResolveCoreWinRTStringDelayLoad and check its return value.
+  const HRESULT hr = GetWindowsCreateStringReference()(
       str, checked_cast<UINT32>(length), &hstring_header_, &hstring_);
+  // All failure modes of WindowsCreateStringReference are handled gracefully
+  // but this class.
   DCHECK_EQ(hr, S_OK);
 }
 
 HStringReference::HStringReference(const wchar_t* str)
     : HStringReference(str, str ? wcslen(str) : 0) {}
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_reference.h b/base/win/hstring_reference.h
index 3cde4acef6f2e..2366a681e72c0 100644
--- a/base/win/hstring_reference.h
+++ b/base/win/hstring_reference.h
@@ -9,7 +9,8 @@
 
 #include "base/base_export.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 // HStringReference is an HSTRING representation of a null terminated
 // string backed by memory that outlives the HStringReference instance.
@@ -17,12 +18,31 @@ namespace base::win {
 // If you need an HSTRING class that manages its own memory, you should
 // use ScopedHString instead.
 //
+// Note that HStringReference requires certain functions that are only
+// available on Windows 8 and later, and that these functions need to be
+// delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using HStringReference.
+//
+// One-time Initialization for HStringReference:
+//
+//   const bool success = HStringReference::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // HStringReference can be used.
+//   } else {
+//     // Handle error.
+//   }
+//
 // Example use:
 //
 //   HStringReference string(L"abc");
 //
 class BASE_EXPORT HStringReference {
  public:
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  static bool ResolveCoreWinRTStringDelayload();
+
   HStringReference(const wchar_t* str, size_t len);
   explicit HStringReference(const wchar_t* str);
 
@@ -47,6 +67,7 @@ class BASE_EXPORT HStringReference {
   HSTRING_HEADER hstring_header_;
 };
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
 
 #endif  // BASE_WIN_HSTRING_REFERENCE_H_
diff --git a/base/win/hstring_reference_unittest.cc b/base/win/hstring_reference_unittest.cc
index 3f67ff223d87e..60bd3d27a9037 100644
--- a/base/win/hstring_reference_unittest.cc
+++ b/base/win/hstring_reference_unittest.cc
@@ -26,6 +26,8 @@ void VerifyHSTRINGEquals(HSTRING hstring, const wchar_t* test_string) {
 }  // namespace
 
 TEST(HStringReferenceTest, Init) {
+  EXPECT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
+
   const HStringReference string(kTestString);
   EXPECT_NE(string.Get(), nullptr);
   VerifyHSTRINGEquals(string.Get(), kTestString);
diff --git a/base/win/registry.cc b/base/win/registry.cc
index 7b9dcb90e627e..d24a4b0ede9d5 100644
--- a/base/win/registry.cc
+++ b/base/win/registry.cc
@@ -23,6 +23,7 @@
 #include "base/win/object_watcher.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 
 extern "C" NTSTATUS WINAPI NtDeleteKey(IN HANDLE KeyHandle);
 
@@ -87,8 +88,9 @@ bool RegKey::Watcher::StartWatching(HKEY key, ChangeCallback callback) {
   }
 
   DWORD filter = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
-                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY |
-                 REG_NOTIFY_THREAD_AGNOSTIC;
+                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY;
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    filter |= REG_NOTIFY_THREAD_AGNOSTIC;
   // Watch the registry key for a change of value.
   LONG result =
       RegNotifyChangeKeyValue(key, /*bWatchSubtree=*/TRUE, filter,
diff --git a/base/win/scoped_hstring.cc b/base/win/scoped_hstring.cc
index 20e027e34632b..c3342f122ca25 100644
--- a/base/win/scoped_hstring.cc
+++ b/base/win/scoped_hstring.cc
@@ -19,23 +19,89 @@
 
 namespace base {
 
+namespace {
+
+static bool g_load_succeeded = false;
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle =
+      ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::WindowsCreateString) GetWindowsCreateString() {
+  static decltype(&::WindowsCreateString) const function =
+      reinterpret_cast<decltype(&::WindowsCreateString)>(
+          LoadComBaseFunction("WindowsCreateString"));
+  return function;
+}
+
+decltype(&::WindowsDeleteString) GetWindowsDeleteString() {
+  static decltype(&::WindowsDeleteString) const function =
+      reinterpret_cast<decltype(&::WindowsDeleteString)>(
+          LoadComBaseFunction("WindowsDeleteString"));
+  return function;
+}
+
+decltype(&::WindowsGetStringRawBuffer) GetWindowsGetStringRawBuffer() {
+  static decltype(&::WindowsGetStringRawBuffer) const function =
+      reinterpret_cast<decltype(&::WindowsGetStringRawBuffer)>(
+          LoadComBaseFunction("WindowsGetStringRawBuffer"));
+  return function;
+}
+
+HRESULT WindowsCreateString(const wchar_t* src,
+                            uint32_t len,
+                            HSTRING* out_hstr) {
+  decltype(&::WindowsCreateString) create_string_func =
+      GetWindowsCreateString();
+  if (!create_string_func)
+    return E_FAIL;
+  return create_string_func(src, len, out_hstr);
+}
+
+HRESULT WindowsDeleteString(HSTRING hstr) {
+  decltype(&::WindowsDeleteString) delete_string_func =
+      GetWindowsDeleteString();
+  if (!delete_string_func)
+    return E_FAIL;
+  return delete_string_func(hstr);
+}
+
+const wchar_t* WindowsGetStringRawBuffer(HSTRING hstr, uint32_t* out_len) {
+  decltype(&::WindowsGetStringRawBuffer) get_string_raw_buffer_func =
+      GetWindowsGetStringRawBuffer();
+  if (!get_string_raw_buffer_func) {
+    *out_len = 0;
+    return nullptr;
+  }
+  return get_string_raw_buffer_func(hstr, out_len);
+}
+
+}  // namespace
+
 namespace internal {
 
 // static
 void ScopedHStringTraits::Free(HSTRING hstr) {
-  ::WindowsDeleteString(hstr);
+  base::WindowsDeleteString(hstr);
 }
 
 }  // namespace internal
 
 namespace win {
 
-ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {}
+ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {
+	DCHECK(g_load_succeeded);
+}
 
 // static
 ScopedHString ScopedHString::Create(std::wstring_view str) {
+  if (!g_load_succeeded) {
+	  return ScopedHString(nullptr);
+  }
   HSTRING hstr;
-  HRESULT hr = ::WindowsCreateString(str.data(),
+  HRESULT hr = base::WindowsCreateString(str.data(),
                                      checked_cast<UINT32>(str.length()), &hstr);
   if (SUCCEEDED(hr))
     return ScopedHString(hstr);
@@ -57,10 +123,22 @@ ScopedHString ScopedHString::Create(StringPiece str) {
   return Create(UTF8ToWide(str));
 }
 
+// static
+bool ScopedHString::ResolveCoreWinRTStringDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+
+  static const bool load_succeeded = []() {
+    bool success = GetWindowsCreateString() && GetWindowsDeleteString() &&
+                   GetWindowsGetStringRawBuffer();
+    g_load_succeeded = success;
+    return success;
+  }();
+  return load_succeeded;
+}
 // static
 std::wstring_view ScopedHString::Get() const {
   UINT32 length = 0;
-  const wchar_t* buffer = ::WindowsGetStringRawBuffer(get(), &length);
+  const wchar_t* buffer = base::WindowsGetStringRawBuffer(get(), &length);
   return std::wstring_view(buffer, length);
 }
 
diff --git a/base/win/scoped_hstring.h b/base/win/scoped_hstring.h
index 50b8451663c3b..7cd0247d93a31 100644
--- a/base/win/scoped_hstring.h
+++ b/base/win/scoped_hstring.h
@@ -28,7 +28,21 @@ struct BASE_EXPORT ScopedHStringTraits {
 
 namespace win {
 
-// ScopedHString is a wrapper around an HSTRING.
+// ScopedHString is a wrapper around an HSTRING. Note that it requires certain
+// functions that are only available on Windows 8 and later, and that these
+// functions need to be delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using ScopedHString.
+//
+// One-time Initialization for ScopedHString:
+//
+//   bool success = ScopedHString::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // ScopeHString can be used.
+//   } else {
+//     // Handle error.
+//   }
 //
 // Example use:
 //
@@ -49,6 +63,9 @@ class BASE_EXPORT ScopedHString
   static ScopedHString Create(std::wstring_view str);
   static ScopedHString Create(StringPiece str);
 
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  [[nodiscard]] static bool ResolveCoreWinRTStringDelayload();
+
   // Returns a view into the memory buffer managed by the instance. The returned
   // StringPiece is only valid during the lifetime of this ScopedHString
   // instance.
diff --git a/base/win/scoped_winrt_initializer.cc b/base/win/scoped_winrt_initializer.cc
index 4c93dcfabf658..85f83dab8192b 100644
--- a/base/win/scoped_winrt_initializer.cc
+++ b/base/win/scoped_winrt_initializer.cc
@@ -5,14 +5,61 @@
 #include "base/win/scoped_winrt_initializer.h"
 
 #include <roapi.h>
+#include <windows.h>
+
+#include <ostream>
 
 #include "base/check_op.h"
+#include "base/threading/scoped_thread_priority.h"
 #include "base/win/com_init_util.h"
+#include "base/win/core_winrt_util.h"
 
 namespace base::win {
 
+namespace {
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoInitialize) GetRoInitializeFunction() {
+  static decltype(&::RoInitialize) const function =
+      reinterpret_cast<decltype(&::RoInitialize)>(
+          LoadComBaseFunction("RoInitialize"));
+  return function;
+}
+
+decltype(&::RoUninitialize) GetRoUninitializeFunction() {
+  static decltype(&::RoUninitialize) const function =
+      reinterpret_cast<decltype(&::RoUninitialize)>(
+          LoadComBaseFunction("RoUninitialize"));
+  return function;
+}
+
+HRESULT CallRoInitialize(RO_INIT_TYPE init_type) {
+  auto ro_initialize_func = GetRoInitializeFunction();
+  if (!ro_initialize_func)
+    return E_FAIL;
+  return ro_initialize_func(init_type);
+}
+
+void CallRoUninitialize() {
+  auto ro_uninitialize_func = GetRoUninitializeFunction();
+  if (ro_uninitialize_func)
+    ro_uninitialize_func();
+}
+
+}  // namespace
+
 ScopedWinrtInitializer::ScopedWinrtInitializer()
-    : hr_(::RoInitialize(RO_INIT_MULTITHREADED)) {
+    : hr_(CallRoInitialize(RO_INIT_MULTITHREADED)) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 #if DCHECK_IS_ON()
   if (SUCCEEDED(hr_))
@@ -25,7 +72,7 @@ ScopedWinrtInitializer::ScopedWinrtInitializer()
 ScopedWinrtInitializer::~ScopedWinrtInitializer() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (SUCCEEDED(hr_))
-    ::RoUninitialize();
+    CallRoUninitialize();
 }
 
 bool ScopedWinrtInitializer::Succeeded() const {
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 25cc9b48a4d14..e710062d4d539 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -39,6 +39,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/files/file_path.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
@@ -68,6 +69,21 @@ namespace win {
 
 namespace {
 
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+
+bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch(kDisableDirectWrite);
+}
+
 // Sets the value of |property_key| to |property_value| in |property_store|.
 bool SetPropVariantValueForPropertyStore(
     IPropertyStore* property_store,
@@ -92,14 +108,44 @@ bool SetPropVariantValueForPropertyStore(
   return false;
 }
 
-void __cdecl ForceCrashOnSigAbort(int) {
-  *((volatile int*)nullptr) = 0x1337;
-}
+//void __cdecl ForceCrashOnSigAbort(int) {
+//  *((volatile int*)nullptr) = 0x1337;
+//}
 
-// Returns the current platform role. We use the PowerDeterminePlatformRoleEx
+// Returns the current platform role. We use the PowerDeterminePlatformRole
 // API for that.
 POWER_PLATFORM_ROLE GetPlatformRole() {
-  return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
+	return PowerDeterminePlatformRole();
+}
+
+// Because we used to support versions earlier than 8.1, we dynamically load
+// this function from user32.dll, so it won't fail to load in runtime.
+// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  if (!IsUser32AndGdi32Available())
+    return false;
+
+  static const auto set_process_dpi_awareness_func =
+      reinterpret_cast<decltype(&::SetProcessDpiAwareness)>(
+          GetUser32FunctionPointer("SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr))
+      return true;
+    DLOG_IF(ERROR, hr == E_ACCESSDENIED)
+        << "Access denied error from SetProcessDpiAwarenessInternal. "
+           "Function called twice, or manifest was used.";
+    NOTREACHED()
+        << "SetProcessDpiAwarenessInternal failed with unexpected error: "
+        << hr;
+    return false;
+  }
+
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
+
+  return false;
 }
 
 // Enable V2 per-monitor high-DPI support for the process. This will cause
@@ -239,10 +285,16 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
            IsDeviceUsedAsATablet(/*reason=*/nullptr);
   }
 
+  if (!ResolveCoreWinRTDelayload() ||
+      !ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
+
   ScopedHString view_settings_guid = ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UIViewSettings);
   Microsoft::WRL::ComPtr<IUIViewSettingsInterop> view_settings_interop;
-  HRESULT hr = ::RoGetActivationFactory(view_settings_guid.get(),
+  HRESULT hr = win::RoGetActivationFactory(view_settings_guid.get(),
                                         IID_PPV_ARGS(&view_settings_interop));
   if (FAILED(hr))
     return false;
@@ -508,7 +560,7 @@ void SetAbortBehaviorForCrashReporting() {
   // Set a SIGABRT handler for good measure. We will crash even if the default
   // is left in place, however this allows us to crash earlier. And it also
   // lets us crash in response to code which might directly call raise(SIGABRT)
-  signal(SIGABRT, ForceCrashOnSigAbort);
+  // signal(SIGABRT, ForceCrashOnSigAbort);
 }
 
 bool IsTabletDevice(std::string* reason, HWND hwnd) {
@@ -607,8 +659,17 @@ bool IsJoinedToAzureAD() {
 bool IsUser32AndGdi32Available() {
   static auto is_user32_and_gdi32_available = []() {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
+	if (!ShouldUseDirectWrite())
+        return true;
+	  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
+    if (!get_process_mitigation_policy)
+		return true;
+
     PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
+    if (get_process_mitigation_policy(GetCurrentProcess(),
                                      ProcessSystemCallDisablePolicy, &policy,
                                      sizeof(policy))) {
       return policy.DisallowWin32kSystemCalls == 0;
@@ -674,7 +735,7 @@ void DisableFlicks(HWND hwnd) {
 }
 
 void EnableHighDPISupport() {
-  if (!IsUser32AndGdi32Available())
+  if (!IsUser32AndGdi32Available() || GetVersion() < Version::VISTA)
     return;
 
   // Enable per-monitor V2 if it is available (Win10 1703 or later).
@@ -683,7 +744,7 @@ void EnableHighDPISupport() {
 
   // Fall back to per-monitor DPI for older versions of Win10.
   PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
-  if (!::SetProcessDpiAwareness(process_dpi_awareness)) {
+  if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
     // For windows versions where SetProcessDpiAwareness fails, try its
     // predecessor.
     BOOL result = ::SetProcessDPIAware();
diff --git a/base/win/winrt_storage_util_unittest.cc b/base/win/winrt_storage_util_unittest.cc
index 5c54819e4b85a..8f3f64f29011a 100644
--- a/base/win/winrt_storage_util_unittest.cc
+++ b/base/win/winrt_storage_util_unittest.cc
@@ -21,6 +21,10 @@ namespace win {
 TEST(WinrtStorageUtilTest, CreateBufferFromData) {
   ScopedCOMInitializer com_initializer(ScopedCOMInitializer::kMTA);
 
+  if (!ResolveCoreWinRTDelayload()) {
+    return;
+  }
+
   const std::vector<uint8_t> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   Microsoft::WRL::ComPtr<ABI::Windows::Storage::Streams::IBuffer> buffer;
   ASSERT_HRESULT_SUCCEEDED(
diff --git a/cc/tiles/software_image_decode_cache_utils.cc b/cc/tiles/software_image_decode_cache_utils.cc
index 1a0a378f11b89..84857d3b82fcd 100644
--- a/cc/tiles/software_image_decode_cache_utils.cc
+++ b/cc/tiles/software_image_decode_cache_utils.cc
@@ -9,8 +9,10 @@
 #include <utility>
 
 #include "base/atomic_sequence_num.h"
+#include "base/command_line.h"
 #include "base/functional/callback_helpers.h"
 #include "base/hash/hash.h"
+#include "base/logging.h"
 #include "base/memory/discardable_memory_allocator.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/memory.h"
@@ -21,6 +23,11 @@
 #include "third_party/skia/include/core/SkImage.h"
 #include "ui/gfx/geometry/skia_conversions.h"
 
+#if BUILDFLAG (IS_WIN) && _M_IX86
+#include <Windows.h>
+#include <psapi.h>
+#endif
+
 namespace cc {
 namespace {
 // If the size of the original sized image breaches kMemoryRatioToSubrect but we
@@ -71,6 +78,19 @@ SoftwareImageDecodeCacheUtils::DoDecodeImage(
     base::OnceClosure on_no_memory) {
   const SkISize target_size =
       SkISize::Make(key.target_size().width(), key.target_size().height());
+#if BUILDFLAG (IS_WIN) && _M_IX86
+  // Supermium (#507): Options for limiting the size of loaded images are very limited.
+  // Insufficient information is available at all levels on the size of the image data.
+  // So the best that can be done is to block image loading if it will increase the memory usage
+  // of a 32 bit process to more than 1.1 GB.
+  PROCESS_MEMORY_COUNTERS pmc;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("enable-webbloat-mitigation") &&
+     ::GetProcessMemoryInfo(::GetCurrentProcess(), &pmc, sizeof(PROCESS_MEMORY_COUNTERS)) &&
+     (target_size.fWidth * target_size.fHeight * 4) + pmc.PagefileUsage > 1100000000) {
+       LOG(ERROR) << "Thorium attempted to load an image of size " << target_size.fWidth * target_size.fHeight << " pixels";
+       return nullptr;
+  }
+#endif
   DCHECK(target_size == paint_image.GetSupportedDecodeSize(target_size));
   sk_sp<SkColorSpace> target_color_space =
       key.target_color_params().color_space.ToSkColorSpace();
diff --git a/chrome/app/chrome_exe_main_win.cc b/chrome/app/chrome_exe_main_win.cc
index 0aced300d8dce..d2c530353eca4 100644
--- a/chrome/app/chrome_exe_main_win.cc
+++ b/chrome/app/chrome_exe_main_win.cc
@@ -242,12 +242,24 @@ __declspec(dllexport) __cdecl void GetPakFileHashes(
   *chrome_200_pak = kSha256_chrome_200_percent_pak.data();
 }
 
+void SwitchToLFHeap() {
+  // Only needed on 2000/XP but harmless on other Windows flavors.
+  auto crt_heap = _get_heap_handle();
+  ULONG enable_LFH = 2;
+  if (HeapSetInformation(reinterpret_cast<HANDLE>(crt_heap),
+                         HeapCompatibilityInformation,
+                         &enable_LFH, sizeof(enable_LFH))) {
+    VLOG(1) << "low fragmentation heap enabled";
+  }
+}
+
 #if !defined(WIN_CONSOLE_APP)
 int APIENTRY wWinMain(HINSTANCE instance, HINSTANCE prev, wchar_t*, int) {
 #else   // !defined(WIN_CONSOLE_APP)
 int main() {
   HINSTANCE instance = GetModuleHandle(nullptr);
 #endif  // !defined(WIN_CONSOLE_APP)
+  SwitchToLFHeap();
 
 #if defined(ARCH_CPU_32_BITS)
   enum class FiberStatus { kConvertFailed, kCreateFiberFailed, kSuccess };
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 0811d62fd215d..8a64908d27de9 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -2265,6 +2265,7 @@ static_library("browser") {
     "//components/net_log",
     "//components/network_hints/common:mojo_bindings",
     "//components/network_session_configurator/browser",
+    "//components/network_session_configurator/common",
     "//components/network_time",
     "//components/no_state_prefetch/browser",
     "//components/no_state_prefetch/common",
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index de3be2eec25cc..93e34b76376f6 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -3777,6 +3777,63 @@ const FeatureEntry::FeatureVariation
         {"experimental V2", kCompressionDictionaryTransportBackendVersionV2,
          std::size(kCompressionDictionaryTransportBackendVersionV2), nullptr}};
 
+
+
+
+
+
+
+
+
+
+
+const FeatureEntry::Choice kBookmarkBarNewTab[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Never",
+     "bookmark-bar-ntp",
+     "never"},
+};
+const FeatureEntry::Choice kOmniboxAutocompleteFiltering[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Search suggestions only",
+     "omnibox-autocomplete-filtering",
+     "search"},
+    {"Search suggestions and bookmarks",
+     "omnibox-autocomplete-filtering",
+     "search-bookmarks"},
+    {"Search suggestions and internal chrome pages",
+     "omnibox-autocomplete-filtering",
+     "search-chrome"},
+    {"Search suggestions, bookmarks, and internal chrome pages",
+     "omnibox-autocomplete-filtering",
+     "search-bookmarks-chrome"},
+};
+const FeatureEntry::Choice kExtensionHandlingChoices[] = {
+    {flags_ui::kGenericExperimentChoiceDefault, "", ""},
+    {"Download as regular file",
+     "extension-mime-request-handling",
+     "download-as-regular-file"},
+    {"Always prompt for install",
+     "extension-mime-request-handling",
+     "always-prompt-for-install"},
+};
+const FeatureEntry::Choice kMaxConnectionsPerHostChoices[] = {
+    {"6", "", ""},
+    {"15", "max-connections-per-host", "15"},
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
 // RECORDING USER METRICS FOR FLAGS:
 // -----------------------------------------------------------------------------
 // The first line of the entry is the internal name.
@@ -6153,6 +6213,18 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kMemlogStackModeDescription, kOsAll,
      MULTI_VALUE_TYPE(kMemlogStackModeChoices)},
 
+
+
+
+
+
+
+
+
+
+
+
+
     {"omnibox-max-zero-suggest-matches",
      flag_descriptions::kOmniboxMaxZeroSuggestMatchesName,
      flag_descriptions::kOmniboxMaxZeroSuggestMatchesDescription,
@@ -6975,10 +7047,6 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableWindowsGamingInputDataFetcherName,
      flag_descriptions::kEnableWindowsGamingInputDataFetcherDescription, kOsWin,
      FEATURE_VALUE_TYPE(features::kEnableWindowsGamingInputDataFetcher)},
-
-    {"windows11-mica-titlebar", flag_descriptions::kWindows11MicaTitlebarName,
-     flag_descriptions::kWindows11MicaTitlebarDescription, kOsWin,
-     FEATURE_VALUE_TYPE(kWindows11MicaTitlebar)},
 #endif
 
 #if BUILDFLAG(IS_ANDROID)
@@ -10715,6 +10789,13 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableBuiltinHlsDescription, kOsAll,
      FEATURE_VALUE_TYPE(media::kBuiltInHlsPlayer)},
 #endif
+	{"ungoogled-thorium",
+	 flag_descriptions::kUngoogledThoriumName, flag_descriptions::kUngoogledThoriumDescription,
+	 kOsAll, SINGLE_VALUE_TYPE("ungoogled-thorium")},
+
+
+
+
 
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
     {"profiles-reordering", flag_descriptions::kProfilesReorderingName,
@@ -11158,6 +11239,163 @@ const FeatureEntry kFeatureEntries[] = {
      FEATURE_VALUE_TYPE(syncer::kSyncShowIdentityErrorsForSignedInUsers)},
 #endif  // BUILDFLAG(IS_ANDROID)
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    {"bookmark-bar-ntp",
+     "Bookmark Bar on New-Tab-Page",
+     "Disable the Bookmark Bar on the New-Tab-Page. ungoogled-chromium flag.",
+     kOsDesktop, MULTI_VALUE_TYPE(kBookmarkBarNewTab)},
+    {"remove-grab-handle",
+     "Remove Grab Handle",
+     "Removes the reserved empty space in the tabstrip for moving the window. ungoogled-chromium flag",
+     kOsDesktop, SINGLE_VALUE_TYPE("remove-grab-handle")},
+    {"omnibox-autocomplete-filtering",
+     "Omnibox Autocomplete Filtering",
+     "Restrict omnibox autocomplete results to a combination of search suggestions (if enabled), bookmarks, and internal chrome pages. ungoogled-chromium flag.",
+     kOsAll, MULTI_VALUE_TYPE(kOmniboxAutocompleteFiltering)},
+	{"disable-sharing-hub",
+	 "Disable Sharing Hub",
+     "Disables the sharing hub button. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("disable-sharing-hub")},
+	{"disable-grease-tls",
+     "Disable GREASE for TLS",
+     "Turn off GREASE (Generate Random Extensions And Sustain Extensibility) for TLS connections. ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-grease-tls")},
+	{"force-punycode-hostnames",
+     "Force punycode hostnames",
+     "Force punycode in hostnames instead of Unicode when displaying Internationalized Domain Names (IDNs). ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("force-punycode-hostnames")},
+	{"hide-crashed-bubble",
+     "Hide crashed bubble",
+     "Hides the bubble box with the message \"Restore Pages? Chromium didn't shut down correctly.\" that shows on startup after the browser did not exit cleanly. ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("hide-crashed-bubble")},
+	{"hide-extensions-menu",
+     "Hide Extensions Menu",
+     "Hides the extensions container. This includes the puzzle piece icon as well as any pinned extensions. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-extensions-menu")},
+	{"hide-fullscreen-exit-ui",
+     "Hide Fullscreen Exit UI",
+     "Hides the \"X\" that appears when the mouse cursor is moved towards the top of the window in fullscreen mode. Additionally, this hides the \"Press F11 to exit full screen\" popup. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-fullscreen-exit-ui")},
+
+
+
+
+	{"hide-tab-close-buttons",
+     "Hide tab close buttons",
+     "Hides the close buttons on tabs. ungoogled-chromium flag.",
+     kOsDesktop, SINGLE_VALUE_TYPE("hide-tab-close-buttons")},
+    {"remove-tabsearch-button",
+     "Remove Tabsearch Button",
+     "Removes the tabsearch button from the tabstrip. ungoogled-chromium flag",
+     kOsDesktop, SINGLE_VALUE_TYPE("remove-tabsearch-button")},
+    {"http-accept-header",
+     "Custom HTTP Accept Header",
+     "Set a custom value for the Accept header which is sent by the browser with every HTTP request.  (e.g. `text/html,application/xhtmlxml,application/xml;q=0.9,image/webp,*/*;q=0.8`). ungoogled-chromium flag.",
+     kOsAll, ORIGIN_LIST_VALUE_TYPE("http-accept-header", "")},
+    {"clear-data-on-exit",
+     "Clear data on exit",
+     "Clears all browsing data on exit. ungoogled-chromium flag",
+     kOsDesktop, FEATURE_VALUE_TYPE(browsing_data::features::kClearDataOnExit)},
+    {"extension-mime-request-handling",
+     "Handling of extension MIME type requests",
+     "Used when deciding how to handle a request for a CRX or User Script MIME type. ungoogled-chromium flag.",
+     kOsAll, MULTI_VALUE_TYPE(kExtensionHandlingChoices)},
+
+
+
+
+	{"disable-qr-generator",
+     "Disable QR Generator",
+     "Disables the QR generator for sharing page links. ungoogled-chromium flag",
+     kOsDesktop, FEATURE_VALUE_TYPE(kDisableQRGenerator)},
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    {"power-bookmarks-side-panel", "Power bookmarks side panel",
+     "Enables the power bookmarks version of the bookmarks side panel content.", kOsDesktop,
+     FEATURE_VALUE_TYPE(features::kPowerBookmarksSidePanel)},
+	{"windows11-mica-titlebar",
+     "Windows 11 Mica Taskbar",
+     "Enables support for the Windows 11 Mica Taskbar, as used in 22H2 and up.",
+     kOsDesktop, SINGLE_VALUE_TYPE("windows11-mica-titlebar")},
+	{"legacy-tooltips-win",
+     "Legacy tooltips for Windows",
+     "Force the use of native legacy tooltips on Windows 8 and up.",
+     kOsWin, SINGLE_VALUE_TYPE("legacy-tooltips-win")},
+	{"disable-pwa-install-prompt",
+     "Disable PWA Install Prompt in Address Bar",
+     "Disables the PWA (Progressive Web App) installation prompt in the address bar.",
+     kOsDesktop, SINGLE_VALUE_TYPE("disable-pwa-install-prompt")},
+	{"max-connections-per-host",
+     "Maximum connections per Host",
+     "Customize maximum allowed connections per host. ungoogled-chromium flag, Bromite feature.",
+     kOsAll, MULTI_VALUE_TYPE(kMaxConnectionsPerHostChoices)},
+	{"disable-search-engine-collection",
+     "Disable Search Engine Collection",
+     "Prevents search engines from being added automatically. ungoogled-chromium flag.",
+     kOsAll, SINGLE_VALUE_TYPE("disable-search-engine-collection")},
+	{"popups-to-tabs",
+     "Popups to Tabs",
+     "Makes popups open in new tabs. ungoogled-chromium flag",
+     kOsAll, SINGLE_VALUE_TYPE("popups-to-tabs")},
+
+
+
+
+	// TODO: move all Supermium-specific flags to new source file.
+
+
     // NOTE: Adding a new flag requires adding a corresponding entry to enum
     // "LoginCustomFlags" in tools/metrics/histograms/enums.xml. See "Flag
     // Histograms" in tools/metrics/histograms/README.md (run the
diff --git a/chrome/browser/browser_process_impl.cc b/chrome/browser/browser_process_impl.cc
index 57cb42c63eb6a..b3db6309c5f59 100644
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -20,11 +20,13 @@
 #include "base/functional/callback.h"
 #include "base/functional/callback_helpers.h"
 #include "base/location.h"
+#include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
 #include "base/path_service.h"
 #include "base/run_loop.h"
+#include "base/strings/string_number_conversions.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/task/sequenced_task_runner.h"
 #include "base/task/single_thread_task_runner.h"
@@ -105,6 +107,7 @@
 #include "components/metrics/metrics_service.h"
 #include "components/metrics_services_manager/metrics_services_manager.h"
 #include "components/metrics_services_manager/metrics_services_manager_client.h"
+#include "components/network_session_configurator/common/network_switches.h"
 #include "components/network_time/network_time_tracker.h"
 #include "components/os_crypt/async/browser/os_crypt_async.h"
 #include "components/permissions/permissions_client.h"
@@ -136,6 +139,7 @@
 #include "media/media_buildflags.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "net/log/net_log.h"
+#include "net/socket/client_socket_pool_manager.h"
 #include "ppapi/buildflags/buildflags.h"
 #include "printing/buildflags/buildflags.h"
 #include "services/network/public/cpp/features.h"
@@ -371,6 +375,18 @@ void BrowserProcessImpl::Init() {
   pref_change_registrar_.Add(metrics::prefs::kMetricsReportingEnabled,
                              base::BindRepeating(&ApplyMetricsReportingPolicy));
 
+  int max_connections_per_host = 0;
+  auto switch_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
+      "max-connections-per-host");
+  if (!switch_value.empty() && !base::StringToInt(switch_value, &max_connections_per_host)) {
+    LOG(DFATAL) << "--" << "max-connections-per-host"
+      << " expected integer; got (\"" << switch_value << "\" instead)";
+  }
+  if (max_connections_per_host != 0) {
+    net::ClientSocketPoolManager::set_max_sockets_per_group(
+        net::HttpNetworkSession::NORMAL_SOCKET_POOL, max_connections_per_host);
+  }
+
   DCHECK(!webrtc_event_log_manager_);
   webrtc_event_log_manager_ = WebRtcEventLogManager::CreateSingletonInstance();
 
diff --git a/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc b/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
index d912e49786837..3b8a9066f376d 100644
--- a/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
+++ b/chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager.cc
@@ -28,6 +28,7 @@
 #include "chrome/browser/sync/sync_service_factory.h"
 #include "chrome/common/chrome_switches.h"
 #include "chrome/common/pref_names.h"
+#include "components/browsing_data/core/features.h"
 #include "components/browsing_data/core/browsing_data_policies_utils.h"
 #include "components/browsing_data/core/pref_names.h"
 #include "components/keep_alive_registry/keep_alive_types.h"
@@ -148,6 +149,21 @@ class BrowsingDataRemoverObserver
 #endif
 };
 
+uint64_t AllOriginTypeMask() {
+  return content::BrowsingDataRemover::ORIGIN_TYPE_PROTECTED_WEB |
+         content::BrowsingDataRemover::ORIGIN_TYPE_UNPROTECTED_WEB;
+}
+
+uint64_t AllRemoveMask() {
+  return content::BrowsingDataRemover::DATA_TYPE_CACHE |
+         content::BrowsingDataRemover::DATA_TYPE_DOWNLOADS |
+         chrome_browsing_data_remover::DATA_TYPE_CONTENT_SETTINGS |
+         chrome_browsing_data_remover::DATA_TYPE_FORM_DATA |
+         chrome_browsing_data_remover::DATA_TYPE_HISTORY |
+         chrome_browsing_data_remover::DATA_TYPE_PASSWORDS |
+         chrome_browsing_data_remover::DATA_TYPE_SITE_DATA;
+}
+
 uint64_t GetOriginTypeMask(const base::Value::List& data_types) {
   uint64_t result = 0;
   for (const auto& data_type : data_types) {
@@ -315,9 +331,10 @@ void ChromeBrowsingDataLifetimeManager::ClearBrowsingDataForOnExitPolicy(
   const base::Value::List& data_types = profile_->GetPrefs()->GetList(
       browsing_data::prefs::kClearBrowsingDataOnExitList);
 
-  if (!data_types.empty() &&
+   bool cdoe = base::FeatureList::IsEnabled(browsing_data::features::kClearDataOnExit);
+   if (cdoe || (!data_types.empty() &&
       IsConditionSatisfiedForBrowsingDataRemoval(GetSyncTypesForPolicyPref(
-          profile_, browsing_data::prefs::kClearBrowsingDataOnExitList))) {
+          profile_, browsing_data::prefs::kClearBrowsingDataOnExitList)))) {
     profile_->GetPrefs()->SetBoolean(
         browsing_data::prefs::kClearBrowsingDataOnExitDeletionPending, true);
     auto* remover = profile_->GetBrowsingDataRemover();
@@ -328,8 +345,8 @@ void ChromeBrowsingDataLifetimeManager::ClearBrowsingDataForOnExitPolicy(
       DCHECK(keep_browser_alive);
 #endif
     remover->RemoveAndReply(base::Time(), base::Time::Max(),
-                            GetRemoveMask(data_types),
-                            GetOriginTypeMask(data_types),
+                            cdoe ? AllRemoveMask() : GetRemoveMask(data_types),
++                           cdoe ? AllOriginTypeMask() : GetOriginTypeMask(data_types),
                             BrowsingDataRemoverObserver::Create(
                                 remover, /*filterable_deletion=*/true, profile_,
                                 keep_browser_alive));
diff --git a/chrome/browser/chrome_browser_interface_binders.cc b/chrome/browser/chrome_browser_interface_binders.cc
index 9851839728f08..fa2ea794f3038 100644
--- a/chrome/browser/chrome_browser_interface_binders.cc
+++ b/chrome/browser/chrome_browser_interface_binders.cc
@@ -1199,9 +1199,17 @@ void PopulateChromeWebUIFrameBinders(
     }
   }
 
-  RegisterWebUIControllerInterfaceBinder<
-      page_image_service::mojom::PageImageServiceHandler, HistoryUI,
-      HistoryClustersSidePanelUI, NewTabPageUI, BookmarksSidePanelUI>(map);
+  if ((history_clusters_service &&
+       history_clusters_service->is_journeys_feature_flag_enabled() &&
+       history_clusters_service->IsJourneysImagesEnabled()) ||
+      base::FeatureList::IsEnabled(ntp_features::kNtpHistoryClustersModule) ||
+      base::FeatureList::IsEnabled(
+          ntp_features::kNtpHistoryClustersModuleLoad) ||
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+    RegisterWebUIControllerInterfaceBinder<
+        page_image_service::mojom::PageImageServiceHandler, HistoryUI,
+        HistoryClustersSidePanelUI, NewTabPageUI, BookmarksSidePanelUI>(map);
+  }
 
   RegisterWebUIControllerInterfaceBinder<
       browser_command::mojom::CommandHandlerFactory, NewTabPageUI, WhatsNewUI>(
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index 8ac74856217e4..c11ba71dc1e48 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -443,6 +443,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void BrowserURLHandlerCreated(content::BrowserURLHandler* handler) override;
   base::FilePath GetDefaultDownloadDirectory() override;
   std::string GetDefaultDownloadName() override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   base::FilePath GetShaderDiskCacheDirectory() override;
   base::FilePath GetGrShaderDiskCacheDirectory() override;
   base::FilePath GetGraphiteDawnDiskCacheDirectory() override;
diff --git a/chrome/browser/device_reauth/win/authenticator_win.cc b/chrome/browser/device_reauth/win/authenticator_win.cc
index 1d9342a94ad70..c12ef488478df 100644
--- a/chrome/browser/device_reauth/win/authenticator_win.cc
+++ b/chrome/browser/device_reauth/win/authenticator_win.cc
@@ -45,6 +45,11 @@ using ABI::Windows::Security::Credentials::UI::
     UserConsentVerifierAvailability_NotConfiguredForUser;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 BiometricAuthenticationStatusWin ConvertUserConsentVerifierAvailability(
     UserConsentVerifierAvailability availability) {
   switch (availability) {
@@ -93,6 +98,11 @@ void GetBiometricAvailabilityFromWindows(
   // (http://crbug/973868).
   SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
 
+  if (!ResolveCoreWinRT()) {
+    ReportCantCheckAvailability(thread, std::move(callback));
+    return;
+  }
+
   ComPtr<IUserConsentVerifierStatics> factory;
   HRESULT hr = base::win::GetActivationFactory<
       IUserConsentVerifierStatics,
diff --git a/chrome/browser/download/chrome_download_manager_delegate.cc b/chrome/browser/download/chrome_download_manager_delegate.cc
index 201cd68c5175c..ee254bc3b7663 100644
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -57,6 +57,7 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pdf_util.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
@@ -1693,6 +1694,10 @@ bool ChromeDownloadManagerDelegate::IsOpenInBrowserPreferredForFile(
 bool ChromeDownloadManagerDelegate::ShouldBlockFile(
     download::DownloadItem* item,
     download::DownloadDangerType danger_type) const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableDownloadUpload) || base::CommandLine::ForCurrentProcess()->HasSwitch("allow-insecure-downloads") ||
+		base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kUngoogledThorium))	{
+	  return false;
+  }
   // Chrome-initiated background downloads should not be blocked.
   if (item && !item->RequireSafetyChecks()) {
     return false;
diff --git a/chrome/browser/download/download_crx_util.cc b/chrome/browser/download/download_crx_util.cc
index 2a1554690f890..6653161db3b95 100644
--- a/chrome/browser/download/download_crx_util.cc
+++ b/chrome/browser/download/download_crx_util.cc
@@ -8,6 +8,7 @@
 
 #include <memory>
 
+#include "base/command_line.h"
 #include "chrome/browser/extensions/crx_installer.h"
 #include "chrome/browser/extensions/extension_install_prompt.h"
 #include "chrome/browser/extensions/extension_management.h"
@@ -101,6 +102,14 @@ scoped_refptr<extensions::CrxInstaller> CreateCrxInstaller(
   return installer;
 }
 
+bool ShouldDownloadAsRegularFile() {
+    const base::CommandLine& command_line =
+        *base::CommandLine::ForCurrentProcess();
+    return command_line.HasSwitch("extension-mime-request-handling") &&
+        command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+        "download-as-regular-file";
+}
+
 bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetTargetDisposition() ==
       DownloadItem::TARGET_DISPOSITION_PROMPT)
@@ -109,7 +118,7 @@ bool IsExtensionDownload(const DownloadItem& download_item) {
   if (download_item.GetMimeType() == extensions::Extension::kMimeType ||
       extensions::UserScript::IsURLUserScript(download_item.GetURL(),
                                               download_item.GetMimeType())) {
-    return true;
+    return !ShouldDownloadAsRegularFile();
   } else {
     return false;
   }
diff --git a/chrome/browser/download/download_crx_util.h b/chrome/browser/download/download_crx_util.h
index 1846c1dcb4028..a50a9af030c77 100644
--- a/chrome/browser/download/download_crx_util.h
+++ b/chrome/browser/download/download_crx_util.h
@@ -35,6 +35,10 @@ scoped_refptr<extensions::CrxInstaller> CreateCrxInstaller(
     Profile* profile,
     const download::DownloadItem& download_item);
 
+// Returns true if the user wants all extensions to be downloaded as regular
+// files.
+bool ShouldDownloadAsRegularFile();
+
 // Returns true if this is an extension download. This also considers user
 // scripts to be extension downloads, since we convert those automatically.
 bool IsExtensionDownload(const download::DownloadItem& download_item);
diff --git a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
index ff0195c8fd8c6..c9cada3abd5ea 100644
--- a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
+++ b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
@@ -88,6 +88,11 @@ class WebAccountSupportFinder
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
 
+    if (!base::win::ResolveCoreWinRTDelayload())
+      return;  // Unsupported.
+    if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+      return;  // Unsupported.
+
     // Get the `WebAuthenticationCoreManager`.
     ComPtr<IWebAuthenticationCoreManagerStatics> auth_manager;
     HRESULT hresult = base::win::GetActivationFactory<
diff --git a/chrome/browser/extensions/extension_management.cc b/chrome/browser/extensions/extension_management.cc
index 16c5b86a66345..6ad24e278dcb0 100644
--- a/chrome/browser/extensions/extension_management.cc
+++ b/chrome/browser/extensions/extension_management.cc
@@ -8,6 +8,7 @@
 #include <string>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -253,6 +254,13 @@ bool ExtensionManagement::IsInstallationExplicitlyBlocked(
 bool ExtensionManagement::IsOffstoreInstallAllowed(
     const GURL& url,
     const GURL& referrer_url) const {
+   const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  if (command_line.HasSwitch("extension-mime-request-handling") &&
+      command_line.GetSwitchValueASCII("extension-mime-request-handling") ==
+      "always-prompt-for-install") {
+    return true;
+  }
   // No allowed install sites specified, disallow by default.
   if (!global_settings_->install_sources.has_value())
     return false;
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index d70932e1ad965..f339f340eacdd 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -1765,6 +1765,11 @@
     "owners": [ "cros-networking@google.com" ],
     "expiry_milestone": 121
   },
+  {
+    "name": "disable-download-upload",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disable-explicit-dma-fences",
     "owners": [ "chromeos-gfx@google.com" ],
@@ -1833,6 +1838,11 @@
     // workaround for some issues.
     "expiry_milestone": -1
   },
+  {
+    "name": "disable-windows-10-custom-titlebar",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disallow-doc-written-script-loads",
     "owners": [ "//chrome/browser/data_saver/OWNERS" ],
@@ -4507,6 +4523,11 @@
     // have no access to commandline flags.
     "expiry_milestone": -1
   },
+  {
+    "name": "disable-aero",
+    "owners": [ "win32ss", "alex313031" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "forced-colors",
     "owners": [ "almaher@microsoft.com" ],
@@ -4888,11 +4909,6 @@
     "owners": [ "//chrome/android/feed/OWNERS", "jianli@chromium.org" ],
     "expiry_milestone": 130
   },
-  {
-    "name": "insecure-download-warnings",
-    "owners": [ "jdeblasio@chromium.org", "trusty-transport@chromium.org" ],
-    "expiry_milestone": 120
-  },
   {
     "name": "install-isolated-web-app-from-url",
     "owners": [ "kuragin@chromium.org", "reillyg@chromium.org", "rmcelrath@chromium.org" ],
diff --git a/chrome/browser/flag-never-expire-list.json b/chrome/browser/flag-never-expire-list.json
index a0af02d2a73eb..d91f528af0605 100644
--- a/chrome/browser/flag-never-expire-list.json
+++ b/chrome/browser/flag-never-expire-list.json
@@ -32,10 +32,12 @@
   "disable-accelerated-video-decode",
   "disable-accelerated-video-encode",
   "disable-buffer-bw-compression",
+  "disable-download-upload",
   "disable-explicit-dma-fences",
   "disable-javascript-harmony-shipping",
   "disable-webrtc-hw-decoding",
   "disable-webrtc-hw-encoding",
+  "disable-windows-10-custom-titlebar",
   "disallow-doc-written-script-loads",
   "enable-autofill-credit-card-upload",
   "enable-benchmarking",
@@ -81,12 +83,15 @@
   "extensions-on-chrome-urls",
   "external-navigation-debug-logs",
   "force-color-profile",
+  "force-dark-mode",
   "force-effective-connection-type",
+  "force-gdi",
   "force-show-update-menu-badge",
   "force-startup-signin-promo",
   "force-text-direction",
   "force-ui-direction",
   "force-update-menu-type",
+  "disable-aero",
   "fullscreen-promos-manager-skip-internal-limits",
   "fullscreen-viewport-adjustment-experiment",
   "gesture-properties-dbus-service",
@@ -133,6 +138,7 @@
   "ui-debug-tools",
   "ui-disable-partial-swap",
   "ui-slow-animations",
+  "ungoogled-thorium",
   "unsafely-treat-insecure-origin-as-secure",
   "update-menu-item-custom-summary",
   "use-android-staging-smds",
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 8385c597f050e..c8b21c41162d4 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -1818,6 +1818,18 @@ const char kDrawImmediatelyWhenInteractiveDescription[] =
     "Causes viz to activate and draw frames immediately during a touch "
     "interaction or scroll.";
 
+const char kIncognitoBrandConsistencyForDesktopName[] =
+    "Enable Incognito brand consistency in desktop.";
+const char kIncognitoBrandConsistencyForDesktopDescription[] =
+    "When enabled, removes any theme or background customization done by the "
+    "user when in Incognito mode.";
+
+const char kInheritNativeThemeFromParentWidgetName[] =
+    "Allow widgets to inherit native theme from its parent widget.";
+const char kInheritNativeThemeFromParentWidgetDescription[] =
+    "When enabled, secondary UI like menus, dialog etc would be in dark mode "
+    "when Incognito mode is open.";
+
 const char kFillingAcrossGroupedSitesName[] =
     "Password filling across grouped websites";
 const char kFillingAcrossGroupedSitesDescription[] =
@@ -1854,6 +1866,14 @@ const char kForceTextDirectionDescription[] =
 const char kForceDirectionLtr[] = "Left-to-right";
 const char kForceDirectionRtl[] = "Right-to-left";
 
+const char kForceGdiName[] = "Force GDI font rendering";
+const char kForceGdiDescription[] =
+    "Use GDI font rendering in place of DirectWrite font rendering on Windows.";
+
+const char kDisableWindows10CustomTitlebarName[] = "Force disable Windows 10 custom titlebar";
+const char kDisableWindows10CustomTitlebarDescription[] =
+    "Disable the \"Windows 10\" custom titlebar to take advantage of Aero Glass fixes for Windows 7.";
+
 const char kForceUiDirectionName[] = "Force UI direction";
 const char kForceUiDirectionDescription[] =
     "Explicitly force the UI to left-to-right (LTR) or right-to-left (RTL) "
@@ -2004,6 +2024,10 @@ const char kHideIncognitoMediaMetadataDescription[] =
     "When enabled, media metadata will be hidden from your OS' media player "
     "if you are in an Incognito session.";
 
+const char kUngoogledThoriumName[] = "\"Ungoogled\" Thorium Mode";
+const char kUngoogledThoriumDescription[] = "A work in progress - this rolls all new privacy-protecting "
+											"features in Thorium into one option";
+
 const char kTabAudioMutingName[] = "Tab audio muting UI control";
 const char kTabAudioMutingDescription[] =
     "When enabled, the audio indicators in the tab strip double as tab audio "
@@ -2814,6 +2838,16 @@ const char kAutoWebContentsDarkModeName[] = "Auto Dark Mode for Web Contents";
 const char kAutoWebContentsDarkModeDescription[] =
     "Automatically render all web contents using a dark theme.";
 
+
+
+
+
+
+const char kDisableAeroThemeName[] = "Use Classic Theme: Disable Aero Window Frame Compositing";
+const char kDisableAeroThemeDescription[] =
+	"Use the classic Chromium theme designed to mimick \"Aero\" window controls. "
+	"Typically used when desktop composition is disabled or unavailable.";
+
 const char kForcedColorsName[] = "Forced Colors";
 const char kForcedColorsDescription[] =
     "Enables forced colors mode for web content.";
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index a023e473a3c31..09375d54c9e93 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1601,6 +1601,18 @@ extern const char kParallelDownloadingDescription[];
 extern const char kPasswordGenerationExperimentName[];
 extern const char kPasswordGenerationExperimentDescription[];
 
+
+
+
+extern const char kUngoogledThoriumName[];
+extern const char kUngoogledThoriumDescription[];
+
+extern const char kForceGdiName[];
+extern const char kForceGdiDescription[];
+
+extern const char kDisableWindows10CustomTitlebarName[];
+extern const char kDisableWindows10CustomTitlebarDescription[];
+
 extern const char kPasswordGenerationStrongLabelExperimentName[];
 extern const char kPasswordGenerationStrongLabelExperimentDescription[];
 
@@ -1619,6 +1631,12 @@ extern const char kPdfXfaFormsDescription[];
 extern const char kAutoWebContentsDarkModeName[];
 extern const char kAutoWebContentsDarkModeDescription[];
 
+
+
+
+extern const char kDisableAeroThemeName[];
+extern const char kDisableAeroThemeDescription[];
+
 extern const char kForcedColorsName[];
 extern const char kForcedColorsDescription[];
 
@@ -4612,6 +4635,12 @@ extern const char kTheoraVideoCodecDescription[];
 extern const char kForceSigninFlowInProfilePickerName[];
 extern const char kForceSigninFlowInProfilePickerDescription[];
 
+extern const char kIncognitoBrandConsistencyForDesktopName[];
+extern const char kIncognitoBrandConsistencyForDesktopDescription[];
+
+extern const char kInheritNativeThemeFromParentWidgetName[];
+extern const char kInheritNativeThemeFromParentWidgetDescription[];
+
 // ============================================================================
 // Don't just add flags to the end, put them in the right section in
 // alphabetical order. See top instructions for more.
diff --git a/chrome/browser/notifications/notification_platform_bridge_win.cc b/chrome/browser/notifications/notification_platform_bridge_win.cc
index f8f6950152bcb..b951f482802a2 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win.cc
@@ -714,7 +714,7 @@ class NotificationPlatformBridgeWinImpl
         InstallUtil::IsStartMenuShortcutWithActivatorGuidInstalled();
 
     int status = static_cast<int>(SetReadyCallbackStatus::kSuccess);
-    bool enabled = activator_registered && shortcut_installed;
+    bool enabled = base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload() && activator_registered && shortcut_installed;
 
     if (!enabled) {
       if (!shortcut_installed) {
@@ -725,6 +725,8 @@ class NotificationPlatformBridgeWinImpl
         status |= static_cast<int>(
             SetReadyCallbackStatus::kComServerMisconfiguration);
       }
+      if (!(base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload()))
+        status |= static_cast<int>(SetReadyCallbackStatus::kComNotInitialized);
     }
 
     LogSetReadyCallbackStatus(static_cast<SetReadyCallbackStatus>(status));
diff --git a/chrome/browser/notifications/win/notification_metrics.h b/chrome/browser/notifications/win/notification_metrics.h
index 8dfbaea83d66c..aab0938792430 100644
--- a/chrome/browser/notifications/win/notification_metrics.h
+++ b/chrome/browser/notifications/win/notification_metrics.h
@@ -137,8 +137,8 @@ enum class SetReadyCallbackStatus {
   kSuccess = 0,
   kShortcutMisconfiguration = 1 << 0,
   kComServerMisconfiguration = 1 << 1,
-  kComNotInitializedObsolete = 1 << 2,  // No longer possible w/ Win10+ only.
-  kMaxValue = kComNotInitializedObsolete,
+  kComNotInitialized = 1 << 2,
+  kMaxValue = kComNotInitialized,
 };
 
 // These values are persisted to logs. Entries should not be renumbered and
diff --git a/chrome/browser/obsolete_system/obsolete_system_win.cc b/chrome/browser/obsolete_system/obsolete_system_win.cc
index 689026a405de0..356efbd904b66 100644
--- a/chrome/browser/obsolete_system/obsolete_system_win.cc
+++ b/chrome/browser/obsolete_system/obsolete_system_win.cc
@@ -22,16 +22,12 @@ base::win::Version GetRealOSVersion() {
   return base::win::OSInfo::Kernel32Version();
 }
 
-bool IsObsoleteOsVersion() {
-  return GetRealOSVersion() < base::win::Version::WIN10;
-}
-
 }  // namespace
 
 namespace ObsoleteSystem {
 
 bool IsObsoleteNowOrSoon() {
-  return IsObsoleteOsVersion();
+  return false;
 }
 
 std::u16string LocalizedObsoleteString() {
@@ -52,7 +48,7 @@ bool IsEndOfTheLine() {
   // M109 was the last milestone to support Win 7/8/8.1, the last deprecated
   // Windows version. Future deprecations should update this to the last
   // milestone that supports the soon-to-be-deprecated Windows version.
-  return CHROME_VERSION_MAJOR >= 109;
+  return false;
 }
 
 const char* GetLinkURL() {
diff --git a/chrome/browser/password_manager/password_manager_util_win.cc b/chrome/browser/password_manager/password_manager_util_win.cc
index 4bff1795c0a87..8e787dbaf87aa 100644
--- a/chrome/browser/password_manager/password_manager_util_win.cc
+++ b/chrome/browser/password_manager/password_manager_util_win.cc
@@ -16,11 +16,19 @@
 #include <security.h>
 #undef SECURITY_WIN32
 
+#include <memory>
+
+#include "chrome/browser/password_manager/password_manager_util_win.h"
+
+#include "base/feature_list.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/hang_watcher.h"
 #include "base/threading/scoped_thread_priority.h"
 #include "base/time/time.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/password_manager/password_manager_util_win.h"
 #include "chrome/grit/branded_strings.h"
@@ -36,6 +44,13 @@ namespace {
 
 const unsigned kMaxPasswordRetries = 3;
 
+const unsigned kCredUiDefaultFlags =
+    CREDUI_FLAGS_GENERIC_CREDENTIALS |
+    CREDUI_FLAGS_EXCLUDE_CERTIFICATES |
+    CREDUI_FLAGS_KEEP_USERNAME |
+    CREDUI_FLAGS_ALWAYS_SHOW_UI |
+    CREDUI_FLAGS_DO_NOT_PERSIST;
+
 struct PasswordCheckPrefs {
   PasswordCheckPrefs() : pref_last_changed_(0), blank_password_(false) {}
 
@@ -160,6 +175,11 @@ std::unique_ptr<char[]> CredentialBufferValidator::GetTokenInformation(
   return token_info_buffer;
 }
 
+// TODO(crbug.com/574581) Remove this feature once this is confirmed to work
+// as expected.
+const base::Feature kCredUIPromptForWindowsCredentialsFeature{
+    "CredUIPromptForWindowsCredentials", base::FEATURE_ENABLED_BY_DEFAULT};
+
 void PasswordCheckPrefs::Read(PrefService* local_state) {
   blank_password_ =
       local_state->GetBoolean(password_manager::prefs::kOsPasswordBlank);
@@ -279,10 +299,106 @@ bool DeviceAuthenticationPresent(const WCHAR* username) {
   return base::win::IsEnrolledToDomain() || !CheckBlankPassword(username);
 }
 
-}  // namespace
+// Authenticate the user using the old Windows credential prompt.
+bool AuthenticateUserOld(gfx::NativeWindow window,
+                         const std::u16string& password_prompt) {
+  bool retval = false;
+  CREDUI_INFO cui = {};
+  WCHAR username[CREDUI_MAX_USERNAME_LENGTH+1] = {};
+  WCHAR displayname[CREDUI_MAX_USERNAME_LENGTH+1] = {};
+  WCHAR password[CREDUI_MAX_PASSWORD_LENGTH+1] = {};
+  DWORD username_length = CREDUI_MAX_USERNAME_LENGTH;
+  std::u16string product_name = l10n_util::GetStringUTF16(IDS_PRODUCT_NAME);
+  HANDLE handle = INVALID_HANDLE_VALUE;
+  size_t tries = 0;
+  bool use_displayname = false;
+  bool use_principalname = false;
+  DWORD logon_result = 0;
+  // On a domain, we obtain the User Principal Name
+  // for domain authentication.
+  if (GetUserNameEx(NameUserPrincipal, username, &username_length)) {
+    use_principalname = true;
+  } else {
+    username_length = CREDUI_MAX_USERNAME_LENGTH;
+    // Otherwise, we're a workstation, use the plain local username.
+    if (!GetUserName(username, &username_length)) {
+      DLOG(ERROR) << "Unable to obtain username " << GetLastError();
+      return false;
+    } else {
+      // As we are on a workstation, it's possible the user
+      // has no password, so check here.
+      if (CheckBlankPassword(username))
+        return true;
+    }
+  }
 
-bool AuthenticateUser(gfx::NativeWindow window,
-                      const std::u16string& password_prompt) {
+  // Try and obtain a friendly display name.
+  username_length = CREDUI_MAX_USERNAME_LENGTH;
+  if (GetUserNameEx(NameDisplay, displayname, &username_length))
+    use_displayname = true;
+
+  cui.cbSize = sizeof(CREDUI_INFO);
+  cui.hwndParent = NULL;
+  cui.hwndParent = window->GetHost()->GetAcceleratedWidget();
+
+  cui.pszMessageText = base::as_wcstr(password_prompt);
+  cui.pszCaptionText = base::as_wcstr(product_name);
+
+  cui.hbmBanner = NULL;
+  BOOL save_password = FALSE;
+  DWORD credErr = NO_ERROR;
+
+  do {
+    tries++;
+
+    // TODO(wfh) Make sure we support smart cards here.
+    credErr = CredUIPromptForCredentials(
+        &cui,
+        base::as_wcstr(product_name),
+        NULL,
+        0,
+        use_displayname ? displayname : username,
+        CREDUI_MAX_USERNAME_LENGTH+1,
+        password,
+        CREDUI_MAX_PASSWORD_LENGTH+1,
+        &save_password,
+        kCredUiDefaultFlags |
+        (tries > 1 ? CREDUI_FLAGS_INCORRECT_PASSWORD : 0));
+
+    if (credErr == NO_ERROR) {
+      logon_result = LogonUser(username,
+                               use_principalname ? NULL : L".",
+                               password,
+                               LOGON32_LOGON_INTERACTIVE,
+                               LOGON32_PROVIDER_DEFAULT,
+                               &handle);
+      if (logon_result) {
+        retval = true;
+        CloseHandle(handle);
+      } else {
+        if (GetLastError() == ERROR_ACCOUNT_RESTRICTION &&
+            wcslen(password) == 0) {
+          // Password is blank, so permit.
+          retval = true;
+        } else {
+          DLOG(WARNING) << "Unable to authenticate " << GetLastError();
+        }
+      }
+      SecureZeroMemory(password, sizeof(password));
+    }
+  } while (credErr == NO_ERROR &&
+           (retval == false && tries < kMaxPasswordRetries));
+  return retval;
+}
+
+// Authenticate the user using the new Windows credential prompt.  The new
+// prompt allows the user to authenticate using additional credential providers,
+// such as PINs, smartcards, fingerprint scanners, and so on.  It also still
+// allows the user to authenticate with their password.  This old prompt only
+// supported password authentication which is not enough for enterprise
+// environments.
+bool AuthenticateUserNew(gfx::NativeWindow window,
+                         const std::u16string& password_prompt) {
   bool retval = false;
   WCHAR cur_username[CREDUI_MAX_USERNAME_LENGTH + 1] = {};
   DWORD cur_username_length = std::size(cur_username);
@@ -348,6 +464,15 @@ bool AuthenticateUser(gfx::NativeWindow window,
   return retval;
 }
 
+}  // namespace
+
+bool AuthenticateUser(gfx::NativeWindow window,
+                      const std::u16string& password_prompt) {
+  return base::FeatureList::IsEnabled(kCredUIPromptForWindowsCredentialsFeature) && base::win::GetVersion() >= base::win::Version::VISTA
+             ? AuthenticateUserNew(window, password_prompt)
+             : AuthenticateUserOld(window, password_prompt);
+}
+
 bool CanAuthenticateWithScreenLock() {
   WCHAR cur_username[CREDUI_MAX_USERNAME_LENGTH + 1] = {};
   DWORD cur_username_length = std::size(cur_username);
diff --git a/chrome/browser/resources/side_panel/bookmarks/BUILD.gn b/chrome/browser/resources/side_panel/bookmarks/BUILD.gn
index 3de29e5e0223a..a575d9af8c31b 100644
--- a/chrome/browser/resources/side_panel/bookmarks/BUILD.gn
+++ b/chrome/browser/resources/side_panel/bookmarks/BUILD.gn
@@ -10,6 +10,7 @@ build_webui("build") {
   grd_prefix = "side_panel_bookmarks"
 
   static_files = [
+    "bookmarks.html",
     "images/bookmarks_empty_dark.svg",
     "images/bookmarks_empty.svg",
     "power_bookmarks.html",
@@ -17,6 +18,8 @@ build_webui("build") {
 
   # Files holding a Polymer element definition and have an equivalent .html file.
   web_component_files = [
+    "bookmark_folder.ts",
+    "bookmarks_list.ts",
     "commerce/shopping_list.ts",
     "power_bookmark_row.ts",
     "power_bookmarks_context_menu.ts",
@@ -27,6 +30,7 @@ build_webui("build") {
 
   non_web_component_files = [
     "bookmarks_api_proxy.ts",
+    "bookmarks_drag_manager.ts",
     "power_bookmarks_drag_manager.ts",
     "power_bookmarks_service.ts",
   ]
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.html b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.html
new file mode 100644
index 0000000000000..4a81cedbda7cb
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.html
@@ -0,0 +1,219 @@
+<style include="mwb-element-shared-style">
+  :host {
+    --row-height: 40px;
+    display: block;
+    user-select: none;
+    white-space: nowrap;
+  }
+
+  .row {
+    --row-padding-inline-start: calc(var(--node-depth) * 17px);
+    --row-icon-width: 20px;
+    align-items: center;
+    appearance: none;
+    background: transparent;
+    border: none;
+    box-sizing: border-box;
+    color: currentColor;
+    display: grid;
+    font-size: var(--mwb-primary-text-font-size);
+    grid-template-areas: 'arrow icon title';
+    grid-template-columns: var(--row-icon-width) var(--row-icon-width) auto;
+    height: var(--row-height);
+    line-height: var(--row-height);
+    padding-block-end: 0;
+    padding-block-start: 0;
+    padding-inline-start: var(--row-padding-inline-start);
+    text-align: start;
+    width: 100%;
+  }
+
+  :host-context([hover-visible]) .row:not([empty]):hover {
+    background-color: var(--mwb-list-item-hover-background-color);
+  }
+
+  :host-context(.focus-outline-visible) .row:focus,
+  :host-context(.focus-outline-visible) .row:focus:hover {
+    background-color: var(--mwb-list-item-selected-background-color);
+    outline: none;
+  }
+
+  .row:focus-visible:focus {
+    outline: none;
+  }
+
+  :host-context([hover-visible]) .row:not([empty]):active,
+  :host-context(.focus-outline-visible) .row:not([empty]):active {
+    background-color: var(--cr-active-background-color);
+  }
+
+  .arrow,
+  .icon,
+  .title {
+    /**
+     * Keep content-visibility on inner children of .row instead of on .row
+     * as the CSS property seems to have bugs with rendering elements outside
+     * of .row when dragging elements around.
+     */
+    content-visibility: auto;
+  }
+
+  #arrow {
+    grid-area: arrow;
+    justify-self: center;
+  }
+
+  #arrowIcon {
+    --cr-icon-button-hover-background-color: transparent;
+    --cr-icon-button-active-background-color: transparent;
+    margin: 0;
+    transform: rotate(-90deg);
+    transition: transform 100ms cubic-bezier(0.4, 0, 0.2, 1);
+  }
+
+  #arrowIcon[open] {
+    transform: rotate(0);
+  }
+
+  #arrowIcon:focus,
+  #arrowIcon:hover {
+    background: none;
+    box-shadow: none;
+  }
+
+  :host-context([dir='rtl']) #arrowIcon:not([open]) {
+    transform: rotate(90deg);
+  }
+
+  .icon {
+    background-position: left center;
+    background-repeat: no-repeat;
+    grid-area: icon;
+    height: 16px;
+    justify-self: center;
+    width: 16px;
+  }
+
+  #folderIcon {
+    background-image: url(chrome://theme/IDR_FOLDER_CLOSED);
+  }
+
+  /**
+   * Folder icons are OS-specific. On Mac, there is a separate folder icon
+   * for dark mode; on non-Mac, there is a separate folder icon for open states
+   * and the icon for that is slightly larger. This is mirroring the icons
+   * used in chrome://bookmarks.
+   */
+<if expr="is_macosx">
+  @media (prefers-color-scheme: dark) {
+    #folderIcon {
+      background-image: url(chrome://theme/IDR_FOLDER_CLOSED_WHITE);
+    }
+  }
+</if>
+
+<if expr="not is_macosx">
+    #folderIcon {
+      height: 20px;
+      width: 20px;
+    }
+
+    #folderIcon[open] {
+      background-image: url(chrome://theme/IDR_FOLDER_OPEN);
+    }
+</if>
+
+  .title {
+    grid-area: title;
+    overflow: hidden;
+    padding: 0 10px;
+    text-overflow: ellipsis;
+  }
+
+  .bookmark {
+    color: currentColor;
+    text-decoration: none;
+  }
+
+  #children {
+    --node-depth: var(--child-depth);
+    min-height: calc(var(--child-count, 0) * var(--row-height));
+  }
+
+  [drop-position='into'] {
+    background: var(--mwb-list-item-selected-background-color);
+  }
+
+  [drop-position='above'],
+  [drop-position='below'] {
+    position: relative;
+  }
+
+  [drop-position='above']::after,
+  [drop-position='below']::after {
+    background: var(--google-blue-500);
+    content: '';
+    display: block;
+    height: 2px;
+    left: calc(
+        var(--row-padding-inline-start) + var(--row-icon-width));
+    position: absolute;
+    right: 0;
+    top: -1px;
+  }
+
+  [drop-position='below']::after {
+    bottom: -1px;
+    top: auto;
+  }
+</style>
+<div id="container" role="treeitem" aria-expanded="[[getAriaExpanded_(open_)]]">
+  <button id="folder" class="row"
+      title="[[folder.title]]"
+      draggable="true"
+      data-bookmark="[[folder]]"
+      empty$="[[!folder.children.length]]"
+      on-click="onFolderClick_" on-contextmenu="onFolderContextMenu_">
+    <div id="arrow" hidden$="[[!folder.children.length]]">
+      <cr-icon-button
+          id="arrowIcon"
+          iron-icon="cr:arrow-drop-down"
+          open$="[[open_]]"
+          tabindex="-1">
+      </cr-icon-button>
+    </div>
+    <div id="folderIcon" class="icon" open$="[[open_]]"></div>
+    <div class="title">[[folder.title]]</div>
+  </button>
+
+  <template is="dom-if" if="[[open_]]" restamp>
+    <div id="children" role="group">
+      <template is="dom-repeat" items="[[folder.children]]" initial-count="20">
+        <template is="dom-if" if="[[!item.url]]" restamp>
+          <bookmark-folder
+              id="bookmark-[[item.id]]"
+              folder="[[item]]"
+              depth="[[childDepth_]]"
+              open-folders="[[openFolders]]">
+          </bookmark-folder>
+        </template>
+
+        <template is="dom-if" if="[[item.url]]" restamp>
+          <button
+              id="bookmark-[[item.id]]" role="treeitem" class="bookmark row"
+              title="[[item.title]]"
+              draggable="true" data-bookmark="[[item]]"
+              on-click="onBookmarkClick_"
+              on-auxclick="onBookmarkAuxClick_"
+              on-contextmenu="onBookmarkContextMenu_">
+            <div
+                class="icon"
+                style="background-image: [[getBookmarkIcon_(item.url)]]">
+            </div>
+            <div class="title">[[item.title]]</div>
+          </button>
+        </template>
+      </template>
+    </div>
+  </template>
+</div>
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.ts b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.ts
new file mode 100644
index 0000000000000..34ace377a0ebc
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmark_folder.ts
@@ -0,0 +1,274 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://resources/cr_elements/cr_icon_button/cr_icon_button.js';
+import 'chrome://resources/cr_elements/icons.html.js';
+import 'chrome://resources/cr_elements/cr_shared_vars.css.js';
+import 'chrome://resources/cr_elements/mwb_element_shared_style.css.js';
+
+import {getFaviconForPageURL} from 'chrome://resources/js/icon.js';
+import {DomRepeatEvent, PolymerElement} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+
+import {getTemplate} from './bookmark_folder.html.js';
+import {ActionSource} from './bookmarks.mojom-webui.js';
+import {BookmarksApiProxy, BookmarksApiProxyImpl} from './bookmarks_api_proxy.js';
+
+export interface BookmarkFolderElement {
+  $: {
+    children: HTMLElement,
+  };
+}
+
+// Event name for open state of a folder being changed.
+export const FOLDER_OPEN_CHANGED_EVENT = 'bookmark-folder-open-changed';
+
+export class BookmarkFolderElement extends PolymerElement {
+  static get is() {
+    return 'bookmark-folder';
+  }
+
+  static get template() {
+    return getTemplate();
+  }
+
+  static get properties() {
+    return {
+      childDepth_: {
+        type: Number,
+        value: 1,
+      },
+
+      depth: {
+        type: Number,
+        observer: 'onDepthChanged_',
+        value: 0,
+      },
+
+      folder: Object,
+
+      open_: {
+        type: Boolean,
+        value: false,
+        computed:
+            'computeIsOpen_(openFolders, folder.id, folder.children.length)',
+      },
+
+      openFolders: Array,
+    };
+  }
+
+  private childDepth_: number;
+  depth: number;
+  folder: chrome.bookmarks.BookmarkTreeNode;
+  private open_: boolean;
+  openFolders: string[];
+  private bookmarksApi_: BookmarksApiProxy =
+      BookmarksApiProxyImpl.getInstance();
+
+  static get observers() {
+    return [
+      'onChildrenLengthChanged_(folder.children.length)',
+    ];
+  }
+
+  private getAriaExpanded_(): string|undefined {
+    if (!this.folder.children || this.folder.children.length === 0) {
+      // Remove the attribute for empty folders that cannot be expanded.
+      return undefined;
+    }
+
+    return this.open_ ? 'true' : 'false';
+  }
+
+  private onBookmarkAuxClick_(
+      event: DomRepeatEvent<chrome.bookmarks.BookmarkTreeNode, MouseEvent>) {
+    if (event.button !== 1) {
+      // Not a middle click.
+      return;
+    }
+
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.openBookmark(
+        event.model.item.id!, this.depth, {
+          middleButton: true,
+          altKey: event.altKey,
+          ctrlKey: event.ctrlKey,
+          metaKey: event.metaKey,
+          shiftKey: event.shiftKey,
+        },
+        ActionSource.kBookmark);
+  }
+
+  private onBookmarkClick_(
+      event: DomRepeatEvent<chrome.bookmarks.BookmarkTreeNode, MouseEvent>) {
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.openBookmark(
+        event.model.item.id!, this.depth, {
+          middleButton: false,
+          altKey: event.altKey,
+          ctrlKey: event.ctrlKey,
+          metaKey: event.metaKey,
+          shiftKey: event.shiftKey,
+        },
+        ActionSource.kBookmark);
+  }
+
+  private onBookmarkContextMenu_(
+      event: DomRepeatEvent<chrome.bookmarks.BookmarkTreeNode, MouseEvent>) {
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.showContextMenu(
+        event.model.item.id, event.clientX, event.clientY,
+        ActionSource.kBookmark);
+  }
+
+  private onFolderContextMenu_(event: MouseEvent) {
+    event.preventDefault();
+    event.stopPropagation();
+    this.bookmarksApi_.showContextMenu(
+        this.folder.id, event.clientX, event.clientY, ActionSource.kBookmark);
+  }
+
+  private getBookmarkIcon_(url: string): string {
+    return getFaviconForPageURL(url, false);
+  }
+
+  private onChildrenLengthChanged_() {
+    if (this.folder.children) {
+      this.style.setProperty(
+          '--child-count', this.folder.children!.length.toString());
+    } else {
+      this.style.setProperty('--child-count', '0');
+    }
+  }
+
+  private onDepthChanged_() {
+    this.childDepth_ = this.depth + 1;
+    this.style.setProperty('--node-depth', `${this.depth}`);
+    this.style.setProperty('--child-depth', `${this.childDepth_}`);
+  }
+
+  private onFolderClick_(event: Event) {
+    event.preventDefault();
+    event.stopPropagation();
+
+    if (!this.folder.children || this.folder.children.length === 0) {
+      // No reason to open if there are no children to show.
+      return;
+    }
+
+    this.dispatchEvent(new CustomEvent(FOLDER_OPEN_CHANGED_EVENT, {
+      bubbles: true,
+      composed: true,
+      detail: {
+        id: this.folder.id,
+        open: !this.open_,
+      },
+    }));
+
+    chrome.metricsPrivate.recordUserAction(
+        this.open_ ? 'SidePanel.Bookmarks.FolderOpen' :
+                     'SidePanel.Bookmarks.FolderClose');
+  }
+
+  private computeIsOpen_() {
+    return Boolean(this.openFolders) &&
+        this.openFolders.includes(this.folder.id) && this.folder.children &&
+        this.folder.children.length > 0;
+  }
+
+  private getFocusableRows_(): HTMLElement[] {
+    return Array.from(
+        this.shadowRoot!.querySelectorAll('.row, bookmark-folder'));
+  }
+
+  getFocusableElement(path: chrome.bookmarks.BookmarkTreeNode[]): (HTMLElement|
+                                                                   null) {
+    const currentNode = path.shift();
+    if (currentNode) {
+      const currentNodeId = currentNode.id;
+      const currentNodeElement =
+          this.shadowRoot!.querySelector(`#bookmark-${currentNodeId}`) as (
+              HTMLElement | null);
+      if (currentNodeElement &&
+          currentNodeElement.classList.contains('bookmark')) {
+        // Found a bookmark item.
+        return currentNodeElement;
+      }
+
+      if (currentNodeElement &&
+          currentNodeElement instanceof BookmarkFolderElement) {
+        // Bookmark item may be a grandchild or be deeper. Iterate through
+        // child BookmarkFolderElements until the bookmark item is found.
+        const nestedElement = currentNodeElement.getFocusableElement(path);
+        if (nestedElement) {
+          return nestedElement;
+        }
+      }
+    }
+
+    // If all else fails, return the focusable folder row.
+    return this.shadowRoot!.querySelector('#folder');
+  }
+
+  moveFocus(delta: -1|1): boolean {
+    const currentFocus = this.shadowRoot!.activeElement;
+    if (currentFocus instanceof BookmarkFolderElement &&
+        currentFocus.moveFocus(delta)) {
+      // If focus is already inside a nested folder, delegate the focus to the
+      // nested folder and return early if successful.
+      return true;
+    }
+
+    let moveFocusTo = null;
+    const focusableRows = this.getFocusableRows_();
+    if (currentFocus) {
+      // If focus is in this folder, move focus to the next or previous
+      // focusable row.
+      const currentFocusIndex =
+          focusableRows.indexOf(currentFocus as HTMLElement);
+      moveFocusTo = focusableRows[currentFocusIndex + delta];
+    } else {
+      // If focus is not in this folder yet, move focus to either end.
+      moveFocusTo = delta === 1 ? focusableRows[0] :
+                                  focusableRows[focusableRows.length - 1];
+    }
+
+    if (moveFocusTo instanceof BookmarkFolderElement) {
+      return moveFocusTo.moveFocus(delta);
+    } else if (moveFocusTo) {
+      moveFocusTo.focus();
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
+
+declare global {
+  interface HTMLElementTagNameMap {
+    'bookmark-folder': BookmarkFolderElement;
+  }
+}
+
+customElements.define(BookmarkFolderElement.is, BookmarkFolderElement);
+
+interface DraggableElement extends HTMLElement {
+  dataBookmark: chrome.bookmarks.BookmarkTreeNode;
+}
+
+export function getBookmarkFromElement(element: HTMLElement):
+    chrome.bookmarks.BookmarkTreeNode {
+  return (element as DraggableElement).dataBookmark;
+}
+
+export function isValidDropTarget(element: HTMLElement) {
+  return element.id === 'folder' || element.classList.contains('bookmark');
+}
+
+export function isBookmarkFolderElement(element: HTMLElement): boolean {
+  return element.id === 'folder';
+}
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks.html b/chrome/browser/resources/side_panel/bookmarks/bookmarks.html
new file mode 100644
index 0000000000000..c6128dc9d8e8b
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks.html
@@ -0,0 +1,35 @@
+<!doctype html>
+<html dir="$i18n{textdirection}" lang="$i18n{language}">
+<head>
+  <meta charset="utf-8">
+  <title>$i18n{bookmarksTabTitle}</title>
+  <meta name="color-scheme" content="light dark">
+  <link rel="stylesheet" href="chrome://resources/css/text_defaults_md.css">
+  <link rel="stylesheet" href="chrome://resources/css/md_colors.css">
+  <style>
+    html,
+    body {
+      height: 100%;
+      margin: 0;
+      padding: 0;
+      width: 100%;
+    }
+
+    body {
+      background: white;
+      overflow-x: hidden;
+      overflow-y: auto;
+    }
+
+    @media (prefers-color-scheme: dark) {
+      body {
+        background: var(--google-grey-900);
+      }
+    }
+  </style>
+</head>
+<body>
+  <bookmarks-list></bookmarks-list>
+  <script type="module" src="bookmarks_list.js"></script>
+</body>
+</html>
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks_drag_manager.ts b/chrome/browser/resources/side_panel/bookmarks/bookmarks_drag_manager.ts
new file mode 100644
index 0000000000000..8131a048c8887
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks_drag_manager.ts
@@ -0,0 +1,270 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import '../strings.m.js';
+
+import {EventTracker} from 'chrome://resources/js/event_tracker.js';
+import {loadTimeData} from 'chrome://resources/js/load_time_data.js';
+
+import {getBookmarkFromElement, isBookmarkFolderElement, isValidDropTarget} from './bookmark_folder.js';
+
+export const DROP_POSITION_ATTR = 'drop-position';
+
+const ROOT_FOLDER_ID = '0';
+
+// Ms to wait during a dragover to open closed folder.
+let folderOpenerTimeoutDelay = 1000;
+export function overrideFolderOpenerTimeoutDelay(ms: number) {
+  folderOpenerTimeoutDelay = ms;
+}
+
+export enum DropPosition {
+  ABOVE = 'above',
+  INTO = 'into',
+  BELOW = 'below',
+}
+
+interface BookmarksDragDelegate extends HTMLElement {
+  getAscendants(bookmarkId: string): string[];
+  getIndex(bookmark: chrome.bookmarks.BookmarkTreeNode): number;
+  isFolderOpen(bookmark: chrome.bookmarks.BookmarkTreeNode): boolean;
+  onFinishDrop(bookmarks: chrome.bookmarks.BookmarkTreeNode[]): void;
+  openFolder(folderId: string): void;
+}
+
+class DragSession {
+  private delegate_: BookmarksDragDelegate;
+  private dragData_: chrome.bookmarkManagerPrivate.DragData;
+  private lastDragOverElement_: HTMLElement|null = null;
+  private lastPointerWasTouch_ = false;
+  private folderOpenerTimeout_: number|null = null;
+
+  constructor(
+      delegate: BookmarksDragDelegate,
+      dragData: chrome.bookmarkManagerPrivate.DragData) {
+    this.delegate_ = delegate;
+    this.dragData_ = dragData;
+  }
+
+  start(e: DragEvent) {
+    chrome.bookmarkManagerPrivate.startDrag(
+        this.dragData_.elements!.map(bookmark => bookmark.id), 0,
+        this.lastPointerWasTouch_, e.clientX, e.clientY);
+  }
+
+  update(e: DragEvent) {
+    const dragOverElement = e.composedPath().find(target => {
+      return target instanceof HTMLElement && isValidDropTarget(target);
+    }) as HTMLElement;
+    if (!dragOverElement) {
+      return;
+    }
+
+    if (dragOverElement !== this.lastDragOverElement_) {
+      this.resetState_();
+    }
+
+    const dragOverBookmark = getBookmarkFromElement(dragOverElement);
+    const ascendants = this.delegate_.getAscendants(dragOverBookmark.id);
+    const isInvalidDragOverTarget = dragOverBookmark.unmodifiable ||
+        this.dragData_.elements &&
+            this.dragData_.elements.some(
+                element => ascendants.indexOf(element.id) !== -1);
+    if (isInvalidDragOverTarget) {
+      this.lastDragOverElement_ = null;
+      return;
+    }
+
+    const isDraggingOverFolder = isBookmarkFolderElement(dragOverElement);
+    const dragOverElRect = dragOverElement.getBoundingClientRect();
+    const dragOverYRatio =
+        (e.clientY - dragOverElRect.top) / dragOverElRect.height;
+
+    let dropPosition;
+    if (isDraggingOverFolder) {
+      const folderIsOpen = this.delegate_.isFolderOpen(dragOverBookmark);
+      if (dragOverBookmark.parentId === ROOT_FOLDER_ID) {
+        // Cannot drag above or below children of root folder.
+        dropPosition = DropPosition.INTO;
+      } else if (dragOverYRatio <= .25) {
+        dropPosition = DropPosition.ABOVE;
+      } else if (dragOverYRatio <= .75) {
+        dropPosition = DropPosition.INTO;
+      } else if (folderIsOpen) {
+        // If a folder is open, its child bookmarks appear immediately below it
+        // so it should not be possible to drop a bookmark right below an open
+        // folder.
+        dropPosition = DropPosition.INTO;
+      } else {
+        dropPosition = DropPosition.BELOW;
+      }
+    } else {
+      dropPosition =
+          dragOverYRatio <= .5 ? DropPosition.ABOVE : DropPosition.BELOW;
+    }
+    dragOverElement.setAttribute(DROP_POSITION_ATTR, dropPosition);
+
+    if (dropPosition === DropPosition.INTO &&
+        !this.delegate_.isFolderOpen(dragOverBookmark) &&
+        !this.folderOpenerTimeout_) {
+      // Queue a timeout to auto-open the dragged over folder.
+      this.folderOpenerTimeout_ = setTimeout(() => {
+        this.delegate_.openFolder(dragOverBookmark.id);
+        this.folderOpenerTimeout_ = null;
+      }, folderOpenerTimeoutDelay);
+    }
+
+    this.lastDragOverElement_ = dragOverElement;
+  }
+
+  cancel() {
+    this.resetState_();
+    this.lastDragOverElement_ = null;
+  }
+
+  finish() {
+    if (!this.lastDragOverElement_) {
+      return;
+    }
+
+    const dropTargetBookmark =
+        getBookmarkFromElement(this.lastDragOverElement_);
+    const dropPosition = this.lastDragOverElement_.getAttribute(
+                             DROP_POSITION_ATTR) as DropPosition;
+    this.resetState_();
+
+    if (isBookmarkFolderElement(this.lastDragOverElement_) &&
+        dropPosition === DropPosition.INTO) {
+      chrome.bookmarkManagerPrivate
+          .drop(dropTargetBookmark.id, /* index */ undefined)
+          .then(() => this.delegate_.onFinishDrop(this.dragData_.elements!));
+      return;
+    }
+
+    let toIndex = this.delegate_.getIndex(dropTargetBookmark);
+    toIndex += dropPosition === DropPosition.BELOW ? 1 : 0;
+    chrome.bookmarkManagerPrivate.drop(dropTargetBookmark.parentId!, toIndex)
+        .then(() => this.delegate_.onFinishDrop(this.dragData_.elements!));
+  }
+
+  private resetState_() {
+    if (this.lastDragOverElement_) {
+      this.lastDragOverElement_.removeAttribute(DROP_POSITION_ATTR);
+    }
+
+    if (this.folderOpenerTimeout_ !== null) {
+      clearTimeout(this.folderOpenerTimeout_);
+      this.folderOpenerTimeout_ = null;
+    }
+  }
+
+  static createFromBookmark(
+      delegate: BookmarksDragDelegate,
+      bookmark: chrome.bookmarks.BookmarkTreeNode) {
+    return new DragSession(delegate, {
+      elements: [bookmark],
+      sameProfile: true,
+    });
+  }
+}
+
+export class BookmarksDragManager {
+  private delegate_: BookmarksDragDelegate;
+  private dragSession_: DragSession|null;
+  private eventTracker_: EventTracker = new EventTracker();
+
+  constructor(delegate: BookmarksDragDelegate) {
+    this.delegate_ = delegate;
+  }
+
+  startObserving() {
+    this.eventTracker_.add(
+        this.delegate_, 'dragstart',
+        (e: Event) => this.onDragStart_(e as DragEvent));
+    this.eventTracker_.add(
+        this.delegate_, 'dragover',
+        (e: Event) => this.onDragOver_(e as DragEvent));
+    this.eventTracker_.add(
+        this.delegate_, 'dragleave', () => this.onDragLeave_());
+    this.eventTracker_.add(this.delegate_, 'dragend', () => this.cancelDrag_());
+    this.eventTracker_.add(
+        this.delegate_, 'drop', (e: Event) => this.onDrop_(e as DragEvent));
+
+    if (loadTimeData.getBoolean('editBookmarksEnabled')) {
+      chrome.bookmarkManagerPrivate.onDragEnter.addListener(
+          (dragData: chrome.bookmarkManagerPrivate.DragData) =>
+              this.onChromeDragEnter_(dragData));
+      chrome.bookmarkManagerPrivate.onDragLeave.addListener(
+          () => this.cancelDrag_());
+    }
+  }
+
+  stopObserving() {
+    this.eventTracker_.removeAll();
+  }
+
+  private cancelDrag_() {
+    if (!this.dragSession_) {
+      return;
+    }
+    this.dragSession_.cancel();
+    this.dragSession_ = null;
+  }
+
+  private onChromeDragEnter_(dragData: chrome.bookmarkManagerPrivate.DragData) {
+    if (this.dragSession_) {
+      // A drag session is already in flight.
+      return;
+    }
+
+    this.dragSession_ = new DragSession(this.delegate_, dragData);
+  }
+
+  private onDragStart_(e: DragEvent) {
+    e.preventDefault();
+    if (!loadTimeData.getBoolean('editBookmarksEnabled')) {
+      return;
+    }
+
+    const bookmark = getBookmarkFromElement(
+        e.composedPath().find(target => (target as HTMLElement).draggable) as
+        HTMLElement);
+    if (!bookmark ||
+        /* Cannot drag root's children. */ bookmark.parentId ===
+            ROOT_FOLDER_ID ||
+        bookmark.unmodifiable) {
+      return;
+    }
+
+    this.dragSession_ =
+        DragSession.createFromBookmark(this.delegate_, bookmark);
+    this.dragSession_.start(e);
+  }
+
+  private onDragOver_(e: DragEvent) {
+    e.preventDefault();
+    if (!this.dragSession_) {
+      return;
+    }
+    this.dragSession_.update(e);
+  }
+
+  private onDragLeave_() {
+    if (!this.dragSession_) {
+      return;
+    }
+
+    this.dragSession_.cancel();
+  }
+
+  private onDrop_(e: DragEvent) {
+    if (!this.dragSession_) {
+      return;
+    }
+
+    e.preventDefault();
+    this.dragSession_.finish();
+    this.dragSession_ = null;
+  }
+}
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.html b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.html
new file mode 100644
index 0000000000000..74c2236c80cba
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.html
@@ -0,0 +1,20 @@
+<style include="cr-icons cr-hidden-style">
+  .divider {
+    border-top: 1px solid var(--cr-separator-color);
+    margin: 0 22px;
+  }
+</style>
+
+<div id="bookmarksContainer">
+  <template is="dom-repeat" items="[[folders_]]">
+    <bookmark-folder id="bookmark-[[item.id]]" folder="[[item]]"
+        open-folders="[[openFolders_]]">
+    </bookmark-folder>
+  </template>
+  <template is="dom-if" if="[[productInfos_.length]]" restamp>
+    <div class="divider"></div>
+    <shopping-list
+        id="shoppingList" product-infos="[[productInfos_]]">
+    </shopping-list>
+  </template>
+</div>
diff --git a/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.ts b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.ts
new file mode 100644
index 0000000000000..9a360fba45cdc
--- /dev/null
+++ b/chrome/browser/resources/side_panel/bookmarks/bookmarks_list.ts
@@ -0,0 +1,460 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import './commerce/shopping_list.js';
+
+import {ShoppingServiceApiProxy, ShoppingServiceApiProxyImpl} from '//bookmarks-side-panel.top-chrome/shared/commerce/shopping_service_api_proxy.js';
+import {BookmarkProductInfo} from '//bookmarks-side-panel.top-chrome/shared/shopping_list.mojom-webui.js';
+import {getInstance as getAnnouncerInstance} from 'chrome://resources/cr_elements/cr_a11y_announcer/cr_a11y_announcer.js';
+import {FocusOutlineManager} from 'chrome://resources/js/focus_outline_manager.js';
+import {loadTimeData} from 'chrome://resources/js/load_time_data.js';
+import {listenOnce} from 'chrome://resources/js/util.js';
+import {afterNextRender, PolymerElement} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+
+import {BookmarkFolderElement, FOLDER_OPEN_CHANGED_EVENT, getBookmarkFromElement, isBookmarkFolderElement} from './bookmark_folder.js';
+import {BookmarksApiProxy, BookmarksApiProxyImpl} from './bookmarks_api_proxy.js';
+import {BookmarksDragManager} from './bookmarks_drag_manager.js';
+import {getTemplate} from './bookmarks_list.html.js';
+
+// Key for localStorage object that refers to all the open folders.
+export const LOCAL_STORAGE_OPEN_FOLDERS_KEY = 'openFolders';
+
+function getBookmarkName(bookmark: chrome.bookmarks.BookmarkTreeNode): string {
+  return bookmark.title || bookmark.url || '';
+}
+
+export interface BookmarksListElement {
+  $: {
+    bookmarksContainer: HTMLElement,
+  };
+}
+
+export class BookmarksListElement extends PolymerElement {
+  static get is() {
+    return 'bookmarks-list';
+  }
+
+  static get template() {
+    return getTemplate();
+  }
+
+  static get properties() {
+    return {
+      folders_: {
+        type: Array,
+        value: () => [],
+      },
+
+      hoverVisible: {
+        reflectToAttribute: true,
+        value: false,
+      },
+
+      openFolders_: {
+        type: Array,
+        value: () => [],
+      },
+    };
+  }
+
+  private bookmarksApi_: BookmarksApiProxy =
+      BookmarksApiProxyImpl.getInstance();
+  private shoppingServiceApi_: ShoppingServiceApiProxy =
+      ShoppingServiceApiProxyImpl.getInstance();
+  private bookmarksDragManager_: BookmarksDragManager =
+      new BookmarksDragManager(this);
+  private focusOutlineManager_: FocusOutlineManager;
+  private listeners_ = new Map<string, Function>();
+  private folders_: chrome.bookmarks.BookmarkTreeNode[];
+  private productInfos_: BookmarkProductInfo[];
+  hoverVisible: boolean;
+  private openFolders_: string[];
+  private shoppingListenerIds_: number[] = [];
+
+  override ready() {
+    super.ready();
+    this.addEventListener(
+        FOLDER_OPEN_CHANGED_EVENT,
+        e => this.onFolderOpenChanged_(
+            e as CustomEvent<{id: string, open: boolean}>));
+    this.addEventListener('keydown', e => this.onKeydown_(e));
+    this.addEventListener('pointermove', () => this.hoverVisible = true);
+    this.addEventListener('pointerleave', () => this.hoverVisible = false);
+  }
+
+  override connectedCallback() {
+    super.connectedCallback();
+    this.setAttribute('role', 'tree');
+
+    listenOnce(this.$.bookmarksContainer, 'dom-change', () => {
+      setTimeout(() => this.bookmarksApi_.showUi(), 0);
+    });
+
+    this.focusOutlineManager_ = FocusOutlineManager.forDocument(document);
+    this.bookmarksApi_.getFolders().then(folders => {
+      this.folders_ = folders;
+
+      this.addListener_(
+          'onChildrenReordered',
+          (id: string, reorderedInfo: chrome.bookmarks.ReorderInfo) =>
+              this.onChildrenReordered_(id, reorderedInfo));
+      this.addListener_(
+          'onChanged',
+          (id: string, changedInfo: chrome.bookmarks.ChangeInfo) =>
+              this.onChanged_(id, changedInfo));
+      this.addListener_(
+          'onCreated',
+          (_id: string, node: chrome.bookmarks.BookmarkTreeNode) =>
+              this.onCreated_(node));
+      this.addListener_(
+          'onMoved',
+          (_id: string, movedInfo: chrome.bookmarks.MoveInfo) =>
+              this.onMoved_(movedInfo));
+      this.addListener_('onRemoved', (id: string) => this.onRemoved_(id));
+
+      try {
+        const openFolders = window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY];
+        this.openFolders_ = JSON.parse(openFolders);
+      } catch (error) {
+        this.openFolders_ = [this.folders_[0]!.id];
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] =
+            JSON.stringify(this.openFolders_);
+      }
+
+      this.bookmarksDragManager_.startObserving();
+    });
+
+    this.shoppingServiceApi_.getAllPriceTrackedBookmarkProductInfo().then(res => {
+      this.productInfos_ = res.productInfos;
+      if (this.productInfos_.length > 0) {
+        chrome.metricsPrivate.recordUserAction(
+            'Commerce.PriceTracking.SidePanel.TrackedProductsShown');
+      }
+    });
+    const callbackRouter = this.shoppingServiceApi_.getCallbackRouter();
+    this.shoppingListenerIds_.push(
+        callbackRouter.priceTrackedForBookmark.addListener(
+            (product: BookmarkProductInfo) =>
+                this.onBookmarkPriceTracked(product)),
+        callbackRouter.priceUntrackedForBookmark.addListener(
+            (product: BookmarkProductInfo) =>
+                this.onBookmarkPriceUntracked(product)),
+    );
+  }
+
+  override disconnectedCallback() {
+    for (const [eventName, callback] of this.listeners_.entries()) {
+      this.bookmarksApi_.callbackRouter[eventName]!.removeListener(callback);
+    }
+    this.bookmarksDragManager_.stopObserving();
+    this.shoppingListenerIds_.forEach(
+        id => this.shoppingServiceApi_.getCallbackRouter().removeListener(id));
+  }
+
+  /** BookmarksDragDelegate */
+  getAscendants(bookmarkId: string): string[] {
+    const path = this.findPathToId_(bookmarkId);
+    return path.map(bookmark => bookmark.id);
+  }
+
+  /** BookmarksDragDelegate */
+  getIndex(bookmark: chrome.bookmarks.BookmarkTreeNode): number {
+    const path = this.findPathToId_(bookmark.id);
+    const parent = path[path.length - 2];
+    if (!parent || !parent.children) {
+      return -1;
+    }
+    return parent.children.findIndex((child) => child.id === bookmark.id);
+  }
+
+  /** BookmarksDragDelegate */
+  isFolderOpen(bookmark: chrome.bookmarks.BookmarkTreeNode): boolean {
+    return this.openFolders_.some(id => bookmark.id === id);
+  }
+
+  /** BookmarksDragDelegate */
+  onFinishDrop(bookmarks: chrome.bookmarks.BookmarkTreeNode[]): void {
+    if (bookmarks.length === 0 || bookmarks[0]!.id === undefined) {
+      return;
+    }
+
+    this.focusBookmark_(bookmarks[0]!.id);
+    this.hoverVisible = false;
+
+    // Show the focus state immediately after dropping a bookmark to indicate
+    // where the bookmark was moved to, and remove the state immediately after
+    // the next mouse event.
+    this.focusOutlineManager_.visible = true;
+    document.addEventListener('mousedown', () => {
+      this.focusOutlineManager_.visible = false;
+    }, {once: true});
+  }
+
+  /** BookmarksDragDelegate */
+  openFolder(folderId: string) {
+    this.changeFolderOpenStatus_(folderId, true);
+  }
+
+  private addListener_(eventName: string, callback: Function): void {
+    this.bookmarksApi_.callbackRouter[eventName]!.addListener(callback);
+    this.listeners_.set(eventName, callback);
+  }
+
+  /**
+   * Finds the node within the nested array of folders and returns the path to
+   * the node in the tree.
+   */
+  private findPathToId_(id: string): chrome.bookmarks.BookmarkTreeNode[] {
+    const path: chrome.bookmarks.BookmarkTreeNode[] = [];
+
+    function findPathByIdInternal(
+        id: string, node: chrome.bookmarks.BookmarkTreeNode) {
+      if (node.id === id) {
+        path.push(node);
+        return true;
+      }
+
+      if (!node.children) {
+        return false;
+      }
+
+      path.push(node);
+      const foundInChildren =
+          node.children.some(child => findPathByIdInternal(id, child));
+      if (!foundInChildren) {
+        path.pop();
+      }
+
+      return foundInChildren;
+    }
+
+    this.folders_.some(folder => findPathByIdInternal(id, folder));
+    return path;
+  }
+
+  /**
+   * Reduces an array of nodes to a string to notify Polymer of changes to the
+   * nested array.
+   */
+  private getPathString_(path: chrome.bookmarks.BookmarkTreeNode[]): string {
+    return path.reduce((reducedString, pathItem, index) => {
+      if (index === 0) {
+        return `folders_.${this.folders_.indexOf(pathItem)}`;
+      }
+
+      const parent = path[index - 1];
+      return `${reducedString}.children.${parent!.children!.indexOf(pathItem)}`;
+    }, '');
+  }
+
+  private onChanged_(id: string, changedInfo: chrome.bookmarks.ChangeInfo) {
+    const path = this.findPathToId_(id);
+    Object.assign(path[path.length - 1], changedInfo);
+
+    const pathString = this.getPathString_(path);
+    Object.keys(changedInfo)
+        .forEach(key => this.notifyPath(`${pathString}.${key}`));
+  }
+
+  private onChildrenReordered_(
+      id: string, reorderedInfo: chrome.bookmarks.ReorderInfo) {
+    const path = this.findPathToId_(id);
+    const parent = path[path.length - 1];
+    const childById = parent!.children!.reduce((map, node) => {
+      map.set(node.id, node);
+      return map;
+    }, new Map());
+    parent!.children = reorderedInfo.childIds.map(id => childById.get(id));
+    const pathString = this.getPathString_(path);
+    this.notifyPath(`${pathString}.children`);
+  }
+
+  private onCreated_(node: chrome.bookmarks.BookmarkTreeNode) {
+    const pathToParent = this.findPathToId_(node.parentId as string);
+    const pathToParentString = this.getPathString_(pathToParent);
+    const parent = pathToParent[pathToParent.length - 1];
+    if (parent && !parent.children) {
+      // Newly created folders in this session may not have an array of
+      // children yet, so create an empty one.
+      parent.children = [];
+    }
+    this.splice(`${pathToParentString}.children`, node.index!, 0, node);
+    afterNextRender(this, () => {
+      this.focusBookmark_(node.id);
+      if (node.url) {
+        getAnnouncerInstance().announce(
+            loadTimeData.getStringF('bookmarkCreated', getBookmarkName(node)));
+      } else {
+        getAnnouncerInstance().announce(loadTimeData.getStringF(
+            'bookmarkFolderCreated', getBookmarkName(node)));
+      }
+    });
+  }
+
+  private changeFolderOpenStatus_(id: string, open: boolean) {
+    const alreadyOpenIndex = this.openFolders_.indexOf(id);
+    if (open && alreadyOpenIndex === -1) {
+      this.openFolders_.push(id);
+    } else if (!open) {
+      this.openFolders_.splice(alreadyOpenIndex, 1);
+    }
+
+    // Assign to a new array so that listeners are triggered.
+    this.openFolders_ = [...this.openFolders_];
+    window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] =
+        JSON.stringify(this.openFolders_);
+  }
+
+  private onFolderOpenChanged_(event: CustomEvent) {
+    const {id, open} = event.detail;
+    this.changeFolderOpenStatus_(id, open);
+  }
+
+  private onKeydown_(event: KeyboardEvent) {
+    if (['ArrowDown', 'ArrowUp'].includes(event.key)) {
+      this.handleArrowKeyNavigation_(event);
+      return;
+    }
+
+    if (!event.ctrlKey && !event.metaKey) {
+      return;
+    }
+    event.preventDefault();
+    const eventTarget = event.composedPath()[0] as HTMLElement;
+    const bookmarkData = getBookmarkFromElement(eventTarget);
+    if (!bookmarkData || !this.focusOutlineManager_.visible) {
+      return;
+    }
+
+    if (event.key === 'x') {
+      this.bookmarksApi_.cutBookmark(bookmarkData.id);
+    } else if (event.key === 'c') {
+      this.bookmarksApi_.copyBookmark(bookmarkData.id);
+      getAnnouncerInstance().announce(loadTimeData.getStringF(
+          'bookmarkCopied', getBookmarkName(bookmarkData)));
+    } else if (event.key === 'v') {
+      if (isBookmarkFolderElement(eventTarget)) {
+        this.bookmarksApi_.pasteToBookmark(bookmarkData.id);
+      } else {
+        this.bookmarksApi_.pasteToBookmark(
+            bookmarkData.parentId!, bookmarkData.id);
+      }
+    }
+  }
+
+  private handleArrowKeyNavigation_(event: KeyboardEvent) {
+    if (!(this.shadowRoot!.activeElement instanceof BookmarkFolderElement)) {
+      // If the key event did not happen within a BookmarkFolderElement, do
+      // not do anything.
+      return;
+    }
+
+    // Prevent arrow keys from causing scroll.
+    event.preventDefault();
+
+    const allFolderElements: BookmarkFolderElement[] =
+        Array.from(this.shadowRoot!.querySelectorAll('bookmark-folder'));
+
+    const delta = event.key === 'ArrowUp' ? -1 : 1;
+    let currentIndex =
+        allFolderElements.indexOf(this.shadowRoot!.activeElement);
+    let focusHasMoved = false;
+    while (!focusHasMoved) {
+      focusHasMoved = allFolderElements[currentIndex]!.moveFocus(delta);
+      currentIndex = (currentIndex + delta + allFolderElements.length) %
+          allFolderElements.length;
+    }
+  }
+
+  private onMoved_(movedInfo: chrome.bookmarks.MoveInfo) {
+    // Get old path and remove node from oldParent at oldIndex.
+    const oldParentPath = this.findPathToId_(movedInfo.oldParentId);
+    const oldParentPathString = this.getPathString_(oldParentPath);
+    const oldParent = oldParentPath[oldParentPath.length - 1];
+    const movedNode = oldParent!.children![movedInfo.oldIndex]!;
+    Object.assign(
+        movedNode, {index: movedInfo.index, parentId: movedInfo.parentId});
+    this.splice(`${oldParentPathString}.children`, movedInfo.oldIndex, 1);
+
+    // Get new parent's path and add the node to the new parent at index.
+    const newParentPath = this.findPathToId_(movedInfo.parentId);
+    const newParentPathString = this.getPathString_(newParentPath);
+    const newParent = newParentPath[newParentPath.length - 1];
+    if (newParent && !newParent.children) {
+      newParent.children = [];
+    }
+    this.splice(
+        `${newParentPathString}.children`, movedInfo.index, 0, movedNode);
+
+    if (movedInfo.oldParentId === movedInfo.parentId) {
+      getAnnouncerInstance().announce(loadTimeData.getStringF(
+          'bookmarkReordered', getBookmarkName(movedNode)));
+    } else {
+      getAnnouncerInstance().announce(loadTimeData.getStringF(
+          'bookmarkMoved', getBookmarkName(movedNode),
+          getBookmarkName(newParent!)));
+    }
+  }
+
+  private onRemoved_(id: string) {
+    const oldPath = this.findPathToId_(id);
+    const removedNode = oldPath.pop()!;
+    const oldParent = oldPath[oldPath.length - 1]!;
+    const oldParentPathString = this.getPathString_(oldPath);
+    this.splice(
+        `${oldParentPathString}.children`,
+        oldParent.children!.indexOf(removedNode), 1);
+
+    getAnnouncerInstance().announce(loadTimeData.getStringF(
+        'bookmarkDeleted', getBookmarkName(removedNode)));
+    this.productInfos_ =
+        this.productInfos_.filter(item => item.bookmarkId !== BigInt(id));
+  }
+
+  private focusBookmark_(id: string) {
+    const path = this.findPathToId_(id);
+    if (path.length === 0) {
+      // Could not find bookmark.
+      return;
+    }
+
+    const rootBookmark = path.shift();
+    const rootBookmarkElement =
+        this.shadowRoot!.querySelector(`#bookmark-${rootBookmark!.id}`) as
+        BookmarkFolderElement;
+    if (!rootBookmarkElement) {
+      return;
+    }
+
+    const bookmarkElement = rootBookmarkElement.getFocusableElement(path);
+    if (bookmarkElement) {
+      bookmarkElement.focus();
+    }
+  }
+
+  private onBookmarkPriceTracked(product: BookmarkProductInfo) {
+    // Here we only control the visibility of ShoppingListElement. The same
+    // signal will also be handled in ShoppingListElement to update shopping
+    // list.
+    if (this.productInfos_.length > 0) {
+      return;
+    }
+    this.push('productInfos_', product);
+    chrome.metricsPrivate.recordUserAction(
+        'Commerce.PriceTracking.SidePanel.TrackedProductsShown');
+  }
+
+  private onBookmarkPriceUntracked(product: BookmarkProductInfo) {
+    this.productInfos_ = this.productInfos_.filter(
+        item => item.bookmarkId !== product.bookmarkId);
+  }
+}
+
+declare global {
+  interface HTMLElementTagNameMap {
+    'bookmarks-list': BookmarksListElement;
+  }
+}
+
+customElements.define(BookmarksListElement.is, BookmarksListElement);
diff --git a/chrome/browser/sharing/features.cc b/chrome/browser/sharing/features.cc
index b82544d1eb4ab..2358483c69a41 100644
--- a/chrome/browser/sharing/features.cc
+++ b/chrome/browser/sharing/features.cc
@@ -6,12 +6,14 @@
 
 #include "build/build_config.h"
 
-BASE_FEATURE(kClickToCall, "ClickToCall", base::FEATURE_DISABLED_BY_DEFAULT);
+BASE_FEATURE(kClickToCall, "ClickToCall", base::FEATURE_ENABLED_BY_DEFAULT);
 
 BASE_FEATURE(kSharingMatchPulseInterval,
              "SharingMatchPulseInterval",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kDisableQRGenerator, "DisableQRGenerator", base::FEATURE_DISABLED_BY_DEFAULT);
+
 const base::FeatureParam<int> kSharingPulseDeltaDesktopHours = {
     &kSharingMatchPulseInterval, "SharingPulseDeltaDesktopHours", 24};
 
diff --git a/chrome/browser/sharing/features.h b/chrome/browser/sharing/features.h
index f1c8b48443cf3..daea87ef05d6c 100644
--- a/chrome/browser/sharing/features.h
+++ b/chrome/browser/sharing/features.h
@@ -13,6 +13,8 @@ BASE_DECLARE_FEATURE(kClickToCall);
 // Feature flag for matching device expiration to pulse interval.
 BASE_DECLARE_FEATURE(kSharingMatchPulseInterval);
 
+BASE_DECLARE_FEATURE(kDisableQRGenerator);
+
 // The delta from the pulse interval in hours after which a device is considered
 // expired, for Desktop devices. Chrome on Desktop is expected to update the
 // last updated timestamp quite frequently because it can do this when
diff --git a/chrome/browser/sharing_hub/sharing_hub_features.cc b/chrome/browser/sharing_hub/sharing_hub_features.cc
index 57d5a500579aa..168b1b576f47a 100644
--- a/chrome/browser/sharing_hub/sharing_hub_features.cc
+++ b/chrome/browser/sharing_hub/sharing_hub_features.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/sharing_hub/sharing_hub_features.h"
 
+#include "base/command_line.h"
 #include "build/build_config.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/share/share_features.h"
@@ -37,6 +38,8 @@ bool ScreenshotsDisabledByPolicy(content::BrowserContext* context) {
 }  // namespace
 
 bool SharingHubOmniboxEnabled(content::BrowserContext* context) {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-sharing-hub"))
+	  return false;
 #if BUILDFLAG(IS_CHROMEOS)
   return false;
 #else
@@ -69,7 +72,7 @@ bool HasPageAction(content::BrowserContext* context, bool is_popup_mode) {
 
 BASE_FEATURE(kDesktopScreenshots,
              "DesktopScreenshots",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+             base::FEATURE_ENABLED_BY_DEFAULT);
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS)
 void RegisterProfilePrefs(PrefRegistrySimple* registry) {
diff --git a/chrome/browser/shell_integration.cc b/chrome/browser/shell_integration.cc
index 9c94c9450e179..2b203e4d00ba5 100644
--- a/chrome/browser/shell_integration.cc
+++ b/chrome/browser/shell_integration.cc
@@ -284,11 +284,17 @@ void DefaultBrowserWorker::SetAsDefaultImpl(
     case SET_DEFAULT_INTERACTIVE:
 #if BUILDFLAG(IS_WIN)
       if (interactive_permitted_) {
-        win::SetAsDefaultBrowserUsingSystemSettings(
-            std::move(on_finished_callback));
-        // Early return because the function above takes care of calling
-        // `on_finished_callback`.
-        return;
+        switch (ShellUtil::GetInteractiveSetDefaultMode()) {
+          case ShellUtil::INTENT_PICKER:
+            win::SetAsDefaultBrowserUsingIntentPicker();
+            break;
+          case ShellUtil::SYSTEM_SETTINGS:
+            win::SetAsDefaultBrowserUsingSystemSettings(
+                std::move(on_finished_callback));
+            // Early return because the function above takes care of calling
+            // |on_finished_callback|.
+            return;
+        }
       }
 #endif  // BUILDFLAG(IS_WIN)
       break;
@@ -371,11 +377,17 @@ void DefaultSchemeClientWorker::SetAsDefaultImpl(
     case SET_DEFAULT_INTERACTIVE:
 #if BUILDFLAG(IS_WIN)
       if (interactive_permitted_) {
-        win::SetAsDefaultClientForSchemeUsingSystemSettings(
-            scheme_, std::move(on_finished_callback));
-        // Early return because the function above takes care of calling
-        // `on_finished_callback`.
-        return;
+        switch (ShellUtil::GetInteractiveSetDefaultMode()) {
+          case ShellUtil::INTENT_PICKER:
+            win::SetAsDefaultClientForSchemeUsingIntentPicker(scheme_);
+            break;
+          case ShellUtil::SYSTEM_SETTINGS:
+            win::SetAsDefaultClientForSchemeUsingSystemSettings(
+                scheme_, std::move(on_finished_callback));
+            // Early return because the function above takes care of calling
+            // |on_finished_callback|.
+            return;
+        }
       }
 #endif  // BUILDFLAG(IS_WIN)
       break;
diff --git a/chrome/browser/shell_integration_win.cc b/chrome/browser/shell_integration_win.cc
index 7fda57c2451ec..9c171c39c2fa6 100644
--- a/chrome/browser/shell_integration_win.cc
+++ b/chrome/browser/shell_integration_win.cc
@@ -742,6 +742,25 @@ DefaultWebClientSetPermission GetPlatformSpecificDefaultWebClientSetPermission(
 
 namespace win {
 
+bool SetAsDefaultBrowserUsingIntentPicker() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  base::FilePath chrome_exe;
+  if (!base::PathService::Get(base::FILE_EXE, &chrome_exe)) {
+    NOTREACHED() << "Error getting app exe path";
+    return false;
+  }
+
+  if (!ShellUtil::ShowMakeChromeDefaultSystemUI(chrome_exe)) {
+    LOG(ERROR) << "Failed to launch the set-default-browser Windows UI.";
+    return false;
+  }
+
+  VLOG(1) << "Set-default-browser Windows UI completed.";
+  return true;
+}
+
 void SetAsDefaultBrowserUsingSystemSettings(
     base::OnceClosure on_finished_callback) {
   base::FilePath chrome_exe;
@@ -767,6 +786,27 @@ void SetAsDefaultBrowserUsingSystemSettings(
                                std::move(on_finished_callback)));
 }
 
+bool SetAsDefaultClientForSchemeUsingIntentPicker(const std::string& scheme) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  base::FilePath chrome_exe;
+  if (!base::PathService::Get(base::FILE_EXE, &chrome_exe)) {
+    NOTREACHED() << "Error getting app exe path";
+    return false;
+  }
+
+  std::wstring wscheme(base::UTF8ToWide(scheme));
+  if (!ShellUtil::ShowMakeChromeDefaultProtocolClientSystemUI(chrome_exe,
+                                                              wscheme)) {
+    LOG(ERROR) << "Failed to launch the set-default-client Windows UI.";
+    return false;
+  }
+
+  VLOG(1) << "Set-default-client Windows UI completed.";
+  return true;
+}
+
 void SetAsDefaultClientForSchemeUsingSystemSettings(
     const std::string& scheme,
     base::OnceClosure on_finished_callback) {
diff --git a/chrome/browser/shell_integration_win.h b/chrome/browser/shell_integration_win.h
index 0abec6c560e12..14cc1525b6482 100644
--- a/chrome/browser/shell_integration_win.h
+++ b/chrome/browser/shell_integration_win.h
@@ -22,12 +22,28 @@ namespace shell_integration::win {
 struct ShortcutProperties;
 enum class ShortcutOperation;
 
+// Initiates an OS shell flow which (if followed by the user) should set
+// Chrome as the default browser. Returns false if the flow cannot be
+// initialized, if it is not supported (introduced for Windows 8) or if the
+// user cancels the operation. This is a blocking call and requires a FILE
+// thread. If Chrome is already default browser, no interactive dialog will be
+// shown and this method returns true.
+bool SetAsDefaultBrowserUsingIntentPicker();
+
 // Initiates the interaction with the system settings for the default browser.
 // The function takes care of making sure |on_finished_callback| will get called
 // exactly once when the interaction is finished.
 void SetAsDefaultBrowserUsingSystemSettings(
     base::OnceClosure on_finished_callback);
 
+// Initiates an OS shell flow which (if followed by the user) should set
+// Chrome as the default handler for |scheme|. Returns false if the flow
+// cannot be initialized, if it is not supported (introduced for Windows 8)
+// or if the user cancels the operation. This is a blocking call and requires
+// a FILE thread. If Chrome is already default for |scheme|, no interactive
+// dialog will be shown and this method returns true.
+bool SetAsDefaultClientForSchemeUsingIntentPicker(const std::string& scheme);
+
 // Initiates the interaction with the system settings for the default handler of
 // |scheme|. The function takes care of making sure |on_finished_callback|
 // will get called exactly once when the interaction is finished.
diff --git a/chrome/browser/themes/theme_helper.cc b/chrome/browser/themes/theme_helper.cc
index 43b03f9c3dce7..b09f78acef546 100644
--- a/chrome/browser/themes/theme_helper.cc
+++ b/chrome/browser/themes/theme_helper.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/themes/theme_service.h"
 
 #include "base/feature_list.h"
+#include "base/features.h"
 #include "base/no_destructor.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -116,6 +117,59 @@ base::RefCountedMemory* ThemeHelper::GetRawData(
   return data;
 }
 
+// For legacy reasons, the theme supplier requires the incognito variants of
+// color IDs.  This converts from normal to incognito IDs where they exist.
+int GetIncognitoId(int id) {
+  switch (id) {
+    case TP::COLOR_FRAME_ACTIVE:
+      return TP::COLOR_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_FRAME_INACTIVE:
+      return TP::COLOR_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_ACTIVE_INCOGNITO;
+    case TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE:
+      return TP::COLOR_TAB_FOREGROUND_INACTIVE_FRAME_INACTIVE_INCOGNITO;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_ACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_ACTIVE;
+    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INACTIVE:
+      return TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INCOGNITO_INACTIVE;
+    default:
+      return id;
+  }
+}
+
+// static
+bool ThemeHelper::ShouldIgnoreThemeSupplier(
+    int id,
+    bool incognito,
+    const CustomThemeSupplier* theme_supplier) {
+  if (incognito && base::FeatureList::IsEnabled(
+                       base::features::kIncognitoBrandConsistencyForDesktop)) {
+    return true;
+  }
+  // The incognito NTP uses the default background color instead of any theme
+  // background color, unless the theme also sets a custom background image.
+  return incognito && (id == TP::COLOR_NTP_BACKGROUND) &&
+         !HasCustomImage(IDR_THEME_NTP_BACKGROUND, theme_supplier);
+}
+
+
+// static
+bool ThemeHelper::UseIncognitoColor(int id,
+                                    const CustomThemeSupplier* theme_supplier) {
+  // Incognito is disabled for any non-ignored custom theme colors so they apply
+  // atop a predictable state.
+  return ShouldIgnoreThemeSupplier(id, true, theme_supplier) ||
+         (!IsCustomTheme(theme_supplier) &&
+          (!theme_supplier || theme_supplier->CanUseIncognitoColors()));
+}
+
+
+
 color_utils::HSL ThemeHelper::GetTint(
     int id,
     bool incognito,
@@ -125,7 +179,7 @@ color_utils::HSL ThemeHelper::GetTint(
   if (theme_supplier && theme_supplier->GetTint(id, &hsl))
     return hsl;
 
-  return TP::GetDefaultTint(id, incognito, UseDarkModeColors(theme_supplier));
+  return TP::GetDefaultTint(id, incognito  && UseIncognitoColor(id, theme_supplier), UseDarkModeColors(theme_supplier));
 }
 
 gfx::ImageSkia* ThemeHelper::GetImageSkiaNamed(
diff --git a/chrome/browser/themes/theme_helper.h b/chrome/browser/themes/theme_helper.h
index 095e3d1c69a43..628fa729b5c63 100644
--- a/chrome/browser/themes/theme_helper.h
+++ b/chrome/browser/themes/theme_helper.h
@@ -95,9 +95,21 @@ class ThemeHelper {
  private:
   friend class theme_service_internal::ThemeServiceTest;
 
+  // Whether the default incognito color/tint for |id| should be used, if
+  // available.
+  static bool UseIncognitoColor(int id,
+                                const CustomThemeSupplier* theme_supplier);
+
   // Whether dark default colors/tints should be used, if available.
   static bool UseDarkModeColors(const CustomThemeSupplier* theme_supplier);
 
+  // Whether the color from |theme_supplier| (if any) should be ignored for
+  // the given |id| and |incognito| state.
+  static bool ShouldIgnoreThemeSupplier(
+      int id,
+      bool incognito,
+      const CustomThemeSupplier* theme_supplier);
+
   // Returns a cross platform image for an id.
   gfx::Image GetImageNamed(int id,
                            bool incognito,
diff --git a/chrome/browser/themes/theme_service.cc b/chrome/browser/themes/theme_service.cc
index ae7735b2bee81..fc84a77bd4a99 100644
--- a/chrome/browser/themes/theme_service.cc
+++ b/chrome/browser/themes/theme_service.cc
@@ -12,6 +12,7 @@
 
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
+#include "base/features.h"
 #include "base/files/file_util.h"
 #include "base/functional/bind.h"
 #include "base/location.h"
@@ -236,7 +237,10 @@ base::RefCountedMemory* ThemeService::BrowserThemeProvider::GetRawData(
 
 CustomThemeSupplier* ThemeService::BrowserThemeProvider::GetThemeSupplier()
     const {
-  return incognito_ ? nullptr : delegate_->GetThemeSupplier();
+    bool should_ignore_theme_supplier =
+      incognito_ && base::FeatureList::IsEnabled(
+                        base::features::kIncognitoBrandConsistencyForDesktop);
+  return should_ignore_theme_supplier ? nullptr : delegate_->GetThemeSupplier();
 }
 
 // ThemeService ---------------------------------------------------------------
diff --git a/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc b/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
index 721e51828987d..61443a280a9b9 100644
--- a/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_tab_helper.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/bookmarks/bookmark_tab_helper.h"
 
+#include "base/command_line.h"
 #include "base/observer_list.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -38,6 +39,11 @@ bool IsNTP(content::WebContents* web_contents) {
   if (entry->IsInitialEntry())
     entry = web_contents->GetController().GetVisibleEntry();
   const GURL& url = entry->GetURL();
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("custom-ntp")) {
+    std::string ntp_location = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("custom-ntp");
+	if (GURL(ntp_location).DeprecatedGetOriginAsURL() == url.DeprecatedGetOriginAsURL())
+		return true;
+  }
   return NewTabUI::IsNewTab(url) || NewTabPageUI::IsNewTabPageOrigin(url) ||
          NewTabPageThirdPartyUI::IsNewTabPageOrigin(url) ||
          search::NavEntryIsInstantNTP(web_contents, entry);
@@ -70,10 +76,12 @@ bool BookmarkTabHelper::ShouldShowBookmarkBar() const {
       !prefs->GetBoolean(bookmarks::prefs::kShowBookmarkBar))
     return false;
 
+  const std::string flag_value =
+    base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("bookmark-bar-ntp");
   // The bookmark bar is only shown on the NTP if the user
   // has added something to it.
   return IsNTP(web_contents()) && bookmark_model_ &&
-         bookmark_model_->HasBookmarks();
+         bookmark_model_->HasBookmarks() && (flag_value != "never");
 }
 
 void BookmarkTabHelper::AddObserver(BookmarkTabHelperObserver* observer) {
diff --git a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
index 681b1aebbf3e4..1de53c7de73c0 100644
--- a/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
+++ b/chrome/browser/ui/bookmarks/recently_used_folders_combo_model.cc
@@ -31,7 +31,7 @@ const size_t kMaxMRUFolders = 5;
 struct RecentlyUsedFoldersComboModel::Item {
   enum Type {
     TYPE_NODE,
-    TYPE_ALL_BOOKMARKS_NODE,
+    TYPE_OTHER_NODE,
     TYPE_SEPARATOR,
     TYPE_CHOOSE_ANOTHER_FOLDER
   };
@@ -87,7 +87,7 @@ RecentlyUsedFoldersComboModel::RecentlyUsedFoldersComboModel(
 
   // And put the bookmark bar and other nodes at the end of the list.
   items_.emplace_back(model->bookmark_bar_node(), Item::TYPE_NODE);
-  items_.emplace_back(model->other_node(), Item::TYPE_ALL_BOOKMARKS_NODE);
+  items_.emplace_back(model->other_node(), Item::TYPE_OTHER_NODE);
   if (model->mobile_node()->IsVisible())
     items_.emplace_back(model->mobile_node(), Item::TYPE_NODE);
   items_.emplace_back(nullptr, Item::TYPE_SEPARATOR);
@@ -106,8 +106,10 @@ std::u16string RecentlyUsedFoldersComboModel::GetItemAt(size_t index) const {
   switch (items_[index].type) {
     case Item::TYPE_NODE:
       return items_[index].node->GetTitle();
-    case Item::TYPE_ALL_BOOKMARKS_NODE:
-      return l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS);
+    case Item::TYPE_OTHER_NODE:
+      return base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+                 ? l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS)
+                 : items_[index].node->GetTitle();
     case Item::TYPE_SEPARATOR:
       // This function should not be called for separators.
       NOTREACHED();
@@ -134,8 +136,7 @@ std::optional<size_t> RecentlyUsedFoldersComboModel::GetDefaultIndex() const {
   // now a lot of code in Combobox assumes an index within `items_` bounds.
   auto it = base::ranges::find(items_, Item(parent_node_, Item::TYPE_NODE));
   if (it == items_.end()) {
-    it = base::ranges::find(items_,
-                            Item(parent_node_, Item::TYPE_ALL_BOOKMARKS_NODE));
+    it = base::ranges::find(items_, Item(parent_node_, Item::TYPE_OTHER_NODE));
   }
   return it == items_.end() ? 0 : static_cast<int>(it - items_.begin());
 }
@@ -229,7 +230,7 @@ void RecentlyUsedFoldersComboModel::MaybeChangeParent(const BookmarkNode* node,
                                                       size_t selected_index) {
   DCHECK_LT(selected_index, items_.size());
   if (items_[selected_index].type != Item::TYPE_NODE &&
-      items_[selected_index].type != Item::TYPE_ALL_BOOKMARKS_NODE) {
+      items_[selected_index].type != Item::TYPE_OTHER_NODE) {
     return;
   }
 
diff --git a/chrome/browser/ui/browser_command_controller.cc b/chrome/browser/ui/browser_command_controller.cc
index 5664d44624283..c3ce856e4f238 100644
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -1395,7 +1395,8 @@ void BrowserCommandController::InitCommandState() {
   command_updater_.UpdateCommandEnabled(IDC_WINDOW_CLOSE_OTHER_TABS,
                                         normal_window);
 
-  const bool enable_tab_search_commands = browser_->is_type_normal();
+  const bool enable_tab_search_commands = browser_->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH,
                                         enable_tab_search_commands);
   command_updater_.UpdateCommandEnabled(IDC_TAB_SEARCH_CLOSE,
@@ -1416,7 +1417,10 @@ void BrowserCommandController::InitCommandState() {
   }
 #endif
 
-  command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_SIDE_PANEL, true);
+  if ((browser_->is_type_normal() && features::IsChromeRefresh2023()) ||
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+    command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_SIDE_PANEL, true);
+  }
 
   if (features::IsChromeRefresh2023()) {
     if (browser_->is_type_normal()) {
diff --git a/chrome/browser/ui/browser_commands.cc b/chrome/browser/ui/browser_commands.cc
index 2feee0eb96a33..9749a09c6f019 100644
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1310,7 +1310,8 @@ void BookmarkCurrentTab(Browser* browser) {
   bool was_bookmarked_by_user = bookmarks::IsBookmarkedByUser(model, url);
 #if !BUILDFLAG(IS_ANDROID)
   PrefService* prefs = browser->profile()->GetPrefs();
-  if (!prefs->GetBoolean(
+  if (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel) &&
+      !prefs->GetBoolean(
           bookmarks::prefs::kAddedBookmarkSincePowerBookmarksLaunch)) {
     bookmarks::AddIfNotBookmarked(model, url, title, model->other_node());
     prefs->SetBoolean(bookmarks::prefs::kAddedBookmarkSincePowerBookmarksLaunch,
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index cc83cf5b38e68..37e8ce7f6cebb 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -10,6 +10,7 @@
 #include "base/functional/bind.h"
 #include "base/no_destructor.h"
 #include "base/win/windows_version.h"
+#include "chrome/browser/themes/browser_theme_pack.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/win/titlebar_config.h"
@@ -46,6 +47,13 @@ class FrameColorHelper {
   static FrameColorHelper* Get();
 
  private:
+  // Returns whether there is a custom image provided for the given id.
+  bool HasCustomImage(int id, const ui::ColorProviderKey& key) const;
+
+  // Returns true if colors from DWM can be used, i.e. this is a native frame
+  // on Windows 8+.
+  bool DwmColorsAllowed(const ui::ColorProviderKey& key) const;
+
   // Returns the Tint for the given |id|. If there is no tint, the identity tint
   // {-1, -1, -1} is returned and won't tint the color on which it is used.
   color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) const;
@@ -73,6 +81,12 @@ class FrameColorHelper {
   SkColor dwm_accent_border_color_ = SK_ColorWHITE;
 };
 
+SkColor GetDefaultInactiveFrameColor() {
+  return base::win::GetVersion() < base::win::Version::WIN10
+             ? SkColorSetRGB(0xEB, 0xEB, 0xEB)
+             : SK_ColorWHITE;
+}
+
 FrameColorHelper::FrameColorHelper() {
   FetchAccentColors();
 }
@@ -90,12 +104,16 @@ void FrameColorHelper::AddNativeChromeColors(
     return std::nullopt;
   };
 
-  // When we're custom-drawing the titlebar we want to use either the colors
-  // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
-  // custom-drawing the titlebar we want to match the color Windows actually
-  // uses because some things (like the incognito icon) use this color to
-  // decide whether they should draw in light or dark mode. Incognito colors
-  // should be the same as non-incognito in all cases here.
+  if (DwmColorsAllowed(key)) {
+    // When we're custom-drawing the titlebar we want to use either the colors
+    // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
+    // custom-drawing the titlebar we want to match the color Windows actually
+    // uses because some things (like the incognito icon) use this color to
+    // decide whether they should draw in light or dark mode. Incognito colors
+    // should be the same as non-incognito in all cases here.
+
+    constexpr SkColor kSystemSolidDarkInactiveFrameColor =
+        SkColorSetRGB(0x2B, 0x2B, 0x2B);
 
   constexpr SkColor kSystemMicaLightFrameColor =
       SkColorSetRGB(0xE8, 0xE8, 0xE8);
@@ -169,13 +187,37 @@ void FrameColorHelper::AddNativeChromeColors(
     mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
   }
 
-  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
-    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonInkDropFrameActive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
-    mixer[kColorNewTabButtonInkDropFrameInactive] =
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      mixer[ui::kColorFrameInactive] = {color.value()};
+    } else if (dwm_inactive_frame_color_) {
+      mixer[ui::kColorFrameInactive] = {dwm_inactive_frame_color_.value()};
+    } else if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemMicaDarkFrameColor
+                                            : kSystemMicaLightFrameColor};
+    } else if (!ShouldCustomDrawSystemTitlebar()) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemSolidDarkInactiveFrameColor
+                                            : GetDefaultInactiveFrameColor()};
+    } else if (dwm_frame_color_) {
+      mixer[ui::kColorFrameInactive] =
+          ui::HSLShift({dwm_frame_color_.value()},
+                       GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+    }
+
+    if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonInkDropFrameInactive] =
         ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
+      mixer[kColorNewTabButtonInkDropFrameActive] =
+          ui::GetColorWithMaxContrast(ui::kColorFrameActive);
+    }
+  } else {
+    if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE))
+      mixer[ui::kColorFrameActive] = {color.value()};
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE))
+      mixer[ui::kColorFrameInactive] = {color.value()};
   }
 }
 
@@ -198,6 +240,19 @@ FrameColorHelper* FrameColorHelper::Get() {
   return g_frame_color_helper.get();
 }
 
+bool FrameColorHelper::HasCustomImage(
+    int id,
+    const ui::ColorProviderKey& key) const {
+  return BrowserThemePack::IsPersistentImageID(id) && key.custom_theme &&
+         key.custom_theme->HasCustomImage(id);
+}
+
+bool FrameColorHelper::DwmColorsAllowed(
+    const ui::ColorProviderKey& key) const {
+  return (!ShouldCustomDrawSystemTitlebar() ||
+         !HasCustomImage(IDR_THEME_FRAME, key));
+}
+
 color_utils::HSL FrameColorHelper::GetTint(
     int id,
     const ui::ColorProviderKey& key) const {
@@ -234,10 +289,15 @@ void FrameColorHelper::FetchAccentColors() {
   }
 
   dwm_accent_border_color_ =
-      accent_color_observer->accent_border_color().value_or(SK_ColorWHITE);
-
-  dwm_frame_color_ = accent_color;
-  dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
+      accent_color_observer->accent_border_color().value_or(
+          GetDefaultInactiveFrameColor());
+
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    dwm_frame_color_ = dwm_accent_border_color_;
+  } else {
+    dwm_frame_color_ = accent_color_observer->accent_color();
+    dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
+  }
 }
 
 ui::ColorTransform GetCaptionForegroundColor(
diff --git a/chrome/browser/ui/frame/window_frame_util.cc b/chrome/browser/ui/frame/window_frame_util.cc
index b2966b46fe9db..4826ca00bbd94 100644
--- a/chrome/browser/ui/frame/window_frame_util.cc
+++ b/chrome/browser/ui/frame/window_frame_util.cc
@@ -8,6 +8,7 @@
 #include "ui/gfx/geometry/size.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/command_line.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "ui/base/ui_base_features.h"
@@ -34,7 +35,8 @@ gfx::Size WindowFrameUtil::GetWindowsCaptionButtonAreaSize() {
 bool WindowFrameUtil::IsWindowsTabSearchCaptionButtonEnabled(
     const Browser* browser) {
 #if BUILDFLAG(IS_WIN)
-  return !features::IsChromeRefresh2023() && browser->is_type_normal();
+  return !features::IsChromeRefresh2023() && browser->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button");
 #else
   return false;
 #endif  // BUILDFLAG(IS_WIN)
diff --git a/chrome/browser/ui/layout_constants.cc b/chrome/browser/ui/layout_constants.cc
index 347b900c1dab8..87d6cc266381c 100644
--- a/chrome/browser/ui/layout_constants.cc
+++ b/chrome/browser/ui/layout_constants.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/layout_constants.h"
 
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/notreached.h"
 #include "build/build_config.h"
@@ -19,6 +20,7 @@
 #endif
 
 int GetLayoutConstant(LayoutConstant constant) {
+  const bool compact_ui = base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui");
   const bool touch_ui = ui::TouchUiController::Get()->touch_ui();
   switch (constant) {
     case APP_MENU_PROFILE_ROW_AVATAR_ICON_SIZE:
@@ -46,14 +48,20 @@ int GetLayoutConstant(LayoutConstant constant) {
       // stretching the container view.
       return 16;
     case LOCATION_BAR_BUBBLE_FONT_VERTICAL_PADDING:
+	  if (compact_ui)
+		  return 0;
       return 2;
     case LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET:
       return 1;
     case LOCATION_BAR_CHILD_INTERIOR_PADDING:
+	  if (compact_ui)
+		  return 0;
       return 3;
     case LOCATION_BAR_CHILD_CORNER_RADIUS:
       return 12;
     case LOCATION_BAR_ELEMENT_PADDING:
+	  if (compact_ui)
+		  return 0;
       return touch_ui ? 3 : 2;
     case LOCATION_BAR_PAGE_INFO_ICON_VERTICAL_PADDING:
       return touch_ui ? 3 : 5;
@@ -67,6 +75,8 @@ int GetLayoutConstant(LayoutConstant constant) {
     case LOCATION_BAR_TRAILING_DECORATION_EDGE_PADDING:
       return touch_ui ? 3 : 12;
     case LOCATION_BAR_HEIGHT:
+	  if (compact_ui)
+		  return 28;
       if (base::FeatureList::IsEnabled(omnibox::kOmniboxSteadyStateHeight) ||
           features::GetChromeRefresh2023Level() ==
               features::ChromeRefresh2023Level::kLevel2) {
@@ -93,6 +103,8 @@ int GetLayoutConstant(LayoutConstant constant) {
     case TAB_CLOSE_BUTTON_SIZE:
       return touch_ui ? 24 : 16;
     case TAB_HEIGHT: {
+	  if (compact_ui)
+		  return 24;
       bool use_touch_padding = touch_ui && !features::IsChromeRefresh2023();
 #if BUILDFLAG(IS_CHROMEOS)
       use_touch_padding &= !chromeos::features::IsRoundedWindowsEnabled();
diff --git a/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc b/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
index bd38b23f61c16..0f266a3b5496a 100644
--- a/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
+++ b/chrome/browser/ui/qrcode_generator/qrcode_generator_bubble_controller.cc
@@ -23,7 +23,7 @@ QRCodeGeneratorBubbleController::~QRCodeGeneratorBubbleController() {
 
 // static
 bool QRCodeGeneratorBubbleController::IsGeneratorAvailable(const GURL& url) {
-  if (!url.SchemeIsHTTPOrHTTPS())
+  if (!url.SchemeIsHTTPOrHTTPS() || base::FeatureList::IsEnabled(kDisableQRGenerator))
     return false;
 
   return true;
diff --git a/chrome/browser/ui/tabs/tab_style.cc b/chrome/browser/ui/tabs/tab_style.cc
index aa9cd30374311..28091f8229b2b 100644
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/tabs/tab_style.h"
 
+#include "base/command_line.h"
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "ui/base/ui_base_features.h"
@@ -71,7 +72,9 @@ TabStyle::~TabStyle() = default;
 
 int GM2TabStyle::GetStandardWidth() const {
   // The standard tab width is 240 DIP including both separators.
-  constexpr int kTabWidth = 240;
+  int kTabWidth = 240;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui"))
+	kTabWidth = 193;
   // The overlap includes one separator, so subtract it here.
   return kTabWidth + GetTabOverlap() - GetSeparatorSize().width();
 }
@@ -118,6 +121,8 @@ int GM2TabStyle::GetMinimumInactiveWidth() const {
 }
 
 int GM2TabStyle::GetTabOverlap() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs"))
+      return -6;
   return GetBottomCornerRadius() * 2 + GetSeparatorSize().width();
 }
 
@@ -126,8 +131,15 @@ int GM2TabStyle::GetDragHandleExtension(int height) const {
 }
 
 gfx::Size GM2TabStyle::GetSeparatorSize() const {
-  return gfx::Size(kGM2SeparatorThickness,
+  if (!base::FeatureList::IsEnabled(features::kThoriumCustomTabs)) {
+	  if (base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui"))
+		  return gfx::Size(kGM2SeparatorThickness,
+                   GetLayoutConstant(TAB_SEPARATOR_HEIGHT) * 0.6);
+	return gfx::Size(kGM2SeparatorThickness,
                    GetLayoutConstant(TAB_SEPARATOR_HEIGHT));
+  }
+  else
+	  return gfx::Size(0, 0);
 }
 
 gfx::Insets GM2TabStyle::GetSeparatorMargins() const {
@@ -147,16 +159,25 @@ gfx::Size GM2TabStyle::GetPreviewImageSize() const {
 }
 
 int GM2TabStyle::GetTopCornerRadius() const {
-  return views::LayoutProvider::Get()->GetCornerRadiusMetric(
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs"))
+		return 0;
+	return views::LayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kHigh);
 }
 
 int GM2TabStyle::GetBottomCornerRadius() const {
-  return views::LayoutProvider::Get()->GetCornerRadiusMetric(
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs"))
+		return 0;
+	return views::LayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kHigh);
 }
 
 gfx::Insets GM2TabStyle::GetContentsInsets() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("rectangular-tabs"))
+	 return gfx::Insets::TLBR(0, views::LayoutProvider::Get()->GetCornerRadiusMetric(
+                             views::Emphasis::kHigh) * 2, 0,
+                           views::LayoutProvider::Get()->GetCornerRadiusMetric(
+                            views::Emphasis::kHigh) * 2);
   return gfx::Insets::TLBR(0, GetBottomCornerRadius() * 2, 0,
                            GetBottomCornerRadius() * 2);
 }
@@ -169,10 +190,15 @@ SkColor GM2TabStyle::GetTabBackgroundColor(
   const SkColor active_color = color_provider.GetColor(
       frame_active ? kColorTabBackgroundActiveFrameActive
                    : kColorTabBackgroundActiveFrameInactive);
+#if BUILDFLAG(IS_WIN)
   const SkColor inactive_color = color_provider.GetColor(
       frame_active ? kColorTabBackgroundInactiveFrameActive
                    : kColorTabBackgroundInactiveFrameInactive);
-
+#else
+  const SkColor inactive_color = color_provider.GetColor(
+      frame_active ? kColorTabBackgroundInactiveFrameActive
+                   : kColorTabBackgroundInactiveFrameInactive);
+#endif
   if (hovered) {
     return active_color;
   }
@@ -206,10 +232,10 @@ int ChromeRefresh2023TabStyle::GetBottomCornerRadius() const {
 
 int ChromeRefresh2023TabStyle::GetTabOverlap() const {
   // The overlap removes the width and the margins of the separator.
-  const float total_separator_width = GetSeparatorMargins().left() +
-                                      GetSeparatorSize().width() +
-                                      GetSeparatorMargins().right();
-  return 2 * GetBottomCornerRadius() - total_separator_width;
+	const float total_separator_width = GetSeparatorMargins().left() +
+										GetSeparatorSize().width() +
+										GetSeparatorMargins().right();
+	return 2 * GetBottomCornerRadius() - total_separator_width;
 }
 
 gfx::Size ChromeRefresh2023TabStyle::GetSeparatorSize() const {
diff --git a/chrome/browser/ui/ui_features.cc b/chrome/browser/ui/ui_features.cc
index a5621a1406701..a89093804ccfc 100644
--- a/chrome/browser/ui/ui_features.cc
+++ b/chrome/browser/ui/ui_features.cc
@@ -99,6 +99,11 @@ BASE_FEATURE(kLightweightExtensionOverrideConfirmations,
              base::FEATURE_ENABLED_BY_DEFAULT);
 #endif
 
+// Enables Bookmarks++ Side Panel UI.
+BASE_FEATURE(kPowerBookmarksSidePanel,
+             "PowerBookmarksSidePanel",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+
 // Enables the QuickCommands UI surface. See https://crbug.com/1014639
 BASE_FEATURE(kQuickCommands,
              "QuickCommands",
diff --git a/chrome/browser/ui/ui_features.h b/chrome/browser/ui/ui_features.h
index 4f1f84c1ed3fe..596b2219a2263 100644
--- a/chrome/browser/ui/ui_features.h
+++ b/chrome/browser/ui/ui_features.h
@@ -60,6 +60,8 @@ BASE_DECLARE_FEATURE(kHaTSWebUI);
 BASE_DECLARE_FEATURE(kLightweightExtensionOverrideConfirmations);
 #endif
 
+BASE_DECLARE_FEATURE(kPowerBookmarksSidePanel);
+
 BASE_DECLARE_FEATURE(kQuickCommands);
 
 BASE_DECLARE_FEATURE(kResponsiveToolbar);
diff --git a/chrome/browser/ui/view_ids.h b/chrome/browser/ui/view_ids.h
index 32cb1ec72c112..ca49cd278596b 100644
--- a/chrome/browser/ui/view_ids.h
+++ b/chrome/browser/ui/view_ids.h
@@ -75,7 +75,7 @@ enum ViewID {
 
   // The Bookmark Bar.
   VIEW_ID_BOOKMARK_BAR,
-  VIEW_ID_ALL_BOOKMARKS,
+  VIEW_ID_OTHER_BOOKMARKS,
   VIEW_ID_MANAGED_BOOKMARKS,
   // Used for bookmarks/folders on the bookmark bar.
   VIEW_ID_BOOKMARK_BAR_ELEMENT,
diff --git a/chrome/browser/ui/views/apps/app_window_frame_view_win.cc b/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
index cdd99c6adf68c..cec34b3d9ebc6 100644
--- a/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
+++ b/chrome/browser/ui/views/apps/app_window_frame_view_win.cc
@@ -6,6 +6,8 @@
 
 #include <windows.h>
 
+#include "base/win/windows_version.h"
+
 #include <algorithm>
 
 #include "extensions/browser/app_window/native_app_window.h"
@@ -33,13 +35,32 @@ gfx::Insets AppWindowFrameViewWin::GetFrameInsets() const {
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYSIZEFRAME) +
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYCAPTION);
 
-  return gfx::Insets::TLBR(caption_height, 0, 0, 0);
+  int frame_size =
+      base::win::GetVersion() < base::win::Version::WIN10
+          ? display::win::ScreenWin::GetSystemMetricsInDIP(SM_CXSIZEFRAME)
+          : 0;
+
+  return gfx::Insets::TLBR(caption_height, frame_size, frame_size, frame_size);
 }
 
 gfx::Insets AppWindowFrameViewWin::GetClientAreaInsets(HMONITOR monitor) const {
-  const int frame_thickness = ui::GetFrameThickness(monitor);
-  return gfx::Insets::TLBR(0, frame_thickness, frame_thickness,
-                           frame_thickness);
+  gfx::Insets insets;
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    // This tells Windows that most of the window is a client area, meaning
+    // Chrome will draw it. Windows still fills in the glass bits because of the
+    // DwmExtendFrameIntoClientArea call in |UpdateDWMFrame|.
+    // Without this 1 pixel offset on the right and bottom:
+    //   * windows paint in a more standard way, and
+    //   * we get weird black bars at the top when maximized in multiple monitor
+    //     configurations.
+    int border_thickness = 1;
+    insets = gfx::Insets::TLBR(0, 0, border_thickness, border_thickness);
+  } else {
+    const int frame_thickness = ui::GetFrameThickness(monitor);
+    insets =
+        gfx::Insets::TLBR(0, frame_thickness, frame_thickness, frame_thickness);
+  }
+  return insets;
 }
 
 gfx::Rect AppWindowFrameViewWin::GetBoundsForClientView() const {
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
index 025e162e8e40b..90d3642460c10 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.cc
@@ -893,9 +893,9 @@ const BookmarkNode* BookmarkBarView::GetNodeForButtonAtModelIndex(
     return bookmark_model_->bookmark_bar_node();
   }
 
-  // And finally the all bookmarks button.
-  if (all_bookmarks_button_->GetVisible() &&
-      all_bookmarks_button_->bounds().Contains(adjusted_loc)) {
+  // And finally the other folder.
+  if (other_bookmarks_button_->GetVisible() &&
+      other_bookmarks_button_->bounds().Contains(adjusted_loc)) {
     return bookmark_model_->other_node();
   }
 
@@ -907,7 +907,7 @@ MenuButton* BookmarkBarView::GetMenuButtonForNode(const BookmarkNode* node) {
     return managed_bookmarks_button_;
   }
   if (node == bookmark_model_->other_node()) {
-    return all_bookmarks_button_;
+    return other_bookmarks_button_;
   }
   if (node == bookmark_model_->bookmark_bar_node()) {
     return overflow_button_;
@@ -926,11 +926,10 @@ void BookmarkBarView::GetAnchorPositionForButton(
     MenuButton* button,
     views::MenuAnchorPosition* anchor) {
   using Position = views::MenuAnchorPosition;
-  if (button == all_bookmarks_button_ || button == overflow_button_) {
+  if (button == other_bookmarks_button_ || button == overflow_button_)
     *anchor = Position::kTopRight;
-  } else {
+  else
     *anchor = Position::kTopLeft;
-  }
 }
 
 int BookmarkBarView::GetLeadingMargin() const {
@@ -1006,7 +1005,7 @@ gfx::Size BookmarkBarView::CalculatePreferredSize() const {
 
 gfx::Size BookmarkBarView::GetMinimumSize() const {
   // The minimum width of the bookmark bar should at least contain the overflow
-  // button, by which one can access all the Bookmark Bar items, and the "All
+  // button, by which one can access all the Bookmark Bar items, and the "Other
   // Bookmarks" folder, along with appropriate margins and button padding.
   // It should also contain the Managed Bookmarks folder, if it is visible.
   int width = GetLeadingMargin();
@@ -1020,8 +1019,8 @@ gfx::Size BookmarkBarView::GetMinimumSize() const {
     gfx::Size size = managed_bookmarks_button_->GetPreferredSize();
     width += size.width() + bookmark_bar_button_padding;
   }
-  if (all_bookmarks_button_->GetVisible()) {
-    gfx::Size size = all_bookmarks_button_->GetPreferredSize();
+  if (other_bookmarks_button_->GetVisible()) {
+    gfx::Size size = other_bookmarks_button_->GetPreferredSize();
     width += size.width() + bookmark_bar_button_padding;
   }
   if (overflow_button_->GetVisible()) {
@@ -1078,9 +1077,10 @@ void BookmarkBarView::Layout() {
   };
   const int y = center_y(button_height);
 
-  gfx::Size all_bookmarks_pref = all_bookmarks_button_->GetVisible()
-                                     ? all_bookmarks_button_->GetPreferredSize()
-                                     : gfx::Size();
+  gfx::Size other_bookmarks_pref =
+      other_bookmarks_button_->GetVisible()
+          ? other_bookmarks_button_->GetPreferredSize()
+          : gfx::Size();
   gfx::Size overflow_pref = overflow_button_->GetPreferredSize();
   gfx::Size bookmarks_separator_pref =
       bookmarks_separator_view_->GetPreferredSize();
@@ -1094,8 +1094,8 @@ void BookmarkBarView::Layout() {
 
   int max_x = GetLeadingMargin() + width - overflow_pref.width() -
               bookmarks_separator_pref.width();
-  if (all_bookmarks_button_->GetVisible()) {
-    max_x -= all_bookmarks_pref.width() + bookmark_bar_button_padding;
+  if (other_bookmarks_button_->GetVisible()) {
+    max_x -= other_bookmarks_pref.width() + bookmark_bar_button_padding;
   }
 
   // Start with the apps page shortcut button.
@@ -1214,11 +1214,11 @@ void BookmarkBarView::Layout() {
     x += bookmarks_separator_pref.width();
   }
 
-  // The "All Bookmarks" button.
-  if (all_bookmarks_button_->GetVisible()) {
-    all_bookmarks_button_->SetBounds(x, y, all_bookmarks_pref.width(),
-                                     button_height);
-    x += all_bookmarks_pref.width();
+  // The "All/Other Bookmarks" button.
+  if (other_bookmarks_button_->GetVisible()) {
+    other_bookmarks_button_->SetBounds(x, y, other_bookmarks_pref.width(),
+                                       button_height);
+    x += other_bookmarks_pref.width();
   }
 }
 
@@ -1355,9 +1355,9 @@ int BookmarkBarView::OnDragUpdated(const ui::DropTargetEvent& event) {
   }
 
   if (location.on || location.button_type == DROP_OVERFLOW ||
-      location.button_type == DROP_ALL_BOOKMARKS_FOLDER) {
+      location.button_type == DROP_OTHER_FOLDER) {
     const BookmarkNode* node;
-    if (location.button_type == DROP_ALL_BOOKMARKS_FOLDER) {
+    if (location.button_type == DROP_OTHER_FOLDER) {
       node = bookmark_model_->other_node();
     } else if (location.button_type == DROP_OVERFLOW) {
       node = bookmark_model_->bookmark_bar_node();
@@ -1465,17 +1465,19 @@ void BookmarkBarView::BookmarkModelLoaded(BookmarkModel* model,
   // once, or we didn't properly clear things. Either of which shouldn't happen.
   // The actual bookmark buttons are added from Layout().
   DCHECK(bookmark_buttons_.empty());
-  const std::u16string all_bookmarks_button_text =
-      l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS);
-  all_bookmarks_button_->SetAccessibleName(all_bookmarks_button_text);
-  all_bookmarks_button_->SetText(all_bookmarks_button_text);
+  const std::u16string other_bookmarks_button_text =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+          ? l10n_util::GetStringUTF16(IDS_BOOKMARKS_ALL_BOOKMARKS)
+          : model->other_node()->GetTitle();
+  other_bookmarks_button_->SetAccessibleName(other_bookmarks_button_text);
+  other_bookmarks_button_->SetText(other_bookmarks_button_text);
   const auto managed_title = managed_->managed_node()->GetTitle();
   managed_bookmarks_button_->SetAccessibleName(
       GetFolderButtonAccessibleName(managed_title));
   managed_bookmarks_button_->SetText(managed_title);
   UpdateAppearanceForTheme();
   UpdateOtherAndManagedButtonsVisibility();
-  all_bookmarks_button_->SetEnabled(true);
+  other_bookmarks_button_->SetEnabled(true);
   managed_bookmarks_button_->SetEnabled(true);
   LayoutAndPaint();
 }
@@ -1708,7 +1710,7 @@ void BookmarkBarView::ShowContextMenuForViewImpl(
 
   const BookmarkNode* parent = nullptr;
   std::vector<raw_ptr<const BookmarkNode, VectorExperimental>> nodes;
-  if (source == all_bookmarks_button_) {
+  if (source == other_bookmarks_button_) {
     parent = bookmark_model_->other_node();
     // Do this so the user can open all bookmarks. BookmarkContextMenu makes
     // sure the user can't edit/delete the node in this case.
@@ -1764,9 +1766,9 @@ void BookmarkBarView::Init() {
 
   overflow_button_ = AddChildView(CreateOverflowButton());
 
-  all_bookmarks_button_ = AddChildView(CreateAllBookmarksButton());
+  other_bookmarks_button_ = AddChildView(CreateOtherBookmarksButton());
   // We'll re-enable when the model is loaded.
-  all_bookmarks_button_->SetEnabled(false);
+  other_bookmarks_button_->SetEnabled(false);
 
   profile_pref_registrar_.Init(browser_->profile()->GetPrefs());
   profile_pref_registrar_.Add(
@@ -1817,13 +1819,13 @@ size_t BookmarkBarView::GetFirstHiddenNodeIndex() const {
   return i - bookmark_buttons_.cbegin();
 }
 
-std::unique_ptr<MenuButton> BookmarkBarView::CreateAllBookmarksButton() {
+std::unique_ptr<MenuButton> BookmarkBarView::CreateOtherBookmarksButton() {
   auto button = std::make_unique<BookmarkFolderButton>(base::BindRepeating(
       [](BookmarkBarView* bar, const ui::Event& event) {
         bar->OnMenuButtonPressed(bar->bookmark_model_->other_node(), event);
       },
       base::Unretained(this)));
-  button->SetID(VIEW_ID_ALL_BOOKMARKS);
+  button->SetID(VIEW_ID_OTHER_BOOKMARKS);
   button->set_context_menu_controller(this);
   return button;
 }
@@ -2110,12 +2112,12 @@ void BookmarkBarView::CalculateDropLocation(
   int mirrored_x = GetMirroredXInView(event.x());
 
   bool found = false;
-  const int other_delta_x = mirrored_x - all_bookmarks_button_->x();
+  const int other_delta_x = mirrored_x - other_bookmarks_button_->x();
   Profile* profile = browser_->profile();
-  if (all_bookmarks_button_->GetVisible() && other_delta_x >= 0 &&
-      other_delta_x < all_bookmarks_button_->width()) {
+  if (other_bookmarks_button_->GetVisible() && other_delta_x >= 0 &&
+      other_delta_x < other_bookmarks_button_->width()) {
     // Mouse is over 'other' folder.
-    location->button_type = DROP_ALL_BOOKMARKS_FOLDER;
+    location->button_type = DROP_OTHER_FOLDER;
     location->on = true;
     found = true;
   } else if (bookmark_buttons_.empty()) {
@@ -2175,8 +2177,8 @@ void BookmarkBarView::CalculateDropLocation(
       } else {
         return;
       }
-    } else if (!all_bookmarks_button_->GetVisible() ||
-               mirrored_x < all_bookmarks_button_->x()) {
+    } else if (!other_bookmarks_button_->GetVisible() ||
+               mirrored_x < other_bookmarks_button_->x()) {
       // Mouse is after the last visible button but before more recently
       // bookmarked; use the last visible index.
       location->index = GetFirstHiddenNodeIndex();
@@ -2186,12 +2188,11 @@ void BookmarkBarView::CalculateDropLocation(
   }
 
   if (location->on) {
-    const BookmarkNode* parent =
-        (location->button_type == DROP_ALL_BOOKMARKS_FOLDER)
-            ? bookmark_model_->other_node()
-            : bookmark_model_->bookmark_bar_node()
-                  ->children()[location->index.value()]
-                  .get();
+    const BookmarkNode* parent = (location->button_type == DROP_OTHER_FOLDER)
+                                     ? bookmark_model_->other_node()
+                                     : bookmark_model_->bookmark_bar_node()
+                                           ->children()[location->index.value()]
+                                           .get();
     location->operation = chrome::GetBookmarkDropOperation(
         profile, event, data, parent, parent->children().size());
     if (location->operation != DragOperation::kNone && !data.has_single_url() &&
@@ -2243,8 +2244,8 @@ void BookmarkBarView::UpdateAppearanceForTheme() {
   }
 
   const SkColor color = color_provider->GetColor(kColorBookmarkBarForeground);
-  all_bookmarks_button_->SetEnabledTextColors(color);
-  all_bookmarks_button_->SetImageModel(
+  other_bookmarks_button_->SetEnabledTextColors(color);
+  other_bookmarks_button_->SetImageModel(
       views::Button::STATE_NORMAL,
       chrome::GetBookmarkFolderIcon(chrome::BookmarkFolderIconType::kNormal,
                                     kColorBookmarkFolderIcon));
@@ -2275,9 +2276,10 @@ void BookmarkBarView::UpdateAppearanceForTheme() {
 
 bool BookmarkBarView::UpdateOtherAndManagedButtonsVisibility() {
   bool has_other_children = !bookmark_model_->other_node()->children().empty();
-  bool update_other = has_other_children != all_bookmarks_button_->GetVisible();
+  bool update_other =
+      has_other_children != other_bookmarks_button_->GetVisible();
   if (update_other) {
-    all_bookmarks_button_->SetVisible(has_other_children);
+    other_bookmarks_button_->SetVisible(has_other_children);
     UpdateBookmarksSeparatorVisibility();
   }
 
@@ -2297,12 +2299,13 @@ void BookmarkBarView::UpdateBookmarksSeparatorVisibility() {
   // ChromeOS does not paint the bookmarks separator line because it looks odd
   // on the flat background. We keep it present for layout, but don't draw it.
   if (features::IsChromeRefresh2023()) {
-    bookmarks_separator_view_->SetVisible(all_bookmarks_button_->GetVisible());
+    bookmarks_separator_view_->SetVisible(
+        other_bookmarks_button_->GetVisible());
   } else {
     bookmarks_separator_view_->SetVisible(false);
   }
 #else
-  bookmarks_separator_view_->SetVisible(all_bookmarks_button_->GetVisible());
+  bookmarks_separator_view_->SetVisible(other_bookmarks_button_->GetVisible());
 #endif
 }
 
@@ -2331,7 +2334,7 @@ void BookmarkBarView::InsertBookmarkButtonAtIndex(
 // All of the secondary buttons are always in the view hierarchy, even if
 // they're not visible. The order should be: [Apps shortcut] [Managed bookmark
 // button] [saved tab group bar] [..bookmark buttons..] [Overflow chevron]
-// [All bookmarks]
+// [All/Other bookmarks]
 #if DCHECK_IS_ON()
   auto i = children().cbegin();
   DCHECK_EQ(*i++, apps_page_shortcut_);
@@ -2342,11 +2345,11 @@ void BookmarkBarView::InsertBookmarkButtonAtIndex(
   const auto is_bookmark_button = [this](const View* v) {
     return (views::IsViewClass<BookmarkButton>(v) ||
             views::IsViewClass<BookmarkFolderButton>(v)) &&
-           v != overflow_button_ && v != all_bookmarks_button_;
+           v != overflow_button_ && v != other_bookmarks_button_;
   };
   i = std::find_if_not(i, children().cend(), is_bookmark_button);
   DCHECK_EQ(*i++, overflow_button_);
-  DCHECK_EQ(*i++, all_bookmarks_button_);
+  DCHECK_EQ(*i++, other_bookmarks_button_);
 #endif
   const auto view_index = saved_tab_group_bar_
                               ? GetIndexOf(saved_tab_group_bar_).value()
@@ -2366,7 +2369,7 @@ size_t BookmarkBarView::GetIndexForButton(views::View* button) {
 const BookmarkNode* BookmarkBarView::GetParentNodeAndIndexForDrop(
     size_t& index) {
   const BookmarkNode* root =
-      (drop_info_->location.button_type == DROP_ALL_BOOKMARKS_FOLDER)
+      (drop_info_->location.button_type == DROP_OTHER_FOLDER)
           ? bookmark_model_->other_node()
           : bookmark_model_->bookmark_bar_node();
 
@@ -2376,7 +2379,7 @@ const BookmarkNode* BookmarkBarView::GetParentNodeAndIndexForDrop(
   }
 
   const BookmarkNode* parent_node;
-  if (drop_info_->location.button_type == DROP_ALL_BOOKMARKS_FOLDER) {
+  if (drop_info_->location.button_type == DROP_OTHER_FOLDER) {
     parent_node = root;
     index = parent_node->children().size();
   } else if (drop_info_->location.on) {
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h
index 81a446510fb2c..039b2dd0c9296 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view.h
@@ -125,8 +125,8 @@ class BookmarkBarView : public views::AccessiblePaneView,
 
   // Returns the button responsible for showing bookmarks in the
   // "Other Bookmarks" folder.
-  views::MenuButton* all_bookmarks_button() const {
-    return all_bookmarks_button_;
+  views::MenuButton* other_bookmarks_button() const {
+    return other_bookmarks_button_;
   }
 
   // Returns the button used when not all the items on the bookmark bar fit.
@@ -239,11 +239,7 @@ class BookmarkBarView : public views::AccessiblePaneView,
   friend class BookmarkBarViewEventTestBase;
 
   // Used to identify what the user is dropping onto.
-  enum DropButtonType {
-    DROP_BOOKMARK,
-    DROP_ALL_BOOKMARKS_FOLDER,
-    DROP_OVERFLOW
-  };
+  enum DropButtonType { DROP_BOOKMARK, DROP_OTHER_FOLDER, DROP_OVERFLOW };
 
   // Creates recent bookmark button and when visible button as well as
   // calculating the preferred height.
@@ -266,8 +262,8 @@ class BookmarkBarView : public views::AccessiblePaneView,
   // visible, this returns GetBookmarkButtonCount().
   size_t GetFirstHiddenNodeIndex() const;
 
-  // Creates the button showing the "All Bookmarks" folder.
-  std::unique_ptr<views::MenuButton> CreateAllBookmarksButton();
+  // Creates the button showing the "Other Bookmarks" folder.
+  std::unique_ptr<views::MenuButton> CreateOtherBookmarksButton();
 
   // Creates the button showing the "Managed Bookmarks" folder.
   std::unique_ptr<views::MenuButton> CreateManagedBookmarksButton();
@@ -411,7 +407,7 @@ class BookmarkBarView : public views::AccessiblePaneView,
   raw_ptr<SavedTabGroupBar> saved_tab_group_bar_ = nullptr;
 
   // Shows the "Other Bookmarks" folder button.
-  raw_ptr<views::MenuButton> all_bookmarks_button_ = nullptr;
+  raw_ptr<views::MenuButton> other_bookmarks_button_ = nullptr;
 
   // Shows the managed bookmarks entries.
   raw_ptr<views::MenuButton> managed_bookmarks_button_ = nullptr;
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
index 213540e0cc6f3..e76cdef698660 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
@@ -911,7 +911,7 @@ class BookmarkBarViewTest7 : public BookmarkBarViewDragTestBase {
 
     // The button should be highlighted now.
     EXPECT_EQ(views::Button::STATE_PRESSED,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     // Cause the target view to trigger a mouse up when dragged over.
     const views::View* target_view = drop_menu->GetSubmenu()->GetMenuItemAt(1);
@@ -931,7 +931,7 @@ class BookmarkBarViewTest7 : public BookmarkBarViewDragTestBase {
   void OnWidgetDragComplete(views::Widget* widget) override {
     // The button should be in normal state now.
     EXPECT_EQ(views::Button::STATE_NORMAL,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     BookmarkBarViewDragTestBase::OnWidgetDragComplete(widget);
   }
@@ -946,7 +946,7 @@ class BookmarkBarViewTest7 : public BookmarkBarViewDragTestBase {
 
   gfx::Point GetDragTargetInScreen() const override {
     return ui_test_utils::GetCenterInScreenCoordinates(
-        bb_view_->all_bookmarks_button());
+        bb_view_->other_bookmarks_button());
   }
 };
 
@@ -1002,7 +1002,7 @@ class BookmarkBarViewTest8 : public BookmarkBarViewDragTestBase {
 
   gfx::Point GetDragTargetInScreen() const override {
     return ui_test_utils::GetCenterInScreenCoordinates(
-        bb_view_->all_bookmarks_button());
+        bb_view_->other_bookmarks_button());
   }
 };
 
@@ -1595,7 +1595,7 @@ class BookmarkBarViewTest17 : public BookmarkBarViewEventTestBase {
 #endif
 VIEW_TEST(BookmarkBarViewTest17, MAYBE_ContextMenus3)
 
-// Verifies sibling menus works. Clicks on the 'all bookmarks' folder, then
+// Verifies sibling menus works. Clicks on the 'other bookmarks' folder, then
 // moves the mouse over the first item on the bookmark bar and makes sure the
 // menu appears.
 class BookmarkBarViewTest18 : public BookmarkBarViewEventTestBase {
@@ -1610,7 +1610,7 @@ class BookmarkBarViewTest18 : public BookmarkBarViewEventTestBase {
   void Step2() {
     // The button should be pressed.
     EXPECT_EQ(views::Button::STATE_PRESSED,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     // Move the mouse to the first folder on the bookmark bar.
     views::LabelButton* button = GetBookmarkButton(0);
@@ -1627,9 +1627,9 @@ class BookmarkBarViewTest18 : public BookmarkBarViewEventTestBase {
     // The menu for the first folder should be in the pressed state (since the
     // menu is showing for it)...
     EXPECT_EQ(views::Button::STATE_PRESSED, GetBookmarkButton(0)->GetState());
-    // ... And the "all bookmarks" button should no longer be pressed.
+    // ... And the "other bookmarks" button should no longer be pressed.
     EXPECT_EQ(views::Button::STATE_NORMAL,
-              bb_view_->all_bookmarks_button()->GetState());
+              bb_view_->other_bookmarks_button()->GetState());
 
     bb_view_->GetMenu()->GetMenuController()->Cancel(
         views::MenuController::ExitType::kAll);
@@ -1663,8 +1663,8 @@ class BookmarkBarViewTest19 : public BookmarkBarViewEventTestBase {
   void Step3() {
     ASSERT_TRUE(MenuIsShowing());
 
-    // Move the mouse back to the "All Bookmarks" button.
-    views::LabelButton* button = bb_view_->all_bookmarks_button();
+    // Move the mouse back to the "Other Bookmarks" button.
+    views::LabelButton* button = bb_view_->other_bookmarks_button();
     gfx::Point button_center(button->width() / 2, button->height() / 2);
     views::View::ConvertPointToScreen(button, &button_center);
     ASSERT_TRUE(ui_controls::SendMouseMoveNotifyWhenDone(
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
index 6c809c86fbac2..648b69fb793ea 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
@@ -326,8 +326,10 @@ class BookmarkBubbleView::BookmarkBubbleDelegate
                   ->GetComboboxByUniqueId(kBookmarkFolderFieldId)
                   ->selected_index());
 
-    browser_->window()->MaybeShowFeaturePromo(
-        feature_engagement::kIPHPowerBookmarksSidePanelFeature);
+    if (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+      browser_->window()->MaybeShowFeaturePromo(
+          feature_engagement::kIPHPowerBookmarksSidePanelFeature);
+    }
   }
 
   RecentlyUsedFoldersComboModel* GetFolderModel() {
@@ -391,6 +393,7 @@ void BookmarkBubbleView::ShowBubble(
     product_info = shopping_service->GetAvailableProductInfoForUrl(url);
   }
 
+  if (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
   if (product_info.has_value() && !product_info->image_url.is_empty()) {
     HandleImageUrlResponse(profile, product_info->image_url);
   } else {
@@ -400,10 +403,20 @@ void BookmarkBubbleView::ShowBubble(
 
   // Display favicon while awaiting one of the above options to load.
   const auto centered_favicon = GetFaviconForWebContents(web_contents);
+
   gfx::ImageSkia main_image = centered_favicon;
 
   dialog_model_builder.SetMainImage(ui::ImageModel::FromImageSkia(main_image));
 
+  } else {
+    dialog_model_builder.AddExtraButton(
+        base::BindRepeating(&BookmarkBubbleDelegate::OnEditButton,
+                            base::Unretained(bubble_delegate)),
+        ui::DialogModel::Button::Params()
+            .SetLabel(l10n_util::GetStringUTF16(IDS_BOOKMARK_BUBBLE_OPTIONS))
+            .AddAccelerator(ui::Accelerator(ui::VKEY_E, ui::EF_ALT_DOWN)));
+  }
+
   ui::ElementIdentifier initially_focused_field = kBookmarkNameFieldId;
   std::u16string secondary_button_label =
       l10n_util::GetStringUTF16(IDS_BOOKMARK_BUBBLE_REMOVE_BOOKMARK);
@@ -490,6 +503,9 @@ void BookmarkBubbleView::ShowBubble(
     bool is_price_tracked = shopping_service->IsSubscribedFromCache(
         commerce::BuildUserSubscriptionForClusterId(
             product_info->product_cluster_id.value()));
+	if (!base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
+      dialog_model_builder.AddSeparator();
+    }
     dialog_model_builder.AddCustomField(
         std::make_unique<views::BubbleDialogModelHost::CustomView>(
             std::make_unique<PriceTrackingView>(profile, url, is_price_tracked,
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc
index 7a61f89fb8d21..114ba5cb30a92 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view_browsertest.cc
@@ -132,6 +132,32 @@ class PowerBookmarkBubbleViewBrowserTest
   ~PowerBookmarkBubbleViewBrowserTest() override = default;
 };
 
+// Ash always has sync ON
+#if !BUILDFLAG(IS_CHROMEOS_ASH)
+IN_PROC_BROWSER_TEST_F(BookmarkBubbleViewBrowserTest,
+                       InvokeUi_bookmark_details_synced_off) {
+  ShowAndVerifyUi();
+}
+#endif
+
+IN_PROC_BROWSER_TEST_F(BookmarkBubbleViewBrowserTest,
+                       InvokeUi_bookmark_details_synced_on) {
+  ShowAndVerifyUi();
+}
+
+// TODO(crbug.com/1473858): Flaky on Windows and Chrome OS.
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_CHROMEOS)
+#define MAYBE_InvokeUi_bookmark_details_on_trackable_product \
+  DISABLED_InvokeUi_bookmark_details_on_trackable_product
+#else
+#define MAYBE_InvokeUi_bookmark_details_on_trackable_product \
+  InvokeUi_bookmark_details_on_trackable_product
+#endif
+IN_PROC_BROWSER_TEST_F(BookmarkBubbleViewBrowserTest,
+                       MAYBE_InvokeUi_bookmark_details_on_trackable_product) {
+  ShowAndVerifyUi();
+}
+
 IN_PROC_BROWSER_TEST_F(PowerBookmarkBubbleViewBrowserTest,
                        InvokeUi_bookmark_details_on_trackable_product) {
   ShowAndVerifyUi();
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc b/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc
index 993424968a989..69a537b3b8e41 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_menu_delegate.cc
@@ -632,7 +632,8 @@ void BookmarkMenuDelegate::BuildMenu(const BookmarkNode* parent,
                                      size_t start_child_index,
                                      MenuItemView* menu) {
   DCHECK_LE(start_child_index, parent->children().size());
-  if (parent == GetBookmarkModel()->other_node()) {
+  if (parent == GetBookmarkModel()->other_node()&&
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)) {
     ui::ImageModel bookmarks_side_panel_icon =
         features::IsSidePanelPinningEnabled()
             ? ui::ImageModel::FromVectorIcon(
diff --git a/chrome/browser/ui/views/commerce/price_tracking_view.cc b/chrome/browser/ui/views/commerce/price_tracking_view.cc
index be19d0361b0b6..528f29d2b0f67 100644
--- a/chrome/browser/ui/views/commerce/price_tracking_view.cc
+++ b/chrome/browser/ui/views/commerce/price_tracking_view.cc
@@ -34,6 +34,8 @@
 #include "ui/views/layout/layout_provider.h"
 
 namespace {
+constexpr int kProductImageSize = 56;
+constexpr int kImageBorderRadius = 4;
 constexpr int kIconSize = 16;
 constexpr int kIconMargin = 14;
 constexpr int kIconSizeRefresh = 20;
@@ -59,22 +61,49 @@ PriceTrackingView::PriceTrackingView(Profile* profile,
       is_price_track_enabled_(is_price_track_enabled),
       product_info_(product_info) {
   auto* layout_provider = views::LayoutProvider::Get();
-  const int label_spacing = 0;
-  const auto label_context = views::style::CONTEXT_LABEL;
+  const bool power_bookmarks_side_panel_enabled =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel);
+  const int label_spacing = power_bookmarks_side_panel_enabled ? 0 : 4;
+  const auto label_context = power_bookmarks_side_panel_enabled
+                                 ? views::style::CONTEXT_LABEL
+                                 : views::style::CONTEXT_DIALOG_BODY_TEXT;
   const int horizontal_spacing = layout_provider->GetDistanceMetric(
       views::DISTANCE_RELATED_CONTROL_HORIZONTAL);
   const gfx::Insets dialog_insets =
       layout_provider->GetInsetsMetric(views::INSETS_DIALOG);
-  if (features::IsChromeRefresh2023()) {
-    SetCrossAxisAlignment(views::LayoutAlignment::kStart);
+  if (power_bookmarks_side_panel_enabled) {
+    if (features::IsChromeRefresh2023()) {
+      SetCrossAxisAlignment(views::LayoutAlignment::kStart);
+    }
+    // Icon column
+    auto* icon = AddChildView(std::make_unique<views::ImageView>());
+    icon->SetImage(
+        ui::ImageModel::FromVectorIcon(omnibox::kPriceTrackingDisabledIcon,
+                                       kColorBookmarkDialogTrackPriceIcon));
+    icon->SetImageSize(GetIconSize());
+    icon->SetProperty(views::kMarginsKey,
+                      gfx::Insets::TLBR(0, 0, 0, GetIconMargin()));
+  } else {
+    // image column
+    auto* product_image_containter =
+        AddChildView(std::make_unique<views::BoxLayoutView>());
+    product_image_containter->SetCrossAxisAlignment(
+        views::BoxLayout::CrossAxisAlignment::kCenter);
+    product_image_containter->SetProperty(
+        views::kMarginsKey, gfx::Insets::TLBR(0, 0, 0, horizontal_spacing));
+    // Set product image.
+    product_image_containter->AddChildView(
+        views::Builder<views::ImageView>()
+            .SetImageSize(gfx::Size(kProductImageSize, kProductImageSize))
+            .SetPreferredSize(gfx::Size(kProductImageSize, kProductImageSize))
+            // TODO(meiliang@): Verify color and corner radius with UX.
+            .SetBorder(views::CreateThemedRoundedRectBorder(
+                1, kImageBorderRadius, kColorBookmarkDialogProductImageBorder))
+            .SetImage(
+						ui::ImageModel::FromVectorIcon(omnibox::kPriceTrackingDisabledIcon,
+                      kColorBookmarkDialogTrackPriceIcon))
+            .Build());
   }
-  // Icon column
-  auto* icon = AddChildView(std::make_unique<views::ImageView>());
-  icon->SetImage(ui::ImageModel::FromVectorIcon(
-      omnibox::kPriceTrackingDisabledIcon, kColorBookmarkDialogTrackPriceIcon));
-  icon->SetImageSize(GetIconSize());
-  icon->SetProperty(views::kMarginsKey,
-                    gfx::Insets::TLBR(0, 0, 0, GetIconMargin()));
 
   // Text column
   auto text_container = std::make_unique<views::FlexLayoutView>();
@@ -110,7 +139,9 @@ PriceTrackingView::PriceTrackingView(Profile* profile,
   body_label_ = text_container->AddChildView(std::make_unique<views::Label>(
       l10n_util::GetStringUTF16(body_string_id), label_context,
       views::style::STYLE_SECONDARY));
-  body_label_->SetFontList(body_label_->font_list().DeriveWithSizeDelta(-1));
+  if (power_bookmarks_side_panel_enabled) {
+    body_label_->SetFontList(body_label_->font_list().DeriveWithSizeDelta(-1));
+  }
   body_label_->SetProperty(views::kMarginsKey,
                            gfx::Insets::TLBR(label_spacing, 0, 0, 0));
   body_label_->SetMultiLine(true);
@@ -136,17 +167,24 @@ PriceTrackingView::PriceTrackingView(Profile* profile,
   const int bubble_width = ChromeLayoutProvider::Get()->GetDistanceMetric(
       views::DISTANCE_BUBBLE_PREFERRED_WIDTH);
   int label_width;
-  toggle_button_->SetProperty(
-      views::kFlexBehaviorKey,
-      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
-                               features::IsChromeRefresh2023()
-                                   ? views::MaximumFlexSizeRule::kPreferred
-                                   : views::MaximumFlexSizeRule::kUnbounded)
-          .WithAlignment(views::LayoutAlignment::kEnd));
-
-  label_width = bubble_width - horizontal_spacing * 2 - dialog_insets.right() -
-                GetIconMargin() - GetIconSize().width() -
-                toggle_button_->GetPreferredSize().width();
+  if (power_bookmarks_side_panel_enabled) {
+    toggle_button_->SetProperty(
+        views::kFlexBehaviorKey,
+        views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
+                                 features::IsChromeRefresh2023()
+                                     ? views::MaximumFlexSizeRule::kPreferred
+                                     : views::MaximumFlexSizeRule::kUnbounded)
+            .WithAlignment(views::LayoutAlignment::kEnd));
+
+    label_width = bubble_width - horizontal_spacing * 2 -
+                  dialog_insets.right() - GetIconMargin() -
+                  GetIconSize().width() -
+                  toggle_button_->GetPreferredSize().width();
+  } else {
+    label_width = bubble_width - horizontal_spacing * 2 -
+                  dialog_insets.width() - kProductImageSize -
+                  toggle_button_->GetPreferredSize().width();
+  }
   body_label_->SizeToFit(label_width);
   base::RecordAction(base::UserMetricsAction(
       "Commerce.PriceTracking.BookmarkDialogPriceTrackViewShown"));
diff --git a/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc b/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc
index 75a72ed465192..baf60d48bd696 100644
--- a/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc
+++ b/chrome/browser/ui/views/commerce/shopping_collection_iph_view.cc
@@ -40,7 +40,11 @@ ShoppingCollectionIphView::ShoppingCollectionIphView() {
       views::style::STYLE_BODY_4_MEDIUM));
   title->SetHorizontalAlignment(gfx::HorizontalAlignment::ALIGN_LEFT);
 
-  const auto label_context = views::style::CONTEXT_LABEL;
+  const bool power_bookmarks_side_panel_enabled =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel);
+  const auto label_context = power_bookmarks_side_panel_enabled
+                                 ? views::style::CONTEXT_LABEL
+                                 : views::style::CONTEXT_DIALOG_BODY_TEXT;
   std::u16string body_text =
       l10n_util::GetStringUTF16(IDS_SHOPPING_COLLECTION_IPH_BODY);
   views::Label* body_label = AddChildView(std::make_unique<views::Label>(
@@ -48,7 +52,10 @@ ShoppingCollectionIphView::ShoppingCollectionIphView() {
   body_label->SetEnabledColorId(ui::kColorSysOnSurfaceSubtle);
   body_label->SetMultiLine(true);
   body_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);
-  body_label->SetFontList(body_label->font_list().DeriveWithSizeDelta(-1));
+
+  if (power_bookmarks_side_panel_enabled) {
+    body_label->SetFontList(body_label->font_list().DeriveWithSizeDelta(-1));
+  }
 }
 
 ShoppingCollectionIphView::~ShoppingCollectionIphView() = default;
diff --git a/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc b/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
index bd44a6dfc03ed..2388b5f0f2635 100644
--- a/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
+++ b/chrome/browser/ui/views/extensions/extensions_toolbar_container.cc
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <memory>
 
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
@@ -35,6 +36,7 @@
 #include "chrome/browser/ui/views/frame/toolbar_button_provider.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_action_hover_card_controller.h"
 #include "chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.h"
+#include "chrome/browser/ui/views/toolbar/toolbar_view.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/feature_engagement/public/event_constants.h"
@@ -538,10 +540,20 @@ void ExtensionsToolbarContainer::AnchorAndShowWidgetImmediately(
   // * AnchorAndShowWidgetImmediately runs.
   // Revisit how to handle that, likely the Widget should Close on removal which
   // would remove the AnchoredWidget entry.
-  views::View* const anchor_view = GetViewForId(iter->extension_id);
+  views::View* anchor_view = GetViewForId(iter->extension_id);
   widget->widget_delegate()->AsBubbleDialogDelegate()->SetAnchorView(
       anchor_view && anchor_view->GetVisible() ? anchor_view
                                                : GetExtensionsButton());
+
+  // Fix the position of widgets. Without this fix, extension-installed-bubble
+  // and extension-uninstall-dialog may be out of the window border on Linux.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-extensions-menu"))
+  {
+    anchor_view = BrowserView::GetBrowserViewForBrowser(browser_)
+      ->toolbar_button_provider()->GetAppMenuButton();
+    widget->widget_delegate()->AsBubbleDialogDelegate()
+      ->SetAnchorView(anchor_view);
+  }
   widget->Show();
 }
 
@@ -919,6 +931,9 @@ void ExtensionsToolbarContainer::UpdateContainerVisibility() {
 }
 
 bool ExtensionsToolbarContainer::ShouldContainerBeVisible() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-extensions-menu"))
+    return false;
+
   // The container (and extensions-menu button) should not be visible if we have
   // no extensions.
   if (!HasAnyExtensions())
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
index 625c6931ab746..a387da94cc498 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
@@ -367,12 +367,20 @@ bool BrowserDesktopWindowTreeHostWin::GetDwmFrameInsetsInPixels(
     *insets = gfx::Insets();
   } else {
     // The glass should extend to the bottom of the tabstrip.
+    HWND hwnd = GetHWND();
     gfx::Rect tabstrip_region_bounds(browser_frame_->GetBoundsForTabStripRegion(
         browser_view_->tab_strip_region_view()->GetMinimumSize()));
-    tabstrip_region_bounds = display::win::ScreenWin::DIPToClientRect(
-        GetHWND(), tabstrip_region_bounds);
-
-    *insets = gfx::Insets::TLBR(tabstrip_region_bounds.bottom(), 0, 0, 0);
+    tabstrip_region_bounds =
+        display::win::ScreenWin::DIPToClientRect(hwnd, tabstrip_region_bounds);
+
+    // The 2 px (not DIP) at the inner edges of Win 7 glass are a light and dark
+    // line, so we must inset further to account for those.
+    constexpr int kWin7GlassInset = 2;
+    const int inset = (base::win::GetVersion() < base::win::Version::WIN8)
+                          ? kWin7GlassInset
+                          : 0;
+    *insets = gfx::Insets::TLBR(tabstrip_region_bounds.bottom() + inset, inset,
+                                inset, inset);
   }
   return true;
 }
@@ -465,6 +473,9 @@ void BrowserDesktopWindowTreeHostWin::PostHandleMSG(UINT message,
 }
 
 views::FrameMode BrowserDesktopWindowTreeHostWin::GetFrameMode() const {
+  if (browser_view_->GetIsWebAppType())
+	  return views::FrameMode::CUSTOM_DRAWN;
+
   const views::FrameMode system_frame_mode =
       ShouldBrowserCustomDrawTitlebar(browser_view_)
           ? views::FrameMode::SYSTEM_DRAWN_NO_CONTROLS
@@ -494,11 +505,13 @@ bool BrowserDesktopWindowTreeHostWin::ShouldUseNativeFrame() const {
   if (!browser_view_->browser())
     return false;
 
-  // We don't theme popup or app windows, so regardless of whether or not a
-  // theme is active for normal browser windows, we don't want to use the custom
-  // frame for popups/apps.
-  if (!browser_view_->GetIsNormalType())
-    return true;
+  // Use the custom frame where desired.
+  if (!browser_view_->GetIsNormalType()) {
+	 if (!browser_view_->GetIsWebAppType() && GetWidget()->GetThemeProvider()->ShouldUseNativeFrame())
+		return true;
+	 else
+		return false;
+  }
   // Otherwise, we use the native frame when we're told we should by the theme
   // provider (e.g. no custom theme is active).
   return GetWidget()->GetThemeProvider()->ShouldUseNativeFrame();
diff --git a/chrome/browser/ui/views/frame/browser_frame.cc b/chrome/browser/ui/views/frame/browser_frame.cc
index a52bb8913d37f..1c1c20afe32df 100644
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -10,6 +10,7 @@
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/debug/leak_annotations.h"
+#include "base/features.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
 #include "build/build_config.h"
@@ -347,7 +348,8 @@ const ui::ThemeProvider* BrowserFrame::GetThemeProvider() const {
 ui::ColorProviderKey::ThemeInitializerSupplier* BrowserFrame::GetCustomTheme()
     const {
   // Do not return any custom theme if this is an incognito browser.
-  if (IsIncognitoBrowser()) {
+  if (IsIncognitoBrowser() && base::FeatureList::IsEnabled(
+            base::features::kIncognitoBrandConsistencyForDesktop)) {
     return nullptr;
   }
 
@@ -568,8 +570,20 @@ void BrowserFrame::SelectNativeTheme() {
   // of system theme (gtk, qt etc).
   ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
   if (IsIncognitoBrowser()) {
-    SetNativeTheme(native_theme);
-    return;
+    // If the flag is enabled, then no matter if we are using the default theme
+    // or not we always use the dark ui instance.
+      if (base::FeatureList::IsEnabled(
+            base::features::kIncognitoBrandConsistencyForDesktop)) {
+      SetNativeTheme(ui::NativeTheme::GetInstanceForDarkUI());
+      return;
+    }
+
+    // Flag is disabled, fallback to using dark theme only if the incognito
+    // profile is using a default theme.
+      if (ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile())
+            ->UsingDefaultTheme()) {
+        native_theme = ui::NativeTheme::GetInstanceForDarkUI();
+	}
   }
 
   // Ignore the system theme for web apps with window-controls-overlay as the
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.cc b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
index bd59ccd1b1784..ad3a40764aa36 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
@@ -10,6 +10,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/trace_event/common/trace_event_common.h"
 #include "base/trace_event/trace_event.h"
 #include "chrome/app/chrome_command_ids.h"
@@ -133,7 +134,9 @@ bool BrowserFrameViewWin::CaptionButtonsOnLeadingEdge() const {
 
 gfx::Rect BrowserFrameViewWin::GetBoundsForTabStripRegion(
     const gfx::Size& tabstrip_minimum_size) const {
-  const int x = CaptionButtonsOnLeadingEdge() ? CaptionButtonsRegionWidth() : 0;
+  int x = CaptionButtonsOnLeadingEdge() ? CaptionButtonsRegionWidth() : 0;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox"))
+      x = 8;
   int end_x = width();
   if (!CaptionButtonsOnLeadingEdge()) {
     end_x = std::min(width() - CaptionButtonsRegionWidth(), end_x);
@@ -417,7 +420,7 @@ void BrowserFrameViewWin::ResetWindowControls() {
 void BrowserFrameViewWin::OnThemeChanged() {
   BrowserNonClientFrameView::OnThemeChanged();
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
@@ -663,24 +666,26 @@ bool BrowserFrameViewWin::ShouldShowWindowTitle(TitlebarType type) const {
 
 void BrowserFrameViewWin::TabletModeChanged() {
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
-void BrowserFrameViewWin::SetSystemMicaTitlebarAttributes() {
-  CHECK(SystemTitlebarCanUseMicaMaterial());
-
-  const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
-                        sizeof(dark_titlebar_enabled));
+void BrowserFrameViewWin::SetSystemTitlebarAttributes() {
+  if (SystemTitlebarSupportsDarkMode()) {
+    const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
+                          sizeof(dark_titlebar_enabled));
+  }
 
-  const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
-      browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
-                                           : DWMSBT_MAINWINDOW;
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
-                        sizeof(dwm_backdrop_type));
+  if (ShouldBrowserUseMicaTitlebar(browser_view())) {
+    const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
+        browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
+                                             : DWMSBT_MAINWINDOW;
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
+                          sizeof(dwm_backdrop_type));
+  }
 }
 
 SkColor BrowserFrameViewWin::GetTitlebarColor() const {
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.h b/chrome/browser/ui/views/frame/browser_frame_view_win.h
index 8f24aba4b8a61..c7ad27ec219e9 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.h
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.h
@@ -146,8 +146,8 @@ class BrowserFrameViewWin : public BrowserNonClientFrameView,
   // Called when the device enters or exits tablet mode.
   void TabletModeChanged();
 
-  // Sets DWM attributes for rendering the system-drawn Mica titlebar.
-  void SetSystemMicaTitlebarAttributes();
+  // Sets DWM attributes for rendering the system-drawn titlebar.
+  void SetSystemTitlebarAttributes();
 
   // Paint various sub-components of this view.
   void PaintTitlebar(gfx::Canvas* canvas) const;
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index a3090da2ca8b4..21c73e4902f76 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1895,6 +1895,9 @@ void BrowserView::UpdateExclusiveAccessExitBubbleContent(
     ExclusiveAccessBubbleHideCallback bubble_first_hide_callback,
     bool notify_download,
     bool force_update) {
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "hide-fullscreen-exit-ui"))
+		return;
   // Trusted pinned mode does not allow to escape. So do not show the bubble.
   bool is_trusted_pinned =
       platform_util::IsBrowserLockedFullscreen(browser_.get());
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
index 8a3f3e300bde5..5f2fa8826a9cb 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
@@ -77,7 +77,9 @@ void OpaqueBrowserFrameViewLayout::SetButtonOrdering(
 gfx::Rect OpaqueBrowserFrameViewLayout::GetBoundsForTabStripRegion(
     const gfx::Size& tabstrip_minimum_size,
     int total_width) const {
-  const int x = available_space_leading_x_;
+  int x = available_space_leading_x_;
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox"))
+      x = 8;
   const int available_width = available_space_trailing_x_ - x;
   return gfx::Rect(x, GetTabStripInsetsTop(false), std::max(0, available_width),
                    tabstrip_minimum_size.height());
diff --git a/chrome/browser/ui/views/frame/tab_strip_region_view.cc b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
index 1dd00552036cb..9e131e95d0982 100644
--- a/chrome/browser/ui/views/frame/tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/frame/tab_strip_region_view.h"
 
+#include "base/command_line.h"
 #include "base/functional/bind.h"
 #include "base/strings/utf_string_conversions.h"
 #include "build/build_config.h"
@@ -66,6 +67,8 @@ class FrameGrabHandle : public views::View {
     // Reserve some space for the frame to be grabbed by, even if the tabstrip
     // is full.
     // TODO(tbergquist): Define this relative to the NTB insets again.
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("remove-grab-handle"))
+		return gfx::Size(0, 0);
     return gfx::Size(42, 0);
   }
 };
@@ -98,7 +101,8 @@ TabStripRegionView::TabStripRegionView(std::unique_ptr<TabStrip> tab_strip)
 
   // Add and configure the TabSearchContainer.
   std::unique_ptr<TabSearchContainer> tab_search_container;
-  if (browser && browser->is_type_normal()) {
+  if (browser && browser->is_type_normal() &&
+      !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button")) {
     tab_search_container = std::make_unique<TabSearchContainer>(
         tab_strip_->controller(), render_tab_search_before_tab_strip_, this);
     tab_search_container->SetProperty(views::kCrossAxisAlignmentKey,
diff --git a/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc b/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
index ccafa0c6ed945..8e003293c011b 100644
--- a/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
+++ b/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
@@ -67,6 +67,9 @@ constexpr base::TimeDelta kTouchPopupTimeout = base::Seconds(10);
 constexpr base::TimeDelta kKeyPressPopupDelay = base::Seconds(1);
 
 bool IsExitUiEnabled() {
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "hide-fullscreen-exit-ui"))
+		return false;
 #if BUILDFLAG(IS_MAC)
   // Exit UI is unnecessary, since Mac uses the OS fullscreen such that window
   // menu and controls reveal when the cursor is moved to the top.
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index b4b2f01a846a7..5f12d63bcf7de 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -9,6 +9,7 @@
 #include <memory>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/containers/adapters.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -203,7 +204,8 @@ LocationBarView::LocationBarView(Browser* browser,
     if (features::IsChromeRefresh2023()) {
       views::FocusRing::Get(this)->SetOutsetFocusRingDisabled(true);
     }
-    views::InstallPillHighlightPathGenerator(this);
+    if (!base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox"))
+        views::InstallPillHighlightPathGenerator(this);
 
 #if BUILDFLAG(IS_MAC)
     geolocation_permission_observation_.Observe(
@@ -347,14 +349,17 @@ void LocationBarView::Init() {
 
     params.types_enabled.push_back(PageActionIconType::kSendTabToSelf);
     params.types_enabled.push_back(PageActionIconType::kClickToCall);
-    params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
+    if (!base::FeatureList::IsEnabled(kDisableQRGenerator))
+      params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
     if (base::FeatureList::IsEnabled(kWebOTPCrossDevice))
       params.types_enabled.push_back(PageActionIconType::kSmsRemoteFetcher);
     params.types_enabled.push_back(PageActionIconType::kManagePasswords);
     if (!apps::features::ShouldShowLinkCapturingUX()) {
       params.types_enabled.push_back(PageActionIconType::kIntentPicker);
     }
-    params.types_enabled.push_back(PageActionIconType::kPwaInstall);
+    if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-pwa-install-prompt")) {
+      params.types_enabled.push_back(PageActionIconType::kPwaInstall);
+    }
     params.types_enabled.push_back(PageActionIconType::kFind);
     params.types_enabled.push_back(PageActionIconType::kTranslate);
     params.types_enabled.push_back(PageActionIconType::kZoom);
@@ -388,6 +393,7 @@ void LocationBarView::Init() {
   if (browser_) {
     if (sharing_hub::HasPageAction(profile_, is_popup_mode_) &&
         !features::IsChromeRefresh2023()) {
+      if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-sharing-hub"))
       params.types_enabled.push_back(PageActionIconType::kSharingHub);
     }
   }
@@ -431,6 +437,8 @@ bool LocationBarView::IsInitialized() const {
 }
 
 int LocationBarView::GetBorderRadius() const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox"))
+      return 3;
   return ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
       views::Emphasis::kMaximum, size());
 }
@@ -1151,6 +1159,8 @@ void LocationBarView::RefreshBackground() {
     border_color = color_provider->GetColor(kColorLocationBarBorderOnMismatch);
   }
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox-border"))
+      border_color = SK_ColorGRAY;
   if (is_popup_mode_) {
     SetBackground(views::CreateSolidBackground(background_color));
   } else {
@@ -1163,6 +1173,13 @@ void LocationBarView::RefreshBackground() {
   // correctly enable subpixel AA.
   omnibox_view_->SetBackgroundColor(background_color);
 
+  if ((base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox") ||
+    base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox-border")) &&
+    base::CommandLine::ForCurrentProcess()->HasSwitch("compact-ui"))
+    // When the location bar is shrunken, the border above is only drawn on the sides.
+    // To resolve this, an extra border is drawn in that area on the top and bottom.
+    // Ideally, only one border would be drawn.
+    omnibox_view_->SetBorder(views::CreateSolidSidedBorder(gfx::Insets::TLBR(1, 0, 1, 0), SK_ColorGRAY));
   SchedulePaint();
 }
 
diff --git a/chrome/browser/ui/views/location_bar/location_icon_view.cc b/chrome/browser/ui/views/location_bar/location_icon_view.cc
index 1f3878e1879a6..6f4a84bde8cd0 100644
--- a/chrome/browser/ui/views/location_bar/location_icon_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_icon_view.cc
@@ -21,6 +21,7 @@
 #include "components/dom_distiller/core/url_constants.h"
 #include "components/omnibox/browser/omnibox_edit_model.h"
 #include "components/omnibox/browser/omnibox_field_trial.h"
+#include "components/omnibox/browser/vector_icons.h"
 #include "components/security_state/core/security_state.h"
 #include "components/strings/grit/components_strings.h"
 #include "content/public/browser/web_contents.h"
@@ -291,8 +292,15 @@ void LocationIconView::UpdateIcon() {
   }
 #endif
 
-  if (!icon.IsEmpty())
-    SetImageModel(icon);
+  if (!icon.IsEmpty()) {
+	  if (icon.IsVectorIcon() && icon.GetVectorIcon().vector_icon()->name != omnibox::kProductChromeRefreshIcon.name &&
+       icon.GetVectorIcon().vector_icon()->name != omnibox::kProductIcon.name)
+	    SetImageModel(icon);
+	   else if (!icon.IsVectorIcon())
+		SetImageModel(icon);
+	  else
+		SetImageModel(ui::ImageModel());
+  }
 }
 
 void LocationIconView::UpdateBackground() {
diff --git a/chrome/browser/ui/views/omnibox/omnibox_text_view.cc b/chrome/browser/ui/views/omnibox/omnibox_text_view.cc
index dce591e1acdf1..9e1a1f5406431 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_text_view.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_text_view.cc
@@ -28,6 +28,10 @@
 #include "ui/views/style/typography.h"
 #include "ui/views/style/typography_provider.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace {
 
 // Use the primary style for everything. TextStyle sometimes controls color, but
@@ -135,6 +139,12 @@ void OmniboxTextView::OnPaint(gfx::Canvas* canvas) {
 
   if (!render_text_)
     return;
+
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled()) {
+	  render_text_->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+  }
+  #endif
   render_text_->SetDisplayRect(GetContentsBounds());
   render_text_->Draw(canvas);
 }
diff --git a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
index 2077715fff453..0f7fcb11e6608 100644
--- a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
+++ b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
@@ -65,6 +65,7 @@ ScreenshotCapturedBubble::ScreenshotCapturedBubble(
       image_(image),
       web_contents_(web_contents->GetWeakPtr()),
       profile_(profile) {
+
   SetButtons(ui::DIALOG_BUTTON_NONE);
   SetTitle(IDS_BROWSER_SHARING_SCREENSHOT_POST_CAPTURE_TITLE);
 }
diff --git a/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc b/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc
index e59856207a85e..c0a2637c0559a 100644
--- a/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_coordinator.cc
@@ -76,7 +76,9 @@ constexpr int kSidePanelContentContainerViewId = 42;
 constexpr int kSidePanelContentWrapperViewId = 43;
 
 SidePanelEntry::Id GetDefaultEntry() {
-  return SidePanelEntry::Id::kBookmarks;
+  return base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+             ? SidePanelEntry::Id::kBookmarks
+             : SidePanelEntry::Id::kReadingList;
 }
 
 void ConfigureControlButton(views::ImageButton* button) {
diff --git a/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc b/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc
index ef0c01072a3f3..424c17078b4ad 100644
--- a/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_interactive_uitest.cc
@@ -4,6 +4,7 @@
 
 #include "base/test/bind.h"
 #include "base/test/gtest_util.h"
+#include "base/test/scoped_feature_list.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser.h"
@@ -55,9 +56,13 @@ class SidePanelInteractiveTest : public InteractiveBrowserTest {
   ~SidePanelInteractiveTest() override = default;
 
   void SetUp() override {
+    scoped_feature_list_.InitAndEnableFeature(features::kPowerBookmarksSidePanel);
     set_open_about_blank_on_browser_launch(true);
     InteractiveBrowserTest::SetUp();
   }
+
+ private:
+  base::test::ScopedFeatureList scoped_feature_list_;
 };
 
 // This test is specifically to guard against this regression
diff --git a/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc b/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc
index 55004e2aeb699..d70584897ec2c 100644
--- a/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc
+++ b/chrome/browser/ui/views/sync/bubble_sync_promo_signin_button_view.cc
@@ -53,7 +53,9 @@ BubbleSyncPromoSigninButtonView::BubbleSyncPromoSigninButtonView(
           : l10n_util::GetStringUTF16(IDS_PROFILES_DICE_NOT_SYNCING_TITLE);
 
   const views::BoxLayout::Orientation orientation =
-      views::BoxLayout::Orientation::kHorizontal;
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+          ? views::BoxLayout::Orientation::kHorizontal
+          : views::BoxLayout::Orientation::kVertical;
 
   std::unique_ptr<views::BoxLayout> button_layout =
       std::make_unique<views::BoxLayout>(orientation, gfx::Insets(), 16);
diff --git a/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc b/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc
index 27e784aa16b31..ffdfb435fad62 100644
--- a/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc
+++ b/chrome/browser/ui/views/sync/bubble_sync_promo_view.cc
@@ -45,8 +45,10 @@ BubbleSyncPromoView::BubbleSyncPromoView(
   }
 
   const views::LayoutOrientation orientation =
-      account.IsEmpty() ? views::LayoutOrientation::kHorizontal
-                        : views::LayoutOrientation::kVertical;
+      (base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel) &&
+       account.IsEmpty())
+          ? views::LayoutOrientation::kHorizontal
+          : views::LayoutOrientation::kVertical;
 
   std::unique_ptr<views::FlexLayout> layout =
       std::make_unique<views::FlexLayout>();
diff --git a/chrome/browser/ui/views/tabs/new_tab_button.cc b/chrome/browser/ui/views/tabs/new_tab_button.cc
index 9e77662e57e76..da13fc6b5dc69 100644
--- a/chrome/browser/ui/views/tabs/new_tab_button.cc
+++ b/chrome/browser/ui/views/tabs/new_tab_button.cc
@@ -7,6 +7,7 @@
 #include <memory>
 #include <string>
 
+#include "base/command_line.h"
 #include "base/strings/string_number_conversions.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -112,11 +113,23 @@ void NewTabButton::AnimateToStateForTesting(views::InkDropState state) {
 
 void NewTabButton::AddLayerToRegion(ui::Layer* new_layer,
                                     views::LayerRegion region) {
-  ink_drop_container_->AddLayerToRegion(new_layer, region);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			!base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+			(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	}
+	else
+		ink_drop_container_->AddLayerToRegion(new_layer, region);
 }
 
 void NewTabButton::RemoveLayerFromRegions(ui::Layer* old_layer) {
-  ink_drop_container_->RemoveLayerFromRegions(old_layer);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+		!base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+		base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	}
+	else
+		ink_drop_container_->RemoveLayerFromRegions(old_layer);
 }
 
 SkColor NewTabButton::GetForegroundColor() const {
@@ -139,17 +152,27 @@ SkPath NewTabButton::GetBorderPath(const gfx::Point& origin,
   const float radius = GetCornerRadius();
 
   SkPath path;
-  if (extend_to_top) {
-    path.moveTo(origin.x(), 0);
-    const float diameter = radius * 2;
-    path.rLineTo(diameter, 0);
-    path.rLineTo(0, origin.y() + radius);
-    path.rArcTo(radius, radius, 0, SkPath::kSmall_ArcSize, SkPathDirection::kCW,
-                -diameter, 0);
-    path.close();
-  } else {
-    path.addCircle(origin.x() + radius, origin.y() + radius, radius);
-  }
+  if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    !base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	  if (extend_to_top) {
+		path.moveTo(origin.x(), 0);
+		const float diameter = radius * 2;
+		path.rLineTo(diameter, 0);
+		path.rLineTo(0, origin.y() + radius);
+		path.rArcTo(radius, radius, 0, SkPath::kSmall_ArcSize, SkPathDirection::kCW,
+					-diameter, 0);
+		path.close();
+	  } else {
+		path.addCircle(origin.x() + radius, origin.y() + radius,
+					   radius);
+	  }
+   } else {
+	   SkPoint pts [] = {SkPoint(0.0, 8.0), SkPoint(24.0, 8.0), SkPoint(30.0, 20.0), SkPoint(6.0, 20.0)};
+	   path.moveTo(origin.x() * 1.10, SkScalar(8.0));
+	   path.addPoly(pts, 4, true);
+   }
   return path;
 }
 
@@ -209,7 +232,12 @@ void NewTabButton::NotifyClick(const ui::Event& event) {
 
 void NewTabButton::PaintButtonContents(gfx::Canvas* canvas) {
   PaintFill(canvas);
-  PaintIcon(canvas);
+  if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    !base::CommandLine::ForCurrentProcess()->HasSwitch("override-new-tab-button-shape-default"))) {
+	PaintIcon(canvas);
+  }
 }
 
 gfx::Size NewTabButton::CalculatePreferredSize() const {
@@ -257,11 +285,32 @@ void NewTabButton::PaintFill(gfx::Canvas* canvas) const {
     cc::PaintFlags flags;
     flags.setAntiAlias(true);
     canvas->Translate(GetContentsBounds().OffsetFromOrigin());
-    flags.setColor(GetColorProvider()->GetColor(
-        GetWidget()->ShouldPaintAsActive()
-            ? background_frame_active_color_id_
-            : background_frame_inactive_color_id_));
+	if (((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			!base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default")) ||
+			(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default"))) &&
+			GetState() == STATE_HOVERED) {
+		flags.setColor(SkColorSetRGB(90, 90, 90));
+	} else {
+		flags.setColor(GetColorProvider()->GetColor(
+			GetWidget()->ShouldPaintAsActive()
+				? background_frame_active_color_id_
+				: background_frame_inactive_color_id_));
+	}
+    if (base::CommandLine::ForCurrentProcess()->HasSwitch("transparent-tabs"))
+		flags.setAlphaf(0.7f);
     canvas->DrawPath(GetBorderPath(gfx::Point(), false), flags);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			!base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default")) ||
+			(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+			base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default"))) {
+	flags.setAlphaf(1.0f);
+	flags.setColor(SkColorSetRGB(0, 0, 0));
+	flags.setStyle(cc::PaintFlags::kStroke_Style);
+	flags.setStrokeWidth(0.5f);
+	canvas->DrawPath(GetBorderPath(gfx::Point(), false),
+						flags);
+	}
   }
 }
 
diff --git a/chrome/browser/ui/views/tabs/tab_style_views.cc b/chrome/browser/ui/views/tabs/tab_style_views.cc
index 33c62c24cc521..2d2eeb9b0881f 100644
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
@@ -322,90 +333,108 @@ SkPath GM2TabStyleViews::GetPath(TabStyle::PathType path_type,
     // stroke width.
 
     // Start with the left side of the shape.
-    path.moveTo(left, extended_bottom);
-
-    if (tab_left != left) {
-      // Draw the left edge of the extension.
-      //   ╭─────────╮
-      //   │ Content │
-      // ┏─╯         ╰─┐
-      if (tab_bottom != extended_bottom)
-        path.lineTo(left, tab_bottom);
-
-      // Draw the bottom-left corner.
-      //   ╭─────────╮
-      //   │ Content │
-      // ┌━╝         ╰─┐
-      if (extend_left_to_bottom) {
-        path.lineTo(tab_left, tab_bottom);
-      } else {
-        path.lineTo(tab_left - extension_corner_radius, tab_bottom);
-        path.arcTo(extension_corner_radius, extension_corner_radius, 0,
-                   SkPath::kSmall_ArcSize, SkPathDirection::kCCW, tab_left,
-                   tab_bottom - extension_corner_radius);
-      }
-    }
-
-    // Draw the ascender and top-left curve, if present.
-    if (extend_to_top) {
-      //   ┎─────────╮
-      //   ┃ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_left, tab_top);
-    } else {
-      //   ╔─────────╮
-      //   ┃ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_left, tab_top + content_corner_radius);
-      path.arcTo(content_corner_radius, content_corner_radius, 0,
-                 SkPath::kSmall_ArcSize, SkPathDirection::kCW,
-                 tab_left + content_corner_radius, tab_top);
-    }
-
-    // Draw the top crossbar and top-right curve, if present.
-    if (extend_to_top) {
-      //   ┌━━━━━━━━━┑
-      //   │ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_right, tab_top);
-    } else {
-      //   ╭━━━━━━━━━╗
-      //   │ Content │
-      // ┌─╯         ╰─┐
-      path.lineTo(tab_right - content_corner_radius, tab_top);
-      path.arcTo(content_corner_radius, content_corner_radius, 0,
-                 SkPath::kSmall_ArcSize, SkPathDirection::kCW, tab_right,
-                 tab_top + content_corner_radius);
-    }
 
-    if (tab_right != right) {
-      // Draw the descender and bottom-right corner.
-      //   ╭─────────╮
-      //   │ Content ┃
-      // ┌─╯         ╚━┐
-      if (extend_right_to_bottom) {
-        path.lineTo(tab_right, tab_bottom);
-      } else {
-        path.lineTo(tab_right, tab_bottom - extension_corner_radius);
-        path.arcTo(extension_corner_radius, extension_corner_radius, 0,
-                   SkPath::kSmall_ArcSize, SkPathDirection::kCCW,
-                   tab_right + extension_corner_radius, tab_bottom);
-      }
-      if (tab_bottom != extended_bottom)
-        path.lineTo(right, tab_bottom);
-    }
-
-    // Draw anything remaining: the descender, the bottom right horizontal
-    // stroke, or the right edge of the extension, depending on which
-    // conditions fired above.
-    //   ╭─────────╮
-    //   │ Content │
-    // ┌─╯         ╰─┓
-    path.lineTo(right, extended_bottom);
-
-    if (path_type != TabStyle::PathType::kBorder) {
-      path.close();
+    if (!base::FeatureList::IsEnabled(features::kThoriumCustomTabs)) {
+		path.moveTo(left, extended_bottom);
+		if (tab_left != left) {
+		  // Draw the left edge of the extension.
+		  //   ╭─────────╮
+		  //   │ Content │
+		  // ┏─╯         ╰─┐
+		  if (tab_bottom != extended_bottom)
+			path.lineTo(left, tab_bottom);
+
+		  // Draw the bottom-left corner.
+		  //   ╭─────────╮
+		  //   │ Content │
+		  // ┌━╝         ╰─┐
+		  if (extend_left_to_bottom) {
+			path.lineTo(tab_left, tab_bottom);
+		  } else {
+			path.lineTo(tab_left - extension_corner_radius, tab_bottom);
+			path.arcTo(extension_corner_radius, extension_corner_radius, 0,
+					   SkPath::kSmall_ArcSize, SkPathDirection::kCCW, tab_left,
+					   tab_bottom - extension_corner_radius);
+		  }
+		}
+
+		// Draw the ascender and top-left curve, if present.
+		if (extend_to_top) {
+		  //   ┎─────────╮
+		  //   ┃ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_left, tab_top);
+		} else {
+		  //   ╔─────────╮
+		  //   ┃ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_left, tab_top + content_corner_radius);
+		  path.arcTo(content_corner_radius, content_corner_radius, 0,
+					 SkPath::kSmall_ArcSize, SkPathDirection::kCW,
+					 tab_left + content_corner_radius, tab_top);
+		}
+
+		// Draw the top crossbar and top-right curve, if present.
+		if (extend_to_top) {
+		  //   ┌━━━━━━━━━┑
+		  //   │ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_right, tab_top);
+		} else {
+		  //   ╭━━━━━━━━━╗
+		  //   │ Content │
+		  // ┌─╯         ╰─┐
+		  path.lineTo(tab_right - content_corner_radius, tab_top);
+		  path.arcTo(content_corner_radius, content_corner_radius, 0,
+					 SkPath::kSmall_ArcSize, SkPathDirection::kCW, tab_right,
+					 tab_top + content_corner_radius);
+		}
+
+		if (tab_right != right) {
+		  // Draw the descender and bottom-right corner.
+		  //   ╭─────────╮
+		  //   │ Content ┃
+		  // ┌─╯         ╚━┐
+		  if (extend_right_to_bottom) {
+			path.lineTo(tab_right, tab_bottom);
+		  } else {
+			path.lineTo(tab_right, tab_bottom - extension_corner_radius);
+			path.arcTo(extension_corner_radius, extension_corner_radius, 0,
+					   SkPath::kSmall_ArcSize, SkPathDirection::kCCW,
+					   tab_right + extension_corner_radius, tab_bottom);
+		  }
+		  if (tab_bottom != extended_bottom)
+			path.lineTo(right, tab_bottom);
+		}
+
+		// Draw anything remaining: the descender, the bottom right horizontal
+		// stroke, or the right edge of the extension, depending on which
+		// conditions fired above.
+		//   ╭─────────╮
+		//   │ Content │
+		// ┌─╯         ╰─┓
+		path.lineTo(right, extended_bottom);
     }
+	else {
+		path.moveTo(left, extended_bottom);
+		if (extend_to_top) {
+		  // Create the vertical extension by extending the side diagonals until
+		  // they reach the top of the bounds.
+			path.cubicTo(left, extended_bottom, (((tab_left + 10) + left) / 2), ((tab_top + extended_bottom) / 2), tab_left + 10,
+						  tab_top);
+			path.lineTo(tab_right - 10, tab_top);
+			path.cubicTo(tab_right - 10, tab_top, (((tab_right - 10) + right) / 2), ((tab_top + extended_bottom) / 2), right,
+					  extended_bottom);
+		} else {
+			path.cubicTo(left, extended_bottom, (((tab_left + 4) + left) / 2), (((tab_top * 0.5) + extended_bottom) / 2), tab_left + 4,
+						(tab_top * 0.5));
+			path.cubicTo(tab_left + 4, (tab_top * 0.5), tab_left + 4, tab_top * 0.5, tab_right - 4, tab_top * 0.5);
+			path.cubicTo(tab_right - 4, (tab_top * 0.5), (((tab_right - 4) + right) / 2), (((tab_top * 0.5) + extended_bottom) / 2), right,
+					  extended_bottom);
+		}
+       if (!force_active)
+           path.close();
+	}
   }
 
   // Convert path to be relative to the tab origin.
@@ -664,6 +705,9 @@ float GM2TabStyleViews::GetSeparatorOpacity(bool for_layout,
 
   const Tab* adjacent_tab =
       tab_->controller()->GetAdjacentTab(tab_, leading ? -1 : 1);
+  // The separator should never appear at the end of the tab strip.
+  if (!adjacent_tab && !leading)
+	  return 0.0f;
 
   const Tab* left_tab = leading ? adjacent_tab : tab_.get();
   const Tab* right_tab = leading ? tab_.get() : adjacent_tab;
@@ -671,6 +715,7 @@ float GM2TabStyleViews::GetSeparatorOpacity(bool for_layout,
       right_tab && right_tab->group().has_value() &&
       (!left_tab || left_tab->group() != right_tab->group());
 
+
   // If the current tab is selected, default to hiding the separator. Only show
   // the separator if it's adjacent to other selected tabs.
   if (tab_->IsSelected()) {
@@ -936,8 +981,21 @@ void GM2TabStyleViews::PaintTabBackgroundFill(
     cc::PaintFlags flags;
     flags.setAntiAlias(true);
     flags.setColor(GetCurrentTabBackgroundColor(selection_state, hovered));
+	if (base::CommandLine::ForCurrentProcess()->HasSwitch("transparent-tabs") &&
+	    selection_state != TabStyle::TabSelectionState::kActive)
+		flags.setAlphaf(0.7f);
     canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),
                      flags);
+	if ((base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    !base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default")) ||
+		(!base::FeatureList::IsEnabled(features::kThoriumCustomTabs) &&
+	    base::CommandLine::ForCurrentProcess()->HasSwitch("override-tab-outline-default"))) {
+	flags.setAlphaf(1.0f);
+	flags.setColor(SkColorSetRGB(0, 0, 0));
+	flags.setStyle(cc::PaintFlags::kStroke_Style);
+	canvas->DrawPath(fill_path,
+                     flags);
+	}
   }
 
   if (fill_id.has_value()) {
diff --git a/chrome/browser/ui/webui/settings/settings_utils_win.cc b/chrome/browser/ui/webui/settings/settings_utils_win.cc
index c39f0509e7d3d..d898145962a05 100644
--- a/chrome/browser/ui/webui/settings/settings_utils_win.cc
+++ b/chrome/browser/ui/webui/settings/settings_utils_win.cc
@@ -14,6 +14,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "base/threading/thread.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/profiles/profile.h"
@@ -102,9 +103,15 @@ void OpenConnectionDialogCallback() {
 }
 
 void ShowNetworkProxySettings(content::WebContents* /*web_contents*/) {
-  // See
-  // https://docs.microsoft.com/en-us/windows/uwp/launch-resume/launch-settings-app#network--internet
-  platform_util::OpenExternal(GURL("ms-settings:network-proxy"));
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    // See
+    // https://docs.microsoft.com/en-us/windows/uwp/launch-resume/launch-settings-app#network--internet
+    platform_util::OpenExternal(GURL("ms-settings:network-proxy"));
+  } else {
+    base::ThreadPool::PostTask(
+        FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
+        base::BindOnce(&OpenConnectionDialogCallback));
+  }
 }
 
 void ShowManageSSLCertificates(content::WebContents* web_contents) {
diff --git a/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc b/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc
index 91684b8998732..46b241f52841c 100644
--- a/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc
+++ b/chrome/browser/ui/webui/side_panel/bookmarks/bookmarks_side_panel_ui.cc
@@ -214,7 +214,10 @@ BookmarksSidePanelUI::BookmarksSidePanelUI(content::WebUI* web_ui)
   content::URLDataSource::Add(
       profile, std::make_unique<FaviconSource>(
                    profile, chrome::FaviconUrlFormat::kFavicon2));
-  const int resource = IDR_SIDE_PANEL_BOOKMARKS_POWER_BOOKMARKS_HTML;
+  const int resource =
+      base::FeatureList::IsEnabled(features::kPowerBookmarksSidePanel)
+          ? IDR_SIDE_PANEL_BOOKMARKS_POWER_BOOKMARKS_HTML
+          : IDR_SIDE_PANEL_BOOKMARKS_BOOKMARKS_HTML;
   webui::SetupWebUIDataSource(source,
                               base::make_span(kSidePanelBookmarksResources,
                                               kSidePanelBookmarksResourcesSize),
diff --git a/chrome/browser/webshare/win/fake_storage_file_statics.cc b/chrome/browser/webshare/win/fake_storage_file_statics.cc
index 6308ccec3a576..f17033b2d1ec7 100644
--- a/chrome/browser/webshare/win/fake_storage_file_statics.cc
+++ b/chrome/browser/webshare/win/fake_storage_file_statics.cc
@@ -9,7 +9,6 @@
 #include <wrl/module.h>
 
 #include <memory>
-#include <string>
 #include <tuple>
 
 #include "base/functional/bind.h"
@@ -279,6 +278,13 @@ IFACEMETHODIMP FakeStorageFileStatics::CreateStreamedFileAsync(
     IStreamedFileDataRequestedHandler* data_requested,
     IRandomAccessStreamReference* thumbnail,
     IAsyncOperation<StorageFile*>** operation) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    ADD_FAILURE() << "Attempted to use FakeStorageFileStatics in an "
+                     "environment that doesn't support ScopedHStrings.";
+    return E_UNEXPECTED;
+  }
+
   auto fake_iasync_operation =
       Make<base::win::FakeIAsyncOperation<StorageFile*>>();
   HRESULT hr = fake_iasync_operation->QueryInterface(IID_PPV_ARGS(operation));
diff --git a/chrome/browser/webshare/win/share_operation.cc b/chrome/browser/webshare/win/share_operation.cc
index ef09f08ba9cf4..8747e21cbe552 100644
--- a/chrome/browser/webshare/win/share_operation.cc
+++ b/chrome/browser/webshare/win/share_operation.cc
@@ -370,6 +370,13 @@ void ShareOperation::Run(blink::mojom::ShareService::ShareCallback callback) {
   DCHECK(!callback_);
   callback_ = std::move(callback);
 
+  // Ensure that the required WinRT functionality is available/loaded.
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    Complete(blink::mojom::ShareError::INTERNAL_ERROR);
+    return;
+  }
+
   // If the corresponding web_contents have already been cleaned up, cancel
   // the operation.
   if (!web_contents_) {
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
index 15f2def437648..021f9f2b55471 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
@@ -40,6 +40,12 @@ HRESULT GetDataTransferManagerHandles(
     HWND hwnd,
     IDataTransferManagerInterop** data_transfer_manager_interop,
     IDataTransferManager** data_transfer_manager) {
+
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return E_FAIL;
+  }
+
   // IDataTransferManagerInterop is semi-hidden behind a CloakedIid
   // structure on the DataTransferManager, excluding it from things
   // used by RoGetActivationFactory like GetIids(). Because of this,
diff --git a/chrome/browser/win/titlebar_config.cc b/chrome/browser/win/titlebar_config.cc
index f088a7071b1e0..3e829274cd26b 100644
--- a/chrome/browser/win/titlebar_config.cc
+++ b/chrome/browser/win/titlebar_config.cc
@@ -4,28 +4,57 @@
 
 #include "chrome/browser/win/titlebar_config.h"
 
+#include <Windows.h>
+#include "base/command_line.h"
 #include "base/win/windows_version.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/common/chrome_switches.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/native_theme/native_theme.h"
 
-// Allows the titlebar to be drawn by the system using the Mica material
-// on Windows 11, version 22H2 and above.
-BASE_FEATURE(kWindows11MicaTitlebar,
-             "Windows11MicaTitlebar",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+bool ShouldCustomDrawSystemTitlebar() {
+  // Some extra code added here because those with pre-win8 and no DWM will have to fallback on the custom titlebar.
+  BOOL result = FALSE;
+
+  typedef HRESULT(WINAPI* DwmIsCompositionEnabledFunc)(BOOL* enabled);
+  DwmIsCompositionEnabledFunc func_ = nullptr;
+
+  HMODULE dwmapi_library_ = LoadLibraryW(L"dwmapi.dll");
+  if (dwmapi_library_) {
+    func_ = reinterpret_cast<DwmIsCompositionEnabledFunc>(
+        GetProcAddress(dwmapi_library_, "DwmIsCompositionEnabled"));
+  }
+  else
+	  return true;
+
+  if (func_) {
+	  func_(&result);
+  }
+  else
+	  return true;
+  // Cache flag lookup.
+  static const bool custom_titlebar_disabled =
+      base::CommandLine::InitializedForCurrentProcess() &&
+      (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableWindows10CustomTitlebar) ||
+	  base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "windows11-mica-titlebar"));
+
+  return (!custom_titlebar_disabled &&
+         base::win::GetVersion() >= base::win::Version::WIN10) || !result;
+}
 
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view) {
-  return !ShouldDefaultThemeUseMicaTitlebar() ||
-         !ThemeServiceFactory::GetForProfile(browser_view->GetProfile())
-              ->UsingSystemTheme() ||
+
+  return ShouldCustomDrawSystemTitlebar() ||
          (!browser_view->browser()->is_type_normal() &&
           !browser_view->browser()->is_type_popup() &&
           !browser_view->browser()->is_type_devtools());
 }
 
+
 bool ShouldDefaultThemeUseMicaTitlebar() {
   return SystemTitlebarCanUseMicaMaterial() &&
          !ui::AccentColorObserver::Get()->use_dwm_frame_color() &&
@@ -34,6 +63,15 @@ bool ShouldDefaultThemeUseMicaTitlebar() {
 }
 
 bool SystemTitlebarCanUseMicaMaterial() {
-  return base::win::GetVersion() >= base::win::Version::WIN11_22H2 &&
-         base::FeatureList::IsEnabled(kWindows11MicaTitlebar);
+  return base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "windows11-mica-titlebar");
+}
+
+bool ShouldBrowserUseMicaTitlebar(class BrowserView *) {
+  return base::CommandLine::ForCurrentProcess()->HasSwitch(
+          "windows11-mica-titlebar");
+}
+
+bool SystemTitlebarSupportsDarkMode() {
+  return base::win::GetVersion() >= base::win::Version::WIN11;
 }
diff --git a/chrome/browser/win/titlebar_config.h b/chrome/browser/win/titlebar_config.h
index 48f413792d5aa..d87174bd1d78c 100644
--- a/chrome/browser/win/titlebar_config.h
+++ b/chrome/browser/win/titlebar_config.h
@@ -6,14 +6,23 @@
 #define CHROME_BROWSER_WIN_TITLEBAR_CONFIG_H_
 
 #include "base/feature_list.h"
+#include "chrome/browser/ui/views/chrome_views_export.h"
 
 class BrowserView;
 
 BASE_DECLARE_FEATURE(kWindows11MicaTitlebar);
+BASE_DECLARE_FEATURE(kDisableAeroTheme);
 
 // Returns whether we should custom draw the titlebar for a browser window.
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view);
 
+// Returns whether we should always custom draw the system title bar.
+bool ShouldCustomDrawSystemTitlebar();
+
+// Returns whether we should use the Mica titlebar material for a browser
+// window.
+bool ShouldBrowserUseMicaTitlebar(BrowserView* browser_view);
+
 // Returns whether we should use the Mica titlebar in standard browser windows
 // using the default theme.
 bool ShouldDefaultThemeUseMicaTitlebar();
@@ -22,4 +31,7 @@ bool ShouldDefaultThemeUseMicaTitlebar();
 // material.
 bool SystemTitlebarCanUseMicaMaterial();
 
+// Returns whether the system-drawn titlebar can be drawn in dark mode.
+bool SystemTitlebarSupportsDarkMode();
+
 #endif  // CHROME_BROWSER_WIN_TITLEBAR_CONFIG_H_
diff --git a/chrome/chrome_elf/BUILD.gn b/chrome/chrome_elf/BUILD.gn
index 37e2d2a50aa2c..196858a63c713 100644
--- a/chrome/chrome_elf/BUILD.gn
+++ b/chrome/chrome_elf/BUILD.gn
@@ -150,6 +150,7 @@ static_library("hook_util") {
   deps = [
     "//base:base_static",  # pe_image
   ]
+  public_deps = [ "//base" ]
 }
 
 # This target contains utility functions which must only depend on
diff --git a/chrome/chrome_elf/chrome_elf_security.cc b/chrome/chrome_elf/chrome_elf_security.cc
index e7bda43a9814b..00146f72d7a61 100644
--- a/chrome/chrome_elf/chrome_elf_security.cc
+++ b/chrome/chrome_elf/chrome_elf_security.cc
@@ -85,6 +85,7 @@ class ExtensionPointDisableSet {
 }  // namespace
 
 void EarlyBrowserSecurity() {
+  typedef decltype(SetProcessMitigationPolicy)* SetProcessMitigationPolicyFunc;
   // This function is called from within DllMain.
   // Don't do anything naughty while we have the loader lock.
   NTSTATUS ret_val = STATUS_SUCCESS;
@@ -108,12 +109,20 @@ void EarlyBrowserSecurity() {
 
   nt::CloseRegKey(handle);
 
-  // Disable extension points (legacy hooking) in this process.
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  policy.DisableExtensionPoints = true;
-  SetProcessMitigationPolicy(ProcessExtensionPointDisablePolicy, &policy,
-                             sizeof(policy));
-  ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+  if (::IsWindows8OrGreater()) {
+    SetProcessMitigationPolicyFunc set_process_mitigation_policy =
+        reinterpret_cast<SetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "SetProcessMitigationPolicy"));
+    if (set_process_mitigation_policy) {
+      // Disable extension points in this process.
+      // (Legacy hooking.)
+      PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+      policy.DisableExtensionPoints = true;
+      set_process_mitigation_policy(ProcessExtensionPointDisablePolicy, &policy,
+                                    sizeof(policy));
+      ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+    }
+  }
 
   return;
 }
diff --git a/chrome/chrome_elf/chrome_elf_util_unittest.cc b/chrome/chrome_elf/chrome_elf_util_unittest.cc
index 5ee09effb6e03..3af5789ad6185 100644
--- a/chrome/chrome_elf/chrome_elf_util_unittest.cc
+++ b/chrome/chrome_elf/chrome_elf_util_unittest.cc
@@ -4,6 +4,8 @@
 
 #include <windows.h>
 
+#include <versionhelpers.h>  // windows.h must be before.
+
 #include <tuple>
 
 #include "base/test/test_reg_util_win.h"
@@ -37,14 +39,28 @@ bool SetExtensionPointEnabledFlag(bool creation) {
 }
 
 bool IsSecuritySet() {
-  // Check that extension points are disabled. (Legacy hooking.)
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                    ProcessExtensionPointDisablePolicy, &policy,
-                                    sizeof(policy))) {
-    return false;
+  typedef decltype(GetProcessMitigationPolicy)* GetProcessMitigationPolicyFunc;
+
+  // Check the settings from EarlyBrowserSecurity().
+  if (::IsWindows8OrGreater()) {
+    GetProcessMitigationPolicyFunc get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (!get_process_mitigation_policy)
+      return false;
+
+    // Check that extension points are disabled.
+    // (Legacy hooking.)
+    PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+    if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                       ProcessExtensionPointDisablePolicy,
+                                       &policy, sizeof(policy)))
+      return false;
+
+    return policy.DisableExtensionPoints;
   }
-  return policy.DisableExtensionPoints;
+
+  return true;
 }
 
 void RegRedirect(nt::ROOT_KEY key,
@@ -70,6 +86,9 @@ void CancelRegRedirect(nt::ROOT_KEY key) {
 }
 
 TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
+
+  if (!::IsWindows8OrGreater())
+    return;
   // We should validate the exe version isn't used for this test
   elf_security::ValidateExeForTesting(true);
 
@@ -78,6 +97,8 @@ TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
 }
 
 TEST(ChromeElfUtilTest, BrowserProcessSecurityTest) {
+  if (!::IsWindows8OrGreater())
+    return;
   // Set up registry override for this test.
   registry_util::RegistryOverrideManager override_manager;
   ASSERT_NO_FATAL_FAILURE(RegRedirect(nt::HKCU, &override_manager));
diff --git a/chrome/chrome_elf/hook_util/hook_util.cc b/chrome/chrome_elf/hook_util/hook_util.cc
index ce309c8b6888b..96ab0afa9bbf3 100644
--- a/chrome/chrome_elf/hook_util/hook_util.cc
+++ b/chrome/chrome_elf/hook_util/hook_util.cc
@@ -8,6 +8,9 @@
 #include <versionhelpers.h>  // windows.h must be before
 
 #include "base/win/pe_image.h"
+#include "chrome/chrome_elf/nt_registry/nt_registry.h"  // utils
+#include "sandbox/win/src/internal_types.h"
+#include "sandbox/win/src/service_resolver.h"
 
 namespace {
 
@@ -194,6 +197,44 @@ DWORD RemoveIATHook(void* intercept_function,
 
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed) {
+  // Create a thunk via the appropriate ServiceResolver instance.
+  sandbox::ServiceResolverThunk* thunk = nullptr;
+
+  // No hooking on unsupported OS versions.
+  if (!::IsWindows7OrGreater())
+    return thunk;
+
+  // Pseudo-handle, no need to close.
+  HANDLE current_process = ::GetCurrentProcess();
+
+#if defined(_WIN64)
+  // ServiceResolverThunk can handle all the formats in 64-bit (instead only
+  // handling one like it does in 32-bit versions).
+  thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+#else
+  BOOL is_wow64 = FALSE;
+  if (::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64) {
+    if (::IsWindows10OrGreater())
+      thunk = new sandbox::Wow64W10ResolverThunk(current_process, relaxed);
+    else if (::IsWindows8OrGreater())
+      thunk = new sandbox::Wow64W8ResolverThunk(current_process, relaxed);
+    else
+      thunk = new sandbox::Wow64ResolverThunk(current_process, relaxed);
+  } else if (::IsWindows8OrGreater()) {
+    thunk = new sandbox::Win8ResolverThunk(current_process, relaxed);
+  } else {
+    thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+  }
+#endif
+
+  return thunk;
+}
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/hook_util/hook_util.h b/chrome/chrome_elf/hook_util/hook_util.h
index 9070b9d93a6f0..687042ec330c7 100644
--- a/chrome/chrome_elf/hook_util/hook_util.h
+++ b/chrome/chrome_elf/hook_util/hook_util.h
@@ -7,8 +7,20 @@
 
 #include <windows.h>
 
+namespace sandbox {
+class ServiceResolverThunk;
+}
+
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+// Creates a |ServiceResolverThunk| based on the OS version. Ownership of the
+// resulting thunk is passed to the caller.
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed);
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 356739e4e088a..bc7dce68e4d77 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -779,7 +779,15 @@ const char kRelauncherProcessDMGDevice[] = "dmg-device";
 const char kMakeChromeDefault[] = "make-chrome-default";
 #endif  // BUILDFLAG(IS_MAC)
 
+const char kDisableDownloadUpload[] = "disable-download-upload";
+
+const char kUngoogledThorium[] = "ungoogled-thorium";
+
 #if BUILDFLAG(IS_WIN)
+// Disables custom-drawing the window titlebar on Windows 10.
+const char kDisableWindows10CustomTitlebar[] =
+    "disable-windows10-custom-titlebar";
+
 // Force-enables the profile shortcut manager. This is needed for tests since
 // they use a custom-user-data-dir which disables this.
 const char kEnableProfileShortcutManager[] = "enable-profile-shortcut-manager";
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index 96ce2223297a2..e3d8006e1bf5d 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -246,7 +246,11 @@ extern const char kRelauncherProcessDMGDevice[];
 extern const char kMakeChromeDefault[];
 #endif  // BUILDFLAG(IS_MAC)
 
+extern const char kDisableDownloadUpload[];
+extern const char kUngoogledThorium[];
+
 #if BUILDFLAG(IS_WIN)
+extern const char kDisableWindows10CustomTitlebar[];
 extern const char kEnableProfileShortcutManager[];
 extern const char kFromInstaller[];
 extern const char kHideIcons[];
diff --git a/chrome/installer/setup/install.cc b/chrome/installer/setup/install.cc
index 26d3bab930e68..c14608e55811c 100644
--- a/chrome/installer/setup/install.cc
+++ b/chrome/installer/setup/install.cc
@@ -28,6 +28,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_params.h"
@@ -134,6 +135,7 @@ void ExecuteAndLogShortcutOperation(
   // For Start Menu shortcut creation on versions of Win10 that support
   // pinning, record whether or not the installer pinned Chrome.
   if (location == ShellUtil::SHORTCUT_LOCATION_START_MENU_ROOT &&
+      base::win::GetVersion() >= base::win::Version::WIN10 &&
       CanPinShortcutToTaskbar()) {
     SetInstallerPinnedChromeToTaskbar(properties.pin_to_taskbar && pinned);
   }
diff --git a/chrome/installer/util/install_util.cc b/chrome/installer/util/install_util.cc
index 03a38089b56a8..2a7fdd070d030 100644
--- a/chrome/installer/util/install_util.cc
+++ b/chrome/installer/util/install_util.cc
@@ -243,10 +243,10 @@ base::Version InstallUtil::GetCriticalUpdateVersion() {
 }
 
 bool InstallUtil::IsOSSupported() {
-  // We do not support anything prior to Windows 10.
+  // We do not support anything prior to Windows Vista.
   VLOG(1) << base::SysInfo::OperatingSystemName() << ' '
           << base::SysInfo::OperatingSystemVersion();
-  return base::win::GetVersion() >= base::win::Version::WIN10;
+  return base::win::GetVersion() >= base::win::Version::VISTA;
 }
 
 void InstallUtil::AddInstallerResultItems(bool system_install,
diff --git a/chrome/installer/util/shell_util.cc b/chrome/installer/util/shell_util.cc
index 1f9d3449c04ce..050db0e033641 100644
--- a/chrome/installer/util/shell_util.cc
+++ b/chrome/installer/util/shell_util.cc
@@ -12,6 +12,7 @@
 #include <objbase.h>
 #include <shlobj.h>
 #include <shobjidl.h>
+#include <windows.h>
 #include <wrl/client.h>
 
 #include <algorithm>
@@ -295,12 +296,13 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
     entries->back()->set_removal_flag(RegistryEntry::RemovalFlag::VALUE);
   }
 
-  // The following entries are required but do not depend on the DelegateExecute
-  // verb handler being set.
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
-  }
+  // The following entries are required as of Windows 8, but do not
+  // depend on the DelegateExecute verb handler being set.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
 
   // Add \Software\Classes\<prog_id>\Application entries
   std::wstring application_path(prog_id_path + ShellUtil::kRegApplication);
@@ -330,6 +332,7 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
         app_info.publisher_name));
   }
 }
+}
 
 // This method returns a list of all the registry entries that are needed to
 // register this installation's ProgIds and AppId.
@@ -708,6 +711,26 @@ bool ElevateAndRegisterChrome(
   return false;
 }
 
+// Launches the Windows 7 and Windows 8 dialog for picking the application to
+// handle the given protocol. Most importantly, this is used to set the default
+// handler for http (and, implicitly with it, https). In that case it is also
+// known as the 'how do you want to open webpages' dialog.
+// It is required that Chrome be already *registered* for the given protocol.
+bool LaunchSelectDefaultProtocolHandlerDialog(const wchar_t* protocol) {
+  DCHECK(protocol);
+  OPENASINFO open_as_info = {};
+  open_as_info.pcszFile = protocol;
+  open_as_info.oaifInFlags =
+      OAIF_URL_PROTOCOL | OAIF_FORCE_REGISTRATION | OAIF_REGISTER_EXT;
+  HRESULT hr = SHOpenWithDialog(nullptr, &open_as_info);
+  DLOG_IF(WARNING, FAILED(hr)) << "Failed to set as default " << protocol
+                               << " handler; hr=0x" << std::hex << hr;
+  if (FAILED(hr))
+    return false;
+  SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, nullptr, nullptr);
+  return true;
+}
+
 // Returns true if |chrome_exe| has been registered with |suffix| for |mode|.
 // |confirmation_level| is the level of verification desired as described in
 // the RegistrationConfirmationLevel enum above.
@@ -742,11 +765,12 @@ bool QuickIsChromeRegisteredForMode(
   }
   reg_key += ShellUtil::kRegShellOpen;
 
-  // ProgId and shell integration registrations are allowed to reside in HKCU
-  // for user-level installs, and values there have priority over values in
-  // HKLM.
+  // ProgId registrations are allowed to reside in HKCU for user-level installs
+  // (and values there have priority over values in HKLM). The same is true for
+  // shell integration entries as of Windows 8.
   if (confirmation_level == CONFIRM_PROGID_REGISTRATION ||
-      confirmation_level == CONFIRM_SHELL_REGISTRATION) {
+      (confirmation_level == CONFIRM_SHELL_REGISTRATION &&
+       base::win::GetVersion() >= base::win::Version::WIN8)) {
     const RegKey key_hkcu(HKEY_CURRENT_USER, reg_key.c_str(), KEY_QUERY_VALUE);
     std::wstring hkcu_value;
     // If |reg_key| is present in HKCU, assert that it points to |chrome_exe|.
@@ -821,7 +845,9 @@ bool GetInstallationSpecificSuffix(const base::FilePath& chrome_exe,
 // be placed for this install. As of Windows 8 everything can go in HKCU for
 // per-user installs.
 HKEY DetermineRegistrationRoot(bool is_per_user) {
-  return is_per_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
+    return is_per_user && base::win::GetVersion() >= base::win::Version::WIN8
+             ? HKEY_CURRENT_USER
+             : HKEY_LOCAL_MACHINE;
 }
 
 // Associates Chrome with supported protocols and file associations. This should
@@ -1040,6 +1066,7 @@ ShellUtil::DefaultState ProbeProtocolHandlers(const base::FilePath& chrome_exe,
 // Returns true on success.
 bool GetAppShortcutsFolder(ShellUtil::ShellChange level, base::FilePath* path) {
   DCHECK(path);
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
 
   base::FilePath folder;
   if (!base::PathService::Get(base::DIR_APP_SHORTCUTS, &folder)) {
@@ -1417,6 +1444,7 @@ bool RegisterChromeBrowserImpl(const base::FilePath& chrome_exe,
 bool RegisterApplicationForProtocols(const std::vector<std::wstring>& protocols,
                                      const std::wstring& prog_id,
                                      const base::FilePath& chrome_exe) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
   std::vector<std::unique_ptr<RegistryEntry>> entries;
   ShellUtil::ApplicationInfo app_info =
       ShellUtil::GetApplicationInfoForProgId(prog_id);
@@ -1520,10 +1548,10 @@ const wchar_t* ShellUtil::kDefaultFileAssociations[] = {
 const wchar_t* ShellUtil::kPotentialFileAssociations[] = {
     L".htm", L".html",  L".pdf",  L".shtml", L".svg",
     L".xht", L".xhtml", L".webp", nullptr};
-const wchar_t* ShellUtil::kBrowserProtocolAssociations[] = {L"http", L"https",
+const wchar_t* ShellUtil::kBrowserProtocolAssociations[] = {L"ftp", L"http", L"https",
                                                             nullptr};
 const wchar_t* ShellUtil::kPotentialProtocolAssociations[] = {
-    L"http", L"https", L"irc",   L"mailto", L"mms", L"news",   L"nntp",
+    L"ftp", L"http", L"https", L"irc",   L"mailto", L"mms", L"news",   L"nntp",
     L"sms",  L"smsto", L"snews", L"tel",    L"urn", L"webcal", nullptr};
 const wchar_t* ShellUtil::kRegUrlProtocol = L"URL Protocol";
 const wchar_t* ShellUtil::kRegApplication = L"\\Application";
@@ -1569,10 +1597,12 @@ bool ShellUtil::ShortcutLocationIsSupported(ShortcutLocation location) {
     case SHORTCUT_LOCATION_START_MENU_ROOT:                   // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_DIR_DEPRECATED:  // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR:        // Falls through.
-    case SHORTCUT_LOCATION_STARTUP:                           // Falls through.
-    case SHORTCUT_LOCATION_TASKBAR_PINS:                      // Falls through.
-    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+    case SHORTCUT_LOCATION_STARTUP:
       return true;
+    case SHORTCUT_LOCATION_TASKBAR_PINS:
+      return base::win::GetVersion() >= base::win::Version::WIN7;
+    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+      return base::win::GetVersion() >= base::win::Version::WIN8;
     default:
       NOTREACHED();
       return false;
@@ -1984,6 +2014,17 @@ bool ShellUtil::CanMakeChromeDefaultUnattended() {
   return base::win::GetVersion() < base::win::Version::WIN8;
 }
 
+// static
+ShellUtil::InteractiveSetDefaultMode ShellUtil::GetInteractiveSetDefaultMode() {
+  DCHECK(!CanMakeChromeDefaultUnattended());
+  // TODO(crbug.com/1385856): Remove all code associated with INTENT_PICKER,
+  // including InteractiveSetDefaultMode and GetInteractiveSetDefaultMode().
+  if (base::win::GetVersion() >= base::win::Version::WIN10)
+    return InteractiveSetDefaultMode::SYSTEM_SETTINGS;
+
+  return InteractiveSetDefaultMode::INTENT_PICKER;
+}
+
 bool ShellUtil::MakeChromeDefault(int shell_change,
                                   const base::FilePath& chrome_exe,
                                   bool elevate_if_not_admin) {
@@ -2078,8 +2119,25 @@ bool ShellUtil::ShowMakeChromeDefaultSystemUI(
   bool succeeded = true;
   bool is_default = (GetChromeDefaultState() == IS_DEFAULT);
   if (!is_default) {
-    // Launch the Windows Apps Settings dialog.
-    succeeded = base::win::LaunchDefaultAppsSettingsModernDialog(L"http");
+    switch (GetInteractiveSetDefaultMode()) {
+      case INTENT_PICKER: {
+        // On Windows 8, you can't set yourself as the default handler
+        // programmatically. In other words IApplicationAssociationRegistration
+        // has been rendered useless. What you can do is to launch
+        // "Set Program Associations" section of the "Default Programs"
+        // control panel, which is a mess, or pop the concise "How you want to
+        // open webpages?" dialog.  We choose the latter.
+        succeeded = LaunchSelectDefaultProtocolHandlerDialog(L"http");
+      } break;
+      case SYSTEM_SETTINGS:
+        // On Windows 10, you can't even launch the associations dialog.
+        // So we launch the settings dialog. Quoting from MSDN: "The Open With
+        // dialog box can no longer be used to change the default program used
+        // to open a file extension. You can only use SHOpenWithDialog to open
+        // a single file."
+        succeeded = base::win::LaunchDefaultAppsSettingsModernDialog(L"http");
+        break;
+    }
     is_default = (succeeded && GetChromeDefaultState() == IS_DEFAULT);
   }
   if (succeeded && is_default)
@@ -2151,9 +2209,24 @@ bool ShellUtil::ShowMakeChromeDefaultProtocolClientSystemUI(
   bool is_default =
       (GetChromeDefaultProtocolClientState(protocol) == IS_DEFAULT);
   if (!is_default) {
-    // Launch the Windows settings dialog.
-    succeeded =
-        base::win::LaunchDefaultAppsSettingsModernDialog(protocol.c_str());
+    switch (GetInteractiveSetDefaultMode()) {
+      case INTENT_PICKER: {
+        // On Windows 8, you can't set yourself as the default handler
+        // programmatically. In other words IApplicationAssociationRegistration
+        // has been rendered useless. What you can do is to launch
+        // "Set Program Associations" section of the "Default Programs"
+        // control panel, which is a mess, or pop the concise "How you want to
+        // open
+        // links of this type (protocol)?" dialog.  We choose the latter.
+        succeeded = LaunchSelectDefaultProtocolHandlerDialog(protocol.c_str());
+      } break;
+      case SYSTEM_SETTINGS:
+        // On Windows 10, you can't even launch the associations dialog.
+        // So we launch the settings dialog.
+        succeeded =
+            base::win::LaunchDefaultAppsSettingsModernDialog(protocol.c_str());
+        break;
+    }
     is_default = (succeeded &&
                   GetChromeDefaultProtocolClientState(protocol) == IS_DEFAULT);
   }
@@ -2518,16 +2591,19 @@ bool ShellUtil::AddAppProtocolAssociations(
     if (!AddRegistryEntries(HKEY_CURRENT_USER, entries))
       success = false;
 
-    // Removing the existing user choice for a given protocol forces Windows to
-    // present a disambiguation dialog the next time this protocol is invoked
-    // from the OS.
-    std::unique_ptr<RegistryEntry> entry = GetProtocolUserChoiceEntry(protocol);
-    if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
-                                        WorkItem::kWow64Default, kRegProgId)) {
-      success = false;
+    // On Windows 10, removing the existing user choice for a given protocol
+    // forces Windows to present a disambiguation dialog the next time this
+    // protocol is invoked from the OS.
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      std::unique_ptr<RegistryEntry> entry =
+          GetProtocolUserChoiceEntry(protocol);
+      if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
+                                          WorkItem::kWow64Default,
+                                          kRegProgId)) {
+        success = false;
+      }
     }
   }
-
   return success;
 }
 
diff --git a/chrome/installer/util/shell_util.h b/chrome/installer/util/shell_util.h
index 2b61198e000fa..cc1edb326af3b 100644
--- a/chrome/installer/util/shell_util.h
+++ b/chrome/installer/util/shell_util.h
@@ -492,6 +492,19 @@ class ShellUtil {
   // Windows prior to Windows 8.
   static bool CanMakeChromeDefaultUnattended();
 
+  enum InteractiveSetDefaultMode {
+    // The intent picker is opened with the different choices available to the
+    // user.
+    INTENT_PICKER,
+    // The Windows default apps settings page is opened with the current default
+    // app focused.
+    SYSTEM_SETTINGS,
+  };
+
+  // Returns the interactive mode that should be used to set the default browser
+  // or default protocol client on Windows 8+.
+  static InteractiveSetDefaultMode GetInteractiveSetDefaultMode();
+
   // Returns the DefaultState of Chrome for HTTP and HTTPS and updates the
   // default browser beacons as appropriate.
   static DefaultState GetChromeDefaultState();
diff --git a/chrome/installer/util/taskbar_util.cc b/chrome/installer/util/taskbar_util.cc
index 0329447fdd3ad..e247deca60ff5 100644
--- a/chrome/installer/util/taskbar_util.cc
+++ b/chrome/installer/util/taskbar_util.cc
@@ -112,7 +112,9 @@ bool UnpinShortcutWithIPinnedList3(const base::FilePath& shortcut) {
 bool CanPinShortcutToTaskbar() {
   // "Pin to taskbar" isn't directly supported in Windows 10, but WIN10_RS5 has
   // some undocumented interfaces to do pinning.
-  return base::win::GetVersion() >= base::win::Version::WIN10_RS5;
+  // And the alternate method should theoretically work since Windows Desktop Update,
+  // always return true.
+  return true;
 }
 
 bool PinShortcutToTaskbar(const base::FilePath& shortcut) {
diff --git a/chrome/renderer/chrome_render_frame_observer.cc b/chrome/renderer/chrome_render_frame_observer.cc
index ef842d9e17cf3..6a6815b8ac9bc 100644
--- a/chrome/renderer/chrome_render_frame_observer.cc
+++ b/chrome/renderer/chrome_render_frame_observer.cc
@@ -251,15 +251,16 @@ void ChromeRenderFrameObserver::DidFinishLoad() {
   // Don't do anything for subframes.
   if (frame->Parent() || frame->IsInFencedFrameTree())
     return;
-
-  GURL osdd_url = frame->GetDocument().OpenSearchDescriptionURL();
-  if (!osdd_url.is_empty()) {
-    mojo::Remote<chrome::mojom::OpenSearchDescriptionDocumentHandler>
-        osdd_handler;
-    render_frame()->GetBrowserInterfaceBroker()->GetInterface(
-        osdd_handler.BindNewPipeAndPassReceiver());
-    osdd_handler->PageHasOpenSearchDescriptionDocument(
-        frame->GetDocument().Url(), osdd_url);
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-search-engine-collection")) {
+	  GURL osdd_url = frame->GetDocument().OpenSearchDescriptionURL();
+	  if (!osdd_url.is_empty()) {
+		mojo::Remote<chrome::mojom::OpenSearchDescriptionDocumentHandler>
+			osdd_handler;
+		render_frame()->GetBrowserInterfaceBroker()->GetInterface(
+			osdd_handler.BindNewPipeAndPassReceiver());
+		osdd_handler->PageHasOpenSearchDescriptionDocument(
+			frame->GetDocument().Url(), osdd_url);
+	}
   }
 }
 
diff --git a/chrome/services/util_win/processor_metrics.cc b/chrome/services/util_win/processor_metrics.cc
index 29c5bb2dd47f4..8742d122b3879 100644
--- a/chrome/services/util_win/processor_metrics.cc
+++ b/chrome/services/util_win/processor_metrics.cc
@@ -7,7 +7,6 @@
 #include <objbase.h>
 #include <sysinfoapi.h>
 #include <wbemidl.h>
-#include <winbase.h>
 #include <wrl/client.h>
 
 #include "base/metrics/histogram_functions.h"
@@ -110,63 +109,36 @@ void RecordCetAvailability() {
           ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"),
                            "IsUserCetAvailableInEnvironment"));
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
   if (is_user_cet_available_in_environment) {
     available = is_user_cet_available_in_environment(
         USER_CET_ENVIRONMENT_WIN32_PROCESS);
   }
   base::UmaHistogramBoolean("Windows.CetAvailable", available);
 
-  if (available) {
+  if (available && get_process_mitigation_policy) {
     PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {0};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                     ProcessUserShadowStackPolicy, &policy,
-                                     sizeof(policy))) {
+    if (get_process_mitigation_policy(GetCurrentProcess(),
+                                      ProcessUserShadowStackPolicy, &policy,
+                                      sizeof(policy))) {
       base::UmaHistogramBoolean("Windows.CetEnabled",
                                 policy.EnableUserShadowStack);
     }
   }
 }
 
-void RecordEnclaveAvailabilityInternal(base::StringPiece type,
-                                       DWORD enclave_type) {
-  // This API does not appear to be exported from kernel32.dll on
-  // Windows 10.0.10240.
-  static auto is_enclave_type_supported_func =
-      reinterpret_cast<decltype(&IsEnclaveTypeSupported)>(::GetProcAddress(
-          ::GetModuleHandleW(L"kernel32.dll"), "IsEnclaveTypeSupported"));
-
-  bool is_supported = false;
-
-  if (is_enclave_type_supported_func) {
-    is_supported = is_enclave_type_supported_func(enclave_type);
-  }
-
-  base::UmaHistogramBoolean(
-      base::StrCat({"Windows.Enclave.", type, ".Available"}), is_supported);
-}
-
-void RecordEnclaveAvailability() {
-  RecordEnclaveAvailabilityInternal("SGX", ENCLAVE_TYPE_SGX);
-  RecordEnclaveAvailabilityInternal("SGX2", ENCLAVE_TYPE_SGX2);
-  RecordEnclaveAvailabilityInternal("VBS", ENCLAVE_TYPE_VBS);
-  RecordEnclaveAvailabilityInternal("VBSBasic", ENCLAVE_TYPE_VBS_BASIC);
-}
-
 void RecordProcessorMetrics() {
-  // These metrics do not require a WMI connection.
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+  ComPtr<IWbemServices> wmi_services;
+  if (!base::win::CreateLocalWmiConnection(true, &wmi_services))
+    return;
+  RecordProcessorMetricsFromWMI(wmi_services);
+  RecordHypervStatusFromWMI(wmi_services);
   RecordCetAvailability();
-  RecordEnclaveAvailability();
-
-  {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-    ComPtr<IWbemServices> wmi_services;
-    if (!base::win::CreateLocalWmiConnection(true, &wmi_services)) {
-      return;
-    }
-    RecordProcessorMetricsFromWMI(wmi_services);
-    RecordHypervStatusFromWMI(wmi_services);
-  }
 }
 
 }  // namespace
diff --git a/chrome/test/data/webui/BUILD.gn b/chrome/test/data/webui/BUILD.gn
index 437c3716c37a6..0f254ac1af106 100644
--- a/chrome/test/data/webui/BUILD.gn
+++ b/chrome/test/data/webui/BUILD.gn
@@ -202,6 +202,7 @@ source_set("interactive_ui_tests") {
     "new_tab_page/new_tab_page_focus_test.cc",
     "password_manager/password_manager_focus_test.cc",
     "settings/settings_focus_test.cc",
+    "side_panel/bookmarks/sp_bookmarks_focus_test.cc",
     "support_tool/support_tool_focus_test.cc",
     "tab_search/tab_search_focus_test.cc",
   ]
diff --git a/chrome/test/data/webui/side_panel/BUILD.gn b/chrome/test/data/webui/side_panel/BUILD.gn
index 1997193e8539d..6dad0386ff454 100644
--- a/chrome/test/data/webui/side_panel/BUILD.gn
+++ b/chrome/test/data/webui/side_panel/BUILD.gn
@@ -6,6 +6,10 @@ import("../build_webui_tests.gni")
 
 build_webui_tests("build") {
   files = [
+    "bookmarks/bookmark_folder_test.ts",
+    "bookmarks/bookmarks_drag_manager_test.ts",
+    "bookmarks/bookmarks_list_focus_test.ts",
+    "bookmarks/bookmarks_list_test.ts",
     "bookmarks/power_bookmarks_context_menu_test.ts",
     "bookmarks/power_bookmarks_drag_manager_test.ts",
     "bookmarks/power_bookmarks_edit_dialog_test.ts",
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmark_folder_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmark_folder_test.ts
new file mode 100644
index 0000000000000..b994bc25787d8
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmark_folder_test.ts
@@ -0,0 +1,353 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+
+import {BookmarkFolderElement, FOLDER_OPEN_CHANGED_EVENT, getBookmarkFromElement} from 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+import {ActionSource} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks.mojom-webui.js';
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {getFaviconForPageURL} from 'chrome://resources/js/icon.js';
+import {assertEquals, assertFalse, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {flushTasks, waitAfterNextRender} from 'chrome://webui-test/polymer_test_util.js';
+import {eventToPromise} from 'chrome://webui-test/test_util.js';
+
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarkFolderTest', () => {
+  let bookmarkFolder: BookmarkFolderElement;
+  let bookmarksApi: TestBookmarksApiProxy;
+
+  const folder: chrome.bookmarks.BookmarkTreeNode = {
+    id: '0',
+    title: 'Bookmarks bar',
+    children: [
+      {
+        id: '1',
+        title: 'Shopping list',
+        children: [
+          {
+            id: '4',
+            title: 'New shoes',
+            url: 'http://shoes/',
+          },
+        ],
+      },
+      {
+        id: '2',
+        title: 'Foo website',
+        url: 'http://foo/',
+      },
+      {
+        id: '3',
+        title: 'Bar website',
+        url: 'http://bar/',
+      },
+    ],
+  };
+
+  function getChildElements(): Array<HTMLElement|BookmarkFolderElement> {
+    return Array.from(bookmarkFolder.shadowRoot!.querySelectorAll(
+        'bookmark-folder, .bookmark'));
+  }
+
+  setup(async () => {
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    bookmarksApi = new TestBookmarksApiProxy();
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    bookmarkFolder = document.createElement('bookmark-folder');
+    bookmarkFolder.folder = folder;
+    bookmarkFolder.openFolders = ['0'];
+    document.body.appendChild(bookmarkFolder);
+
+    await flushTasks();
+  });
+
+  test('UpdatesDepthVariables', () => {
+    bookmarkFolder.depth = 3;
+    assertEquals('3', bookmarkFolder.style.getPropertyValue('--node-depth'));
+    assertEquals('4', bookmarkFolder.style.getPropertyValue('--child-depth'));
+  });
+
+  test('RendersChildren', () => {
+    const childElements = getChildElements();
+    assertEquals(3, childElements.length);
+
+    assertTrue(childElements[0] instanceof BookmarkFolderElement);
+    assertEquals(
+        folder.children![0],
+        (childElements[0]! as BookmarkFolderElement).folder);
+
+    assertEquals(
+        folder.children![1]!.title,
+        childElements[1]!.querySelector('.title')!.textContent);
+    assertEquals(
+        folder.children![2]!.title,
+        childElements[2]!.querySelector('.title')!.textContent);
+  });
+
+  test('UpdatesChildCountVariable', () => {
+    assertEquals('3', bookmarkFolder.style.getPropertyValue('--child-count'));
+
+    bookmarkFolder.folder = Object.assign({}, folder, {
+      children: [
+        {
+          id: '1',
+          title: 'Shopping list',
+          children: [],
+        },
+      ],
+    });
+    assertEquals('1', bookmarkFolder.style.getPropertyValue('--child-count'));
+
+    bookmarkFolder.folder = Object.assign({}, folder, {children: undefined});
+    assertEquals('0', bookmarkFolder.style.getPropertyValue('--child-count'));
+  });
+
+  test('ShowsFaviconForBookmarks', () => {
+    const fooWebsiteElement = getChildElements()[1]!;
+    assertEquals(
+        getFaviconForPageURL(folder.children![1]!.url!, false),
+        fooWebsiteElement.querySelector<HTMLElement>('.icon')!.style
+            .getPropertyValue('background-image'));
+  });
+
+  test('OpensAndClosesFolder', async () => {
+    const arrowIcon =
+        bookmarkFolder.shadowRoot!.querySelector<HTMLElement>('#arrowIcon')!;
+    assertTrue(arrowIcon.hasAttribute('open'));
+    assertEquals(3, getChildElements().length);
+
+    const eventPromise =
+        eventToPromise(FOLDER_OPEN_CHANGED_EVENT, document.body);
+    bookmarkFolder.shadowRoot!.querySelector<HTMLElement>('.row')!.click();
+    await eventPromise;
+
+    // Normally, the event listener for FOLDER_OPEN_CHANGED_EVENT will update
+    // the openFolders property.
+    bookmarkFolder.openFolders = [];
+    await waitAfterNextRender(bookmarkFolder);
+    assertFalse(arrowIcon.hasAttribute('open'));
+    assertEquals(0, getChildElements().length);
+  });
+
+  test('UpdatesOpenStateBasedOnOpenFolders', async () => {
+    bookmarkFolder.openFolders = [];
+    await waitAfterNextRender(bookmarkFolder);
+    getChildElements().forEach(
+        child => assertEquals('none', child.style.display));
+  });
+
+  test('OpensBookmark', async () => {
+    getChildElements()[1]!.click();
+    const [id, parentFolderDepth, , source] =
+        await bookmarksApi.whenCalled('openBookmark');
+    assertEquals(folder.children![1]!.id, id);
+    assertEquals(0, parentFolderDepth);
+    assertEquals(ActionSource.kBookmark, source);
+  });
+
+  test('OpensBookmarkContextMenu', async () => {
+    getChildElements()[1]!.dispatchEvent(new MouseEvent('contextmenu'));
+    const [id, , , source] = await bookmarksApi.whenCalled('showContextMenu');
+    assertEquals(folder.children![1]!.id, id);
+    assertEquals(ActionSource.kBookmark, source);
+  });
+
+  test('MovesFocusDown', () => {
+    // No focus yet, should focus folder row.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('.row'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus down one, should focus first child which is a folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('#children bookmark-folder'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    const bookmarkElements =
+        bookmarkFolder.shadowRoot!.querySelectorAll('#children .row');
+    // Move focus down one, should focus second child, the first bookmark.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(bookmarkElements[0], bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus down one, should focus second child, the second bookmark.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(bookmarkElements[1], bookmarkFolder.shadowRoot!.activeElement);
+
+    // No more room.
+    assertFalse(bookmarkFolder.moveFocus(1));
+  });
+
+  test('MovesFocusUp', () => {
+    // No focus yet, should focus last bookmark.
+    const bookmarkElements =
+        bookmarkFolder.shadowRoot!.querySelectorAll('#children .row');
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkElements[bookmarkElements.length - 1],
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus up one, should focus the first bookmark.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(bookmarkElements[0], bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus up one, should focus the child folder.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('#children bookmark-folder'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus up one, should focus the folder itself.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('.row'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // No more room.
+    assertFalse(bookmarkFolder.moveFocus(-1));
+  });
+
+  test('DoesNotFocusHiddenChildren', async () => {
+    bookmarkFolder.openFolders = [];
+    await waitAfterNextRender(bookmarkFolder);
+    assertTrue(bookmarkFolder.moveFocus(1));   // Moves focus to folder.
+    assertFalse(bookmarkFolder.moveFocus(1));  // No children to move focus to.
+  });
+
+  test('MovesFocusWithinNestedFolders', async () => {
+    bookmarkFolder.folder = {
+      id: '0',
+      title: 'Bookmarks bar',
+      children: [{
+        id: '1',
+        title: 'Nested folder 1',
+        children: [{
+          id: '2',
+          title: 'Nested folder 2',
+          children: [{
+            id: '3',
+            title: 'Nested folder 3',
+            children: [],
+          }],
+        }],
+      }],
+    };
+    bookmarkFolder.openFolders = ['0', '1', '2', '3'];
+    await waitAfterNextRender(bookmarkFolder);
+
+    // Move focus down 1, should focus root folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.shadowRoot!.querySelector('.row'),
+        bookmarkFolder.shadowRoot!.activeElement);
+
+    // Move focus down 1, should focus first nested folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.folder.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement! as BookmarkFolderElement)
+            .folder);
+
+    // Move focus down 1, should focus grandchild folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.folder.children![0]!.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement!.shadowRoot!.activeElement! as
+         BookmarkFolderElement)
+            .folder);
+
+    // Move focus down 1, should focus great grandchild folder.
+    assertTrue(bookmarkFolder.moveFocus(1));
+    assertEquals(
+        bookmarkFolder.folder.children![0]!.children![0]!.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement!.shadowRoot!.activeElement!
+             .shadowRoot!.activeElement! as BookmarkFolderElement)
+            .folder);
+
+    // Move focus up 1, should focus grandchild folder.
+    assertTrue(bookmarkFolder.moveFocus(-1));
+    assertEquals(
+        bookmarkFolder.folder.children![0]!.children![0],
+        (bookmarkFolder.shadowRoot!.activeElement!.shadowRoot!.activeElement! as
+         BookmarkFolderElement)
+            .folder);
+  });
+
+  test('SendsClickModifiers', async () => {
+    const item = getChildElements()[1]!;
+    item.dispatchEvent(new MouseEvent('click'));
+    const [, , click] = await bookmarksApi.whenCalled('openBookmark');
+    assertFalse(
+        click.middleButton || click.altKey || click.ctrlKey || click.metaKey ||
+        click.shiftKey);
+    bookmarksApi.resetResolver('openBookmark');
+
+    // Middle mouse button click.
+    item.dispatchEvent(new MouseEvent('auxclick', {button: 1}));
+    const [, , auxClick] = await bookmarksApi.whenCalled('openBookmark');
+    assertTrue(auxClick.middleButton);
+    assertFalse(
+        auxClick.altKey || auxClick.ctrlKey || auxClick.metaKey ||
+        auxClick.shiftKey);
+    bookmarksApi.resetResolver('openBookmark');
+
+    // Non-middle mouse aux clicks.
+    item.dispatchEvent(new MouseEvent('auxclick', {button: 2}));
+    assertEquals(0, bookmarksApi.getCallCount('openBookmark'));
+
+    // Modifier keys.
+    item.dispatchEvent(new MouseEvent('click', {
+      altKey: true,
+      ctrlKey: true,
+      metaKey: true,
+      shiftKey: true,
+    }));
+    const [, , modifiedClick] = await bookmarksApi.whenCalled('openBookmark');
+    assertFalse(modifiedClick.middleButton);
+    assertTrue(
+        modifiedClick.altKey && modifiedClick.ctrlKey &&
+        modifiedClick.metaKey && modifiedClick.shiftKey);
+  });
+
+  test('GetsFocusableElements', async () => {
+    let focusableElement = bookmarkFolder.getFocusableElement([folder]);
+    assertTrue(!!focusableElement);
+    assertEquals('folder', focusableElement!.id);
+
+    const childBookmark = folder.children![1]!;
+    focusableElement = bookmarkFolder.getFocusableElement([childBookmark]);
+    assertTrue(!!focusableElement);
+    assertTrue(focusableElement!.classList.contains('bookmark'));
+    assertEquals(childBookmark, getBookmarkFromElement(focusableElement!));
+
+    const childFolder = folder.children![0]!;
+    focusableElement = bookmarkFolder.getFocusableElement([childFolder]);
+    assertTrue(!!focusableElement);
+    assertEquals('folder', focusableElement!.id);
+    assertEquals(childFolder.id, getBookmarkFromElement(focusableElement!).id);
+
+    // Grandchild bookmark is in a closed folder, so the focusable element
+    // should still be the child folder.
+    const grandchildBookmark = childFolder.children![0]!;
+    focusableElement =
+        bookmarkFolder.getFocusableElement([childFolder, grandchildBookmark]);
+    assertTrue(!!focusableElement);
+    assertEquals('folder', focusableElement!.id);
+    assertEquals(childFolder.id, getBookmarkFromElement(focusableElement!).id);
+
+    // Once the child folder is opened, the grandchild bookmark element should
+    // be focusable.
+    bookmarkFolder.openFolders = ['0', '1'];
+    await waitAfterNextRender(bookmarkFolder);
+    focusableElement =
+        bookmarkFolder.getFocusableElement([childFolder, grandchildBookmark]);
+    assertTrue(!!focusableElement);
+    assertTrue(focusableElement!.classList.contains('bookmark'));
+    assertEquals(grandchildBookmark, getBookmarkFromElement(focusableElement!));
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmarks_drag_manager_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_drag_manager_test.ts
new file mode 100644
index 0000000000000..6d7cb7204b67a
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_drag_manager_test.ts
@@ -0,0 +1,313 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {BookmarksDragManager, DROP_POSITION_ATTR, DropPosition, overrideFolderOpenerTimeoutDelay} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_drag_manager.js';
+import {BookmarksListElement, LOCAL_STORAGE_OPEN_FOLDERS_KEY} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+import {ShoppingListApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/shared/commerce/shopping_list_api_proxy.js';
+import {loadTimeData} from 'chrome://resources/js/load_time_data.js';
+import {assertDeepEquals, assertEquals, assertFalse, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {flushTasks} from 'chrome://webui-test/polymer_test_util.js';
+
+import {TestShoppingListApiProxy} from './commerce/test_shopping_list_api_proxy.js';
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarkDragManagerTest', () => {
+  let delegate: BookmarksListElement;
+
+  const folders: chrome.bookmarks.BookmarkTreeNode[] = [{
+    id: '1',
+    title: 'Bookmarks bar',
+    parentId: '0',
+    children: [
+      {
+        id: '2',
+        title: 'Google',
+        parentId: '1',
+        url: 'http://google.com',
+      },
+      {
+        id: '3',
+        title: 'Google Docs',
+        parentId: '1',
+        url: 'http://docs.google.com',
+      },
+      {
+        id: '4',
+        title: 'My folder',
+        parentId: '1',
+        children: [{
+          id: '5',
+          title: 'My folder\'s child',
+          url: 'http://google.com',
+          parentId: '4',
+        }],
+      },
+      {
+        id: '5',
+        title: 'Closed folder',
+        parentId: '1',
+        children: [{
+          id: '6',
+          title: 'Closed folder\'s child',
+          url: 'http://google.com',
+          parentId: '5',
+        }],
+      },
+    ],
+  }];
+
+  function getDraggableElements(): HTMLElement[] {
+    function getDraggableElementsInner(root: HTMLElement) {
+      const draggableElements: HTMLElement[] = [];
+      const children = root.shadowRoot!.querySelectorAll<HTMLElement>(
+          'bookmark-folder, .bookmark');
+      children.forEach(child => {
+        if (child.tagName === 'BOOKMARK-FOLDER') {
+          draggableElements.push(child.shadowRoot!.querySelector('#folder')!);
+          draggableElements.push(...getDraggableElementsInner(child));
+        } else {
+          draggableElements.push(child);
+        }
+      });
+      return draggableElements;
+    }
+
+    const rootFolder = delegate.shadowRoot!.querySelector('bookmark-folder')!;
+    return getDraggableElementsInner(rootFolder);
+  }
+
+  setup(async () => {
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    loadTimeData.overrideValues({
+      editBookmarksEnabled: true,
+    });
+
+    const bookmarksApi = new TestBookmarksApiProxy();
+    bookmarksApi.setFolders(JSON.parse(JSON.stringify(folders)));
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    const shoppingListApi = new TestShoppingListApiProxy();
+    ShoppingListApiProxyImpl.setInstance(shoppingListApi);
+
+    window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] =
+        JSON.stringify(['1', '4']);
+
+    delegate = new BookmarksListElement();
+    new BookmarksDragManager(delegate);
+    document.body.appendChild(delegate);
+
+    await flushTasks();
+  });
+
+  test('DragStartCallsAPI', () => {
+    let calledIds;
+    let calledIndex;
+    let calledX;
+    let calledY;
+    let calledTouch = false;
+    chrome.bookmarkManagerPrivate.startDrag =
+        (ids: string[], index: number, touch: boolean, x: number,
+         y: number) => {
+          calledIds = ids;
+          calledIndex = index;
+          calledTouch = touch;
+          calledX = x;
+          calledY = y;
+        };
+
+    const draggableBookmark = getDraggableElements()[0]!;
+    draggableBookmark.dispatchEvent(new DragEvent(
+        'dragstart',
+        {bubbles: true, composed: true, clientX: 100, clientY: 200}));
+
+    assertDeepEquals(['2'], calledIds);
+    assertEquals(0, calledIndex);
+    assertFalse(calledTouch);
+    assertEquals(100, calledX);
+    assertEquals(200, calledY);
+  });
+
+  test('DragOverUpdatesAttributes', () => {
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[0]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    function assertDropPosition(
+        dragOverElement: HTMLElement, yRatio: number,
+        dropPosition: DropPosition) {
+      const dragOverRect = dragOverElement.getBoundingClientRect();
+      dragOverElement.dispatchEvent(new DragEvent('dragover', {
+        bubbles: true,
+        composed: true,
+        clientX: dragOverRect.left,
+        clientY: dragOverRect.top + (dragOverRect.height * yRatio),
+      }));
+      assertEquals(
+          dropPosition, dragOverElement.getAttribute(DROP_POSITION_ATTR));
+    }
+
+    const dragOverBookmark = draggableElements[1]!;
+    assertDropPosition(dragOverBookmark, 0.2, DropPosition.ABOVE);
+    assertDropPosition(dragOverBookmark, 0.5, DropPosition.ABOVE);
+    assertDropPosition(dragOverBookmark, 0.8, DropPosition.BELOW);
+
+    const dragOverFolder = draggableElements[2]!;
+    assertDropPosition(dragOverFolder, 0.2, DropPosition.ABOVE);
+    assertDropPosition(dragOverFolder, 0.5, DropPosition.INTO);
+    delegate.isFolderOpen = () => false;
+    assertDropPosition(dragOverFolder, 0.8, DropPosition.BELOW);
+    delegate.isFolderOpen = () => true;
+    assertDropPosition(dragOverFolder, 0.8, DropPosition.INTO);
+  });
+
+  test('DragOverDescendant', async () => {
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    const draggableElements = getDraggableElements();
+    const draggedFolder = draggableElements[2]!;
+    draggedFolder.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    // Drag over self.
+    let dragOverRect = draggedFolder.getBoundingClientRect();
+    draggedFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top,
+    }));
+    assertEquals(null, draggedFolder.getAttribute(DROP_POSITION_ATTR));
+
+    const dragOverChild = draggableElements[3]!;
+    dragOverRect = dragOverChild.getBoundingClientRect();
+    dragOverChild.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top,
+    }));
+    assertEquals(null, dragOverChild.getAttribute(DROP_POSITION_ATTR));
+  });
+
+  test('DropsIntoFolder', () => {
+    let calledId;
+    let calledIndex;
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    chrome.bookmarkManagerPrivate.drop = (id, index) => {
+      calledId = id;
+      calledIndex = index;
+      return Promise.resolve();
+    };
+
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[0]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    const dropFolder = draggableElements[2]!;
+    const dragOverRect = dropFolder.getBoundingClientRect();
+    dropFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top + (dragOverRect.height * .5),
+    }));
+    dropFolder.dispatchEvent(
+        new DragEvent('drop', {bubbles: true, composed: true}));
+
+    assertEquals('4', calledId);
+    assertEquals(undefined, calledIndex);
+  });
+
+  test('DropsBookmarksToReorder', () => {
+    let calledId;
+    let calledIndex;
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    chrome.bookmarkManagerPrivate.drop = (id, index) => {
+      calledId = id;
+      calledIndex = index;
+      return Promise.resolve();
+    };
+
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[2]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    const dragAboveBookmark = draggableElements[0]!;
+    const dragAboveRect = dragAboveBookmark.getBoundingClientRect();
+    dragAboveBookmark.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragAboveRect.left,
+      clientY: dragAboveRect.top + (dragAboveRect.height * .1),
+    }));
+    dragAboveBookmark.dispatchEvent(
+        new DragEvent('drop', {bubbles: true, composed: true}));
+    assertEquals('1', calledId);
+    assertEquals(0, calledIndex);
+
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+    const dragBelowBookmark = draggableElements[1]!;
+    const dragBelowRect = dragBelowBookmark.getBoundingClientRect();
+    dragBelowBookmark.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragBelowRect.left,
+      clientY: dragBelowRect.top + (dragBelowRect.height * .9),
+    }));
+    dragBelowBookmark.dispatchEvent(
+        new DragEvent('drop', {bubbles: true, composed: true}));
+    assertEquals('1', calledId);
+    assertEquals(2, calledIndex);
+  });
+
+  test('DragOverFolderAutoOpens', async () => {
+    overrideFolderOpenerTimeoutDelay(0);
+    chrome.bookmarkManagerPrivate.startDrag = () => {};
+    const draggableElements = getDraggableElements();
+    const draggedBookmark = draggableElements[0]!;
+    draggedBookmark.dispatchEvent(new DragEvent(
+        'dragstart', {bubbles: true, composed: true, clientX: 0, clientY: 0}));
+
+    const folderNode = folders[0]!.children![3]!;
+    const dragOverFolder = draggableElements[4]!;
+    const dragOverRect = dragOverFolder.getBoundingClientRect();
+    dragOverFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top + (dragOverRect.height * .5),
+    }));
+    assertFalse(delegate.isFolderOpen(folderNode));
+
+    // Drag over a new bookmark before the timeout runs out to ensure the
+    // timeout is canceled.
+    const newDragOverBookmark = draggableElements[3]!;
+    const newDragOverBookmarkRect = newDragOverBookmark.getBoundingClientRect();
+    newDragOverBookmark.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: newDragOverBookmarkRect.left,
+      clientY:
+          newDragOverBookmarkRect.top + (newDragOverBookmarkRect.height * .5),
+    }));
+    await new Promise(resolve => setTimeout(resolve, 0));
+    assertFalse(delegate.isFolderOpen(folderNode));
+
+    // Drag back into closed folder and wait for the timeout to resolve.
+    dragOverFolder.dispatchEvent(new DragEvent('dragover', {
+      bubbles: true,
+      composed: true,
+      clientX: dragOverRect.left,
+      clientY: dragOverRect.top + (dragOverRect.height * .5),
+    }));
+    await new Promise(resolve => setTimeout(resolve, 0));
+    assertTrue(delegate.isFolderOpen(folderNode));
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_focus_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_focus_test.ts
new file mode 100644
index 0000000000000..3c4bc63a8accd
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_focus_test.ts
@@ -0,0 +1,172 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+
+import {BookmarkFolderElement} from 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {BookmarksListElement} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+import {ShoppingListApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/shared/commerce/shopping_list_api_proxy.js';
+import {FocusOutlineManager} from 'chrome://resources/js/focus_outline_manager.js';
+import {down, keyDownOn} from 'chrome://resources/polymer/v3_0/iron-test-helpers/mock-interactions.js';
+import {assertEquals, assertFalse, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {flushTasks} from 'chrome://webui-test/polymer_test_util.js';
+
+import {TestShoppingListApiProxy} from './commerce/test_shopping_list_api_proxy.js';
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarksListFocusTest', () => {
+  let bookmarksList: BookmarksListElement;
+  let bookmarksApi: TestBookmarksApiProxy;
+
+  const folders: chrome.bookmarks.BookmarkTreeNode[] = [
+    {
+      id: '0',
+      parentId: 'root',
+      title: 'Bookmarks bar',
+      children: [
+        {
+          id: '3',
+          parentId: '0',
+          title: 'Child bookmark',
+          url: 'http://child/bookmark/',
+        },
+        {
+          id: '4',
+          parentId: '0',
+          title: 'Child folder',
+          children: [
+            {
+              id: '5',
+              parentId: '4',
+              title: 'Nested bookmark',
+              url: 'http://nested/bookmark/',
+            },
+          ],
+        },
+      ],
+    },
+    {
+      id: '1',
+      parentId: 'root',
+      title: 'Other bookmarks',
+      children: [],
+    },
+    {
+      id: '2',
+      title: 'Mobile bookmarks',
+      children: [],
+    },
+  ];
+
+  function getFolderElements(root: HTMLElement):
+      NodeListOf<BookmarkFolderElement> {
+    return root.shadowRoot!.querySelectorAll('bookmark-folder');
+  }
+
+  function getBookmarkElements(root: HTMLElement): NodeListOf<HTMLElement> {
+    return root.shadowRoot!.querySelectorAll('.bookmark');
+  }
+
+  setup(async () => {
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    bookmarksApi = new TestBookmarksApiProxy();
+    bookmarksApi.setFolders(JSON.parse(JSON.stringify(folders)));
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    const shoppingListApi = new TestShoppingListApiProxy();
+    ShoppingListApiProxyImpl.setInstance(shoppingListApi);
+
+    bookmarksList = document.createElement('bookmarks-list');
+    document.body.appendChild(bookmarksList);
+    await flushTasks();
+  });
+
+  test('MovesFocusBetweenFolders', () => {
+    const folderElements = getFolderElements(bookmarksList);
+
+    function assertActiveElement(index: number) {
+      assertEquals(
+          folderElements[index], bookmarksList.shadowRoot!.activeElement);
+    }
+
+    // Move focus to the first folder.
+    folderElements[0]!.moveFocus(1);
+    assertActiveElement(0);
+
+    // One ArrowDown key should still keep focus in the first folder since the
+    // folder has children.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(0);
+
+    // Two ArrowsDown to eventually make it to the second folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(1);
+
+    // One ArrowsDown to eventually make it to the third folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(2);
+
+    // One ArrowsDown to loop back to the first folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowDown');
+    assertActiveElement(0);
+
+    // One ArrowUp to loop back to the last folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowUp');
+    assertActiveElement(2);
+
+    // One ArrowUp to loop back to the second folder.
+    keyDownOn(bookmarksList, 0, [], 'ArrowUp');
+    assertActiveElement(1);
+  });
+
+  test('CutsCopyPastesBookmark', async () => {
+    const folderElement = getFolderElements(bookmarksList)[0]!;
+    const bookmarkElement = getBookmarkElements(folderElement)[0]!;
+
+    // Hide focus states and focus.
+    FocusOutlineManager.forDocument(document).visible = false;
+    bookmarkElement.focus();
+    assertEquals(bookmarkElement, folderElement.shadowRoot!.activeElement);
+
+    // When focus is hidden, keyboard shortcuts should not be allowed.
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'x');
+    assertEquals(0, bookmarksApi.getCallCount('cutBookmark'));
+
+    // Show focus states, which should allow keyboard shortcuts.
+    FocusOutlineManager.forDocument(document).visible = true;
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'x');
+    const cutId = await bookmarksApi.whenCalled('cutBookmark');
+    assertEquals(1, bookmarksApi.getCallCount('cutBookmark'));
+    assertEquals('3', cutId);
+
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'c');
+    const copiedId = await bookmarksApi.whenCalled('copyBookmark');
+    assertEquals('3', copiedId);
+
+    keyDownOn(bookmarkElement, 0, ['ctrl'], 'v');
+    const [pastedId, pastedDestinationId] =
+        await bookmarksApi.whenCalled('pasteToBookmark');
+    assertEquals('0', pastedId);
+    assertEquals('3', pastedDestinationId);
+  });
+
+  test('ShowsFocusStateOnDrop', () => {
+    const focusOutlineManager = FocusOutlineManager.forDocument(document);
+
+    // Mousedown to hide focus state initially.
+    down(bookmarksList, {x: 0, y: 0});
+    assertFalse(focusOutlineManager.visible);
+
+    // Perform a drop and assert that focus state is visible.
+    bookmarksList.onFinishDrop([folders[0]!.children![0]!]);
+    assertTrue(focusOutlineManager.visible);
+
+    // Make sure on the next mouse event, the focus state gets rehidden.
+    down(bookmarksList, {x: 0, y: 0});
+    assertFalse(focusOutlineManager.visible);
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_test.ts b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_test.ts
new file mode 100644
index 0000000000000..400ca60d35ed8
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/bookmarks_list_test.ts
@@ -0,0 +1,319 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+
+import {BookmarkFolderElement, FOLDER_OPEN_CHANGED_EVENT} from 'chrome://bookmarks-side-panel.top-chrome/bookmark_folder.js';
+import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
+import {BookmarksListElement, LOCAL_STORAGE_OPEN_FOLDERS_KEY} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
+import {ShoppingListApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/shared/commerce/shopping_list_api_proxy.js';
+import {BookmarkProductInfo} from 'chrome://bookmarks-side-panel.top-chrome/shared/shopping_list.mojom-webui.js';
+import {flush} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+import {assertEquals, assertTrue} from 'chrome://webui-test/chai_assert.js';
+import {fakeMetricsPrivate, MetricsTracker} from 'chrome://webui-test/metrics_test_support.js';
+import {flushTasks} from 'chrome://webui-test/polymer_test_util.js';
+import {isVisible} from 'chrome://webui-test/test_util.js';
+
+import {TestShoppingListApiProxy} from './commerce/test_shopping_list_api_proxy.js';
+import {TestBookmarksApiProxy} from './test_bookmarks_api_proxy.js';
+
+suite('SidePanelBookmarksListTest', () => {
+  let bookmarksList: BookmarksListElement;
+  let bookmarksApi: TestBookmarksApiProxy;
+  let shoppingListApi: TestShoppingListApiProxy;
+  let metrics: MetricsTracker;
+
+  const folders: chrome.bookmarks.BookmarkTreeNode[] = [
+    {
+      id: '0',
+      parentId: 'root',
+      title: 'Bookmarks bar',
+      children: [
+        {
+          id: '3',
+          parentId: '0',
+          title: 'Child bookmark',
+          url: 'http://child/bookmark/',
+        },
+        {
+          id: '4',
+          parentId: '0',
+          title: 'Child folder',
+          children: [
+            {
+              id: '5',
+              parentId: '4',
+              title: 'Nested bookmark',
+              url: 'http://nested/bookmark/',
+            },
+          ],
+        },
+      ],
+    },
+    {
+      id: '1',
+      parentId: 'root',
+      title: 'Other bookmarks',
+      children: [],
+    },
+    {
+      id: '2',
+      title: 'Mobile bookmarks',
+      children: [],
+    },
+  ];
+
+  const products: BookmarkProductInfo[] = [{
+    bookmarkId: BigInt(3),
+    info: {
+      title: 'Product Foo',
+      clusterTitle: 'Product Cluster Foo',
+      domain: 'foo.com',
+      imageUrl: {url: 'https://foo.com/image'},
+      productUrl: {url: 'https://foo.com/product'},
+      currentPrice: '$12',
+      previousPrice: '$34',
+      clusterId: BigInt(12345),
+    },
+  }];
+
+  function getFolderElements(root: HTMLElement): BookmarkFolderElement[] {
+    return Array.from(root.shadowRoot!.querySelectorAll('bookmark-folder'));
+  }
+
+  function getBookmarkElements(root: HTMLElement): HTMLElement[] {
+    return Array.from(root.shadowRoot!.querySelectorAll('.bookmark'));
+  }
+
+  function checkShoppingListVisibility(
+      root: HTMLElement, visible: boolean): void {
+    const shoppingListElement = root.shadowRoot!.getElementById('shoppingList');
+    const dividerElement =
+        root.shadowRoot!.querySelector<HTMLElement>('.divider');
+
+    assertEquals(visible, isVisible(shoppingListElement));
+    assertEquals(visible, isVisible(dividerElement));
+  }
+
+  setup(async () => {
+    window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY] = undefined;
+    document.body.innerHTML = window.trustedTypes!.emptyHTML;
+
+    metrics = fakeMetricsPrivate();
+
+    bookmarksApi = new TestBookmarksApiProxy();
+    bookmarksApi.setFolders(JSON.parse(JSON.stringify(folders)));
+    BookmarksApiProxyImpl.setInstance(bookmarksApi);
+
+    shoppingListApi = new TestShoppingListApiProxy();
+    shoppingListApi.setProducts(products);
+    ShoppingListApiProxyImpl.setInstance(shoppingListApi);
+
+    bookmarksList = document.createElement('bookmarks-list');
+    document.body.appendChild(bookmarksList);
+
+    await flushTasks();
+  });
+
+  test('GetsAndShowsFolders', () => {
+    assertEquals(1, bookmarksApi.getCallCount('getFolders'));
+    assertEquals(folders.length, getFolderElements(bookmarksList).length);
+  });
+
+  test('UpdatesChangedBookmarks', () => {
+    const rootFolderIndex = 0;
+    const bookmarkIndex = 0;
+
+    const changedBookmark = folders[rootFolderIndex]!.children![bookmarkIndex]!;
+    bookmarksApi.callbackRouter.onChanged.callListeners(changedBookmark.id, {
+      title: 'New title',
+      url: 'http://new/url',
+    });
+
+    const folderElement = getFolderElements(bookmarksList)[rootFolderIndex] as
+        BookmarkFolderElement;
+    const bookmarkElement = getBookmarkElements(folderElement)[bookmarkIndex]!;
+    assertEquals('New title', bookmarkElement.textContent);
+  });
+
+  test('UpdatesReorderedChildren', () => {
+    // Reverse the children of Bookmarks bar.
+    const children = folders[0]!.children!;
+    const reverseOrder = children.map(child => child.id).reverse();
+    bookmarksApi.callbackRouter.onChildrenReordered.callListeners(
+        folders[0]!.id, {childIds: reverseOrder});
+    flush();
+
+    const rootFolderElement = getFolderElements(bookmarksList)[0]!;
+    const childFolder = getFolderElements(rootFolderElement)[0]!;
+    const childBookmark = getBookmarkElements(rootFolderElement)[0]!;
+    assertTrue(
+        !!(childFolder.compareDocumentPosition(childBookmark) &
+           Node.DOCUMENT_POSITION_FOLLOWING));
+  });
+
+  test('AddsCreatedBookmark', async () => {
+    bookmarksApi.callbackRouter.onCreated.callListeners('999', {
+      id: '999',
+      title: 'New bookmark',
+      index: 0,
+      parentId: '4',
+      url: '//new/bookmark',
+    });
+    flush();
+
+    const rootFolderElement = getFolderElements(bookmarksList)[0]!;
+    const childFolder = getFolderElements(rootFolderElement)[0]!;
+    childFolder.shadowRoot!.querySelector<HTMLElement>(
+                               '.row')!.click();  // Open folder.
+    await flushTasks();
+    const childFolderBookmarks = getBookmarkElements(childFolder);
+    assertEquals(2, childFolderBookmarks.length);
+    assertEquals('New bookmark', childFolderBookmarks[0]!.textContent);
+  });
+
+  test('AddsCreatedBookmarkForNewFolder', () => {
+    // Create a new folder without a children array.
+    bookmarksApi.callbackRouter.onCreated.callListeners('1000', {
+      id: '1000',
+      title: 'New folder',
+      index: 0,
+      parentId: '0',
+    });
+    flush();
+
+    // Create a new bookmark within that folder.
+    bookmarksApi.callbackRouter.onCreated.callListeners('1001', {
+      id: '1001',
+      title: 'New bookmark in new folder',
+      index: 0,
+      parentId: '1000',
+      url: 'http://google.com',
+    });
+    flush();
+
+    const rootFolderElement = getFolderElements(bookmarksList)[0]!;
+    const newFolder = getFolderElements(rootFolderElement)[0]!;
+    assertEquals(1, newFolder.folder.children!.length);
+  });
+
+  test('MovesBookmarks', () => {
+    const movedBookmark = folders[0]!.children![1]!.children![0]!;
+    bookmarksApi.callbackRouter.onMoved.callListeners(movedBookmark.id, {
+      index: 0,
+      parentId: folders[0]!.id,                   // Moving to bookmarks bar.
+      oldParentId: folders[0]!.children![1]!.id,  // Moving from child folder.
+      oldIndex: 0,
+    });
+    flush();
+
+    const bookmarksBarFolder = getFolderElements(bookmarksList)[0]!;
+    const movedBookmarkElement = getBookmarkElements(bookmarksBarFolder)[0]!;
+    assertEquals('Nested bookmark', movedBookmarkElement.textContent);
+
+    const childFolder = getFolderElements(bookmarksBarFolder)[0]!;
+    const childFolderBookmarks = getBookmarkElements(childFolder);
+    assertEquals(0, childFolderBookmarks.length);
+  });
+
+  test('MovesBookmarksIntoNewFolder', () => {
+    // Create a new folder without a children array.
+    bookmarksApi.callbackRouter.onCreated.callListeners('1000', {
+      id: '1000',
+      title: 'New folder',
+      index: 0,
+      parentId: '0',
+    });
+    flush();
+
+    const movedBookmark = folders[0]!.children![1]!.children![0]!;
+    bookmarksApi.callbackRouter.onMoved.callListeners(movedBookmark.id, {
+      index: 0,
+      parentId: '1000',
+      oldParentId: folders[0]!.children![1]!.id,
+      oldIndex: 0,
+    });
+    flush();
+
+    const bookmarksBarFolder = getFolderElements(bookmarksList)[0]!;
+    const newFolder = getFolderElements(bookmarksBarFolder)[0]!;
+    assertEquals(1, newFolder.folder.children!.length);
+  });
+
+  test('DefaultsToFirstFolderBeingOpen', () => {
+    assertEquals(
+        JSON.stringify([folders[0]!.id]),
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY]);
+  });
+
+  test('UpdatesLocalStorageOnFolderOpenChanged', () => {
+    bookmarksList.dispatchEvent(new CustomEvent(FOLDER_OPEN_CHANGED_EVENT, {
+      bubbles: true,
+      composed: true,
+      detail: {
+        id: folders[0]!.id,
+        open: false,
+      },
+    }));
+    assertEquals(
+        JSON.stringify([]),
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY]);
+
+    bookmarksList.dispatchEvent(new CustomEvent(FOLDER_OPEN_CHANGED_EVENT, {
+      bubbles: true,
+      composed: true,
+      detail: {
+        id: '5001',
+        open: true,
+      },
+    }));
+    assertEquals(
+        JSON.stringify(['5001']),
+        window.localStorage[LOCAL_STORAGE_OPEN_FOLDERS_KEY]);
+  });
+
+  test('ShoppingListVisibility', async () => {
+    checkShoppingListVisibility(bookmarksList, true);
+    assertEquals(
+        1,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+
+    shoppingListApi.setProducts([]);
+    const newbookmarksList = document.createElement('bookmarks-list');
+    document.body.appendChild(newbookmarksList);
+
+    checkShoppingListVisibility(newbookmarksList, false);
+    assertEquals(
+        1,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+
+    shoppingListApi.getCallbackRouterRemote().priceTrackedForBookmark(
+        products[0]!);
+    await flushTasks();
+    checkShoppingListVisibility(newbookmarksList, true);
+    assertEquals(
+        2,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+
+    shoppingListApi.getCallbackRouterRemote().priceUntrackedForBookmark(
+        products[0]!);
+    await flushTasks();
+    checkShoppingListVisibility(newbookmarksList, false);
+    assertEquals(
+        2,
+        metrics.count('Commerce.PriceTracking.SidePanel.TrackedProductsShown'));
+  });
+
+  test('RemovesBookmarksInShoppingList', async () => {
+    checkShoppingListVisibility(bookmarksList, true);
+
+    bookmarksApi.callbackRouter.onRemoved.callListeners('4');
+    flush();
+    checkShoppingListVisibility(bookmarksList, true);
+
+    bookmarksApi.callbackRouter.onRemoved.callListeners('3');
+    flush();
+    checkShoppingListVisibility(bookmarksList, false);
+  });
+});
diff --git a/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts b/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts
index 8810a38c7aa30..3891e6fba6ed2 100644
--- a/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts
+++ b/chrome/test/data/webui/side_panel/bookmarks/commerce/shopping_list_test.ts
@@ -3,7 +3,7 @@
 // found in the LICENSE file.
 
 import 'chrome://bookmarks-side-panel.top-chrome/commerce/shopping_list.js';
-import 'chrome://bookmarks-side-panel.top-chrome/power_bookmarks_list.js';
+import 'chrome://bookmarks-side-panel.top-chrome/bookmarks_list.js';
 
 import {ActionSource} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks.mojom-webui.js';
 import {BookmarksApiProxyImpl} from 'chrome://bookmarks-side-panel.top-chrome/bookmarks_api_proxy.js';
diff --git a/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc
index 56a720efad282..7da20843509fd 100644
--- a/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc
+++ b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_browsertest.cc
@@ -15,6 +15,18 @@ class SidePanelBookmarksTest : public WebUIMochaBrowserTest {
   }
 };
 
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksTest, List) {
+  RunTest("side_panel/bookmarks/bookmarks_list_test.js", "mocha.run()");
+}
+
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksTest, DragManager) {
+  RunTest("side_panel/bookmarks/bookmarks_drag_manager_test.js", "mocha.run()");
+}
+
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksTest, BookmarkFolder) {
+  RunTest("side_panel/bookmarks/bookmark_folder_test.js", "mocha.run()");
+}
+
 // TODO(crbug.com/1396268): Flaky on Mac and Linux dbg. Re-enable this test.
 #if BUILDFLAG(IS_MAC) || (BUILDFLAG(IS_LINUX) && !defined(NDEBUG))
 #define MAYBE_ShoppingList DISABLED_ShoppingList
diff --git a/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_focus_test.cc b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_focus_test.cc
new file mode 100644
index 0000000000000..deb0258397bf1
--- /dev/null
+++ b/chrome/test/data/webui/side_panel/bookmarks/sp_bookmarks_focus_test.cc
@@ -0,0 +1,13 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/common/webui_url_constants.h"
+#include "chrome/test/base/web_ui_mocha_browser_test.h"
+#include "content/public/test/browser_test.h"
+
+using SidePanelBookmarksFocusTest = WebUIMochaFocusTest;
+IN_PROC_BROWSER_TEST_F(SidePanelBookmarksFocusTest, List) {
+  set_test_loader_host(chrome::kChromeUIBookmarksSidePanelHost);
+  RunTest("side_panel/bookmarks/bookmarks_list_focus_test.js", "mocha.run()");
+}
diff --git a/chrome/updater/net/network_fetcher_win.cc b/chrome/updater/net/network_fetcher_win.cc
index 102ff03867ebc..dc6c1d31f037a 100644
--- a/chrome/updater/net/network_fetcher_win.cc
+++ b/chrome/updater/net/network_fetcher_win.cc
@@ -21,10 +21,12 @@
 #include "base/sequence_checker.h"
 #include "base/strings/sys_string_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "chrome/updater/net/network.h"
 #include "chrome/updater/policy/service.h"
 #include "chrome/updater/util/util.h"
 #include "chrome/updater/util/win_util.h"
+#include "chrome/updater/win/scoped_impersonation.h"
 #include "chrome/updater/win/user_info.h"
 #include "components/update_client/network.h"
 #include "components/winhttp/proxy_configuration.h"
@@ -34,6 +36,56 @@
 namespace updater {
 namespace {
 
+	std::wstring FromCharOrEmpty(const wchar_t* str) {
+  return str ? std::wstring(str) : std::wstring();
+}
+
+// Wrapper for WINHTTP_CURRENT_USER_IE_PROXY_CONFIG structure.
+// According to MSDN, callers must free strings with GlobalFree.
+class ScopedIeProxyConfig {
+ public:
+  ScopedIeProxyConfig();
+  ScopedIeProxyConfig(const ScopedIeProxyConfig&) = delete;
+  ScopedIeProxyConfig& operator=(const ScopedIeProxyConfig&) = delete;
+  ~ScopedIeProxyConfig();
+
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* receive() { return &ie_proxy_config_; }
+
+  bool auto_detect() const { return ie_proxy_config_.fAutoDetect; }
+  std::wstring auto_config_url() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszAutoConfigUrl);
+  }
+  std::wstring proxy() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxy);
+  }
+  std::wstring proxy_bypass() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxyBypass);
+  }
+
+ private:
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG ie_proxy_config_ = {};
+};
+
+ScopedIeProxyConfig::ScopedIeProxyConfig() {
+  ie_proxy_config_.fAutoDetect = false;
+  ie_proxy_config_.lpszAutoConfigUrl = nullptr;
+  ie_proxy_config_.lpszProxy = nullptr;
+  ie_proxy_config_.lpszProxyBypass = nullptr;
+}
+
+ScopedIeProxyConfig::~ScopedIeProxyConfig() {
+  if (ie_proxy_config_.lpszAutoConfigUrl)
+    ::GlobalFree(ie_proxy_config_.lpszAutoConfigUrl);
+
+  if (ie_proxy_config_.lpszProxy)
+    ::GlobalFree(ie_proxy_config_.lpszProxy);
+
+  if (ie_proxy_config_.lpszProxyBypass)
+    ::GlobalFree(ie_proxy_config_.lpszProxyBypass);
+}
+
+
+
 // Factory method for the proxy configuration strategy.
 scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
     std::optional<PolicyServiceProxyConfiguration>
@@ -50,7 +102,32 @@ scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
 
   VLOG(1) << "Using the system configuration for proxy.";
 
-  return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+   const base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  const bool supports_automatic_proxy =
+      os_info->version() >= base::win::Version::WIN8_1;
+  if (supports_automatic_proxy) {
+    return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+  }
+
+  ScopedImpersonation impersonate_user;
+  if (IsLocalSystemUser()) {
+    VLOG(2) << "Running as SYSTEM, impersonate the current user.";
+    base::win::ScopedHandle user_token = GetUserTokenFromCurrentSessionId();
+    if (user_token.IsValid()) {
+      impersonate_user.Impersonate(user_token.Get());
+    }
+  }
+
+  ScopedIeProxyConfig ie_proxy_config;
+  if (::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config.receive())) {
+    return base::MakeRefCounted<winhttp::ProxyConfiguration>(winhttp::ProxyInfo{
+        ie_proxy_config.auto_detect(), ie_proxy_config.auto_config_url(),
+        ie_proxy_config.proxy(), ie_proxy_config.proxy_bypass()});
+  } else {
+    PLOG(ERROR) << "Failed to get proxy for current user";
+  }
+
+  return base::MakeRefCounted<winhttp::ProxyConfiguration>();
 }
 
 class NetworkFetcher : public update_client::NetworkFetcher {
diff --git a/chrome/updater/win/installer/installer.cc b/chrome/updater/win/installer/installer.cc
index 0cb917e3c840b..2ef47f76f238b 100644
--- a/chrome/updater/win/installer/installer.cc
+++ b/chrome/updater/win/installer/installer.cc
@@ -324,7 +324,7 @@ ProcessExitResult InstallerMain(HMODULE module) {
   CHECK(EnableSecureDllLoading());
   EnableProcessHeapMetadataProtection();
 
-  if (base::win::GetVersion() < base::win::Version::WIN10) {
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
     return ProcessExitResult(UNSUPPORTED_WINDOWS_VERSION);
   }
 
diff --git a/components/browsing_data/core/features.cc b/components/browsing_data/core/features.cc
index 6060759c7da9a..2c45c8a526a49 100644
--- a/components/browsing_data/core/features.cc
+++ b/components/browsing_data/core/features.cc
@@ -7,6 +7,8 @@
 #include "build/build_config.h"
 
 namespace browsing_data::features {
+BASE_FEATURE(kClearDataOnExit, "ClearDataOnExit", base::FEATURE_DISABLED_BY_DEFAULT);
+
 BASE_FEATURE(kEnableBrowsingDataLifetimeManager,
              "BrowsingDataLifetimeManager",
              base::FEATURE_ENABLED_BY_DEFAULT);
diff --git a/components/browsing_data/core/features.h b/components/browsing_data/core/features.h
index 9877fd49ac0af..43f3d14a937d4 100644
--- a/components/browsing_data/core/features.h
+++ b/components/browsing_data/core/features.h
@@ -8,6 +8,7 @@
 #include "base/feature_list.h"
 
 namespace browsing_data::features {
+BASE_DECLARE_FEATURE(kClearDataOnExit);
 
 // Enable BrowsingDataLifetimeManager that periodically delete browsing data as
 // defined by the BrowsingDataLifetime policy.
diff --git a/components/components_chromium_strings.grd b/components/components_chromium_strings.grd
index 1bb22e041c9db..9d07a665aad93 100644
--- a/components/components_chromium_strings.grd
+++ b/components/components_chromium_strings.grd
@@ -22,7 +22,7 @@
     <output filename="components_chromium_strings_de.pak" type="data_package" lang="de" />
     <output filename="components_chromium_strings_el.pak" type="data_package" lang="el" />
     <output filename="components_chromium_strings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="components_chromium_strings_en-US.pak" type="data_package" lang="en" />
+    <output filename="components_chromium_strings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="components_chromium_strings_es.pak" type="data_package" lang="es" />
     <if expr="is_ios">
       <!-- iOS uses es-MX for es-419 -->
diff --git a/components/components_locale_settings.grd b/components/components_locale_settings.grd
index 8a13525fd218f..cb316b0023a37 100644
--- a/components/components_locale_settings.grd
+++ b/components/components_locale_settings.grd
@@ -20,7 +20,7 @@
     <output filename="components_locale_settings_de.pak" type="data_package" lang="de" />
     <output filename="components_locale_settings_el.pak" type="data_package" lang="el" />
     <output filename="components_locale_settings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="components_locale_settings_en-US.pak" type="data_package" lang="en" />
+    <output filename="components_locale_settings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="components_locale_settings_es.pak" type="data_package" lang="es" />
     <if expr="is_ios">
       <then>
diff --git a/components/components_strings.grd b/components/components_strings.grd
index 1f9eba905658c..6359976ed21ef 100644
--- a/components/components_strings.grd
+++ b/components/components_strings.grd
@@ -22,7 +22,7 @@
     <output filename="components_strings_de.pak" type="data_package" lang="de" />
     <output filename="components_strings_el.pak" type="data_package" lang="el" />
     <output filename="components_strings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="components_strings_en-US.pak" type="data_package" lang="en" />
+    <output filename="components_strings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="components_strings_es.pak" type="data_package" lang="es" />
     <if expr="is_ios">
       <!-- iOS uses es-MX for es-419 -->
diff --git a/components/crash/core/app/crashpad.cc b/components/crash/core/app/crashpad.cc
index 9ea9021f16006..bc737d6b77bde 100644
--- a/components/crash/core/app/crashpad.cc
+++ b/components/crash/core/app/crashpad.cc
@@ -249,7 +249,6 @@ void SetUploadConsent(bool consent) {
     // if consent is present.
     enable_uploads = consent && !crash_reporter_client->IsRunningUnattended();
   }
-
   crashpad::Settings* settings = g_database->GetSettings();
   settings->SetUploadsEnabled(enable_uploads &&
                               crash_reporter_client->GetCollectStatsInSample());
diff --git a/components/download/internal/common/base_file_win.cc b/components/download/internal/common/base_file_win.cc
index 1db03ae8852aa..4de26908df8bc 100644
--- a/components/download/internal/common/base_file_win.cc
+++ b/components/download/internal/common/base_file_win.cc
@@ -14,6 +14,7 @@
 
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/com_init_util.h"
+#include "base/win/windows_version.h"
 #include "components/download/public/common/download_interrupt_reasons_utils.h"
 #include "components/download/public/common/download_stats.h"
 
@@ -142,6 +143,212 @@ DownloadInterruptReason HRESULTToDownloadInterruptReason(HRESULT hr) {
   return DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
 }
 
+// Maps the result of a call to |SHFileOperation()| onto a
+// |DownloadInterruptReason|.
+//
+// These return codes are *old* (as in, DOS era), and specific to
+// |SHFileOperation()|.
+// They do not appear in any windows header.
+//
+// See http://msdn.microsoft.com/en-us/library/bb762164(VS.85).aspx.
+DownloadInterruptReason MapShFileOperationCodes(int code) {
+  DownloadInterruptReason result = DOWNLOAD_INTERRUPT_REASON_NONE;
+
+  // Check these pre-Win32 error codes first, then check for matches
+  // in Winerror.h.
+  // This switch statement should be kept in sync with the list of codes
+  // above.
+  switch (code) {
+    // Not a pre-Win32 error code; here so that this particular case shows up in
+    // our histograms. Unfortunately, it is used not just to signal actual
+    // ACCESS_DENIED errors, but many other errors as well. So we treat it as a
+    // transient error.
+    case ERROR_ACCESS_DENIED:  // Access is denied.
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // This isn't documented but returned from SHFileOperation. Sharing
+    // violations indicate that another process had the file open while we were
+    // trying to rename. Anti-virus is believed to be the cause of this error in
+    // the wild. Treated as a transient error on the assumption that the file
+    // will be made available for renaming at a later time.
+    case ERROR_SHARING_VIOLATION:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // This is also not a documented return value of SHFileOperation, but has
+    // been observed in the wild. We are treating it as a transient error based
+    // on the cases we have seen so far.  See http://crbug.com/368455.
+    case ERROR_INVALID_PARAMETER:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR;
+      break;
+
+    // The source and destination files are the same file.
+    // DE_SAMEFILE == 0x71
+    case 0x71:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The operation was canceled by the user, or silently canceled if the
+    // appropriate flags were supplied to SHFileOperation.
+    // DE_OPCANCELLED == 0x75
+    case 0x75:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Security settings denied access to the source.
+    // DE_ACCESSDENIEDSRC == 0x78
+    case 0x78:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source or destination path exceeded or would exceed MAX_PATH.
+    // DE_PATHTOODEEP == 0x79
+    case 0x79:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // The path in the source or destination or both was invalid.
+    // DE_INVALIDFILES == 0x7C
+    case 0x7C:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination path is an existing file.
+    // DE_FLDDESTISFILE == 0x7E
+    case 0x7E:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination path is an existing folder.
+    // DE_FILEDESTISFLD == 0x80
+    case 0x80:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The name of the file exceeds MAX_PATH.
+    // DE_FILENAMETOOLONG == 0x81
+    case 0x81:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // The destination is a read-only CD-ROM, possibly unformatted.
+    // DE_DEST_IS_CDROM == 0x82
+    case 0x82:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The destination is a read-only DVD, possibly unformatted.
+    // DE_DEST_IS_DVD == 0x83
+    case 0x83:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The destination is a writable CD-ROM, possibly unformatted.
+    // DE_DEST_IS_CDRECORD == 0x84
+    case 0x84:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The file involved in the operation is too large for the destination
+    // media or file system.
+    // DE_FILE_TOO_LARGE == 0x85
+    case 0x85:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE;
+      break;
+
+    // The source is a read-only CD-ROM, possibly unformatted.
+    // DE_SRC_IS_CDROM == 0x86
+    case 0x86:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source is a read-only DVD, possibly unformatted.
+    // DE_SRC_IS_DVD == 0x87
+    case 0x87:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // The source is a writable CD-ROM, possibly unformatted.
+    // DE_SRC_IS_CDRECORD == 0x88
+    case 0x88:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED;
+      break;
+
+    // MAX_PATH was exceeded during the operation.
+    // DE_ERROR_MAX == 0xB7
+    case 0xB7:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG;
+      break;
+
+    // An unspecified error occurred on the destination.
+    // XE_ERRORONDEST == 0x10000
+    case 0x10000:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Multiple file paths were specified in the source buffer, but only one
+    // destination file path.
+    // DE_MANYSRC1DEST == 0x72
+    case 0x72:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Rename operation was specified but the destination path is
+    // a different directory. Use the move operation instead.
+    // DE_DIFFDIR == 0x73
+    case 0x73:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The source is a root directory, which cannot be moved or renamed.
+    // DE_ROOTDIR == 0x74
+    case 0x74:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The destination is a subtree of the source.
+    // DE_DESTSUBTREE == 0x76
+    case 0x76:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The operation involved multiple destination paths,
+    // which can fail in the case of a move operation.
+    // DE_MANYDEST == 0x7A
+    case 0x7A:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // The source and destination have the same parent folder.
+    // DE_DESTSAMETREE == 0x7D
+    case 0x7D:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // An unknown error occurred.  This is typically due to an invalid path in
+    // the source or destination.  This error does not occur on Windows Vista
+    // and later.
+    // DE_UNKNOWN_ERROR == 0x402
+    case 0x402:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+
+    // Destination is a root directory and cannot be renamed.
+    // DE_ROOTDIR | ERRORONDEST == 0x10074
+    case 0x10074:
+      result = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+      break;
+  }
+
+  if (result != DOWNLOAD_INTERRUPT_REASON_NONE)
+    return result;
+
+  // If not one of the above codes, it should be a standard Windows error code.
+  return ConvertFileErrorToInterruptReason(
+      base::File::OSErrorToFileError(code));
+}
+
 class FileOperationProgressSink
     : public Microsoft::WRL::RuntimeClass<
           Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom>,
@@ -244,6 +451,35 @@ DownloadInterruptReason BaseFile::MoveFileAndAdjustPermissions(
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
+	  // The parameters to SHFileOperation must be terminated with 2 NULL chars.
+	  base::FilePath::StringType source = full_path_.value();
+	  base::FilePath::StringType target = new_path.value();
+
+	  source.append(1, L'\0');
+	  target.append(1, L'\0');
+
+	  SHFILEOPSTRUCT move_info = {nullptr};
+	  move_info.wFunc = FO_MOVE;
+	  move_info.pFrom = source.c_str();
+	  move_info.pTo = target.c_str();
+	  move_info.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOERRORUI |
+						 FOF_NOCONFIRMMKDIR | FOF_NOCOPYSECURITYATTRIBS;
+
+	  int result = SHFileOperation(&move_info);
+	  DownloadInterruptReason interrupt_reason = DOWNLOAD_INTERRUPT_REASON_NONE;
+
+	  if (result == 0 && move_info.fAnyOperationsAborted)
+		interrupt_reason = DOWNLOAD_INTERRUPT_REASON_FILE_FAILED;
+	  else if (result != 0)
+		interrupt_reason = MapShFileOperationCodes(result);
+
+	  if (interrupt_reason != DOWNLOAD_INTERRUPT_REASON_NONE)
+		return LogInterruptReason("SHFileOperation", result, interrupt_reason);
+
+	  return interrupt_reason;
+  }
+
   base::win::AssertComInitialized();
   Microsoft::WRL::ComPtr<IShellItem> original_path;
   HRESULT hr = SHCreateItemFromParsingName(full_path_.value().c_str(), nullptr,
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index 44cf15e1b4703..5dfe3eaee5ba0 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -88,13 +88,45 @@ int GetPreRS5UniversalApiContractVersion() {
     return 6;
   }
   // The list above should account for all Windows versions prior to
-  // RS5.
-  NOTREACHED();
+  // RS5. 0 represents all pre-Win10 releases.
   return 0;
 }
 
+int GetLegacyWindowsVersion() {
+// The User Agent Client Hints specification indicates that Windows 7 through 8.x
+// should be handled as having a major version of 0 while using the OS' minor version.
+// (i.e. Windows 7 is 0.1). This does not account for how to handle Windows Vista and below.
+// As a result, Vista will report as 0.60 and NT 5.x as 0.5x.
+// TODO: introduce UA-CH spoofer to avoid any undesirable impacts of having the "wrong" values in future.
+	const base::win::Version version = base::win::OSInfo::Kernel32Version();
+	if (version == base::win::Version::WIN8_1) {
+		return 3;
+	}
+	if (version == base::win::Version::WIN8) {
+		return 2;
+	}
+	if (version == base::win::Version::WIN7) {
+		return 1;
+	}
+	if (version == base::win::Version::VISTA) {
+		return 60;
+	}
+	if (version == base::win::Version::SERVER_2003) {
+		return 52;
+	}
+	if (version == base::win::Version::XP) {
+		return 51;
+	}
+	if (version == base::win::Version::PRE_XP) {
+		return 50;
+	}
+	return 0;
+}
+
 // Returns the UniversalApiContract version number, which is available for
-// Windows versions greater than RS5. Otherwise, returns 0.
+// Windows versions greater than RS5. Otherwise, returns a version value
+// representing the Windows version (non-zero major version for early Windows 10,
+// non-zero minor version for pre-Windows 10).
 const std::string& GetUniversalApiContractVersion() {
   // Do not use this for runtime environment detection logic. This method should
   // only be used to help populate the Sec-CH-UA-Platform client hint. If
@@ -108,6 +140,7 @@ const std::string& GetUniversalApiContractVersion() {
         if (base::win::OSInfo::Kernel32Version() <=
             base::win::Version::WIN10_RS4) {
           major_version = GetPreRS5UniversalApiContractVersion();
+		  minor_version = GetLegacyWindowsVersion();
         } else {
           base::win::RegKey version_key(
               HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
diff --git a/components/metrics/motherboard.cc b/components/metrics/motherboard.cc
index 4b2270d10a86d..e97bde5ddf5d1 100644
--- a/components/metrics/motherboard.cc
+++ b/components/metrics/motherboard.cc
@@ -16,6 +16,7 @@
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
 
+#include "base/scoped_native_library.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/scoped_bstr.h"
@@ -142,7 +143,19 @@ void ReadWin32Bios(const ComPtr<IWbemServices>& services,
 
 void ReadFirmwareType(absl::optional<Motherboard::BiosType>* bios_type) {
   FIRMWARE_TYPE firmware_type = FirmwareTypeUnknown;
-  if (::GetFirmwareType(&firmware_type)) {
+  // NOTE: GetFirmwareType API only exists on >= Win8.  Dynamically
+  //       get function handle.
+  using GetFirmwareTypeFunction = decltype(&GetFirmwareType);
+  base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+  if (!dll.is_valid())
+    return;
+  GetFirmwareTypeFunction get_firmware_type_function =
+      reinterpret_cast<GetFirmwareTypeFunction>(
+          dll.GetFunctionPointer("GetFirmwareType"));
+  if (!get_firmware_type_function)
+    return;
+
+  if (get_firmware_type_function(&firmware_type)) {
     if (firmware_type == FirmwareTypeBios) {
       *bios_type = Motherboard::BiosType::kLegacy;
     } else if (firmware_type == FirmwareTypeUefi) {
diff --git a/components/network_time/network_time_tracker.cc b/components/network_time/network_time_tracker.cc
index b104ce71c069c..22a8f75fa69ca 100644
--- a/components/network_time/network_time_tracker.cc
+++ b/components/network_time/network_time_tracker.cc
@@ -271,7 +271,7 @@ void NetworkTimeTracker::UpdateNetworkTime(base::Time network_time,
 }
 
 bool NetworkTimeTracker::AreTimeFetchesEnabled() const {
-  return base::FeatureList::IsEnabled(kNetworkTimeServiceQuerying);
+  return false;
 }
 
 NetworkTimeTracker::FetchBehavior NetworkTimeTracker::GetFetchBehavior() const {
diff --git a/components/omnibox/browser/autocomplete_controller.cc b/components/omnibox/browser/autocomplete_controller.cc
index bb091060cf93e..73210ab0662f4 100644
--- a/components/omnibox/browser/autocomplete_controller.cc
+++ b/components/omnibox/browser/autocomplete_controller.cc
@@ -19,6 +19,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/feature_list.h"
 #include "base/format_macros.h"
@@ -394,6 +395,15 @@ AutocompleteController::AutocompleteController(
           metrics::OmniboxEventProto::UNKNOWN_POSITION) {
   provider_types &= ~OmniboxFieldTrial::GetDisabledProviderTypes();
 
+if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering")) {
+    const std::string flag_value = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("omnibox-autocomplete-filtering");
+    provider_types &= AutocompleteProvider::TYPE_KEYWORD | AutocompleteProvider::TYPE_SEARCH |
+        AutocompleteProvider::TYPE_HISTORY_URL | AutocompleteProvider::TYPE_BOOKMARK | AutocompleteProvider::TYPE_BUILTIN;
+    if (!base::Contains(flag_value, "bookmarks"))
+      provider_types &= ~AutocompleteProvider::TYPE_BOOKMARK;
+    if (!base::Contains(flag_value, "chrome"))
+      provider_types &= ~AutocompleteProvider::TYPE_BUILTIN;
+  }
   // Providers run in the order they're added. Async providers should run first
   // so their async requests can be kicked off before waiting a few milliseconds
   // for the other sync providers to complete.
diff --git a/components/omnibox/browser/history_url_provider.cc b/components/omnibox/browser/history_url_provider.cc
index 83f8b0fb22983..75eaea36b134a 100644
--- a/components/omnibox/browser/history_url_provider.cc
+++ b/components/omnibox/browser/history_url_provider.cc
@@ -479,6 +479,8 @@ void HistoryURLProvider::Start(const AutocompleteInput& input,
   if (fixed_up_input.type() != metrics::OmniboxInputType::QUERY)
     matches_.push_back(what_you_typed_match);
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering"))
+    return;
   // We'll need the history service to run both passes, so try to obtain it.
   history::HistoryService* const history_service =
       client()->GetHistoryService();
diff --git a/components/omnibox/browser/search_provider.cc b/components/omnibox/browser/search_provider.cc
index 9ef95f00eaacc..11378f7e96981 100644
--- a/components/omnibox/browser/search_provider.cc
+++ b/components/omnibox/browser/search_provider.cc
@@ -10,6 +10,7 @@
 #include <utility>
 
 #include "base/base64.h"
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
@@ -645,6 +646,8 @@ void SearchProvider::Run(bool query_is_private) {
 void SearchProvider::DoHistoryQuery(bool minimal_changes) {
   // The history query results are synchronous, so if minimal_changes is true,
   // we still have the last results and don't need to do anything.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering"))
+    return;
   if (minimal_changes)
     return;
 
diff --git a/components/pdf/renderer/internal_plugin_renderer_helpers.cc b/components/pdf/renderer/internal_plugin_renderer_helpers.cc
index 801003e99fe39..2e1b93c427f76 100644
--- a/components/pdf/renderer/internal_plugin_renderer_helpers.cc
+++ b/components/pdf/renderer/internal_plugin_renderer_helpers.cc
@@ -29,7 +29,8 @@ namespace pdf {
 
 bool IsPdfRenderer() {
   static const bool has_switch =
-      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kPdfRenderer);
+      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kPdfRenderer) ||
+      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess);
   return has_switch;
 }
 
diff --git a/components/search_engines/template_url_service.cc b/components/search_engines/template_url_service.cc
index 48b351d2e56ad..0bd04aa016505 100644
--- a/components/search_engines/template_url_service.cc
+++ b/components/search_engines/template_url_service.cc
@@ -15,6 +15,7 @@
 #include "base/base64url.h"
 #include "base/check_deref.h"
 #include "base/check_is_test.h"
+#include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/containers/flat_map.h"
 #include "base/debug/crash_logging.h"
@@ -181,6 +182,12 @@ bool IsCreatedByExtension(const TemplateURL* template_url) {
          template_url->type() == TemplateURL::OMNIBOX_API_EXTENSION;
 }
 
+bool ShouldAutocollect() {
+  const base::CommandLine& command_line =
+    *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-search-engine-collection");
+}
+
 // Checks if `new_values` has updated versions of `existing_turl`. Only fields
 // set by the `SiteSearchSettings` policy are checked.
 bool ShouldMergeEnterpriseSiteSearchEngines(const TemplateURL& existing_turl,
@@ -389,6 +396,7 @@ TemplateURLService::TemplateURLService(
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
     )
     : prefs_(prefs),
+	  should_autocollect_(true),
       search_engine_choice_service_(search_engine_choice_service),
       search_terms_data_(std::move(search_terms_data)),
       web_data_service_(web_data_service),
@@ -520,8 +528,8 @@ bool TemplateURLService::CanAddAutogeneratedKeyword(
   // that may interfere with search queries).  An easy heuristic for this is
   // whether the user has a TemplateURL that has been manually modified (e.g.,
   // renamed) connected to the same host.
-  return !url.is_valid() || url.host().empty() ||
-      CanAddAutogeneratedKeywordForHost(url.host());
+  return should_autocollect_ && (!url.is_valid() || url.host().empty() ||
+      CanAddAutogeneratedKeywordForHost(url.host()));
 }
 
 bool TemplateURLService::IsPrepopulatedOrDefaultProviderByPolicy(
@@ -1900,6 +1908,8 @@ SyncDataMap TemplateURLService::CreateGUIDToSyncDataMap(
 }
 
 void TemplateURLService::Init() {
+  should_autocollect_ = ShouldAutocollect();
+
   if (client_)
     client_->SetOwner(this);
 
@@ -2074,6 +2084,8 @@ void TemplateURLService::ChangeToLoadedState() {
 
 bool TemplateURLService::CanAddAutogeneratedKeywordForHost(
     const std::string& host) const {
+  if (!should_autocollect_)
+    return false;
   const TemplateURLSet* urls = provider_map_->GetURLsForHost(host);
   if (!urls)
     return true;
diff --git a/components/search_engines/template_url_service.h b/components/search_engines/template_url_service.h
index e2b43ef5d67bb..52280dcd3882b 100644
--- a/components/search_engines/template_url_service.h
+++ b/components/search_engines/template_url_service.h
@@ -878,6 +878,8 @@ class TemplateURLService final : public WebDataServiceConsumer,
   // ---------- Browser state related members ---------------------------------
   raw_ptr<PrefService> prefs_ = nullptr;
 
+  bool should_autocollect_; // Whether search engines should be auto-collected
+
   raw_ptr<search_engines::SearchEngineChoiceService>
       search_engine_choice_service_ = nullptr;
 
diff --git a/components/system_media_controls/win/system_media_controls_win.cc b/components/system_media_controls/win/system_media_controls_win.cc
index c932ad09c40ac..a855edb420af1 100644
--- a/components/system_media_controls/win/system_media_controls_win.cc
+++ b/components/system_media_controls/win/system_media_controls_win.cc
@@ -81,6 +81,11 @@ bool SystemMediaControlsWin::Initialize() {
 
   attempted_to_initialize_ = true;
 
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
   Microsoft::WRL::ComPtr<ISystemMediaTransportControlsInterop> interop;
   HRESULT hr = base::win::GetActivationFactory<
       ISystemMediaTransportControlsInterop,
diff --git a/components/url_formatter/url_fixer.cc b/components/url_formatter/url_fixer.cc
index e3aa778739688..b48a5e3c10bb7 100644
--- a/components/url_formatter/url_fixer.cc
+++ b/components/url_formatter/url_fixer.cc
@@ -7,6 +7,8 @@
 #include <stddef.h>
 
 #include "base/check_op.h"
+#include "base/containers/contains.h"
+#include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/i18n/char_iterator.h"
@@ -617,6 +619,8 @@ GURL FixupURLInternal(const std::string& text,
 
     FixupHost(trimmed, parts.host, parts.scheme.is_valid(), desired_tld, &url);
     if (chrome_url && !parts.host.is_valid())
+		if (!base::CommandLine::ForCurrentProcess()->HasSwitch("omnibox-autocomplete-filtering") ||
+			base::Contains(base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("omnibox-autocomplete-filtering"), "chrome"))
       url.append(kChromeUIDefaultHost);
     FixupPort(trimmed, parts.port, &url);
     FixupPath(trimmed, parts.path, &url);
diff --git a/components/url_formatter/url_formatter.cc b/components/url_formatter/url_formatter.cc
index 9936039f78fdd..ab7234423f134 100644
--- a/components/url_formatter/url_formatter.cc
+++ b/components/url_formatter/url_formatter.cc
@@ -9,6 +9,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/command_line.h"
 #include "base/lazy_instance.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
@@ -311,6 +312,13 @@ IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
   host16.reserve(host.length());
   host16.insert(host16.end(), host.begin(), host.end());
 
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("force-punycode-hostnames")) {
+    // Leave as punycode.
+    IDNConversionResult result;
+    result.result = host16;
+    return result;
+  }
+
   // Compute the top level domain to be used in spoof checks later.
   base::StringPiece top_level_domain;
   std::u16string top_level_domain_unicode;
diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index 6600e576a857f..6259f4a0754e9 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,6 +20,10 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,16 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
+#elif BUILDFLAG(IS_ANDROID)
+    // On Android we run a Finch experiment testing direct memory allocation.
+    config.force_direct_shared_memory_allocation = base::FeatureList::IsEnabled(
+        mojo::core::kMojoDirectSharedMemoryAndroid);
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index a460c6503d695..598067532ae00 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2848,6 +2848,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/legacy_render_widget_host_win.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 8c144725c6e54..c6c1b602562b5 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -195,6 +195,7 @@
 #include <windows.h>
 
 #include "base/threading/platform_thread_win.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
@@ -1015,6 +1016,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/compositor/viz_process_transport_factory.cc b/content/browser/compositor/viz_process_transport_factory.cc
index 516c7f65097f1..000815240587e 100644
--- a/content/browser/compositor/viz_process_transport_factory.cc
+++ b/content/browser/compositor/viz_process_transport_factory.cc
@@ -158,7 +158,6 @@ VizProcessTransportFactory::VizProcessTransportFactory(
   GetHostFrameSinkManager()->SetConnectionLostCallback(
       base::BindRepeating(&VizProcessTransportFactory::OnGpuProcessLost,
                           weak_ptr_factory_.GetWeakPtr()));
-
   if (GpuDataManagerImpl::GetInstance()->IsGpuCompositingDisabled()) {
     DisableGpuCompositing(nullptr);
   }
diff --git a/content/browser/font_access/font_enumeration_data_source_win.cc b/content/browser/font_access/font_enumeration_data_source_win.cc
index 094283551322c..01dc697c6178d 100644
--- a/content/browser/font_access/font_enumeration_data_source_win.cc
+++ b/content/browser/font_access/font_enumeration_data_source_win.cc
@@ -4,6 +4,7 @@
 
 #include "content/browser/font_access/font_enumeration_data_source_win.h"
 
+#include <Windows.h>
 #include <dwrite.h>
 #include <stdint.h>
 #include <wrl/client.h>
@@ -178,6 +179,23 @@ FontEnumerationDataSourceWin::~FontEnumerationDataSourceWin() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 }
 
+int CALLBACK EnumFontFamProc(ENUMLOGFONTA* lpelf,
+                             NEWTEXTMETRICA* lpntm,
+                             DWORD FontType,
+                             LPARAM lParam)
+{
+  blink::FontEnumerationTable* font_enumeration_table =
+      (blink::FontEnumerationTable*)lParam;
+  blink::FontEnumerationTable_FontData* data =
+      font_enumeration_table->add_fonts();
+  data->set_postscript_name(std::string());
+  data->set_full_name(std::string("Click the font name itself"));
+  data->set_family(std::string((const char*)lpelf->elfFullName));
+  data->set_style(std::string((const char*)lpelf->elfStyle));
+
+  return 1;
+}
+
 blink::FontEnumerationTable FontEnumerationDataSourceWin::GetFonts(
     const std::string& locale) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -185,6 +203,14 @@ blink::FontEnumerationTable FontEnumerationDataSourceWin::GetFonts(
   blink::FontEnumerationTable font_enumeration_table;
 
   Microsoft::WRL::ComPtr<IDWriteFontCollection> collection = GetSystemFonts();
+  if (!collection)
+  {
+    HDC hDC = ::GetDC(NULL);
+    ::EnumFontFamiliesA(hDC, NULL, (FONTENUMPROCA)EnumFontFamProc,
+                        (LPARAM) &font_enumeration_table);
+    ::ReleaseDC(NULL, hDC);
+    return font_enumeration_table;
+  }
   uint32_t family_count;
   {
     base::ScopedBlockingCall scoped_blocking_call(
diff --git a/content/browser/installedapp/installed_app_provider_impl_win.cc b/content/browser/installedapp/installed_app_provider_impl_win.cc
index 252da4a57d373..4f379ef5a3d65 100644
--- a/content/browser/installedapp/installed_app_provider_impl_win.cc
+++ b/content/browser/installedapp/installed_app_provider_impl_win.cc
@@ -112,6 +112,13 @@ void FilterInstalledAppsForWin(
     std::vector<blink::mojom::RelatedApplicationPtr> related_apps,
     blink::mojom::InstalledAppProvider::FilterInstalledAppsCallback callback,
     const GURL frame_url) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload() ||
+      !base::win::ResolveCoreWinRTDelayload()) {
+    std::move(callback).Run(std::vector<blink::mojom::RelatedApplicationPtr>());
+    return;
+  }
+
   ComPtr<ILauncherStatics4> launcher_statics;
   HRESULT hr = base::win::RoActivateInstance(
       base::win::ScopedHString::Create(RuntimeClass_Windows_System_Launcher)
diff --git a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
index 62cc6bca47934..5e47b05ee71ee 100644
--- a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
+++ b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
@@ -12,6 +12,7 @@
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox_policy.h"
@@ -33,10 +34,13 @@ bool PpapiPluginSandboxedProcessLauncherDelegate::InitializeConfig(
   // The Pepper process is as locked-down as a renderer except that it can
   // create the server side of Chrome pipes.
   sandbox::ResultCode result;
+  // We don't support PPAPI win32k lockdown prior to Windows 10.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
   result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
   if (result != sandbox::SBOX_ALL_OK) {
     return false;
   }
+  }
 
   // No plugins can generate executable code.
   sandbox::MitigationFlags flags = config->GetDelayedProcessMitigations();
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index b04194c32a4d1..d760a109ff576 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,10 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +46,9 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
@@ -173,9 +181,12 @@ void DirectManipulationHelper::OnPointerHitTest(WPARAM w_param) {
   // For WM_POINTER, the pointer type will show the event from mouse.
   // For WM_POINTERACTIVATE, the pointer id will be different with the following
   // message.
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(pointer_id, &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     viewport_->SetContact(pointer_id);
   }
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..2547e1d5e893b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,771 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  if (!collection_) {
+    return;
+  }
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (UNLIKELY(slow_down_mode_for_testing == SlowDownMode::kDelayEachTask)) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (UNLIKELY(slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask) &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..cee91dd4e059b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index 257f8480a4c49..955f34a4b2973 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -36,6 +36,9 @@
 #include "third_party/abseil-cpp/absl/utility/utility.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/ports/SkTypeface_win.h"
 #include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/text_analysis_source.h"
 
@@ -446,6 +449,40 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -542,7 +579,52 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {
+  InitializeDirectWrite();
+  callback = mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+      std::move(callback),
+      blink::mojom::FallbackFamilyAndStyle::New("",
+                                                /* weight */ 0,
+                                                /* width */ 0,
+                                                /* slant */ 0));
+
+  if (!codepoint || !collection_ || !factory_)
+    return;
+
+  sk_sp<SkFontMgr> font_mgr(
+      SkFontMgr_New_DirectWrite(factory_.Get(), collection_.Get()));
+
+  if (!font_mgr)
+    return;
+
+  const char* bcp47_locales[] = {locale_name.c_str()};
+  int num_locales = locale_name.empty() ? 0 : 1;
+  const char** locales = locale_name.empty() ? nullptr : bcp47_locales;
+
+  sk_sp<SkTypeface> typeface(font_mgr->matchFamilyStyleCharacter(
+      base_family_name.c_str(), SkFontStyle(), locales, num_locales,
+      codepoint));
+
+  if (!typeface)
+    return;
+
+  SkString family_name;
+  typeface->getFamilyName(&family_name);
+
+  SkFontStyle font_style = typeface->fontStyle();
+
+  auto result_fallback_and_style = blink::mojom::FallbackFamilyAndStyle::New(
+      family_name.c_str(), font_style.weight(), font_style.width(),
+      font_style.slant());
+  std::move(callback).Run(std::move(result_fallback_and_style));
+}
+
 void DWriteFontProxyImpl::InitializeDirectWrite() {
+  HRESULT hr;
   if (direct_write_initialized_)
     return;
   direct_write_initialized_ = true;
@@ -556,20 +638,30 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
-  // Normally identical to factory_->GetSystemFontCollection() unless a
-  // sideloaded font has been added using SideLoadFontForTesting().
-  HRESULT hr = GetLocalFontCollection(factory3_, &collection_);
+  // On Windows 10 and up (or Vista exkernel/Windows 8.x with modified dwrite.dll from 1809)
+  // you can take advantage of the extended DirectWrite APIs to sideload local fonts in
+  // addition to system fonts. But if IDWriteFactory3 is unavailable, fall back to
+  // GetSystemFontCollection.
+  // TODO: make DirectWrite optional for the benefit of the NT 5 users.
+
+  if (factory3_  == nullptr) {
+  hr = factory_->GetSystemFontCollection(&collection_);
   DCHECK(SUCCEEDED(hr));
+  }
+  else {
+  hr = GetLocalFontCollection(factory3_, &collection_);
+  DCHECK(SUCCEEDED(hr));
+  }
+
 
   if (!collection_) {
     return;
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index 11af003ea85fe..efb8c813661f5 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_thread.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
@@ -62,6 +63,20 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
   void InitializeDirectWrite();
 
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
index 5f8c1b00295ce..152f73280e000 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
@@ -25,6 +25,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
 #include "third_party/icu/source/common/unicode/umachine.h"
+#include "ui/gfx/test/font_fallback_test_data.h"
 
 namespace content {
 
@@ -182,6 +183,32 @@ TEST_F(DWriteFontProxyImplUnitTest, TestCustomFontFiles) {
   }
 }
 
+TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
+  for (auto& fallback_request : gfx::kGetFontFallbackTests) {
+    blink::mojom::FallbackFamilyAndStylePtr fallback_family_and_style;
+    UChar32 codepoint;
+    U16_GET(fallback_request.text.c_str(), 0, 0, fallback_request.text.size(),
+            codepoint);
+    dwrite_font_proxy().FallbackFamilyAndStyleForCodepoint(
+        "Times New Roman", fallback_request.language_tag, codepoint,
+        &fallback_family_and_style);
+
+    EXPECT_TRUE(base::Contains(fallback_request.fallback_fonts,
+                               fallback_family_and_style->fallback_family_name))
+        << "Did not find expected fallback font for language: "
+        << fallback_request.language_tag << ", codepoint U+" << std::hex
+        << codepoint << " DWrite returned font name: \""
+        << fallback_family_and_style->fallback_family_name << "\""
+        << ", expected: "
+        << base::JoinString(fallback_request.fallback_fonts, ", ");
+    EXPECT_EQ(fallback_family_and_style->weight, 400u);
+    EXPECT_EQ(fallback_family_and_style->width,
+              5u);  // SkFontStyle::Width::kNormal_Width
+    EXPECT_EQ(fallback_family_and_style->slant,
+              0u);  // SkFontStyle::Slant::kUpright_Slant
+  }
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 545c860afff13..2694bbb816b17 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3578,7 +3578,9 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kRendererWaitForJavaDebugger,
 #endif
 #if BUILDFLAG(IS_WIN)
+    switches::kDisableDirectWrite,
     switches::kDisableHighResTimer,
+    switches::kEnableWin7WebRtcHWH264Decoding,
     switches::kTrySupportedChannelLayouts,
     switches::kRaiseTimerFrequency,
 #endif
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
index 896d975020696..f6857fa9353f2 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
@@ -41,9 +41,19 @@ base::RepeatingCallback<mojo::PendingRemote<blink::mojom::DWriteFontProxy>(
 void CreateDirectWriteFactory(IDWriteFactory** factory) {
   // This shouldn't be necessary, but not having this causes breakage in
   // content_browsertests, and possibly other high-stress cases.
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+
+  HMODULE dwrite_dll = GetModuleHandleW(L"dwrite.dll");
+
   PatchServiceManagerCalls();
 
-  CHECK(SUCCEEDED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_ISOLATED,
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
+  CHECK(SUCCEEDED(dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_ISOLATED,
                                       __uuidof(IDWriteFactory),
                                       reinterpret_cast<IUnknown**>(factory))));
 }
@@ -53,6 +63,10 @@ void CreateDirectWriteFactory(IDWriteFactory** factory) {
 void InitializeDWriteFontProxy() {
   TRACE_EVENT0("dwrite,fonts", "InitializeDWriteFontProxy");
   mswr::ComPtr<IDWriteFactory> factory;
+  // Halt the init process if the DLL is not there.
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
 
   CreateDirectWriteFactory(&factory);
 
@@ -79,7 +93,7 @@ void InitializeDWriteFontProxy() {
 
   skia::OverrideDefaultSkFontMgr(std::move(skia_font_manager));
 
-  DCHECK(g_font_fallback);
+  blink::WebFontRendering::SetUseSkiaFontFallback(g_font_fallback ? true : false);
 }
 
 void UninitializeDWriteFontProxy() {
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
index 163d1ecca00c1..0186a5a3d8b8d 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
@@ -52,8 +52,18 @@ class DWriteFontProxyUnitTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
-                        &factory);
+    using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+    if (!dwrite_dll)
+      return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+      return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+                               &factory);
 
     std::vector<wchar_t> font_path;
     font_path.resize(MAX_PATH);
diff --git a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
index 90a04f1deef7f..3f40491a80b7b 100644
--- a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
@@ -27,7 +27,17 @@ namespace {
 class FontFallbackUnitTest : public testing::Test {
  public:
   FontFallbackUnitTest() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+	DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+	if (!dwrite_create_factory_proc)
+		return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory_);
 
     factory_->CreateNumberSubstitution(DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE,
diff --git a/content/child/font_warmup_win_unittest.cc b/content/child/font_warmup_win_unittest.cc
index 051af55e65a2c..eb511cfa3cee1 100644
--- a/content/child/font_warmup_win_unittest.cc
+++ b/content/child/font_warmup_win_unittest.cc
@@ -19,6 +19,7 @@
 #include "base/path_service.h"
 #include "base/sys_byteorder.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 
 #include "content/child/dwrite_font_proxy/dwrite_font_proxy_win.h"
 #include "content/public/common/content_paths.h"
@@ -69,6 +70,16 @@ class GDIFontEmulationTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+	HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+		return;
     DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory);
   }
@@ -136,6 +147,8 @@ int CALLBACK EnumFontCallbackTest(const LOGFONT* log_font,
 }  // namespace
 
 TEST_F(GDIFontEmulationTest, CreateDeleteDCSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_FALSE(!patch_data);
 
@@ -147,6 +160,8 @@ TEST_F(GDIFontEmulationTest, CreateDeleteDCSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateUniqueDCSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
 
@@ -162,6 +177,8 @@ TEST_F(GDIFontEmulationTest, CreateUniqueDCSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateFontSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   LOGFONTW logfont = {0};
@@ -173,6 +190,8 @@ TEST_F(GDIFontEmulationTest, CreateFontSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateFontFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   LOGFONTW logfont = {0};
@@ -182,6 +201,8 @@ TEST_F(GDIFontEmulationTest, CreateFontFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, EnumFontFamilySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -194,6 +215,8 @@ TEST_F(GDIFontEmulationTest, EnumFontFamilySuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, EnumFontFamilyFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -206,6 +229,8 @@ TEST_F(GDIFontEmulationTest, EnumFontFamilyFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, DeleteDCFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = reinterpret_cast<HDC>(0x55667788);
@@ -213,6 +238,8 @@ TEST_F(GDIFontEmulationTest, DeleteDCFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, DeleteObjectFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HFONT font = reinterpret_cast<HFONT>(0x88aabbcc);
@@ -220,6 +247,8 @@ TEST_F(GDIFontEmulationTest, DeleteObjectFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataSizeSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -237,6 +266,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataSizeSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataInvalidTagSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -253,6 +284,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataInvalidTagSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataInvalidFontSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -263,6 +296,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataInvalidFontSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataDataSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
diff --git a/content/child/runtime_features.cc b/content/child/runtime_features.cc
index 5a5b3c03b3b26..fa39ca2868ae6 100644
--- a/content/child/runtime_features.cc
+++ b/content/child/runtime_features.cc
@@ -4,7 +4,6 @@
 
 #include "content/child/runtime_features.h"
 
-#include <string>
 #include <vector>
 
 #include "base/base_switches.h"
@@ -55,6 +54,10 @@
 #include "device/vr/public/cpp/features.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using blink::WebRuntimeFeatures;
 
 namespace {
diff --git a/content/child/webthemeengine_impl_default_browsertest.cc b/content/child/webthemeengine_impl_default_browsertest.cc
index a638c432bb49d..e68ee23fdbd23 100644
--- a/content/child/webthemeengine_impl_default_browsertest.cc
+++ b/content/child/webthemeengine_impl_default_browsertest.cc
@@ -15,7 +15,7 @@ namespace content {
 
 class WebThemeEngineImplDefaultBrowserTest : public ContentBrowserTest {
  public:
-  WebThemeEngineImplDefaultBrowserTest() = default;
+  WebThemeEngineImplDefaultBrowserTest() {}
 };
 
 #if BUILDFLAG(IS_WIN)
@@ -23,9 +23,6 @@ IN_PROC_BROWSER_TEST_F(WebThemeEngineImplDefaultBrowserTest, GetSystemColor) {
   // The test non-deterministically fails on Windows-2008ServerR2 builders due
   // to a difference in the default theme. As a result, only run the test on
   // non-server versions.
-  // TODO(https://crbug.com/1385856): Remove this, and the windows_version.h
-  // include, if the failure turns out to be specific to Windows-2008ServerR2
-  // and not any Windows server.
   if (base::win::OSInfo::GetInstance()->version_type() ==
       base::win::VersionType::SUITE_SERVER) {
     return;
@@ -115,19 +112,36 @@ IN_PROC_BROWSER_TEST_F(WebThemeEngineImplDefaultBrowserTest, GetSystemColor) {
                                   "window",
                                   "windowFrame",
                                   "windowText"};
-  const std::vector<std::string> expected_colors = {
-      "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
-      "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
-      "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
-      "rgb(0, 120, 215)",   "rgb(255, 255, 255)", "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
-      "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
-      "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  std::vector<std::string> expected_colors;
+  if (base::win::GetVersion() <= base::win::Version::WIN8_1) {
+    expected_colors = {
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
+        "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
+        "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
+        "rgb(51, 153, 255)",  "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  } else {
+    expected_colors = {
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
+        "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
+        "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
+        "rgb(0, 120, 215)",   "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  }
 
   ASSERT_EQ(ids.size(), expected_colors.size());
 
diff --git a/content/common/font_list_win.cc b/content/common/font_list_win.cc
index 7a26dddd5c8dc..061e913812fa5 100644
--- a/content/common/font_list_win.cc
+++ b/content/common/font_list_win.cc
@@ -18,6 +18,45 @@
 
 namespace content {
 
+static int CALLBACK EnumFontFamExProc(ENUMLOGFONTEXW* logical_font,
+                                      NEWTEXTMETRICEXW* physical_font,
+                                      DWORD font_type,
+                                      LPARAM lparam) {
+  std::set<std::wstring>* font_names =
+      reinterpret_cast<std::set<std::wstring>*>(lparam);
+  if (font_names) {
+    const LOGFONTW& lf = logical_font->elfLogFont;
+    if (lf.lfFaceName[0] && lf.lfFaceName[0] != '@') {
+      std::wstring face_name(lf.lfFaceName);
+      font_names->insert(face_name);
+    }
+  }
+  return 1;
+}
+
+base::Value::List GetFontList_SlowBlocking_Legacy() {
+  std::set<std::u16string> font_names;
+
+  LOGFONTW logfont;
+  memset(&logfont, 0, sizeof(logfont));
+  logfont.lfCharSet = DEFAULT_CHARSET;
+
+  HDC hdc = ::GetDC(NULL);
+  ::EnumFontFamiliesExW(hdc, &logfont, (FONTENUMPROCW)&EnumFontFamExProc,
+                        (LPARAM)&font_names, 0);
+  ::ReleaseDC(NULL, hdc);
+
+  base::Value::List font_list;
+  std::set<std::u16string>::iterator iter;
+  for (iter = font_names.begin(); iter != font_names.end(); ++iter) {
+    base::Value::List font_item;
+    font_item.Append(*iter);
+    font_item.Append(*iter);
+    font_list.Append(std::move(font_item));
+  }
+  return font_list;
+}
+
 base::Value::List GetFontList_SlowBlocking() {
   TRACE_EVENT0("fonts", "GetFontList_SlowBlocking");
 
@@ -25,12 +64,13 @@ base::Value::List GetFontList_SlowBlocking() {
 
   Microsoft::WRL::ComPtr<IDWriteFactory> factory;
   gfx::win::CreateDWriteFactory(&factory);
+  // Fall back to GDI font list API if DirectWrite is unavailable
   if (!factory)
-    return font_list;
+    return GetFontList_SlowBlocking_Legacy();
 
   Microsoft::WRL::ComPtr<IDWriteFontCollection> collection;
   if (FAILED(factory->GetSystemFontCollection(&collection)))
-    return font_list;
+    return GetFontList_SlowBlocking_Legacy();
 
   // Retrieve the localized font family name. If there is no localized name,
   // used the native name instead.
diff --git a/content/common/sandbox_init_win.cc b/content/common/sandbox_init_win.cc
index 498f60227d13e..724ce1120b720 100644
--- a/content/common/sandbox_init_win.cc
+++ b/content/common/sandbox_init_win.cc
@@ -17,6 +17,7 @@
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace content {
 
diff --git a/content/ppapi_plugin/ppapi_plugin_main.cc b/content/ppapi_plugin/ppapi_plugin_main.cc
index 89e84b2c25c52..8af071d123a33 100644
--- a/content/ppapi_plugin/ppapi_plugin_main.cc
+++ b/content/ppapi_plugin/ppapi_plugin_main.cc
@@ -172,7 +172,12 @@ int PpapiPluginMain(MainFunctionParams parameters) {
 #if BUILDFLAG(IS_WIN)
   if (!base::win::IsUser32AndGdi32Available())
     gfx::win::InitializeDirectWrite();
-  InitializeDWriteFontProxy();
+  bool use_direct_write = gfx::win::IsDirectWriteEnabled();
+  if (use_direct_write) {
+    InitializeDWriteFontProxy();
+  }
+
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   int antialiasing_enabled = 1;
   base::StringToInt(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index d004abc6fe3da..1d43fe3c9eeee 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -746,6 +746,10 @@ std::string ContentBrowserClient::GetDefaultDownloadName() {
   return std::string();
 }
 
+base::FilePath ContentBrowserClient::GetFontLookupTableCacheDir() {
+  return base::FilePath();
+}
+
 base::FilePath ContentBrowserClient::GetShaderDiskCacheDirectory() {
   return base::FilePath();
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index d0a5dbc454670..670c9a80489b8 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1220,6 +1220,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // else we should do with the file.
   virtual std::string GetDefaultDownloadName();
 
+  // Returns the path to the font lookup table cache directory in which - on
+  // Windows 7 & 8 - we cache font name meta information to perform @font-face {
+  // src: local() } lookups.
+  virtual base::FilePath GetFontLookupTableCacheDir();
+
   // Returns the path to the browser shader disk cache root.
   virtual base::FilePath GetShaderDiskCacheDirectory();
 
diff --git a/content/public/common/content_features.cc b/content/public/common/content_features.cc
index 7890cd4195e8f..53b8c7b09f63f 100644
--- a/content/public/common/content_features.cc
+++ b/content/public/common/content_features.cc
@@ -4,8 +4,6 @@
 
 #include "content/public/common/content_features.h"
 
-#include <string>
-
 #include "base/feature_list.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
@@ -13,6 +11,10 @@
 #include "content/common/buildflags.h"
 #include "content/public/common/dips_utils.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace features {
 
 // All features in alphabetical order.
@@ -1399,6 +1401,11 @@ VideoCaptureServiceConfiguration GetVideoCaptureServiceConfiguration() {
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
   return VideoCaptureServiceConfiguration::kEnabledForBrowserProcess;
 #else
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return VideoCaptureServiceConfiguration::kEnabledForBrowserProcess;
+  }
+#endif
   return base::FeatureList::IsEnabled(
              features::kRunVideoCaptureServiceInBrowserProcess)
              ? VideoCaptureServiceConfiguration::kEnabledForBrowserProcess
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index 0e06580a8d496..43106e9dc7aa4 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -1027,6 +1027,9 @@ const char kDeviceScaleFactor[]     = "device-scale-factor";
 // Disable the Legacy Window which corresponds to the size of the WebContents.
 const char kDisableLegacyIntermediateWindow[] = "disable-legacy-window";
 
+// Enables H264 HW decode acceleration for WebRTC on Win 7.
+const char kEnableWin7WebRtcHWH264Decoding[] = "enable-win7-webrtc-hw-h264-decoding";
+
 // DirectWrite FontCache is shared by browser to renderers using shared memory.
 // This switch allows us to pass the shared memory handle to the renderer.
 const char kFontCacheSharedHandle[] = "font-cache-shared-handle";
diff --git a/content/public/common/content_switches.h b/content/public/common/content_switches.h
index 1708337fd82f0..5519702d8f0c3 100644
--- a/content/public/common/content_switches.h
+++ b/content/public/common/content_switches.h
@@ -284,6 +284,7 @@ CONTENT_EXPORT extern const char kPrefetchArgumentOther[];
 // like renderers, etc.
 CONTENT_EXPORT extern const char kDeviceScaleFactor[];
 CONTENT_EXPORT extern const char kDisableLegacyIntermediateWindow[];
+CONTENT_EXPORT extern const char kEnableWin7WebRtcHWH264Decoding[];
 // Switch to pass the font cache shared memory handle to the renderer.
 CONTENT_EXPORT extern const char kFontCacheSharedHandle[];
 CONTENT_EXPORT extern const char kPpapiAntialiasedTextEnabled[];
diff --git a/content/renderer/pepper/content_renderer_pepper_host_factory.cc b/content/renderer/pepper/content_renderer_pepper_host_factory.cc
index 54379d58e8cd0..c732b56f4a3d6 100644
--- a/content/renderer/pepper/content_renderer_pepper_host_factory.cc
+++ b/content/renderer/pepper/content_renderer_pepper_host_factory.cc
@@ -40,6 +40,10 @@
 #include "third_party/blink/public/web/web_document.h"
 #include "third_party/blink/public/web/web_plugin_container.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using ppapi::host::ResourceHost;
 using ppapi::UnpackMessage;
 
@@ -120,10 +124,12 @@ ContentRendererPepperHostFactory::CreateResourceHost(
       ppapi::PPB_ImageData_Shared::ImageDataType image_type =
           ppapi::PPB_ImageData_Shared::PLATFORM;
 #if BUILDFLAG(IS_WIN)
+      // Win32K lockdown mitigations are enabled for Windows 8 and beyond.
       // We use the SIMPLE image data type as the PLATFORM image data type
       // calls GDI functions to create DIB sections etc which fail in Win32K
       // lockdown mode.
-      image_type = ppapi::PPB_ImageData_Shared::SIMPLE;
+      if (base::win::GetVersion() >= base::win::Version::WIN8)
+        image_type = ppapi::PPB_ImageData_Shared::SIMPLE;
 #endif
       scoped_refptr<PPB_ImageData_Impl> image_data(new PPB_ImageData_Impl(
           instance, image_type));
diff --git a/content/renderer/pepper/resource_creation_impl.cc b/content/renderer/pepper/resource_creation_impl.cc
index 7ec35f454a984..a232bc9581726 100644
--- a/content/renderer/pepper/resource_creation_impl.cc
+++ b/content/renderer/pepper/resource_creation_impl.cc
@@ -21,6 +21,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/command_line.h"
+#include "base/win/windows_version.h"
 #endif
 
 using ppapi::InputEventData;
@@ -112,17 +113,18 @@ PP_Resource ResourceCreationImpl::CreateImageData(PP_Instance instance,
                                                   const PP_Size* size,
                                                   PP_Bool init_to_zero) {
 #if BUILDFLAG(IS_WIN)
-  // We use the SIMPLE image data type as the PLATFORM image data type
+  // If Win32K lockdown mitigations are enabled for Windows 8 and beyond,
+  // we use the SIMPLE image data type as the PLATFORM image data type
   // calls GDI functions to create DIB sections etc which fail in Win32K
   // lockdown mode.
-  return CreateImageDataSimple(instance, format, size, init_to_zero);
-#else
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    return CreateImageDataSimple(instance, format, size, init_to_zero);
+#endif
   return PPB_ImageData_Impl::Create(instance,
                                     ppapi::PPB_ImageData_Shared::PLATFORM,
                                     format,
                                     *size,
                                     init_to_zero);
-#endif
 }
 
 PP_Resource ResourceCreationImpl::CreateImageDataSimple(
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 07bb68687683a..bf4f77383ef53 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -1203,6 +1203,8 @@ WindowOpenDisposition NavigationPolicyToDisposition(
     case blink::kWebNavigationPolicyNewWindow:
       return WindowOpenDisposition::NEW_WINDOW;
     case blink::kWebNavigationPolicyNewPopup:
+	  if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+         return WindowOpenDisposition::NEW_FOREGROUND_TAB;
       return WindowOpenDisposition::NEW_POPUP;
     case blink::kWebNavigationPolicyPictureInPicture:
       return WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
@@ -2220,11 +2222,11 @@ void RenderFrameImpl::Delete(mojom::FrameDeleteIntention intent) {
       // main frame when a commit (and ownership transfer) is imminent.
       // TODO(dcheng): This is the case of https://crbug.com/838348.
       DCHECK(is_main_frame_);
-#if !BUILDFLAG(IS_ANDROID)
+#if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_WIN)
       // This check is not enabled on Android, since it seems like it's much
       // easier to trigger data races there.
       CHECK(!in_frame_tree_);
-#endif  // !BUILDFLAG(IS_ANDROID)
+#endif  // !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_WIN)
       break;
   }
 
diff --git a/content/renderer/render_view_browsertest.cc b/content/renderer/render_view_browsertest.cc
index fb0d957ee5d88..245fcda505aba 100644
--- a/content/renderer/render_view_browsertest.cc
+++ b/content/renderer/render_view_browsertest.cc
@@ -124,6 +124,10 @@
 #include "third_party/blink/public/common/input/web_input_event.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_OZONE)
 #include "ui/events/keycodes/keyboard_code_conversion.h"
 #endif
@@ -3134,6 +3138,12 @@ TEST_F(RenderViewImplScaleFactorTest, ConvertViewportToWindow) {
 TEST_F(RenderViewImplScaleFactorTest,
        DISABLED_GetCompositionCharacterBoundsTest) {  // http://crbug.com/582016
   SetDeviceScaleFactor(1.f);
+#if BUILDFLAG(IS_WIN)
+  // http://crbug.com/508747
+  if (base::win::GetVersion() >= base::win::Version::WIN10)
+    return;
+#endif
+
   LoadHTML("<textarea id=\"test\"></textarea>");
   ExecuteJavaScriptForTests("document.getElementById('test').focus();");
 
diff --git a/content/renderer/renderer_blink_platform_impl.cc b/content/renderer/renderer_blink_platform_impl.cc
index 619323f485c6a..8faa0e8848445 100644
--- a/content/renderer/renderer_blink_platform_impl.cc
+++ b/content/renderer/renderer_blink_platform_impl.cc
@@ -127,6 +127,10 @@
 #include "content/common/android/sync_compositor_statics.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using blink::Platform;
 using blink::WebAudioDevice;
 using blink::WebAudioLatencyHint;
@@ -598,6 +602,25 @@ void RendererBlinkPlatformImpl::GetWebRTCRendererPreferences(
   *allow_mdns_obfuscation = true;
 }
 
+bool RendererBlinkPlatformImpl::IsWebRtcHWH264DecodingEnabled(
+    webrtc::VideoCodecType video_codec_type) {
+#if BUILDFLAG(IS_WIN)
+  // Do not use hardware decoding for H.264 on Win7, due to high latency.
+  // See https://crbug.com/webrtc/5717.
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnableWin7WebRtcHWH264Decoding) &&
+      video_codec_type == webrtc::kVideoCodecH264 &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    DVLOG(1) << "WebRTC H.264 HW decoding is not supported on Win7";
+    return false;
+  }
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableWin7WebRtcHWH264Decoding)) {
+    LOG(WARNING) << "WebRTC H.264 HW decoding is not supported on Windows 7";
+  }
+#endif  // BUILDFLAG(IS_WIN)
+  return true;
+}
+
 bool RendererBlinkPlatformImpl::IsWebRtcHWEncodingEnabled() {
   return !base::CommandLine::ForCurrentProcess()->HasSwitch(
       switches::kDisableWebRtcHWEncoding);
diff --git a/content/renderer/renderer_blink_platform_impl.h b/content/renderer/renderer_blink_platform_impl.h
index ecbcf12493f77..c3279cea45f70 100644
--- a/content/renderer/renderer_blink_platform_impl.h
+++ b/content/renderer/renderer_blink_platform_impl.h
@@ -158,6 +158,8 @@ class CONTENT_EXPORT RendererBlinkPlatformImpl : public BlinkPlatformImpl {
                                     uint16_t* udp_min_port,
                                     uint16_t* udp_max_port,
                                     bool* allow_mdns_obfuscation) override;
+  bool IsWebRtcHWH264DecodingEnabled(
+      webrtc::VideoCodecType video_coded_type) override;
   bool IsWebRtcHWEncodingEnabled() override;
   bool IsWebRtcHWDecodingEnabled() override;
   bool IsWebRtcSrtpEncryptedHeadersEnabled() override;
diff --git a/content/renderer/renderer_main.cc b/content/renderer/renderer_main.cc
index 4953e20861803..c7521519c31aa 100644
--- a/content/renderer/renderer_main.cc
+++ b/content/renderer/renderer_main.cc
@@ -94,6 +94,11 @@
 #include "mojo/public/cpp/bindings/lib/test_random_mojo_delays.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace content {
 namespace {
 
@@ -241,8 +246,18 @@ int RendererMain(MainFunctionParams parameters) {
   {
     content::ContentRendererClient* client = GetContentClient()->renderer();
     bool should_run_loop = true;
-    bool need_sandbox =
+#if BUILDFLAG(IS_WIN)
+    bool need_sandbox = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8) {
+	// Windows 8+ specific limitations required renderer sandbox disabled for GDI
+    need_sandbox = gfx::win::ShouldUseDirectWrite() &&
         !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+	}
+	else
+	need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#else
+    bool need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#endif
 
     if (!need_sandbox) {
       // The post-sandbox actions still need to happen at some point.
diff --git a/content/renderer/renderer_main_platform_delegate_win.cc b/content/renderer/renderer_main_platform_delegate_win.cc
index e7b8caa9ab118..93bccc4ed53fe 100644
--- a/content/renderer/renderer_main_platform_delegate_win.cc
+++ b/content/renderer/renderer_main_platform_delegate_win.cc
@@ -27,6 +27,18 @@
 #include "ui/gfx/win/direct_write.h"
 
 namespace content {
+namespace {
+
+// Windows-only skia sandbox support
+// These are used for GDI-path rendering.
+void SkiaPreCacheFont(const LOGFONT& logfont) {
+  RenderThread* render_thread = RenderThread::Get();
+  if (render_thread) {
+    render_thread->PreCacheFont(logfont);
+  }
+}
+
+}  // namespace
 
 RendererMainPlatformDelegate::RendererMainPlatformDelegate(
     const MainFunctionParams& parameters)
@@ -40,8 +52,16 @@ void RendererMainPlatformDelegate::PlatformInitialize() {
 
   // Be mindful of what resources you acquire here. They can be used by
   // malicious code if the renderer gets compromised.
-  bool no_sandbox =
-      command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+  bool no_sandbox = command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+
+  bool use_direct_write = gfx::win::ShouldUseDirectWrite();
+
+  if (use_direct_write) {
+      InitializeDWriteFontProxy();
+    } else {
+      SkTypeface_SetEnsureLOGFONTAccessibleProc(SkiaPreCacheFont);
+    }
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   if (!no_sandbox) {
     // ICU DateFormat class (used in base/time_format.cc) needs to get the
diff --git a/content/shell/browser/shell_content_browser_client.cc b/content/shell/browser/shell_content_browser_client.cc
index 3e0b86f6834c5..46e00b4581fbb 100644
--- a/content/shell/browser/shell_content_browser_client.cc
+++ b/content/shell/browser/shell_content_browser_client.cc
@@ -14,6 +14,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/cxx20_erase.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
@@ -468,6 +468,11 @@ std::string ShellContentBrowserClient::GetDefaultDownloadName() {
   return "download";
 }
 
+base::FilePath ShellContentBrowserClient::GetFontLookupTableCacheDir() {
+  return browser_context()->GetPath().Append(
+      FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 std::unique_ptr<WebContentsViewDelegate>
 ShellContentBrowserClient::GetWebContentsViewDelegate(
     WebContents* web_contents) {
diff --git a/content/shell/browser/shell_content_browser_client.h b/content/shell/browser/shell_content_browser_client.h
index 83253e9feb3eb..fc91dcc11ae5f 100644
--- a/content/shell/browser/shell_content_browser_client.h
+++ b/content/shell/browser/shell_content_browser_client.h
@@ -95,6 +95,7 @@ class ShellContentBrowserClient : public ContentBrowserClient {
       override;
   void OverrideWebkitPrefs(WebContents* web_contents,
                            blink::web_pref::WebPreferences* prefs) override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   std::unique_ptr<content::DevToolsManagerDelegate>
   CreateDevToolsManagerDelegate() override;
   void ExposeInterfacesToRenderer(
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index 54d7450544572..dd6c051111e0c 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -146,6 +146,12 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {}
+
 FakeFontCollection::~FakeFontCollection() = default;
 
 }  // namespace content
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index e5c7230ffcaad..3906ff44e64a6 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,11 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
  private:
   std::vector<FakeFont> fonts_;
diff --git a/crypto/unexportable_key_win.cc b/crypto/unexportable_key_win.cc
index 7e39e10de7be3..a3ad47adbfc54 100644
--- a/crypto/unexportable_key_win.cc
+++ b/crypto/unexportable_key_win.cc
@@ -367,6 +367,11 @@ class UnexportableKeyProviderWin : public UnexportableKeyProvider {
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if (!::LoadLibraryW(L"ncrypt.dll")) {
+		  return absl::nullopt;
+	  }
+
       if (FAILED(NCryptOpenStorageProvider(
               ScopedNCryptProvider::Receiver(provider).get(),
               MS_PLATFORM_CRYPTO_PROVIDER, /*flags=*/0))) {
@@ -386,6 +391,11 @@ class UnexportableKeyProviderWin : public UnexportableKeyProvider {
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if (!::LoadLibraryW(L"ncrypt.dll")) {
+		  return nullptr;
+	  }
+
       if (FAILED(NCryptOpenStorageProvider(
               ScopedNCryptProvider::Receiver(provider).get(),
               MS_PLATFORM_CRYPTO_PROVIDER, /*flags=*/0))) {
@@ -612,6 +622,11 @@ class VirtualUnexportableKeyProviderWin
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if (!::LoadLibraryW(L"ncrypt.dll")) {
+		  return absl::nullopt;
+	  }
+
       SECURITY_STATUS status = NCryptOpenStorageProvider(
           ScopedNCryptProvider::Receiver(provider).get(),
           MS_KEY_STORAGE_PROVIDER, /*dwFlags=*/0);
@@ -634,6 +649,11 @@ class VirtualUnexportableKeyProviderWin
     ScopedNCryptProvider provider;
     {
       SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+	  if (!::LoadLibraryW(L"ncrypt.dll")) {
+		  return nullptr;
+	  }
+
       SECURITY_STATUS status = NCryptOpenStorageProvider(
           ScopedNCryptProvider::Receiver(provider).get(),
           MS_KEY_STORAGE_PROVIDER, /*dwFlags=*/0);
diff --git a/device/bluetooth/bluetooth_adapter_winrt.cc b/device/bluetooth/bluetooth_adapter_winrt.cc
index a2ba812053fa5..195ec4ee6afe8 100644
--- a/device/bluetooth/bluetooth_adapter_winrt.cc
+++ b/device/bluetooth/bluetooth_adapter_winrt.cc
@@ -105,6 +105,11 @@ using ABI::Windows::Storage::Streams::IDataReaderStatics;
 using Microsoft::WRL::Callback;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 // Query string for powered Bluetooth radios. GUID Reference:
 // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/guid-bthport-device-interface
 // TODO(https://crbug.com/821766): Consider adding WindowsCreateStringReference
@@ -666,6 +671,14 @@ void BluetoothAdapterWinrt::InitForTests(
     ComPtr<IBluetoothAdapterStatics> bluetooth_adapter_statics,
     ComPtr<IDeviceInformationStatics> device_information_statics,
     ComPtr<IRadioStatics> radio_statics) {
+
+  if (!ResolveCoreWinRT()) {
+    CompleteInit(std::move(init_callback), std::move(bluetooth_adapter_statics),
+                 std::move(device_information_statics),
+                 std::move(radio_statics));
+    return;
+  }
+
   auto statics = PerformSlowInitTasks();
 
   // This allows any passed in values (which would be fakes) to replace
@@ -689,6 +702,8 @@ void BluetoothAdapterWinrt::InitForTests(
 BluetoothAdapterWinrt::StaticsInterfaces
 BluetoothAdapterWinrt::PerformSlowInitTasks() {
   base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
+  if (!ResolveCoreWinRT())
+    return BluetoothAdapterWinrt::StaticsInterfaces();
   ComPtr<IBluetoothAdapterStatics> adapter_statics;
   HRESULT hr = base::win::GetActivationFactory<
       IBluetoothAdapterStatics,
diff --git a/device/gamepad/wgi_data_fetcher_win.cc b/device/gamepad/wgi_data_fetcher_win.cc
index a215ae7f06fc7..5c685f7deea47 100644
--- a/device/gamepad/wgi_data_fetcher_win.cc
+++ b/device/gamepad/wgi_data_fetcher_win.cc
@@ -210,6 +210,11 @@ GamepadSource WgiDataFetcherWin::source() {
 
 void WgiDataFetcherWin::OnAddedToProvider() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!base::win::HStringReference::ResolveCoreWinRTStringDelayload()) {
+    initialization_state_ =
+        InitializationState::kCoreWinrtStringDelayLoadFailed;
+    return;
+  }
   HRESULT hr = get_activation_factory_function_(
       base::win::HStringReference(RuntimeClass_Windows_Gaming_Input_Gamepad)
           .Get(),
diff --git a/device/gamepad/wgi_data_fetcher_win.h b/device/gamepad/wgi_data_fetcher_win.h
index a5a27848749a2..450ad10130f76 100644
--- a/device/gamepad/wgi_data_fetcher_win.h
+++ b/device/gamepad/wgi_data_fetcher_win.h
@@ -36,6 +36,7 @@ class DEVICE_GAMEPAD_EXPORT WgiDataFetcherWin final
     kAddGamepadAddedFailed,
     kAddGamepadRemovedFailed,
     kRoGetActivationFactoryFailed,
+    kCoreWinrtStringDelayLoadFailed,
   };
 
   using Factory =
diff --git a/docs/README.md b/docs/README.md
index 6eadc1f036521..bc969fe8d1478 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -1,20 +1,33 @@
-# Chromium docs
+# Supermium + Thorium - an up-to-date, open-source browser for legacy Windows users
 
-This directory contains [chromium project](https://www.chromium.org/Home/)
-documentation in [Gitiles-flavored Markdown]. It is automatically
-[rendered by Gitiles].
+The aim of Supermium is to provide the latest Chromium features, support for rendering the web and security patches to users
+of Windows Vista (with extended kernel), Windows 7 and Windows 8.x.
 
-[Gitiles-flavored Markdown]: https://gerrit.googlesource.com/gitiles/+/master/Documentation/markdown.md
-[rendered by Gitiles]: https://chromium.googlesource.com/chromium/src/+/main/docs/
+Releases are expected every one to two months.
 
-**If you add new documents, please also add a link to them in the Document Index
-below.**
+# Support this and other legacy software projects at: http://paypal.me/win32420
 
-[TOC]
+# Future objectives
 
-## Creating Documentation
+-Maintaining support for Manifest v2
 
-### Guidelines
+-Supporting Windows Vista (without extended kernel)
+
+-Restoring GDI font rendering
+
+-Adding basic GUI to installer to allow user to pick an install directory
+
+-Adding trapezoidal tabs option
+
+-"ungoogled" mode
+
+# Future objectives of lower priority
+
+-Supporting Windows XP
+
+-SSE2 build
+
+Upstream README.md follows below:
 
 *   See the [Chromium Documentation Guidelines](documentation_guidelines.md)
     and the
@@ -470,4 +483,4 @@ a video series of interviews with Chromium software engineers.
 *   [Vanilla msysgit workflow](vanilla_msysgit_workflow.md) - A workflow for
     using mostly vanilla git on Windows.
 *   [Old Options](chrome_settings.md) - Pre-Material Design chrome://settings
-    notes.
+    notes.
\ No newline at end of file
diff --git a/gin/v8_initializer.cc b/gin/v8_initializer.cc
index 0b7fcb2ffd5e1..cf2cc3ac104b2 100644
--- a/gin/v8_initializer.cc
+++ b/gin/v8_initializer.cc
@@ -52,6 +52,10 @@
 #endif
 #endif  // V8_USE_EXTERNAL_STARTUP_DATA
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gin {
 
 namespace {
@@ -522,6 +526,22 @@ void V8Initializer::Initialize(IsolateHolder::ScriptMode mode,
   const size_t min_pool_size = partition_alloc::internal::
       PartitionAddressSpace::ConfigurablePoolMinSize();
   size_t pool_size = max_pool_size;
+#if BUILDFLAG(IS_WIN)
+  // On Windows prior to 8.1 we allocate a smaller Pool since reserving
+  // virtual memory is expensive on these OSes.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1) {
+    // The size chosen here should be synchronized with the size of the
+    // virtual memory reservation for the V8 sandbox on these platforms.
+    // Currently, that is 8GB, of which 4GB are used for V8's pointer
+    // compression region.
+    // TODO(saelo) give this constant a proper name and maybe move it
+    // somewhere else.
+    constexpr size_t kGB = 1ULL << 30;
+    pool_size = 8ULL * kGB;
+    DCHECK_LE(pool_size, max_pool_size);
+    DCHECK_GE(pool_size, min_pool_size);
+  }
+#endif
   // Try to reserve the maximum size of the pool at first, then keep halving
   // the size on failure until it succeeds.
   uintptr_t pool_base = 0;
diff --git a/gpu/command_buffer/service/shared_image/d3d_image_backing_factory.cc b/gpu/command_buffer/service/shared_image/d3d_image_backing_factory.cc
index 473355dec4e12..3d875b994b69c 100644
--- a/gpu/command_buffer/service/shared_image/d3d_image_backing_factory.cc
+++ b/gpu/command_buffer/service/shared_image/d3d_image_backing_factory.cc
@@ -8,6 +8,7 @@
 
 #include "base/memory/shared_memory_mapping.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "components/viz/common/resources/shared_image_format_utils.h"
 #include "gpu/command_buffer/common/gpu_memory_buffer_support.h"
 #include "gpu/command_buffer/common/shared_image_usage.h"
@@ -362,7 +363,7 @@ std::unique_ptr<SharedImageBacking> D3DImageBackingFactory::CreateSharedImage(
   const bool needs_shared_handle =
       has_webgpu_usage ||
       (has_gl_usage && (d3d11_device_ != angle_d3d11_device_));
-  if (needs_shared_handle) {
+  if (needs_shared_handle && base::win::GetVersion() >= base::win::Version::WIN8) {
     // TODO(crbug.com/1468604): Many texture formats cannot be shared on old
     // GPUs/drivers to try to detect that and implement a fallback path or
     // disallow Graphite/WebGPU in those cases.
diff --git a/gpu/config/gpu_driver_bug_list.json b/gpu/config/gpu_driver_bug_list.json
index e4176a963cdca..1689bcc6e8761 100644
--- a/gpu/config/gpu_driver_bug_list.json
+++ b/gpu/config/gpu_driver_bug_list.json
@@ -1142,6 +1142,50 @@
         "disable_program_disk_cache"
       ]
     },
+    {
+      "id": 26,
+      "description": "Disable use of Direct3D 11 on Windows Vista and lower",
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<=",
+          "value": "6.0"
+        }
+      },
+      "features": [
+        "disable_d3d11"
+      ]
+    },
+    {
+      "id": 149,
+      "description": "Direct composition flashes black initially on Win <10",
+      "cr_bugs": [588588],
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<",
+          "value": "10.0"
+        }
+      },
+      "features": [
+        "disable_direct_composition"
+      ]
+    },
+    {
+      "id": 170,
+      "description": "Zero copy DXGI video hangs on shutdown on Win < 8.1",
+      "cr_bugs": [621190],
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<",
+          "value": "8.1"
+        }
+      },
+      "features": [
+        "disable_dxgi_zero_copy_video"
+      ]
+    },
     {
       "id": 219,
       "description": "Zero-copy DXGI video hangs or displays incorrect colors on older AMD drivers",
diff --git a/gpu/config/gpu_info_collector_win.cc b/gpu/config/gpu_info_collector_win.cc
index b3fc392c7b8fc..14992248d8ac6 100644
--- a/gpu/config/gpu_info_collector_win.cc
+++ b/gpu/config/gpu_info_collector_win.cc
@@ -187,6 +187,9 @@ void CollectHardwareOverlayInfo(OverlayInfo* overlay_info) {
 bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
   TRACE_EVENT0("gpu", "CollectDriverInfoD3D");
 
+  if (!::GetProcAddress(::GetModuleHandleW(L"dxgi.dll"), "CreateDXGIFactory1"))
+    return false;
+
   Microsoft::WRL::ComPtr<IDXGIFactory1> dxgi_factory;
   HRESULT hr = ::CreateDXGIFactory1(IID_PPV_ARGS(&dxgi_factory));
   if (FAILED(hr))
diff --git a/gpu/config/software_rendering_list.json b/gpu/config/software_rendering_list.json
index 79ea316cf4c63..4254dcc172ff6 100644
--- a/gpu/config/software_rendering_list.json
+++ b/gpu/config/software_rendering_list.json
@@ -350,6 +350,21 @@
         "accelerated_video_decode"
       ]
     },
+    {
+      "id": 79,
+      "description": "Disable GPU on all Windows versions prior to and including Vista",
+      "cr_bugs": [315199],
+      "os": {
+        "type": "win",
+        "version": {
+          "op": "<=",
+          "value": "6.0"
+        }
+      },
+      "features": [
+        "all"
+      ]
+    },
     {
       "id": 68,
       "description": "VMware Fusion 4 has corrupt rendering on Windows",
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index b3c80d0943c74..2392d747f4107 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -231,6 +231,8 @@ source_set("audio") {
       "win/core_audio_util_win.h",
       "win/device_enumeration_win.cc",
       "win/device_enumeration_win.h",
+      "win/wavein_input_win.cc",
+      "win/wavein_input_win.h",
       "win/waveout_output_win.cc",
       "win/waveout_output_win.h",
     ]
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index 185790836e1b8..c20ada15e5e8f 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -235,6 +235,13 @@ bool InitializeUWPSupport() {
     // 10.0.10240.0.
     DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
 
+    if (!(base::win::ResolveCoreWinRTDelayload() &&
+          base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+      // Failed loading functions from combase.dll.
+      DLOG(WARNING) << "Failed to initialize WinRT/UWP";
+      return false;
+    }
+
     return true;
   }();
 
diff --git a/media/audio/win/audio_manager_win.cc b/media/audio/win/audio_manager_win.cc
index b160875beda79..2e27bcf22d3e5 100644
--- a/media/audio/win/audio_manager_win.cc
+++ b/media/audio/win/audio_manager_win.cc
@@ -28,6 +28,7 @@
 #include "media/audio/win/audio_low_latency_output_win.h"
 #include "media/audio/win/core_audio_util_win.h"
 #include "media/audio/win/device_enumeration_win.h"
+#include "media/audio/win/wavein_input_win.h"
 #include "media/audio/win/waveout_output_win.h"
 #include "media/base/audio_parameters.h"
 #include "media/base/channel_layout.h"
@@ -61,6 +62,13 @@ constexpr int kMaxOutputStreams = 50;
 // right drivers, but graceful error handling is needed.
 constexpr int kWinMaxChannels = 8;
 
+// We use 3 buffers for recording audio so that if a recording callback takes
+// some time to return we won't lose audio. More buffers while recording are
+// ok because they don't introduce any delay in recording, unlike in playback
+// where you first need to fill in that number of buffers before starting to
+// play.
+static const int kNumInputBuffers = 3;
+
 // Buffer size to use for input and output stream when a proper size can't be
 // determined from the system
 constexpr int kFallbackBufferSize = 2048;
@@ -157,24 +165,35 @@ void AudioManagerWin::InitializeOnAudioThread() {
   // callback to a WeakPtr: NotifyAllOutputDeviceChangeListeners() will be
   // posted to the audio thread instead of being run synchronously, since we use
   // BindPostTaskToCurrentDefault().
+  if (CoreAudioUtil::IsSupported()) {
   output_device_listener_ = std::make_unique<AudioDeviceListenerWin>(
       base::BindPostTaskToCurrentDefault(base::BindRepeating(
           &AudioManagerWin::NotifyAllOutputDeviceChangeListeners,
           weak_this_on_audio_thread_)));
+  }
 }
 
 void AudioManagerWin::GetAudioDeviceNamesImpl(bool input,
                                               AudioDeviceNames* device_names) {
   DCHECK(device_names->empty());
   // Enumerate all active audio-endpoint capture devices.
-  if (input)
-    GetInputDeviceNamesWin(device_names);
-  else
-    GetOutputDeviceNamesWin(device_names);
-
+  if (!CoreAudioUtil::IsSupported()) {
+    // Utilize the Wave API for Windows 2000/XP.
+    if (input)
+      GetInputDeviceNamesWinXP(device_names);
+    else
+      GetOutputDeviceNamesWinXP(device_names);
+  } else {
+    // Utilize the MMDevice API (part of Core Audio) for Vista and higher.
+    if (input)
+      GetInputDeviceNamesWin(device_names);
+    else
+      GetOutputDeviceNamesWin(device_names);
+  }
   if (!device_names->empty()) {
-    device_names->push_front(AudioDeviceName::CreateCommunications());
-
+	  if (CoreAudioUtil::IsSupported()) {
+		device_names->push_front(AudioDeviceName::CreateCommunications());
+	  }
     // Always add default device parameters as first element.
     device_names->push_front(AudioDeviceName::CreateDefault());
   }
@@ -192,18 +211,22 @@ void AudioManagerWin::GetAudioOutputDeviceNames(
 AudioParameters AudioManagerWin::GetInputStreamParameters(
     const std::string& device_id) {
   AudioParameters parameters;
-  HRESULT hr =
-      CoreAudioUtil::GetPreferredAudioParameters(device_id, false, &parameters);
+  HRESULT hr = E_FAIL;
+  if (CoreAudioUtil::IsSupported()) {
+	hr = CoreAudioUtil::GetPreferredAudioParameters(device_id, false, &parameters);
+  }
 
   if (FAILED(hr) || !parameters.IsValid()) {
+	if (CoreAudioUtil::IsSupported()) {
     LOG(WARNING) << "Unable to get preferred audio params for " << device_id
                  << " 0x" << std::hex << hr;
+	}
     // TODO(tommi): We appear to have callers to GetInputStreamParameters that
     // rely on getting valid audio parameters returned for an invalid or
     // unavailable device. We should track down those code paths (it is likely
     // that they actually don't need a real device but depend on the audio
     // code path somehow for a configuration - e.g. tab capture).
-    parameters = AudioParameters(AudioParameters::AUDIO_PCM_LINEAR,
+    parameters = AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
                                  ChannelLayoutConfig::Stereo(), 48000,
                                  kFallbackBufferSize);
   }
@@ -217,6 +240,11 @@ AudioParameters AudioManagerWin::GetInputStreamParameters(
 
 std::string AudioManagerWin::GetAssociatedOutputDeviceID(
     const std::string& input_device_id) {
+  if (!CoreAudioUtil::IsSupported()) {
+		    NOTIMPLEMENTED()
+        << "GetAssociatedOutputDeviceID is not supported on this OS";
+    return std::string();
+  }
   return CoreAudioUtil::GetMatchingOutputDeviceID(input_device_id);
 }
 
@@ -270,9 +298,14 @@ AudioOutputStream* AudioManagerWin::MakeLowLatencyOutputStream(
     return nullptr;
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceWaveAudio)) {
-    DLOG(WARNING) << "Forcing usage of Windows WaveXxx APIs";
-    return nullptr;
+          switches::kForceWaveAudio) || !CoreAudioUtil::IsSupported()) {
+		// Fall back to Windows Wave implementation on Windows XP or lower.
+		DLOG_IF(ERROR, !device_id.empty() &&
+						   device_id != AudioDeviceDescription::kDefaultDeviceId)
+			<< "Opening by device id not supported by PCMWaveOutAudioOutputStream";
+		DVLOG(1) << "Using WaveOut since WASAPI requires at least Vista.";
+		return new PCMWaveOutAudioOutputStream(
+			this, params, NumberOfWaveOutBuffers(), WAVE_MAPPER);
   }
 
   // Pass an empty string to indicate that we want the default device
@@ -305,7 +338,16 @@ AudioInputStream* AudioManagerWin::MakeLowLatencyInputStream(
     const std::string& device_id,
     const LogCallback& log_callback) {
   // Used for both AUDIO_PCM_LOW_LATENCY and AUDIO_PCM_LINEAR.
-  return new WASAPIAudioInputStream(this, params, device_id, log_callback);
+    AudioInputStream* stream = NULL;
+    if (!CoreAudioUtil::IsSupported()) {
+      // Fall back to Windows Wave implementation on Windows XP or lower.
+      DVLOG(1) << "Using WaveIn since WASAPI requires at least Vista.";
+      stream = CreatePCMWaveInAudioInputStream(params, device_id);
+    } else {
+      stream = new WASAPIAudioInputStream(this, params, device_id, log_callback);
+    }
+
+  return stream;
 }
 
 std::string AudioManagerWin::GetDefaultInputDeviceID() {
@@ -313,6 +355,8 @@ std::string AudioManagerWin::GetDefaultInputDeviceID() {
 }
 
 std::string AudioManagerWin::GetDefaultOutputDeviceID() {
+  if (!CoreAudioUtil::IsSupported())
+    return std::string();
   return CoreAudioUtil::GetDefaultOutputDeviceID();
 }
 
@@ -335,79 +379,91 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
   int min_buffer_size = 0;
   int max_buffer_size = 0;
 
-  if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio)) {
-    // TODO(rtoy): tune these values for best possible WebAudio
-    // performance. WebRTC works well at 48kHz and a buffer size of 480
-    // samples will be used for this case. Note that exclusive mode is
-    // experimental. This sample rate will be combined with a buffer size of
-    // 256 samples, which corresponds to an output delay of ~5.33ms.
-    sample_rate = 48000;
-    buffer_size = 256;
-    if (input_params.IsValid())
-      channel_layout_config = input_params.channel_layout_config();
-  } else {
-    AudioParameters params;
-    HRESULT hr = CoreAudioUtil::GetPreferredAudioParameters(
-        output_device_id.empty() ? GetDefaultOutputDeviceID()
-                                 : output_device_id,
-        true, &params);
-    if (FAILED(hr)) {
-      // This can happen when CoreAudio isn't supported or available
-      // (e.g. certain installations of Windows Server 2008 R2).
-      // Instead of returning the input_params, we'll return invalid
-      // AudioParameters to make sure that an attempt to create this output
-      // stream, won't succeed. This behavior is also consistent with
-      // GetInputStreamParameters.
-      DLOG(ERROR) << "GetPreferredAudioParameters failed: " << std::hex << hr;
-      return AudioParameters();
+  if (CoreAudioUtil::IsSupported()) {
+	  if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio)) {
+		// TODO(rtoy): tune these values for best possible WebAudio
+		// performance. WebRTC works well at 48kHz and a buffer size of 480
+		// samples will be used for this case. Note that exclusive mode is
+		// experimental. This sample rate will be combined with a buffer size of
+		// 256 samples, which corresponds to an output delay of ~5.33ms.
+		sample_rate = 48000;
+		buffer_size = 256;
+		if (input_params.IsValid())
+		  channel_layout_config = input_params.channel_layout_config();
+	  } else {
+		AudioParameters params;
+		HRESULT hr = CoreAudioUtil::GetPreferredAudioParameters(
+			output_device_id.empty() ? GetDefaultOutputDeviceID()
+									 : output_device_id,
+			true, &params);
+		if (FAILED(hr)) {
+		  // This can happen when CoreAudio isn't supported or available
+		  // (e.g. certain installations of Windows Server 2008 R2).
+		  // Instead of returning the input_params, we'll return invalid
+		  // AudioParameters to make sure that an attempt to create this output
+		  // stream, won't succeed. This behavior is also consistent with
+		  // GetInputStreamParameters.
+		  DLOG(ERROR) << "GetPreferredAudioParameters failed: " << std::hex << hr;
+		  return AudioParameters();
+		}
+		DVLOG(1) << params.AsHumanReadableString();
+		DCHECK(params.IsValid());
+
+		channel_layout_config = params.channel_layout_config();
+		buffer_size = params.frames_per_buffer();
+		sample_rate = params.sample_rate();
+		effects = params.effects();
+
+		AudioParameters::HardwareCapabilities hardware_capabilities =
+			params.hardware_capabilities().value_or(
+				AudioParameters::HardwareCapabilities());
+		min_buffer_size = hardware_capabilities.min_frames_per_buffer;
+		max_buffer_size = hardware_capabilities.max_frames_per_buffer;
+	  }
+
+	  if (input_params.IsValid()) {
+		// If the user has enabled checking supported channel layouts or we don't
+		// have a valid channel layout yet, try to use the input layout.  See bugs
+		// http://crbug.com/259165 and http://crbug.com/311906 for more details.
+		if (cmd_line->HasSwitch(switches::kTrySupportedChannelLayouts) ||
+			channel_layout_config.channel_layout() == CHANNEL_LAYOUT_UNSUPPORTED) {
+		  // Check if it is possible to open up at the specified input channel
+		  // layout but avoid checking if the specified layout is the same as the
+		  // hardware (preferred) layout. We do this extra check to avoid the
+		  // CoreAudioUtil::IsChannelLayoutSupported() overhead in most cases.
+		  if (input_params.channel_layout() !=
+			  channel_layout_config.channel_layout()) {
+			// TODO(henrika): Internally, IsChannelLayoutSupported does many of the
+			// operations that have already been done such as opening up a client
+			// and fetching the WAVEFORMATPCMEX format.  Ideally we should only do
+			// that once.  Then here, we can check the layout from the data we
+			// already hold.
+			if (CoreAudioUtil::IsChannelLayoutSupported(
+					output_device_id, eRender, eConsole,
+					input_params.channel_layout())) {
+			  // Open up using the same channel layout as the source if it is
+			  // supported by the hardware.
+			  channel_layout_config = input_params.channel_layout_config();
+			  DVLOG(1) << "Hardware channel layout is not used; using same layout"
+					   << " as the source instead ("
+					   << channel_layout_config.channel_layout() << ")";
+			}
+		  }
+		}
     }
-    DVLOG(1) << params.AsHumanReadableString();
-    DCHECK(params.IsValid());
-
-    channel_layout_config = params.channel_layout_config();
-    buffer_size = params.frames_per_buffer();
-    sample_rate = params.sample_rate();
-    effects = params.effects();
-
-    AudioParameters::HardwareCapabilities hardware_capabilities =
-        params.hardware_capabilities().value_or(
-            AudioParameters::HardwareCapabilities());
-    min_buffer_size = hardware_capabilities.min_frames_per_buffer;
-    max_buffer_size = hardware_capabilities.max_frames_per_buffer;
-  }
+    effects |= input_params.effects();
 
-  if (input_params.IsValid()) {
-    // If the user has enabled checking supported channel layouts or we don't
-    // have a valid channel layout yet, try to use the input layout.  See bugs
-    // http://crbug.com/259165 and http://crbug.com/311906 for more details.
-    if (cmd_line->HasSwitch(switches::kTrySupportedChannelLayouts) ||
-        channel_layout_config.channel_layout() == CHANNEL_LAYOUT_UNSUPPORTED) {
-      // Check if it is possible to open up at the specified input channel
-      // layout but avoid checking if the specified layout is the same as the
-      // hardware (preferred) layout. We do this extra check to avoid the
-      // CoreAudioUtil::IsChannelLayoutSupported() overhead in most cases.
-      if (input_params.channel_layout() !=
-          channel_layout_config.channel_layout()) {
-        // TODO(henrika): Internally, IsChannelLayoutSupported does many of the
-        // operations that have already been done such as opening up a client
-        // and fetching the WAVEFORMATPCMEX format.  Ideally we should only do
-        // that once.  Then here, we can check the layout from the data we
-        // already hold.
-        if (CoreAudioUtil::IsChannelLayoutSupported(
-                output_device_id, eRender, eConsole,
-                input_params.channel_layout())) {
-          // Open up using the same channel layout as the source if it is
-          // supported by the hardware.
-          channel_layout_config = input_params.channel_layout_config();
-          DVLOG(1) << "Hardware channel layout is not used; using same layout"
-                   << " as the source instead ("
-                   << channel_layout_config.channel_layout() << ")";
-        }
-      }
+    if (!CoreAudioUtil::IsSupported()) {
+      // If WASAPI isn't supported we'll fallback to WaveOut, which will take
+      // care of resampling and bits per sample changes.  By setting these
+      // equal to the input values, AudioOutputResampler will skip resampling
+      // and bit per sample differences (since the input parameters will match
+      // the output parameters).
+      buffer_size = input_params.frames_per_buffer();
+      sample_rate = input_params.sample_rate();
+	  channel_layout_config = input_params.channel_layout_config();
     }
 
-    effects |= input_params.effects();
-
     // Allow non-default buffer sizes if we have a valid min and max.
     if (min_buffer_size > 0 && max_buffer_size > 0) {
       buffer_size =
@@ -438,6 +494,23 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
   return params;
 }
 
+AudioInputStream* AudioManagerWin::CreatePCMWaveInAudioInputStream(
+    const AudioParameters& params,
+    const std::string& device_id) {
+  std::string xp_device_id = device_id;
+  if (device_id != AudioDeviceDescription::kDefaultDeviceId) {
+    xp_device_id = ConvertToWinXPInputDeviceId(device_id);
+    if (xp_device_id.empty()) {
+      DLOG(ERROR) << "Cannot find a waveIn device which matches the device ID "
+                  << device_id;
+      return NULL;
+    }
+  }
+
+  return new PCMWaveInAudioInputStream(this, params, kNumInputBuffers,
+                                       xp_device_id);
+}
+
 // static
 std::unique_ptr<AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
diff --git a/media/audio/win/audio_manager_win.h b/media/audio/win/audio_manager_win.h
index 0a53e62efa795..5417b2902a95f 100644
--- a/media/audio/win/audio_manager_win.h
+++ b/media/audio/win/audio_manager_win.h
@@ -74,6 +74,15 @@ class MEDIA_EXPORT AudioManagerWin : public AudioManagerBase {
   // Allow unit test to modify the utilized enumeration API.
   friend class AudioManagerTest;
 
+  // Returns a PCMWaveInAudioInputStream instance or NULL on failure.
+  // This method converts MMDevice-style device ID to WaveIn-style device ID if
+  // necessary.
+  // (Please see device_enumeration_win.h for more info about the two kinds of
+  // device IDs.)
+  AudioInputStream* CreatePCMWaveInAudioInputStream(
+      const AudioParameters& params,
+      const std::string& device_id);
+
   // Helper methods for performing expensive initialization tasks on the audio
   // thread instead of on the UI thread which AudioManager is constructed on.
   void InitializeOnAudioThread();
diff --git a/media/audio/win/device_enumeration_win.cc b/media/audio/win/device_enumeration_win.cc
index 11b1678768a10..75f9ac80ec71b 100644
--- a/media/audio/win/device_enumeration_win.cc
+++ b/media/audio/win/device_enumeration_win.cc
@@ -165,6 +165,54 @@ bool GetOutputDeviceNamesWinXP(AudioDeviceNames* device_names) {
                                  waveOutGetDevCapsW>(device_names);
 }
 
+std::string ConvertToWinXPInputDeviceId(const std::string& device_id) {
+  UINT number_of_active_devices = waveInGetNumDevs();
+  MMRESULT result = MMSYSERR_NOERROR;
+
+  UINT i = 0;
+  for (; i < number_of_active_devices; ++i) {
+    size_t size = 0;
+    // Get the size (including the terminating NULL) of the endpoint ID of the
+    // waveIn device.
+    result = waveInMessage(reinterpret_cast<HWAVEIN>(i),
+                           DRV_QUERYFUNCTIONINSTANCEIDSIZE,
+                           reinterpret_cast<DWORD_PTR>(&size), NULL);
+    if (result != MMSYSERR_NOERROR)
+      continue;
+
+    ScopedCoMem<WCHAR> id;
+    id.Reset(static_cast<WCHAR*>(CoTaskMemAlloc(size)));
+    if (!id)
+      continue;
+
+    // Get the endpoint ID string for this waveIn device.
+    result = waveInMessage(
+        reinterpret_cast<HWAVEIN>(i), DRV_QUERYFUNCTIONINSTANCEID,
+        reinterpret_cast<DWORD_PTR>(static_cast<WCHAR*>(id)), size);
+    if (result != MMSYSERR_NOERROR)
+      continue;
+
+    std::string utf8_id = base::WideToUTF8(static_cast<WCHAR*>(id));
+    // Check whether the endpoint ID string of this waveIn device matches that
+    // of the audio endpoint device.
+    if (device_id == utf8_id)
+      break;
+  }
+
+  // If a matching waveIn device was found, convert the unique endpoint ID
+  // string to a standard friendly name with max 32 characters.
+  if (i < number_of_active_devices) {
+    WAVEINCAPS capabilities;
+
+    result = waveInGetDevCaps(i, &capabilities, sizeof(capabilities));
+    if (result == MMSYSERR_NOERROR)
+      return base::WideToUTF8(capabilities.szPname);
+  }
+
+  return std::string();
+
+}
+
 std::string GetDeviceSuffixWin(const std::string& controller_id) {
   std::string suffix;
   if (controller_id.size() >= 21 && controller_id.substr(0, 8) == "USB\\VID_" &&
diff --git a/media/audio/win/device_enumeration_win.h b/media/audio/win/device_enumeration_win.h
index d6f73a8424496..0c3eed8ce4e03 100644
--- a/media/audio/win/device_enumeration_win.h
+++ b/media/audio/win/device_enumeration_win.h
@@ -28,8 +28,17 @@ bool GetOutputDeviceNamesWin(media::AudioDeviceNames* device_names);
 // Example record in the output list:
 // - device_name: "Microphone (Realtek High Defini".
 // - unique_id: "Microphone (Realtek High Defini" (same as friendly name).
+bool GetInputDeviceNamesWinXP(media::AudioDeviceNames* device_names);
 bool GetOutputDeviceNamesWinXP(media::AudioDeviceNames* device_names);
 
+// Converts an input device ID generated by |GetInputDeviceNamesWin()| to the
+// corresponding ID by |GetInputDeviceNamesWinXP()|. Returns an empty string on
+// failure.
+// Example input and output:
+// - input ID: "{0.0.1.00000000}.{8db6020f-18e3-4f25-b6f5-7726c9122574}"
+// - output ID: "Microphone (Realtek High Defini"
+std::string ConvertToWinXPInputDeviceId(const std::string& device_id);
+
 // Given a string |controller_id| with the controller ID of an audio device,
 // returns a string containing extra information about the device.
 // If the device is a USB device, the format of the returned string is
diff --git a/media/audio/win/wavein_input_win.cc b/media/audio/win/wavein_input_win.cc
new file mode 100644
index 0000000000000..dfd016042567a
--- /dev/null
+++ b/media/audio/win/wavein_input_win.cc
@@ -0,0 +1,333 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/audio/win/wavein_input_win.h"
+
+#include "base/logging.h"
+#include "base/time/time.h"
+#include "media/audio/audio_device_description.h"
+#include "media/audio/audio_io.h"
+#include "media/audio/win/audio_manager_win.h"
+#include "media/audio/win/device_enumeration_win.h"
+#include "media/base/audio_bus.h"
+
+namespace media {
+
+// Our sound buffers are allocated once and kept in a linked list using the
+// the WAVEHDR::dwUser variable. The last buffer points to the first buffer.
+static WAVEHDR* GetNextBuffer(WAVEHDR* current) {
+  return reinterpret_cast<WAVEHDR*>(current->dwUser);
+}
+
+constexpr SampleFormat kSampleFormat = kSampleFormatS16;
+
+PCMWaveInAudioInputStream::PCMWaveInAudioInputStream(
+    AudioManagerWin* manager,
+    const AudioParameters& params,
+    int num_buffers,
+    const std::string& device_id)
+    : state_(kStateEmpty),
+      manager_(manager),
+      callback_(nullptr),
+      num_buffers_(num_buffers),
+      channels_(params.channels()),
+      device_id_(device_id),
+      wavein_(nullptr),
+      buffer_(nullptr),
+      audio_bus_(media::AudioBus::Create(params)) {
+  DCHECK_GT(num_buffers_, 0);
+  format_.wFormatTag = WAVE_FORMAT_PCM;
+  format_.nChannels = params.channels() > 2 ? 2 : params.channels();
+  format_.nSamplesPerSec = params.sample_rate();
+  format_.wBitsPerSample = SampleFormatToBitsPerChannel(kSampleFormat);
+  format_.cbSize = 0;
+  format_.nBlockAlign = (format_.nChannels * format_.wBitsPerSample) / 8;
+  format_.nAvgBytesPerSec = format_.nBlockAlign * format_.nSamplesPerSec;
+  buffer_size_ = params.frames_per_buffer() * format_.nBlockAlign;
+  // If we don't have a packet size we use 100ms.
+  if (!buffer_size_)
+    buffer_size_ = format_.nAvgBytesPerSec / 10;
+  // The event is auto-reset.
+  stopped_event_.Set(::CreateEventW(NULL, FALSE, FALSE, NULL));
+}
+
+PCMWaveInAudioInputStream::~PCMWaveInAudioInputStream() {
+  DCHECK(NULL == wavein_);
+}
+
+AudioInputStream::OpenOutcome PCMWaveInAudioInputStream::Open() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateEmpty)
+    return AudioInputStream::OpenOutcome::kFailed;
+  if (num_buffers_ < 2 || num_buffers_ > 10)
+    return AudioInputStream::OpenOutcome::kFailed;
+
+  // Convert the stored device id string into an unsigned integer
+  // corresponding to the selected device.
+  UINT device_id = WAVE_MAPPER;
+  if (!GetDeviceId(&device_id)) {
+    return AudioInputStream::OpenOutcome::kFailed;
+  }
+
+  // Open the specified input device for recording.
+  MMRESULT result = MMSYSERR_NOERROR;
+  result = ::waveInOpen(&wavein_, device_id, &format_,
+                        reinterpret_cast<DWORD_PTR>(WaveCallback),
+                        reinterpret_cast<DWORD_PTR>(this),
+                        CALLBACK_FUNCTION);
+  if (result != MMSYSERR_NOERROR)
+    return AudioInputStream::OpenOutcome::kFailed;
+
+  SetupBuffers();
+  state_ = kStateReady;
+  return AudioInputStream::OpenOutcome::kSuccess;
+}
+
+void PCMWaveInAudioInputStream::SetupBuffers() {
+  WAVEHDR* last = NULL;
+  WAVEHDR* first = NULL;
+  WAVEHDR* buffer_local = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    uint32_t sz = sizeof(WAVEHDR) + buffer_size_;
+    buffer_ =  reinterpret_cast<WAVEHDR*>(new char[sz]);
+    buffer_->lpData = reinterpret_cast<char*>(buffer_local) + sizeof(WAVEHDR);
+    buffer_->dwBufferLength = buffer_size_;
+    buffer_->dwBytesRecorded = 0;
+    buffer_->dwUser = reinterpret_cast<DWORD_PTR>(last);
+    buffer_->dwFlags = WHDR_DONE;
+    buffer_->dwLoops = 0;
+    if (ix == 0)
+      first = buffer_;
+    last = buffer_;
+    ::waveInPrepareHeader(wavein_, buffer_, sizeof(WAVEHDR));
+  }
+  // Fix the first buffer to point to the last one.
+  first->dwUser = reinterpret_cast<DWORD_PTR>(last);
+}
+
+void PCMWaveInAudioInputStream::FreeBuffers() {
+  WAVEHDR* current = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    WAVEHDR* next = GetNextBuffer(current);
+    if (current->dwFlags & WHDR_PREPARED)
+      ::waveInUnprepareHeader(wavein_, current, sizeof(WAVEHDR));
+    delete[] reinterpret_cast<char*>(current);
+    current = next;
+  }
+  buffer_ = nullptr;
+}
+
+void PCMWaveInAudioInputStream::Start(AudioInputCallback* callback) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateReady)
+    return;
+
+  DCHECK(!callback_);
+  callback_ = callback;
+  state_ = kStateRecording;
+
+  WAVEHDR* buffer = buffer_;
+  for (int ix = 0; ix != num_buffers_; ++ix) {
+    QueueNextPacket(buffer);
+    buffer = GetNextBuffer(buffer);
+  }
+  buffer = buffer_;
+
+  MMRESULT result = ::waveInStart(wavein_);
+  if (result != MMSYSERR_NOERROR) {
+    HandleError(result);
+    state_ = kStateReady;
+    callback_ = nullptr;
+  }
+}
+
+// Stopping is tricky. First, no buffer should be locked by the audio driver
+// or else the waveInReset() will deadlock and secondly, the callback should
+// not be inside the AudioInputCallback's OnData because waveInReset()
+// forcefully kills the callback thread.
+void PCMWaveInAudioInputStream::Stop() {
+  DVLOG(1) << "PCMWaveInAudioInputStream::Stop()";
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (state_ != kStateRecording)
+    return;
+
+  bool already_stopped = false;
+  {
+    // Tell the callback that we're stopping.
+    // As a result, |stopped_event_| will be signaled in callback method.
+    base::AutoLock auto_lock(lock_);
+    already_stopped = (callback_ == nullptr);
+    callback_ = nullptr;
+  }
+
+  if (already_stopped)
+    return;
+
+  // Wait for the callback to finish, it will signal us when ready to be reset.
+  DWORD wait = ::WaitForSingleObject(stopped_event_.Get(), INFINITE);
+  DCHECK_EQ(wait, WAIT_OBJECT_0);
+
+  // Stop input and reset the current position to zero for |wavein_|.
+  // All pending buffers are marked as done and returned to the application.
+  MMRESULT res = ::waveInReset(wavein_);
+  DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+
+  state_ = kStateReady;
+}
+
+void PCMWaveInAudioInputStream::Close() {
+  DVLOG(1) << "PCMWaveInAudioInputStream::Close()";
+  DCHECK(thread_checker_.CalledOnValidThread());
+
+  // We should not call Close() while recording. Catch it with DCHECK and
+  // implement auto-stop just in case.
+  DCHECK_NE(state_, kStateRecording);
+  Stop();
+
+  if (wavein_) {
+    FreeBuffers();
+
+    // waveInClose() generates a WIM_CLOSE callback.  In case Start() was never
+    // called, force a reset to ensure close succeeds.
+    MMRESULT res = ::waveInReset(wavein_);
+    DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+    res = ::waveInClose(wavein_);
+    DCHECK_EQ(res, static_cast<MMRESULT>(MMSYSERR_NOERROR));
+    state_ = kStateClosed;
+    wavein_ = NULL;
+  }
+
+  // Tell the audio manager that we have been released. This can result in
+  // the manager destroying us in-place so this needs to be the last thing
+  // we do on this function.
+  manager_->ReleaseInputStream(this);
+}
+
+double PCMWaveInAudioInputStream::GetMaxVolume() {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  return 0.0;
+}
+
+void PCMWaveInAudioInputStream::SetVolume(double volume) {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+}
+
+double PCMWaveInAudioInputStream::GetVolume() {
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  return 0.0;
+}
+
+bool PCMWaveInAudioInputStream::SetAutomaticGainControl(bool enabled) {
+  // TODO(henrika): Add AGC support when volume control has been added.
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool PCMWaveInAudioInputStream::GetAutomaticGainControl() {
+  // TODO(henrika): Add AGC support when volume control has been added.
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool PCMWaveInAudioInputStream::IsMuted() {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void PCMWaveInAudioInputStream::HandleError(MMRESULT error) {
+  DLOG(WARNING) << "PCMWaveInAudio error " << error;
+  if (callback_)
+    callback_->OnError();
+}
+
+void PCMWaveInAudioInputStream::QueueNextPacket(WAVEHDR *buffer) {
+  MMRESULT res = ::waveInAddBuffer(wavein_, buffer, sizeof(WAVEHDR));
+  if (res != MMSYSERR_NOERROR)
+    HandleError(res);
+}
+
+bool PCMWaveInAudioInputStream::GetDeviceId(UINT* device_index) {
+  // Deliver the default input device id (WAVE_MAPPER) if the default
+  // device has been selected.
+  if (device_id_ == AudioDeviceDescription::kDefaultDeviceId) {
+    *device_index = WAVE_MAPPER;
+    return true;
+  }
+
+  // Get list of all available and active devices.
+  AudioDeviceNames device_names;
+  if (!media::GetInputDeviceNamesWinXP(&device_names))
+    return false;
+
+  if (device_names.empty())
+    return false;
+
+  // Search the full list of devices and compare with the specified
+  // device id which was specified in the constructor. Stop comparing
+  // when a match is found and return the corresponding index.
+  UINT index = 0;
+  bool found_device = false;
+  AudioDeviceNames::const_iterator it = device_names.begin();
+  while (it != device_names.end()) {
+    if (it->unique_id.compare(device_id_) == 0) {
+      *device_index = index;
+      found_device = true;
+      break;
+    }
+    ++index;
+    ++it;
+  }
+
+  return found_device;
+}
+
+// Windows calls us back in this function when some events happen. Most notably
+// when it has an audio buffer with recorded data.
+void PCMWaveInAudioInputStream::WaveCallback(HWAVEIN hwi, UINT msg,
+                                             DWORD_PTR instance,
+                                             DWORD_PTR param1, DWORD_PTR) {
+  PCMWaveInAudioInputStream* obj =
+      reinterpret_cast<PCMWaveInAudioInputStream*>(instance);
+
+  // The lock ensures that Stop() can't be called during a callback.
+  base::AutoLock auto_lock(obj->lock_);
+
+  if (msg == WIM_DATA) {
+    // The WIM_DATA message is sent when waveform-audio data is present in
+    // the input buffer and the buffer is being returned to the application.
+    // The message can be sent when the buffer is full or after the
+    // waveInReset function is called.
+    if (obj->callback_) {
+      // TODO(henrika): the |volume| parameter is always set to zero since
+      // there is currently no support for controlling the microphone volume
+      // level.
+      WAVEHDR* buffer = reinterpret_cast<WAVEHDR*>(param1);
+      obj->audio_bus_->FromInterleaved<SignedInt16SampleTypeTraits>(
+          reinterpret_cast<int16_t*>(buffer->lpData), obj->audio_bus_->frames());
+      obj->callback_->OnData(obj->audio_bus_.get(), base::TimeTicks::Now(), 0.0, {});
+
+      // Queue the finished buffer back with the audio driver. Since we are
+      // reusing the same buffers we can get away without calling
+      // waveInPrepareHeader.
+      obj->QueueNextPacket(buffer);
+    } else {
+      // Main thread has called Stop() and set |callback_| to NULL and is
+      // now waiting to issue waveInReset which will kill this thread.
+      // We should not call AudioSourceCallback code anymore.
+      ::SetEvent(obj->stopped_event_.Get());
+    }
+  } else if (msg == WIM_CLOSE) {
+    // Intentionaly no-op for now.
+  } else if (msg == WIM_OPEN) {
+    // Intentionaly no-op for now.
+  }
+}
+
+void PCMWaveInAudioInputStream::SetOutputDeviceForAec(
+    const std::string& output_device_id) {
+  // Not supported. Do nothing.
+}
+
+
+}  // namespace media
\ No newline at end of file
diff --git a/media/audio/win/wavein_input_win.h b/media/audio/win/wavein_input_win.h
new file mode 100644
index 0000000000000..2a38e16327599
--- /dev/null
+++ b/media/audio/win/wavein_input_win.h
@@ -0,0 +1,141 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
+#define MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
+
+#include <windows.h>
+#include <mmsystem.h>
+#include <stdint.h>
+
+#include <memory>
+#include <string>
+
+#include "base/compiler_specific.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/thread_checker.h"
+#include "base/win/scoped_handle.h"
+#include "media/audio/audio_io.h"
+#include "media/audio/audio_manager_base.h"
+#include "media/base/audio_parameters.h"
+
+// Put this in the declarations for a class to be uncopyable and unassignable.
+
+
+namespace media {
+
+class AudioBus;
+class AudioManagerWin;
+
+class PCMWaveInAudioInputStream : public  AudioInputStream {
+ public:
+  // The ctor takes all the usual parameters, plus |manager| which is the
+  // the audio manager who is creating this object and |device_id| which
+  // is provided by the operating system.
+  PCMWaveInAudioInputStream(AudioManagerWin* manager,
+                            const AudioParameters& params,
+                            int num_buffers,
+                            const std::string& device_id);
+  ~PCMWaveInAudioInputStream() override;
+
+  // Implementation of AudioInputStream.
+  OpenOutcome Open() override;
+  void Start(AudioInputCallback* callback) override;
+  void Stop() override;
+  void Close() override;
+  // TODO(henrika): Add volume support using the Audio Mixer API.
+  double GetMaxVolume() override;
+  void SetVolume(double volume) override;
+  double GetVolume() override;
+  bool SetAutomaticGainControl(bool enabled) override;
+  bool GetAutomaticGainControl() override;
+  bool IsMuted() override;
+  void SetOutputDeviceForAec(const std::string& output_device_id) override;
+
+ private:
+  enum State {
+    kStateEmpty,      // Initial state.
+    kStateReady,      // Device obtained and ready to record.
+    kStateRecording,  // Recording audio.
+    kStateStopping,   // Trying to stop, waiting for callback to finish.
+    kStateStopped,    // Stopped. Device was reset.
+    kStateClosed      // Device has been released.
+  };
+
+  // Allow unit tests to query the device ID.
+  friend class AudioManagerTest;
+
+  // Windows calls us back with the recorded audio data here. See msdn
+  // documentation for 'waveInProc' for details about the parameters.
+  static void CALLBACK WaveCallback(HWAVEIN hwi, UINT msg, DWORD_PTR instance,
+                                    DWORD_PTR param1, DWORD_PTR param2);
+
+  // If windows reports an error this function handles it and passes it to
+  // the attached AudioInputCallback::OnError().
+  void HandleError(MMRESULT error);
+
+  // Allocates and prepares the memory that will be used for recording.
+  void SetupBuffers();
+
+  // Deallocates the memory allocated in SetupBuffers.
+  void FreeBuffers();
+
+  // Sends a buffer to the audio driver for recording.
+  void QueueNextPacket(WAVEHDR* buffer);
+
+  // Converts the stored device id string into an unsigned integer which
+  // can be used by waveInOpen() to open the specified capture device.
+  bool GetDeviceId(UINT* device_index);
+
+  base::ThreadChecker thread_checker_;
+
+  // Reader beware. Visual C has stronger guarantees on volatile vars than
+  // most people expect. In fact, it has release semantics on write and
+  // acquire semantics on reads. See the msdn documentation.
+  volatile State state_;
+
+  // The audio manager that created this input stream. We notify it when
+  // we close so it can release its own resources.
+  raw_ptr<AudioManagerWin> manager_;
+
+  // We use the callback mostly to periodically give the recorded audio data.
+  raw_ptr<AudioInputCallback> callback_;
+
+  // The number of buffers of size |buffer_size_| each to use.
+  const int num_buffers_;
+
+  // The size in bytes of each audio buffer.
+  uint32_t buffer_size_;
+
+  // Channels, 1 or 2.
+  const int channels_;
+
+  // Contains the unique name of the selected endpoint device.
+  // Note that AudioDeviceDescription::kDefaultDeviceId represents the default
+  // device role and is not a valid ID as such.
+  std::string device_id_;
+
+  // Windows native structure to encode the format parameters.
+  WAVEFORMATEX format_;
+
+  // Handle to the instance of the wave device.
+  HWAVEIN wavein_;
+
+  // Pointer to the first allocated audio buffer. This object owns it.
+  raw_ptr<WAVEHDR> buffer_;
+
+  // An event that is signaled when the callback thread is ready to stop.
+  base::win::ScopedHandle stopped_event_;
+
+  // Lock used to avoid conflicts when Stop() is called during a callback.
+  base::Lock lock_;
+
+  // Extra audio bus used for storage of deinterleaved data for the OnData
+  // callback.
+  std::unique_ptr<media::AudioBus> audio_bus_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_AUDIO_WIN_WAVEIN_INPUT_WIN_H_
\ No newline at end of file
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/media/capture/video/win/video_capture_device_factory_win.cc
index 16841257c164d..578577652451a 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/media/capture/video/win/video_capture_device_factory_win.cc
@@ -303,6 +303,16 @@ bool DevicesInfoContainsDeviceId(const DevicesInfo& devices_info,
                         });
 }
 
+bool IsEnclosureLocationSupported() {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
+  return true;
+}
+
 // Returns a non DirectShow descriptor DevicesInfo with the provided name and
 // model.
 DevicesInfo::const_iterator FindNonDirectShowDeviceInfoByNameAndModel(
@@ -752,17 +762,23 @@ void VideoCaptureDeviceFactoryWin::GetDevicesInfo(
     devices_info = GetDevicesInfoDirectShow(devices_info);
   }
 
-  com_thread_.init_com_with_mta(true);
-  com_thread_.Start();
-  com_thread_data_ =
+  if (IsEnclosureLocationSupported()) {
+   com_thread_.init_com_with_mta(true);
+   com_thread_.Start();
+   com_thread_data_ =
       base::MakeRefCounted<VideoCaptureDeviceFactoryWin::ComThreadData>(
           weak_ptr_factory_.GetWeakPtr(), com_thread_.task_runner(),
           base::SingleThreadTaskRunner::GetCurrentDefault());
-  com_thread_.task_runner()->PostTask(
+   com_thread_.task_runner()->PostTask(
       FROM_HERE,
       base::BindOnce(
           &VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP,
           com_thread_data_, std::move(devices_info), std::move(callback)));
+
+  } else {
+    DeviceInfoReady(std::move(devices_info), std::move(callback));
+  }
+
 }
 
 void VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP(
diff --git a/media/cdm/win/media_foundation_cdm_module.cc b/media/cdm/win/media_foundation_cdm_module.cc
index 28fbd5d233a83..963314b8c0452 100644
--- a/media/cdm/win/media_foundation_cdm_module.cc
+++ b/media/cdm/win/media_foundation_cdm_module.cc
@@ -129,6 +129,10 @@ HRESULT MediaFoundationCdmModule::ActivateCdmFactory() {
     return kErrorLoadLibrary;
   }
 
+  // Initialization required to call base::win::ScopedHString::Create();
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Get function pointer to the activation factory.
   using GetActivationFactoryFunc =
       HRESULT(WINAPI*)(_In_ HSTRING activatible_class_id,
diff --git a/media/filters/passthrough_dts_audio_decoder.h b/media/filters/passthrough_dts_audio_decoder.h
index 6cec47a26e3db..1b7595fb34164 100644
--- a/media/filters/passthrough_dts_audio_decoder.h
+++ b/media/filters/passthrough_dts_audio_decoder.h
@@ -60,7 +60,7 @@ class MEDIA_EXPORT PassthroughDTSAudioDecoder : public AudioDecoder {
 
   AudioDecoderConfig config_;
 
-  MediaLog* media_log_;
+  raw_ptr<MediaLog> media_log_;
 
   scoped_refptr<AudioBufferMemoryPool> pool_;
 };
diff --git a/media/midi/midi_manager_winrt.cc b/media/midi/midi_manager_winrt.cc
index d5ce6175bffbf..5ee947135e9ee 100644
--- a/media/midi/midi_manager_winrt.cc
+++ b/media/midi/midi_manager_winrt.cc
@@ -822,6 +822,17 @@ void MidiManagerWinrt::InitializeOnComRunner() {
 
   DCHECK(service()->task_service()->IsOnTaskRunner(kComTaskRunner));
 
+  bool preload_success = base::win::ResolveCoreWinRTDelayload() &&
+                         ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!preload_success) {
+    service()->task_service()->PostBoundTask(
+        kDefaultTaskRunner,
+        base::BindOnce(&MidiManagerWinrt::CompleteInitialization,
+                       base::Unretained(this), Result::INITIALIZATION_ERROR));
+    return;
+  }
+
   port_manager_in_ = std::make_unique<MidiInPortManager>(this);
   port_manager_out_ = std::make_unique<MidiOutPortManager>(this);
 
diff --git a/media/renderers/win/media_foundation_protection_manager.cc b/media/renderers/win/media_foundation_protection_manager.cc
index cd4b85d979afa..cd27c6f07fd86 100644
--- a/media/renderers/win/media_foundation_protection_manager.cc
+++ b/media/renderers/win/media_foundation_protection_manager.cc
@@ -37,6 +37,9 @@ HRESULT MediaFoundationProtectionManager::RuntimeClassInitialize(
   task_runner_ = std::move(task_runner);
   waiting_cb_ = std::move(waiting_cb);
 
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Init an empty |property_set_| as MFMediaEngine could access it via
   // |get_Properties| before we populate it within SetPMPServer.
   base::win::ScopedHString property_set_id = base::win::ScopedHString::Create(
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
index da19df4f20b5d..ba05f58ae6762 100644
--- a/mojo/core/embedder/embedder.cc
+++ b/mojo/core/embedder/embedder.cc
@@ -28,6 +28,10 @@
 #include "mojo/core/node_controller.h"
 #include "mojo/public/c/system/thunks.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif // BUILDFLAG(IS_WIN)
+
 #if !BUILDFLAG(IS_NACL)
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
 #include "mojo/core/channel_linux.h"
@@ -86,7 +90,20 @@ void InitFeatures() {
 }
 
 void EnableMojoIpcz() {
-  g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+#if BUILDFLAG(IS_WIN)
+  // TODO(https://crbug.com/1299283): Sandboxed processes on Windows versions
+  // older than 8.1 require some extra (not yet implemented... err... never implemented) setup for ipcz to
+  // work properly. This is omitted for early experimentation.
+  const bool kIsIpczSupported =
+      base::win::GetVersion() >= base::win::Version::WIN8_1;
+#else
+  const bool kIsIpczSupported = true;
+#endif
+  if (kIsIpczSupported) {
+    g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+  }
+  else
+    g_mojo_ipcz_enabled.store(false, std::memory_order_release);
 }
 
 void Init(const Configuration& configuration) {
diff --git a/net/proxy_resolution/win/winhttp_status.h b/net/proxy_resolution/win/winhttp_status.h
index ae5f9ee08ba6a..975d714dab343 100644
--- a/net/proxy_resolution/win/winhttp_status.h
+++ b/net/proxy_resolution/win/winhttp_status.h
@@ -19,6 +19,9 @@ enum class WinHttpStatus {
   // Aborted by caller.
   kAborted,
 
+  // WinHttp binary failed to load.
+  kFunctionsNotLoaded,
+
   // WinHttpOpen() API failed.
   kWinHttpOpenFailed,
 
diff --git a/net/socket/ssl_client_socket_impl.cc b/net/socket/ssl_client_socket_impl.cc
index eeb27239bb883..f00690af09775 100644
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -298,7 +298,8 @@ class SSLClientSocketImpl::SSLContext {
     SSL_CTX_sess_set_new_cb(ssl_ctx_.get(), NewSessionCallback);
     SSL_CTX_set_timeout(ssl_ctx_.get(), 1 * 60 * 60 /* one hour */);
 
-    SSL_CTX_set_grease_enabled(ssl_ctx_.get(), 1);
+	int grease_mode = !base::CommandLine::ForCurrentProcess()->HasSwitch("disable-grease-tls");
+    SSL_CTX_set_grease_enabled(ssl_ctx_.get(), grease_mode);
 
     // Deduplicate all certificates minted from the SSL_CTX in memory.
     SSL_CTX_set0_buffer_pool(ssl_ctx_.get(), x509_util::GetBufferPool());
diff --git a/sandbox/policy/BUILD.gn b/sandbox/policy/BUILD.gn
index fa0edf457b612..51d49af3aa46c 100644
--- a/sandbox/policy/BUILD.gn
+++ b/sandbox/policy/BUILD.gn
@@ -164,6 +164,8 @@ component("policy") {
       "win/sandbox_win.h",
     ]
     deps += [ "//sandbox/win:sandbox" ]
+
+    public_deps += [ "//ui/gfx" ]
   }
   if (is_fuchsia) {
     sources += [
diff --git a/sandbox/policy/win/sandbox_warmup.cc b/sandbox/policy/win/sandbox_warmup.cc
index 1c5142a49ceb7..fa36708b609a6 100644
--- a/sandbox/policy/win/sandbox_warmup.cc
+++ b/sandbox/policy/win/sandbox_warmup.cc
@@ -18,48 +18,16 @@
 #include <NTSecAPI.h>
 #undef SystemFunction036
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace sandbox::policy {
 
-namespace {
-
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
-}  // namespace
-
 void WarmupRandomnessInfrastructure() {
   BYTE data[1];
-
-  if (base::FeatureList::IsEnabled(
-          sandbox::policy::features::kWinSboxWarmupProcessPrng)) {
-    // TODO(crbug.com/74242) Call a warmup function exposed by boringssl.
-    static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-    BOOL success = process_prng_fn(data, sizeof(data));
-    // ProcessPrng is documented to always return TRUE.
-    CHECK(success);
-  } else {
     // This loads advapi!SystemFunction036 which is forwarded to
     // cryptbase!SystemFunction036. This allows boringsll and Chrome to call
     // RtlGenRandom from within the sandbox. This has the unfortunate side
     // effect of opening a handle to \\Device\KsecDD which we will later close
     // in processes that do not need this.
     RtlGenRandom(data, sizeof(data));
-  }
 }
 
 }  // namespace sandbox::policy
diff --git a/sandbox/policy/win/sandbox_win.cc b/sandbox/policy/win/sandbox_win.cc
index 714422bd2d088..3780b5ab6033e 100644
--- a/sandbox/policy/win/sandbox_win.cc
+++ b/sandbox/policy/win/sandbox_win.cc
@@ -63,6 +63,7 @@
 #include "sandbox/win/src/app_container.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace sandbox {
 namespace policy {
@@ -180,16 +181,19 @@ bool AddWindowsFontsDir(TargetConfig* config) {
     return false;
   }
 
-  ResultCode result = config->AllowFileAccess(FileSemantics::kAllowReadonly,
-                                              directory.value().c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
-  std::wstring directory_str = directory.value() + L"\\*";
-  result = config->AllowFileAccess(FileSemantics::kAllowReadonly,
-                                   directory_str.c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
+  if (gfx::win::ShouldUseDirectWrite()) {
+	  ResultCode result =
+		  config->AllowFileAccess(FileSemantics::kAllowReadonly,
+						  directory.value().c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+
+	  std::wstring directory_str = directory.value() + L"\\*";
+	  result = config->AllowFileAccess(FileSemantics::kAllowReadonly,
+							   directory_str.c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+  }
 
   return true;
 }
@@ -257,6 +261,7 @@ std::wstring PrependWindowsSessionPath(const wchar_t* object) {
       {L"\\Sessions\\", base::NumberToWString(s_session_id), object});
 }
 
+
 // Adds the generic config rules to a sandbox TargetConfig.
 ResultCode AddGenericConfig(sandbox::TargetConfig* config) {
   DCHECK(!config->IsConfigured());
@@ -324,7 +329,9 @@ ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
 
   config->SetLockdownDefaultDacl();
 
-  result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  // Win8+ adds a device DeviceApi that we don't need.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
   if (result != SBOX_ALL_OK)
     return result;
 
@@ -582,6 +589,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
       MITIGATION_IMAGE_LOAD_NO_REMOTE | MITIGATION_IMAGE_LOAD_NO_LOW_LABEL |
       MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION | MITIGATION_KTM_COMPONENT;
 
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      mitigations &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
   // CET is enabled with the CETCOMPAT bit on chrome.exe so must be
   // disabled for processes we know are not compatible.
   if (!delegate->CetCompatible())
@@ -624,10 +637,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
         return result;
       }
     }
-    result = SandboxWin::AddWin32kLockdownPolicy(config);
-    if (result != SBOX_ALL_OK) {
-      return result;
-    }
+  if (gfx::win::ShouldUseDirectWrite()) {
+     result = SandboxWin::AddWin32kLockdownPolicy(config);
+     if (result != SBOX_ALL_OK) {
+       return result;
+     }
+  }
   }
 
   if (!delegate->DisableDefaultPolicy()) {
@@ -730,12 +745,18 @@ ResultCode LaunchWithoutSandbox(
   // on process shutdown, in which case TerminateProcess can fail. See
   // https://crbug.com/820996.
   if (delegate->ShouldUnsandboxedRunInJob()) {
+    BOOL in_job = true;
+    // Prior to Windows 8 nested jobs aren't possible.
+    if (base::win::GetVersion() >= base::win::Version::WIN8 ||
+        (::IsProcessInJob(::GetCurrentProcess(), nullptr, &in_job) &&
+         !in_job)) {
     static base::NoDestructor<base::win::ScopedHandle> job_object(
         CreateUnsandboxedJob());
     if (!job_object->is_valid()) {
       return SBOX_ERROR_CANNOT_INIT_JOB;
     }
     options.job_handle = job_object->get();
+    }
   }
 
   // Chromium binaries are marked as CET Compatible but some processes
@@ -823,6 +844,9 @@ ResultCode SandboxWin::AddAppContainerPolicy(TargetConfig* config,
 // static
 ResultCode SandboxWin::AddWin32kLockdownPolicy(TargetConfig* config) {
   DCHECK(!config->IsConfigured());
+  // Win32k Lockdown is supported on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return SBOX_ALL_OK;
   MitigationFlags flags = config->GetProcessMitigations();
   // Check not enabling twice. Should not happen.
   DCHECK_EQ(0U, flags & MITIGATION_WIN32K_DISABLE);
diff --git a/sandbox/win/src/app_container_base.cc b/sandbox/win/src/app_container_base.cc
index 8fd0b01040c31..5f32fcc4eb818 100644
--- a/sandbox/win/src/app_container_base.cc
+++ b/sandbox/win/src/app_container_base.cc
@@ -20,6 +20,18 @@ namespace sandbox {
 
 namespace {
 
+typedef decltype(::CreateAppContainerProfile) CreateAppContainerProfileFunc;
+
+typedef decltype(::DeriveAppContainerSidFromAppContainerName)
+    DeriveAppContainerSidFromAppContainerNameFunc;
+
+typedef decltype(::DeleteAppContainerProfile) DeleteAppContainerProfileFunc;
+
+typedef decltype(::GetAppContainerFolderPath) GetAppContainerFolderPathFunc;
+
+typedef decltype(
+    ::GetAppContainerRegistryLocation) GetAppContainerRegistryLocationFunc;
+
 struct FreeSidDeleter {
   inline void operator()(void* ptr) const { ::FreeSid(ptr); }
 };
@@ -30,8 +42,14 @@ struct FreeSidDeleter {
 AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
                                                   const wchar_t* display_name,
                                                   const wchar_t* description) {
-  PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::CreateAppContainerProfile(
+  static auto create_app_container_profile =
+      reinterpret_cast<CreateAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "CreateAppContainerProfile"));
+  if (!create_app_container_profile)
+    return nullptr;
+
+ PSID package_sid_ptr = nullptr;
+  HRESULT hr = create_app_container_profile(
       package_name, display_name, description, nullptr, 0, &package_sid_ptr);
   if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
     return Open(package_name);
@@ -47,9 +65,15 @@ AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
 
 // static
 AppContainerBase* AppContainerBase::Open(const wchar_t* package_name) {
+  static auto derive_app_container_sid =
+      reinterpret_cast<DeriveAppContainerSidFromAppContainerNameFunc*>(
+          GetProcAddress(GetModuleHandle(L"userenv"),
+                         "DeriveAppContainerSidFromAppContainerName"));
+  if (!derive_app_container_sid)
+    return nullptr;
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::DeriveAppContainerSidFromAppContainerName(package_name,
-                                                           &package_sid_ptr);
+  HRESULT hr = derive_app_container_sid(package_name, &package_sid_ptr);
   if (FAILED(hr))
     return nullptr;
 
@@ -71,7 +95,13 @@ AppContainerBase* AppContainerBase::CreateLowbox(const wchar_t* sid) {
 
 // static
 bool AppContainerBase::Delete(const wchar_t* package_name) {
-  return SUCCEEDED(::DeleteAppContainerProfile(package_name));
+  static auto delete_app_container_profile =
+      reinterpret_cast<DeleteAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "DeleteAppContainerProfile"));
+  if (!delete_app_container_profile)
+    return false;
+
+  return SUCCEEDED(delete_app_container_profile(package_name));
 }
 
 AppContainerBase::AppContainerBase(base::win::Sid& package_sid,
diff --git a/sandbox/win/src/broker_services.cc b/sandbox/win/src/broker_services.cc
index 08e1f13c4501e..1f391aa0069e9 100644
--- a/sandbox/win/src/broker_services.cc
+++ b/sandbox/win/src/broker_services.cc
@@ -454,7 +454,11 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   if (container)
     startup_info->SetAppContainer(container);
 
-  startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  // On Win10, jobs are associated via startup_info.
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      policy_base->HasJob()) {
+    startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  }
 
   if (!startup_info->BuildStartupInformation())
     return SBOX_ERROR_PROC_THREAD_ATTRIBUTES;
diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index a522652988a63..638dcd0c5513e 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -11,6 +11,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 
 namespace sandbox {
@@ -150,8 +151,11 @@ bool HandleCloserAgent::CloseHandles() {
     return true;
 
   std::optional<ProcessHandleMap> handle_map = GetCurrentProcessHandles();
-  if (!handle_map)
-    return false;
+  // Fallback for pre-Windows 8.1.
+  if (!handle_map) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN8_1);
+    handle_map = GetCurrentProcessHandlesWin7();
+  }
 
   for (const HandleMap::value_type& handle_to_close : handles_to_close_) {
     ProcessHandleMap::iterator result = handle_map->find(handle_to_close.first);
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index ee6c56e762753..ad04012dd4293 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -19,6 +19,7 @@
 #include "base/rand_util.h"
 #include "base/scoped_native_library.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
@@ -424,7 +425,39 @@ InterceptionManager::PatchClientFunctions(DllInterceptionData* thunks,
   patch.dll_data.num_thunks = 0;
   patch.dll_data.used_bytes = offsetof(DllInterceptionData, thunks);
 
-  ServiceResolverThunk thunk(child_->Process(), /*relaxed=*/true);
+  std::unique_ptr<ServiceResolverThunk> thunk;
+#if defined(_WIN64)
+  thunk = std::make_unique<ServiceResolverThunk>(child_->Process(), true);
+#else
+  DWORD base_code = 0;
+  DWORD bytes_read = 0;
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  base::win::Version real_os_version = os_info->Kernel32Version();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (real_os_version >= base::win::Version::WIN10)
+      thunk.reset(new Wow64W10ResolverThunk(child_->Process(), true));
+    else if (real_os_version >= base::win::Version::WIN8)
+      thunk.reset(new Wow64W8ResolverThunk(child_->Process(), true));
+    else {
+      thunk.reset(new Wow64ResolverThunk(child_->Process(), true));
+	  if (!::ReadProcessMemory(child_->Process(), ntdll_base, &base_code,
+			sizeof(base_code), &bytes_read)) {
+				if (::GetLastError() == ERROR_PARTIAL_COPY) {
+					::ResumeThread(child_->MainThread());
+					while(!::ReadProcessMemory(child_->Process(), ntdll_base, &base_code,
+						sizeof(base_code), &bytes_read)) {
+						;
+					}
+					::SuspendThread(child_->MainThread());
+					}
+			}
+	}
+  } else if (real_os_version >= base::win::Version::WIN8) {
+    thunk.reset(new Win8ResolverThunk(child_->Process(), true));
+  } else {
+    thunk.reset(new ServiceResolverThunk(child_->Process(), true));
+  }
+#endif
 
   patch.originals = {};
   for (auto interception : interceptions_) {
@@ -435,7 +468,7 @@ InterceptionManager::PatchClientFunctions(DllInterceptionData* thunks,
     if (INTERCEPTION_SERVICE_CALL != interception.type)
       return base::unexpected(SBOX_ERROR_BAD_PARAMS);
 
-    NTSTATUS ret = thunk.Setup(
+    NTSTATUS ret = thunk->Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
         &thunks->thunks[patch.dll_data.num_thunks],
diff --git a/sandbox/win/src/job.cc b/sandbox/win/src/job.cc
index 1bb579f1d1061..7f7d15f339c23 100644
--- a/sandbox/win/src/job.cc
+++ b/sandbox/win/src/job.cc
@@ -9,21 +9,24 @@
 #include <stddef.h>
 #include <utility>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/restricted_token.h"
 
 namespace sandbox {
 
-Job::Job() = default;
-Job::~Job() = default;
+Job::Job() : job_handle_(nullptr) {}
+
+Job::~Job() {}
 
 DWORD Job::Init(JobLevel security_level,
                 DWORD ui_exceptions,
                 size_t memory_limit) {
-  if (job_handle_.is_valid())
+  if (job_handle_.IsValid())
     return ERROR_ALREADY_INITIALIZED;
 
-  job_handle_.Set(::CreateJobObject(nullptr, nullptr));
-  if (!job_handle_.is_valid())
+  job_handle_.Set(::CreateJobObject(nullptr,  // No security attribute
+                                    nullptr));
+  if (!job_handle_.IsValid())
     return ::GetLastError();
 
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
@@ -63,6 +66,9 @@ DWORD Job::Init(JobLevel security_level,
       jeli.BasicLimitInformation.LimitFlags |=
           JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
       break;
+    }
+	case JobLevel::kNone: {
+      return ERROR_BAD_ARGUMENTS;
     }
   }
 
@@ -83,20 +89,42 @@ DWORD Job::Init(JobLevel security_level,
 }
 
 bool Job::IsValid() {
-  return job_handle_.is_valid();
+  return job_handle_.IsValid();
 }
 
 HANDLE Job::GetHandle() {
-  return job_handle_.get();
+  return job_handle_.Get();
+}
+
+DWORD Job::UserHandleGrantAccess(HANDLE handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::UserHandleGrantAccess(handle, job_handle_.Get(),
+                               true)) {  // Access allowed.
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+DWORD Job::AssignProcessToJob(HANDLE process_handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::AssignProcessToJobObject(job_handle_.Get(), process_handle))
+    return ::GetLastError();
+
+  return ERROR_SUCCESS;
 }
 
 DWORD Job::SetActiveProcessLimit(DWORD processes) {
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
 
-  if (!job_handle_.is_valid())
+  if (!job_handle_.IsValid())
     return ERROR_NO_DATA;
 
-  if (!::QueryInformationJobObject(job_handle_.get(),
+  if (!::QueryInformationJobObject(job_handle_.Get(),
                                    JobObjectExtendedLimitInformation, &jeli,
                                    sizeof(jeli), nullptr)) {
     return ::GetLastError();
@@ -104,7 +132,7 @@ DWORD Job::SetActiveProcessLimit(DWORD processes) {
   jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   jeli.BasicLimitInformation.ActiveProcessLimit = processes;
 
-  if (!::SetInformationJobObject(job_handle_.get(),
+  if (!::SetInformationJobObject(job_handle_.Get(),
                                  JobObjectExtendedLimitInformation, &jeli,
                                  sizeof(jeli))) {
     return ::GetLastError();
diff --git a/sandbox/win/src/job.h b/sandbox/win/src/job.h
index 31037e1b7aff7..a148179e108a5 100644
--- a/sandbox/win/src/job.h
+++ b/sandbox/win/src/job.h
@@ -15,7 +15,8 @@ enum class JobLevel;
 // Handles the creation of job objects based on a security profile.
 // Sample usage:
 //   Job job;
-//   job.Init(JobLevel::kLockdown, 0, 0);
+//   job.Init(JobLevel::kLockdown, nullptr);  //no job name
+//   job.AssignProcessToJob(process_handle);
 class Job {
  public:
   Job();
@@ -27,6 +28,7 @@ class Job {
 
   // Initializes and creates the job object. The security of the job is based
   // on the security_level parameter.
+  // job_name can be nullptr if the job is unnamed.
   // If the chosen profile has too many ui restrictions, you can disable some
   // by specifying them in the ui_exceptions parameters.
   // If the function succeeds, the return value is ERROR_SUCCESS. If the
@@ -34,6 +36,19 @@ class Job {
   // the error.
   DWORD Init(JobLevel security_level, DWORD ui_exceptions, size_t memory_limit);
 
+  // Assigns the process referenced by process_handle to the job.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD AssignProcessToJob(HANDLE process_handle);
+
+  // Grants access to "handle" to the job. All processes in the job can
+  // subsequently recognize and use the handle.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD UserHandleGrantAccess(HANDLE handle);
+
   // True if the job has been initialized and has a valid handle.
   bool IsValid();
 
diff --git a/sandbox/win/src/nt_internals.h b/sandbox/win/src/nt_internals.h
index 72d96b96f4fd4..c3dedf262abcf 100644
--- a/sandbox/win/src/nt_internals.h
+++ b/sandbox/win/src/nt_internals.h
@@ -162,7 +162,13 @@ typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN PVOID ThreadInformation,
     IN ULONG ThreadInformationLength);
 
+typedef struct _PROCESS_ACCESS_TOKEN {
+  HANDLE token;
+  HANDLE thread;
+} PROCESS_ACCESS_TOKEN;
+
 // Partial definition only for values not in PROCESS_INFO_CLASS.
+constexpr auto ProcessInformationAccessToken = static_cast<PROCESSINFOCLASS>(9);
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
 constexpr auto ProcessHandleTable = static_cast<PROCESSINFOCLASS>(58);
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 2b870c0ebd409..498d207d4249c 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -24,6 +24,7 @@
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/win_utils.h"
+#include "ui/gfx/win/direct_write.h"
 
 // These are missing in 10.0.19551.0 but are in 10.0.19041.0 and 10.0.20226.0.
 #ifndef PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_STRICT_MODE
@@ -44,22 +45,39 @@ namespace sandbox {
 
 namespace {
 
+// API defined in libloaderapi.h >= Win8. Also available in Vista/7 starting with KB2533623.
+// Known to be buggy on Vista, but not known to affect Chromium.
+using SetDefaultDllDirectoriesFunction = decltype(&SetDefaultDllDirectories);
+
+// APIs defined in processthreadsapi.h >= Win8.
+using SetProcessMitigationPolicyFunction =
+    decltype(&SetProcessMitigationPolicy);
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+using SetThreadInformationFunction = decltype(&SetThreadInformation);
+
 // Returns a two-element array of mitigation flags supported on this machine.
 const ULONG64* GetSupportedMitigations() {
   static ULONG64 mitigations[2] = {};
 
   // This static variable will only be initialized once.
   if (!mitigations[0] && !mitigations[1]) {
-    // NOTE: the two-element-sized input array is only supported on >= Win10
-    // RS2. If an earlier version, the second element will be left 0.
-    size_t mits_size =
-        (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
-            ? (sizeof(mitigations[0]) * 2)
-            : sizeof(mitigations[0]);
-    if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                      ProcessMitigationOptionsMask,
-                                      &mitigations, mits_size)) {
-      NOTREACHED();
+    GetProcessMitigationPolicyFunction get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+            ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (get_process_mitigation_policy) {
+      // NOTE: the two-element-sized input array is only supported on >= Win10
+      // RS2.
+      //       If an earlier version, the second element will be left 0.
+      size_t mits_size =
+          (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
+              ? (sizeof(mitigations[0]) * 2)
+              : sizeof(mitigations[0]);
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessMitigationOptionsMask,
+                                         &mitigations, mits_size)) {
+        NOTREACHED();
+      }
     }
   }
 
@@ -83,7 +101,14 @@ bool IsRunning32bitEmulatedOnArm64() {
 bool SetProcessMitigationPolicyInternal(PROCESS_MITIGATION_POLICY policy,
                                         PVOID lpBuffer,
                                         SIZE_T dwLength) {
-  PCHECK(::SetProcessMitigationPolicy(policy, lpBuffer, dwLength))
+  HMODULE module = ::GetModuleHandleA("kernel32.dll");
+  SetProcessMitigationPolicyFunction set_process_mitigation_policy_function =
+      reinterpret_cast<SetProcessMitigationPolicyFunction>(
+          ::GetProcAddress(module, "SetProcessMitigationPolicy"));
+  if (!set_process_mitigation_policy_function)
+    return false;
+
+  PCHECK(set_process_mitigation_policy_function(policy, lpBuffer, dwLength))
       << "SetProcessMitigationPolicy failed with Policy: " << policy;
 
   return true;
@@ -99,21 +124,35 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
 
   base::win::Version version = base::win::GetVersion();
 
-  if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+  #if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite())
+    flags &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_WIN32K_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+ if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+    HMODULE module = ::GetModuleHandleA("kernel32.dll");
+    SetDefaultDllDirectoriesFunction set_default_dll_directories =
+        reinterpret_cast<SetDefaultDllDirectoriesFunction>(
+            ::GetProcAddress(module, "SetDefaultDllDirectories"));
+
+    // Check for SetDefaultDllDirectories since it requires KB2533623.
+    if (set_default_dll_directories) {
 #if defined(COMPONENT_BUILD)
-    const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
+      const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
 #else
-    // In a non-component build, all DLLs will be loaded manually, or via
-    // manifest definition, so these flags can be stronger. This prevents DLL
-    // planting in the application directory.
-    const DWORD directory_flags =
-        LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
+      // In a non-component build, all DLLs will be loaded manually, or via
+      // manifest definition, so these flags can be stronger. This prevents DLL
+      // planting in the application directory.
+      const DWORD directory_flags =
+          LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
 #endif
-    if (!::SetDefaultDllDirectories(directory_flags)) {
-      return false;
-    }
+      if (!set_default_dll_directories(directory_flags)) {
+        return false;
+      }
 
-    applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+      applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+    }
   }
 
   // Set the heap to terminate on corruption
@@ -156,6 +195,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   }
 #endif
 
+  // This is all we can do in Win7 and below.
+  if (version < base::win::Version::WIN8)
+    return true;
+
   // Enable ASLR policies.
   if (flags & MITIGATION_RELOCATE_IMAGE) {
     PROCESS_MITIGATION_ASLR_POLICY policy = {};
@@ -219,6 +262,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_EXTENSION_POINT_DISABLE;
   }
 
+  if (version < base::win::Version::WIN8_1)
+    return true;
+
   // Enable dynamic code policies.
   if (!IsRunning32bitEmulatedOnArm64() &&
       (flags & MITIGATION_DYNAMIC_CODE_DISABLE)) {
@@ -235,6 +281,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
   }
 
+  if (version < base::win::Version::WIN10)
+    return true;
+
   // Enable font policies.
   if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
     PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
@@ -356,9 +405,20 @@ bool ApplyMitigationsToCurrentThread(MitigationFlags flags) {
   if (flags & MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD) {
     DWORD thread_policy = THREAD_DYNAMIC_CODE_ALLOW;
 
+   // NOTE: SetThreadInformation API only exists on >= Win8.  Dynamically
+    //       get function handle.
+    base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+    if (!dll.is_valid())
+      return false;
+    SetThreadInformationFunction set_thread_info_function =
+        reinterpret_cast<SetThreadInformationFunction>(
+            dll.GetFunctionPointer("SetThreadInformation"));
+    if (!set_thread_info_function)
+      return false;
+
     // NOTE: Must use the pseudo-handle here, a thread HANDLE won't work.
-    if (!::SetThreadInformation(::GetCurrentThread(), ThreadDynamicCodePolicy,
-                                &thread_policy, sizeof(thread_policy))) {
+    if (!set_thread_info_function(::GetCurrentThread(), ThreadDynamicCodePolicy,
+                                  &thread_policy, sizeof(thread_policy))) {
       return false;
     }
   }
@@ -379,8 +439,14 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
   *policy_value_1 = 0;
   *policy_value_2 = 0;
 
-#if defined(_WIN64) || defined(_M_IX86)
+#if defined(_WIN64)
   *size = sizeof(*policy_flags);
+#elif defined(_M_IX86)
+  // A 64-bit flags attribute is illegal on 32-bit Win 7.
+  if (version < base::win::Version::WIN8)
+    *size = sizeof(DWORD);
+  else
+    *size = sizeof(*policy_flags);
 #else
 #error This platform is not supported.
 #endif
@@ -398,53 +464,79 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
     *policy_value_1 |= PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE;
 #endif
 
-  if (flags & MITIGATION_RELOCATE_IMAGE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
-    if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+  // Win 7
+  if (version < base::win::Version::WIN8)
+    return;
+
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      *policy_value_1 &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+  // Everything >= Win8, do not return before the end of the function where
+  // the final policy bitmap is sanity checked against what is supported on this
+  // machine.  The API required to do so is only available since Win8.
+
+  // Mitigations >= Win8:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8) {
+    if (flags & MITIGATION_RELOCATE_IMAGE) {
       *policy_value_1 |=
-          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
+      if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+        *policy_value_1 |=
+            PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+      }
     }
-  }
 
-  if (flags & MITIGATION_HEAP_TERMINATE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HEAP_TERMINATE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_BOTTOM_UP_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_BOTTOM_UP_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_WIN32K_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_WIN32K_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+  // Mitigations >= Win8.1:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8_1) {
+    if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+  // Mitigations >= Win10:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN10) {
+    if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+    }
   }
 
   // Mitigations >= Win10 TH2:
@@ -557,6 +649,15 @@ void ConvertProcessMitigationsToComponentFilter(MitigationFlags flags,
 }
 
 MitigationFlags FilterPostStartupProcessMitigations(MitigationFlags flags) {
+  base::win::Version version = base::win::GetVersion();
+
+  // Windows 7.
+  if (version < base::win::Version::WIN8) {
+    return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER |
+                    MITIGATION_HEAP_TERMINATE);
+  }
+
+  // Windows 8 and above.
   return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER);
 }
 
diff --git a/sandbox/win/src/process_mitigations_unittest.cc b/sandbox/win/src/process_mitigations_unittest.cc
index 47eab9bbcd6df..54ce6d20df760 100644
--- a/sandbox/win/src/process_mitigations_unittest.cc
+++ b/sandbox/win/src/process_mitigations_unittest.cc
@@ -51,6 +51,22 @@ typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_2 {
 
 namespace {
 
+//------------------------------------------------------------------------------
+// Internal Defines & Functions
+//------------------------------------------------------------------------------
+
+// API defined in winbase.h.
+using GetProcessDEPPolicyFunction = decltype(&GetProcessDEPPolicy);
+
+// API defined in processthreadsapi.h.
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+GetProcessMitigationPolicyFunction get_process_mitigation_policy;
+
+// APIs defined in wingdi.h.
+using AddFontMemResourceExFunction = decltype(&AddFontMemResourceEx);
+using RemoveFontMemResourceExFunction = decltype(&RemoveFontMemResourceEx);
+
 //------------------------------------------------------------------------------
 // NonSystemFont test helper function.
 //
@@ -104,6 +120,13 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
   if (!test)
     return SBOX_TEST_INVALID_PARAMETER;
 
+  get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
+
   switch (test) {
     //--------------------------------------------------
     // MITIGATION_DEP
@@ -113,8 +136,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
 #if !defined(_WIN64)
       // DEP - always enabled on 64-bit.
       PROCESS_MITIGATION_DEP_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(), ProcessDEPPolicy,
-                                        &policy, sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDEPPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.Enable || !policy.Permanent)
@@ -128,9 +152,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_ASLR): {
       PROCESS_MITIGATION_ASLR_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessASLRPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessASLRPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.EnableForceRelocateImages || !policy.DisallowStrippedImages)
@@ -143,9 +167,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_STRICTHANDLE): {
       PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessStrictHandleCheckPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessStrictHandleCheckPolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.RaiseExceptionOnInvalidHandleReference ||
@@ -160,9 +184,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_WIN32K): {
       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessSystemCallDisablePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessSystemCallDisablePolicy,
+                                         &policy, sizeof(policy)))  {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisallowWin32kSystemCalls)
@@ -179,7 +203,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_EXTENSIONPOINT): {
       PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessExtensionPointDisablePolicy,
                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -194,7 +218,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODE): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -209,7 +233,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_NONSYSFONT): {
       PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessFontDisablePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -224,7 +248,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_MSSIGNED): {
       PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessSignaturePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -239,7 +263,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOREMOTE): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -254,7 +278,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOLOW): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -269,7 +293,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODEOPTOUT): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -284,7 +308,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADPREFERSYS32): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -309,7 +333,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDISABLED): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -325,7 +349,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDYNAMICAPIS): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -348,7 +372,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETSTRICT): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -389,7 +413,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     case (TESTPOLICY_PREANDPOSTSTARTUP): {
       // Both policies should be set now.
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -517,11 +541,18 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
       return SBOX_TEST_SUCCEEDED;
     }
   }
+
+  auto get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
   // Process failed to be created.
   // Note: GetLastError from CreateProcess returns 5, "ERROR_ACCESS_DENIED".
   // Validate the NoChildProcessCreation policy is applied.
   PROCESS_MITIGATION_CHILD_PROCESS_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+  if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                     ProcessChildProcessPolicy, &policy,
                                     sizeof(policy))) {
     return SBOX_TEST_NOT_FOUND;
@@ -892,10 +923,14 @@ TEST(ProcessMitigationsTest, CetDisablePolicy) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -932,10 +967,14 @@ TEST(ProcessMitigationsTest, CetAllowDynamicApis) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -970,10 +1009,14 @@ TEST(ProcessMitigationsTest, CetStrictMode) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
diff --git a/sandbox/win/src/restricted_token.cc b/sandbox/win/src/restricted_token.cc
index dd6710c471325..23197af98b2a3 100644
--- a/sandbox/win/src/restricted_token.cc
+++ b/sandbox/win/src/restricted_token.cc
@@ -16,6 +16,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/win/access_token.h"
 #include "base/win/security_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 
 namespace sandbox {
@@ -184,7 +185,7 @@ std::optional<base::win::AccessToken> RestrictedToken::CreateRestricted(
     return std::nullopt;
   }
 
-  if (lockdown_default_dacl_) {
+  if (lockdown_default_dacl_ && base::win::GetVersion() >= base::win::Version::VISTA) {
     // Don't add Restricted sid and also remove logon sid access.
     std::optional<base::win::Sid> logon_sid = new_token->LogonId();
     if (logon_sid.has_value()) {
@@ -217,7 +218,7 @@ std::optional<base::win::AccessToken> RestrictedToken::CreateRestricted(
     return std::nullopt;
   }
 
-  if (integrity_rid_.has_value()) {
+  if (integrity_rid_.has_value() && base::win::GetVersion() >= base::win::Version::VISTA) {
     if (!new_token->SetIntegrityLevel(*integrity_rid_)) {
       return std::nullopt;
     }
diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
index 9cefa097e1439..ec8d3b9f48ecf 100644
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -11,8 +11,10 @@
 #include "base/check.h"
 #include "base/notreached.h"
 #include "base/win/access_token.h"
+#include "base/win/scoped_handle.h"
 #include "base/win/security_descriptor.h"
 #include "sandbox/win/src/acl.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/security_level.h"
diff --git a/sandbox/win/src/sandbox_policy_diagnostic.cc b/sandbox/win/src/sandbox_policy_diagnostic.cc
index b6a5874adab7f..96a1ffe0e23f2 100644
--- a/sandbox/win/src/sandbox_policy_diagnostic.cc
+++ b/sandbox/win/src/sandbox_policy_diagnostic.cc
@@ -83,6 +83,8 @@ std::string GetJobLevelInEnglish(JobLevel job) {
       return "Interactive";
     case JobLevel::kUnprotected:
       return "Unprotected";
+    case JobLevel::kNone:
+      return "None";
   }
 }
 
diff --git a/sandbox/win/src/security_level.h b/sandbox/win/src/security_level.h
index 288d2baea917c..8c3c6b25ad2b0 100644
--- a/sandbox/win/src/security_level.h
+++ b/sandbox/win/src/security_level.h
@@ -95,6 +95,9 @@ enum TokenLevel {
 //  JobLevel        |General                            |Quota               |
 //                  |restrictions                       |restrictions        |
 // -----------------|---------------------------------- |--------------------|
+// kNone            | No job is assigned to the         | None               |
+//                  | sandboxed process.                |                    |
+// -----------------|---------------------------------- |--------------------|
 // kUnprotected     | None                              | *Kill on Job close.|
 // -----------------|---------------------------------- |--------------------|
 // kInteractive     | *Forbid system-wide changes using |                    |
@@ -120,7 +123,7 @@ enum TokenLevel {
 // In the context of the above table, 'user handles' refers to the handles of
 // windows, bitmaps, menus, etc. Files, treads and registry handles are kernel
 // handles and are not affected by the job level settings.
-enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected };
+enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected,  kNone };
 
 // These flags correspond to various process-level mitigations (eg. ASLR and
 // DEP). Most are implemented via UpdateProcThreadAttribute() plus flags for
diff --git a/sandbox/win/src/service_resolver.h b/sandbox/win/src/service_resolver.h
index dc74bd6e52539..97f828e3feeb0 100644
--- a/sandbox/win/src/service_resolver.h
+++ b/sandbox/win/src/service_resolver.h
@@ -53,23 +53,18 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   size_t GetThunkSize() const override;
 
   // Call this to set up ntdll_base_ which will allow for local patches.
-  void AllowLocalPatches();
+  virtual void AllowLocalPatches();
 
   // Verifies that the function specified by |target_name| in |target_module| is
   // a service and copies the data from that function into |thunk_storage|. If
   // |storage_bytes| is too small, then the method fails.
-  NTSTATUS CopyThunk(const void* target_module,
-                     const char* target_name,
-                     BYTE* thunk_storage,
-                     size_t storage_bytes,
-                     size_t* storage_used);
+  virtual NTSTATUS CopyThunk(const void* target_module,
+                             const char* target_name,
+                             BYTE* thunk_storage,
+                             size_t storage_bytes,
+                             size_t* storage_used);
 
-  // Checks if a target was patched correctly for a jump. This is only for use
-  // in testing in 32-bit builds. Will always return true on 64-bit builds. Set
-  // |thunk_storage| to the same pointer passed to Setup().
-  bool VerifyJumpTargetForTesting(void* thunk_storage) const;
-
- private:
+ protected:
   // The unit test will use this member to allow local patch on a buffer.
   HMODULE ntdll_base_;
 
@@ -87,15 +82,15 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   // Returns true if the code pointer by target_ corresponds to the expected
   // type of function. Saves that code on the first part of the thunk pointed
   // by local_thunk (should be directly accessible from the parent).
-  bool IsFunctionAService(void* local_thunk) const;
+  virtual bool IsFunctionAService(void* local_thunk) const;
 
   // Performs the actual patch of target_.
   // local_thunk must be already fully initialized, and the first part must
   // contain the original code. The real type of this buffer is ServiceFullThunk
   // (yes, private). remote_thunk (real type ServiceFullThunk), must be
   // allocated on the child, and will contain the thunk data, after this call.
-  // Returns the appropriate status code.
-  NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
+  // Returns the apropriate status code.
+  virtual NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
 
   // Provides basically the same functionality as IsFunctionAService but it
   // continues even if it does not recognize the function code. remote_thunk
@@ -107,6 +102,74 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   ULONG relative_jump_;
 };
 
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).
+class Wow64ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64ResolverThunk(const Wow64ResolverThunk&) = delete;
+  Wow64ResolverThunk& operator=(const Wow64ResolverThunk&) = delete;
+
+  ~Wow64ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 8.
+class Wow64W8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W8ResolverThunk(const Wow64W8ResolverThunk&) = delete;
+  Wow64W8ResolverThunk& operator=(const Wow64W8ResolverThunk&) = delete;
+
+  ~Wow64W8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on Windows 8.
+class Win8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Win8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Win8ResolverThunk(const Win8ResolverThunk&) = delete;
+  Win8ResolverThunk& operator=(const Win8ResolverThunk&) = delete;
+
+  ~Win8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 10.
+class Wow64W10ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W10ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W10ResolverThunk(const Wow64W10ResolverThunk&) = delete;
+  Wow64W10ResolverThunk& operator=(const Wow64W10ResolverThunk&) = delete;
+
+  ~Wow64W10ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_SERVICE_RESOLVER_H_
diff --git a/sandbox/win/src/service_resolver_32.cc b/sandbox/win/src/service_resolver_32.cc
index fcf0688800444..30094fab7def2 100644
--- a/sandbox/win/src/service_resolver_32.cc
+++ b/sandbox/win/src/service_resolver_32.cc
@@ -18,16 +18,43 @@ namespace {
 const BYTE kMovEax = 0xB8;
 const BYTE kMovEdx = 0xBA;
 const USHORT kMovEdxEsp = 0xD48B;
+const USHORT kCallPtrEdx = 0x12FF;
 const USHORT kCallEdx = 0xD2FF;
 const BYTE kCallEip = 0xE8;
 const BYTE kRet = 0xC2;
 const BYTE kRet2 = 0xC3;
 const USHORT kJmpEdx = 0xE2FF;
+const USHORT kXorEcx = 0xC933;
+const ULONG kLeaEdx = 0x0424548D;
+const ULONG kCallFs1 = 0xC015FF64;
+const USHORT kCallFs2 = 0;
+const BYTE kCallFs3 = 0;
+const BYTE kAddEsp1 = 0x83;
+const USHORT kAddEsp2 = 0x4C4;
 const BYTE kJmp32 = 0xE9;
 const USHORT kSysenter = 0x340F;
 
-// Service code for 32 bit Windows. Introduced in Windows 8.
-struct ServiceEntry32 {
+// Service code for 32 bit systems.
+// NOTE: on win2003 "call dword ptr [edx]" is "call edx".
+struct ServiceEntry {
+  // This struct contains roughly the following code:
+  // 00 mov     eax,25h
+  // 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
+  // 0a call    dword ptr [edx]
+  // 0c ret     2Ch
+  // 0f nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  BYTE mov_edx;         // = BA
+  ULONG stub;
+  USHORT call_ptr_edx;  // = FF 12
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for 32 bit Windows 8.
+struct ServiceEntryW8 {
   // This struct contains the following code:
   // 00 b825000000      mov     eax,25h
   // 05 e803000000      call    eip+3
@@ -48,13 +75,60 @@ struct ServiceEntry32 {
   USHORT nop;
 };
 
-// Service code for a 32 bit process under Wow64. Introduced in Windows 10.
-// Also used for the patching process.
-struct ServiceEntryWow64 {
+// Service code for a 32 bit process running on a 64 bit os.
+struct Wow64Entry {
+  // This struct may contain one of two versions of code:
+  // 1. For XP, Vista and 2K3:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 c22c00          ret     2Ch
+  //
+  // 2. For Windows 7:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 83c404          add     esp, 4
+  // 15 c22c00          ret     2Ch
+  //
+  // So we base the structure on the bigger one:
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  USHORT xor_ecx;       // = 33 C9
+  ULONG lea_edx;        // = 8D 54 24 04
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE add_esp1;        // = 83             or ret
+  USHORT add_esp2;      // = C4 04          or num_params
+  BYTE ret;             // = C2
+  USHORT num_params;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 8.
+struct Wow64EntryW8 {
+  // 00 b825000000      mov     eax, 25h
+  // 05 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 0b c22c00          ret     2Ch
+  // 0f 90              nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 10.
+struct Wow64EntryW10 {
   // 00 b828000000      mov     eax, 28h
   // 05 bab0d54877      mov     edx, 7748D5B0h
   // 09 ffd2            call    edx
-  // 0c c22800          ret     28h
+  // 0b c22800          ret     28h
   BYTE mov_eax;         // = B8
   ULONG service_id;
   BYTE mov_edx;         // = BA
@@ -62,86 +136,27 @@ struct ServiceEntryWow64 {
   USHORT call_edx;      // = FF D2
   BYTE ret;             // = C2
   USHORT num_params;
-  BYTE nop;
 };
 
 // Make sure that relaxed patching works as expected.
-const size_t kMinServiceSize = offsetof(ServiceEntryWow64, ret);
-// Maximum size of the entry, was the size of the Windows Vista WoW64 entry.
-// Keep this fixed for compatibility reasons.
-const size_t kMaxServiceSize = 24;
-static_assert(sizeof(ServiceEntry32) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntry32) < kMaxServiceSize,
-              "wrong maximum service length");
-static_assert(sizeof(ServiceEntryWow64) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntryWow64) < kMaxServiceSize,
-              "wrong maximum service length");
+const size_t kMinServiceSize = offsetof(ServiceEntry, ret);
+static_assert(sizeof(ServiceEntryW8) >= kMinServiceSize,
+              "wrong service length");
+static_assert(sizeof(Wow64Entry) >= kMinServiceSize, "wrong service length");
+static_assert(sizeof(Wow64EntryW8) >= kMinServiceSize, "wrong service length");
 
 struct ServiceFullThunk {
   union {
-    ServiceEntryWow64 original;
-    // Pad the entry to the maximum size.
-    char dummy[kMaxServiceSize];
+    ServiceEntry original;
+    ServiceEntryW8 original_w8;
+    Wow64Entry wow_64;
+    Wow64EntryW8 wow_64_w8;
   };
   int internal_thunk;  // Dummy member to the beginning of the internal thunk.
 };
 
 #pragma pack(pop)
 
-bool IsWow64Process() {
-  // We don't need to use IsWow64Process2 as this returns the expected result
-  // when running in the ARM64 x86 emulator.
-  BOOL is_wow64 = FALSE;
-  return ::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64;
-}
-
-bool IsFunctionAService32(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntry32 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
-      function_code.call_offset != 3 || kRet != function_code.ret_p ||
-      kMovEdxEsp != function_code.mov_edx_esp ||
-      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-
-  return true;
-}
-
-bool IsFunctionAServiceWow64(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntryWow64 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
-      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-  return true;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -210,14 +225,69 @@ NTSTATUS ServiceResolverThunk::CopyThunk(const void* target_module,
 }
 
 bool ServiceResolverThunk::IsFunctionAService(void* local_thunk) const {
-  static bool is_wow64 = IsWow64Process();
-  return is_wow64 ? IsFunctionAServiceWow64(process_, target_, local_thunk)
-                  : IsFunctionAService32(process_, target_, local_thunk);
+  ServiceEntry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      (kCallPtrEdx != function_code.call_ptr_edx &&
+       kCallEdx != function_code.call_ptr_edx) ||
+      kRet != function_code.ret) {
+    return false;
+  }
+
+  // Find the system call pointer if we don't already have it.
+  if (kCallEdx != function_code.call_ptr_edx) {
+    DWORD ki_system_call;
+    if (!::ReadProcessMemory(process_,
+                             reinterpret_cast<const void*>(function_code.stub),
+                             &ki_system_call, sizeof(ki_system_call), &read)) {
+      return false;
+    }
+
+    if (sizeof(ki_system_call) != read)
+      return false;
+
+    HMODULE module_1, module_2;
+    // last check, call_stub should point to a KiXXSystemCall function on ntdll
+    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                           reinterpret_cast<const wchar_t*>(ki_system_call),
+                           &module_1)) {
+      return false;
+    }
+
+    if (ntdll_base_) {
+      // This path is only taken when running the unit tests. We want to be
+      // able to patch a buffer in memory, so target_ is not inside ntdll.
+      module_2 = ntdll_base_;
+    } else {
+      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                             reinterpret_cast<const wchar_t*>(target_),
+                             &module_2))
+        return false;
+    }
+
+    if (module_1 != module_2)
+      return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
 }
 
 NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
                                             void* remote_thunk) {
-  ServiceEntryWow64 intercepted_code;
+  ServiceEntry intercepted_code;
   size_t bytes_to_write = sizeof(intercepted_code);
   ServiceFullThunk* full_local_thunk =
       reinterpret_cast<ServiceFullThunk*>(local_thunk);
@@ -230,15 +300,15 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   intercepted_code.mov_eax = kMovEax;
   intercepted_code.service_id = full_local_thunk->original.service_id;
   intercepted_code.mov_edx = kMovEdx;
-  intercepted_code.mov_edx_param =
-      reinterpret_cast<ULONG>(&full_remote_thunk->internal_thunk);
-  intercepted_code.call_edx = kJmpEdx;
+  intercepted_code.stub =
+       reinterpret_cast<ULONG>(&full_remote_thunk->internal_thunk);
+  intercepted_code.call_ptr_edx = kJmpEdx;
   bytes_to_write = kMinServiceSize;
 
   if (relative_jump_) {
     intercepted_code.mov_eax = kJmp32;
     intercepted_code.service_id = relative_jump_;
-    bytes_to_write = offsetof(ServiceEntryWow64, mov_edx);
+    bytes_to_write = offsetof(ServiceEntry, mov_edx);
   }
 
   // setup the thunk
@@ -274,7 +344,7 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
 
 bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
                                                 void* remote_thunk) {
-  ServiceEntryWow64 function_code;
+  ServiceEntry function_code;
   SIZE_T read;
   if (!::ReadProcessMemory(process_, target_, &function_code,
                            sizeof(function_code), &read)) {
@@ -310,18 +380,100 @@ bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
   return true;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(
-    void* thunk_storage) const {
-  const size_t kJmp32Size = 5;
-  ServiceEntryWow64* patched = static_cast<ServiceEntryWow64*>(target_);
-  if (kJmp32 != patched->mov_eax) {
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64Entry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kXorEcx != function_code.xor_ecx ||
+      kLeaEdx != function_code.lea_edx || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3) {
+    return false;
+  }
+
+  if ((kAddEsp1 == function_code.add_esp1 &&
+       kAddEsp2 == function_code.add_esp2 && kRet == function_code.ret) ||
+      kRet == function_code.add_esp1) {
+    // Save the verified code
+    memcpy(local_thunk, &function_code, sizeof(function_code));
+    return true;
+  }
+
+  return false;
+}
+
+bool Wow64W8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
     return false;
   }
 
-  ULONG source_addr = reinterpret_cast<ULONG>(target_);
-  ULONG target_addr = reinterpret_cast<ULONG>(thunk_storage);
-  return target_addr + kMaxServiceSize - kJmp32Size - source_addr ==
-         patched->service_id;
+if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3 || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
+}
+
+bool Win8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  ServiceEntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
+      function_code.call_offset != 3 || kRet != function_code.ret_p ||
+      kMovEdxEsp != function_code.mov_edx_esp ||
+      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
+}
+
+bool Wow64W10ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW10 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_64.cc b/sandbox/win/src/service_resolver_64.cc
index 33b91d04ad114..38e451da143a3 100644
--- a/sandbox/win/src/service_resolver_64.cc
+++ b/sandbox/win/src/service_resolver_64.cc
@@ -282,8 +282,4 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   return STATUS_SUCCESS;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(void*) const {
-  return true;
-}
-
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_unittest.cc b/sandbox/win/src/service_resolver_unittest.cc
index aa05e37c0c0e0..01d0fee18b17d 100644
--- a/sandbox/win/src/service_resolver_unittest.cc
+++ b/sandbox/win/src/service_resolver_unittest.cc
@@ -13,53 +13,98 @@
 
 #include "base/bit_cast.h"
 #include "base/memory/raw_ptr.h"
-#include "sandbox/win/src/nt_internals.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/resolver.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
 
+class ResolverThunkTest {
+ public:
+  virtual ~ResolverThunkTest() {}
+
+  virtual sandbox::ServiceResolverThunk* resolver() = 0;
+
+  // Sets the interception target to the desired address.
+  void set_target(void* target) { fake_target_ = target; }
+
+ protected:
+  // Holds the address of the fake target.
+  raw_ptr<void> fake_target_;
+};
+
 // This is the concrete resolver used to perform service-call type functions
 // inside ntdll.dll.
-class ServiceResolverTest : public sandbox::ServiceResolverThunk {
+template <typename T>
+class ResolverThunkTestImpl : public T, public ResolverThunkTest {
  public:
   // The service resolver needs a child process to write to.
-  explicit ServiceResolverTest(bool relaxed)
-      : sandbox::ServiceResolverThunk(::GetCurrentProcess(), relaxed) {}
+  explicit ResolverThunkTestImpl(bool relaxed)
+      : T(::GetCurrentProcess(), relaxed) {}
 
-  ServiceResolverTest(const ServiceResolverTest&) = delete;
-  ServiceResolverTest& operator=(const ServiceResolverTest&) = delete;
+  ResolverThunkTestImpl(const ResolverThunkTestImpl&) = delete;
+  ResolverThunkTestImpl& operator=(const ResolverThunkTestImpl&) = delete;
 
-  // Sets the interception target to the desired address.
-  void set_target(void* target) { fake_target_ = target; }
+  sandbox::ServiceResolverThunk* resolver() { return this; }
 
  protected:
   // Overrides Resolver::Init
-  NTSTATUS Init(const void* target_module,
-                const void* interceptor_module,
-                const char* target_name,
-                const char* interceptor_name,
-                const void* interceptor_entry_point,
-                void* thunk_storage,
-                size_t storage_bytes) final {
+  virtual NTSTATUS Init(const void* target_module,
+                        const void* interceptor_module,
+                        const char* target_name,
+                        const char* interceptor_name,
+                        const void* interceptor_entry_point,
+                        void* thunk_storage,
+                        size_t storage_bytes) {
     NTSTATUS ret = STATUS_SUCCESS;
-    ret = sandbox::ServiceResolverThunk::Init(
-        target_module, interceptor_module, target_name, interceptor_name,
-        interceptor_entry_point, thunk_storage, storage_bytes);
+    ret = T::Init(target_module, interceptor_module, target_name,
+                  interceptor_name, interceptor_entry_point, thunk_storage,
+                  storage_bytes);
     EXPECT_EQ(STATUS_SUCCESS, ret);
 
     this->target_ = fake_target_;
 
     return ret;
   }
-
-  // Holds the address of the fake target.
-  raw_ptr<void> fake_target_;
 };
 
+typedef ResolverThunkTestImpl<sandbox::ServiceResolverThunk> WinXpResolverTest;
+
+#if !defined(_WIN64)
+typedef ResolverThunkTestImpl<sandbox::Win8ResolverThunk> Win8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W8ResolverThunk>
+    Wow64W8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W10ResolverThunk>
+    Wow64W10ResolverTest;
+#endif
+
+const BYTE kJump32 = 0xE9;
+
+void CheckJump(void* source, void* target) {
+#pragma pack(push)
+#pragma pack(1)
+  struct Code {
+    BYTE jump;
+    ULONG delta;
+  };
+#pragma pack(pop)
+
+#if defined(_WIN64)
+  FAIL() << "Running 32-bit codepath";
+#else
+  Code* patched = reinterpret_cast<Code*>(source);
+  EXPECT_EQ(kJump32, patched->jump);
+
+  ULONG source_addr = base::bit_cast<ULONG>(source);
+  ULONG target_addr = base::bit_cast<ULONG>(target);
+  EXPECT_EQ(target_addr + 19 - source_addr, patched->delta);
+#endif
+}
+
 NTSTATUS PatchNtdllWithResolver(const char* function,
                                 bool relaxed,
-                                ServiceResolverTest& resolver) {
+                                ResolverThunkTest* thunk_test) {
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   EXPECT_TRUE(ntdll_base);
 
@@ -72,20 +117,21 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
   BYTE service[50];
   memcpy(service, target, sizeof(service));
 
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
-  resolver.AllowLocalPatches();
+  resolver->AllowLocalPatches();
 
-  NTSTATUS ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                                function_entry, thunk.get(), thunk_size, &used);
+  NTSTATUS ret =
+      resolver->Setup(ntdll_base, nullptr, function, nullptr, function_entry,
+                      thunk.get(), thunk_size, &used);
   if (NT_SUCCESS(ret)) {
-    const BYTE kJump32 = 0xE9;
     EXPECT_EQ(thunk_size, used);
     EXPECT_NE(0, memcmp(service, target, sizeof(service)));
     EXPECT_NE(kJump32, service[0]);
@@ -93,18 +139,30 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
     if (relaxed) {
       // It's already patched, let's patch again, and simulate a direct patch.
       service[0] = kJump32;
-      ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                           function_entry, thunk.get(), thunk_size, &used);
-      EXPECT_TRUE(resolver.VerifyJumpTargetForTesting(thunk.get()));
+      ret = resolver->Setup(ntdll_base, nullptr, function, nullptr,
+                            function_entry, thunk.get(), thunk_size, &used);
+      CheckJump(service, thunk.get());
     }
   }
 
   return ret;
 }
 
+std::unique_ptr<ResolverThunkTest> GetTestResolver(bool relaxed) {
+#if defined(_WIN64)
+  return std::make_unique<WinXpResolverTest>(relaxed);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  if (os_info->IsWowX86OnAMD64())
+    return std::make_unique<Wow64W10ResolverTest>(relaxed);
+
+  return std::make_unique<Win8ResolverTest>(relaxed);
+#endif
+}
+
 NTSTATUS PatchNtdll(const char* function, bool relaxed) {
-  ServiceResolverTest resolver(relaxed);
-  return PatchNtdllWithResolver(function, relaxed, resolver);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(relaxed);
+  return PatchNtdllWithResolver(function, relaxed, thunk_test.get());
 }
 
 TEST(ServiceResolverTest, PatchesServices) {
@@ -155,26 +213,26 @@ TEST(ServiceResolverTest, PatchesPatchedServices) {
 TEST(ServiceResolverTest, MultiplePatchedServices) {
 // We don't support "relaxed mode" for Win64 apps.
 #if !defined(_WIN64)
-  ServiceResolverTest thunk_test(true);
-  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
+  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateFile, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateMutant, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, LocalPatchesAllowed) {
-  ServiceResolverTest resolver(true);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
 
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   ASSERT_TRUE(ntdll_base);
@@ -187,25 +245,26 @@ TEST(ServiceResolverTest, LocalPatchesAllowed) {
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
   NTSTATUS ret = STATUS_UNSUCCESSFUL;
 
   // First try patching without having allowed local patches.
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_FALSE(NT_SUCCESS(ret));
 
   // Now allow local patches and check that things work.
-  resolver.AllowLocalPatches();
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  resolver->AllowLocalPatches();
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_EQ(STATUS_SUCCESS, ret);
 }
 
diff --git a/sandbox/win/src/startup_information_helper.cc b/sandbox/win/src/startup_information_helper.cc
index b7688c6b74d9c..dab303f872b1e 100644
--- a/sandbox/win/src/startup_information_helper.cc
+++ b/sandbox/win/src/startup_information_helper.cc
@@ -115,6 +115,8 @@ bool StartupInformationHelper::BuildStartupInformation() {
   if (!startup_info_.InitializeProcThreadAttributeList(expected_attributes))
     return false;
 
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
+
   if (mitigations_[0] || mitigations_[1]) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &mitigations_[0],
@@ -133,7 +135,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     }
     expected_attributes--;
   }
-
+  }
   if (restrict_child_process_creation_) {
     child_process_creation_ = PROCESS_CREATION_CHILD_PROCESS_RESTRICTED;
     if (!startup_info_.UpdateProcThreadAttribute(
@@ -159,7 +161,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     inherit_handles_ = true;
     expected_attributes--;
   }
-
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
   if (!job_handle_list_.empty()) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_JOB_LIST, &job_handle_list_[0],
@@ -191,6 +193,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
   }
 
   CHECK(expected_attributes == 0);
+  }
   return true;
 }
 
diff --git a/sandbox/win/src/target_services.cc b/sandbox/win/src/target_services.cc
index 603ed9bd8a725..dd06f131529a2 100644
--- a/sandbox/win/src/target_services.cc
+++ b/sandbox/win/src/target_services.cc
@@ -16,6 +16,7 @@
 #include "base/containers/span.h"
 #include "base/logging.h"
 #include "base/win/access_token.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/handle_closer_agent.h"
@@ -115,6 +116,8 @@ bool WarmupWindowsLocales() {
 }
 
 bool SetProcessIntegrityLevel(IntegrityLevel integrity_level) {
+  if (base::win::GetVersion() < base::win::Version::VISTA)
+    return true;
   std::optional<DWORD> rid = GetIntegrityLevelRid(integrity_level);
   if (!rid) {
     // No mandatory level specified, we don't change it.
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index 6b34ade19b28f..dc3f2751ea554 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -571,6 +571,36 @@ std::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return handle_map;
 }
 
+std::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
+    return std::nullopt;
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 }  // namespace sandbox
 
 void ResolveNTFunctionPtr(const char* name, void* ptr) {
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index 0f62c23677133..bdf95cb2de733 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -115,6 +115,11 @@ void* GetProcessBaseAddress(HANDLE process);
 // use them.
 std::optional<ProcessHandleMap> GetCurrentProcessHandles();
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+std::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
 }  // namespace sandbox
 
 // Resolves a function name in NTDLL to a function pointer. The second parameter
diff --git a/services/device/geolocation/win/location_provider_winrt.cc b/services/device/geolocation/win/location_provider_winrt.cc
index 9406c2b456dd4..c5c1eb0b183a5 100644
--- a/services/device/geolocation/win/location_provider_winrt.cc
+++ b/services/device/geolocation/win/location_provider_winrt.cc
@@ -49,6 +49,11 @@ using Microsoft::WRL::ComPtr;
 // API which will trigger an update.
 constexpr double kDefaultMovementThresholdMeters = 1.0;
 
+bool IsWinRTSupported() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 template <typename F>
 absl::optional<DOUBLE> GetOptionalDouble(F&& getter) {
   DOUBLE value = 0;
@@ -460,6 +465,7 @@ std::unique_ptr<LocationProvider> NewSystemLocationProvider(
     GeolocationManager* geolocation_manager) {
   if (!base::FeatureList::IsEnabled(
           features::kWinrtGeolocationImplementation) ||
+	!IsWinRTSupported() ||
       !IsSystemLocationSettingEnabled()) {
     return nullptr;
   }
diff --git a/services/proxy_resolver_win/BUILD.gn b/services/proxy_resolver_win/BUILD.gn
index ed4b004f06350..c3fa7ec452180 100644
--- a/services/proxy_resolver_win/BUILD.gn
+++ b/services/proxy_resolver_win/BUILD.gn
@@ -11,6 +11,8 @@ component("proxy_resolver_win") {
     "winhttp_api_wrapper.h",
     "winhttp_api_wrapper_impl.cc",
     "winhttp_api_wrapper_impl.h",
+    "winhttp_proxy_resolver_functions.cc",
+    "winhttp_proxy_resolver_functions.h",
   ]
 
   libs = [ "winhttp.lib" ]
diff --git a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
index 68801e4636cab..e22cdfbb1fa0e 100644
--- a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
+++ b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
@@ -15,6 +15,8 @@ EnumTraits<proxy_resolver_win::mojom::WinHttpStatus,
       return proxy_resolver_win::mojom::WinHttpStatus::kOk;
     case net::WinHttpStatus::kAborted:
       return proxy_resolver_win::mojom::WinHttpStatus::kAborted;
+   case net::WinHttpStatus::kFunctionsNotLoaded:
+      return proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded;
     case net::WinHttpStatus::kWinHttpOpenFailed:
       return proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed;
     case net::WinHttpStatus::kWinHttpSetTimeoutsFailed:
@@ -55,6 +57,9 @@ bool EnumTraits<proxy_resolver_win::mojom::WinHttpStatus, net::WinHttpStatus>::
     case proxy_resolver_win::mojom::WinHttpStatus::kAborted:
       *output = net::WinHttpStatus::kAborted;
       return true;
+    case proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded:
+      *output = net::WinHttpStatus::kFunctionsNotLoaded;
+      return true;
     case proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed:
       *output = net::WinHttpStatus::kWinHttpOpenFailed;
       return true;
diff --git a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
index c05d1f63d7d9b..ff3447e285e46 100644
--- a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
+++ b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
@@ -12,6 +12,7 @@ import "url/mojom/url.mojom";
 enum WinHttpStatus {
   kOk,
   kAborted,
+  kFunctionsNotLoaded,
   kWinHttpOpenFailed,
   kWinHttpSetTimeoutsFailed,
   kWinHttpSetStatusCallbackFailed,
diff --git a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
index 54baece710f7a..78e4538bd2ded 100644
--- a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
+++ b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
@@ -9,6 +9,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
 
 namespace proxy_resolver_win {
 
@@ -34,9 +35,9 @@ WinHttpAPIWrapperImpl::~WinHttpAPIWrapperImpl() {
 
 bool WinHttpAPIWrapperImpl::CallWinHttpOpen() {
   DCHECK_EQ(nullptr, session_handle_);
-  session_handle_ = ::WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY,
-                                  WINHTTP_NO_PROXY_NAME,
-                                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
+  session_handle_ =
+      WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME,
+                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
   return (session_handle_ != nullptr);
 }
 
@@ -45,16 +46,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetTimeouts(int resolve_timeout,
                                                    int send_timeout,
                                                    int receive_timeout) {
   DCHECK_NE(nullptr, session_handle_);
-  return (!!::WinHttpSetTimeouts(session_handle_, resolve_timeout,
-                                 connect_timeout, send_timeout,
-                                 receive_timeout));
+  return (!!WinHttpSetTimeouts(session_handle_, resolve_timeout,
+                               connect_timeout, send_timeout, receive_timeout));
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
     WINHTTP_STATUS_CALLBACK internet_callback) {
   DCHECK_NE(nullptr, session_handle_);
   const WINHTTP_STATUS_CALLBACK winhttp_status_callback =
-      ::WinHttpSetStatusCallback(
+      WinHttpSetStatusCallback(
           session_handle_, internet_callback,
           WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
               WINHTTP_CALLBACK_FLAG_GETPROXYFORURL_COMPLETE,
@@ -64,14 +64,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetIEProxyConfigForCurrentUser(
     WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* ie_proxy_config) {
-  return !!::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
+  return !!WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpCreateProxyResolver(
     HINTERNET* out_resolver_handle) {
   DCHECK_NE(nullptr, session_handle_);
   const DWORD result =
-      ::WinHttpCreateProxyResolver(session_handle_, out_resolver_handle);
+      WinHttpProxyResolverFunctions::GetInstance().create_proxy_resolver(
+          session_handle_, out_resolver_handle);
   return (result == ERROR_SUCCESS);
 }
 
@@ -83,25 +84,28 @@ bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyForUrlEx(
   const std::wstring wide_url(url.begin(), url.end());
   // TODO(https://crbug.com/1032820): Upgrade to WinHttpGetProxyForUrlEx2()
   // if there is a clear reason to do so.
-  const DWORD result = ::WinHttpGetProxyForUrlEx(
-      resolver_handle, wide_url.data(), autoproxy_options, context);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_for_url_ex(
+          resolver_handle, wide_url.data(), autoproxy_options, context);
   return (result == ERROR_IO_PENDING);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyResult(
     HINTERNET resolver_handle,
     WINHTTP_PROXY_RESULT* proxy_result) {
-  const DWORD result = ::WinHttpGetProxyResult(resolver_handle, proxy_result);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_result(
+          resolver_handle, proxy_result);
   return (result == ERROR_SUCCESS);
 }
 
 VOID WinHttpAPIWrapperImpl::CallWinHttpFreeProxyResult(
     WINHTTP_PROXY_RESULT* proxy_result) {
-  WinHttpFreeProxyResult(proxy_result);
+  WinHttpProxyResolverFunctions::GetInstance().free_proxy_result(proxy_result);
 }
 
 void WinHttpAPIWrapperImpl::CallWinHttpCloseHandle(HINTERNET internet_handle) {
-  ::WinHttpCloseHandle(internet_handle);
+  WinHttpCloseHandle(internet_handle);
 }
 
 void WinHttpAPIWrapperImpl::CloseSessionHandle() {
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
new file mode 100644
index 0000000000000..b00c5670bb517
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
@@ -0,0 +1,43 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+WinHttpProxyResolverFunctions::WinHttpProxyResolverFunctions() {
+  HMODULE winhttp_module =
+      LoadLibraryEx(L"winhttp.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  if (winhttp_module) {
+    create_proxy_resolver = reinterpret_cast<WinHttpCreateProxyResolverFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpCreateProxyResolver"));
+    get_proxy_for_url_ex = reinterpret_cast<WinHttpGetProxyForUrlExFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyForUrlEx"));
+    get_proxy_result = reinterpret_cast<WinHttpGetProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyResult"));
+    free_proxy_result = reinterpret_cast<WinHttpFreeProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpFreeProxyResult"));
+  }
+}
+
+// Never called due to base::NoDestructor.
+WinHttpProxyResolverFunctions::~WinHttpProxyResolverFunctions() = default;
+
+bool WinHttpProxyResolverFunctions::are_all_functions_loaded() const {
+  return create_proxy_resolver && get_proxy_for_url_ex && get_proxy_result &&
+         free_proxy_result;
+}
+
+// static
+const WinHttpProxyResolverFunctions&
+WinHttpProxyResolverFunctions::GetInstance() {
+  // This is a singleton for performance reasons. This avoids having to load
+  // proxy resolver functions multiple times.
+  static base::NoDestructor<WinHttpProxyResolverFunctions> instance;
+  return *instance;
+}
+
+}  // namespace proxy_resolver_win
\ No newline at end of file
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
new file mode 100644
index 0000000000000..768269019cd0e
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
@@ -0,0 +1,47 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+#define SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+
+#include <windows.h>
+#include <winhttp.h>
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+// Not all WinHttp APIs we'll be using exist in all versions of Windows.
+// Several only exist in Windows 8+. Thus, each function entry point must be
+// loaded dynamically.
+struct WinHttpProxyResolverFunctions {
+ public:
+  WinHttpProxyResolverFunctions(const WinHttpProxyResolverFunctions&) = delete;
+  WinHttpProxyResolverFunctions& operator=(
+      const WinHttpProxyResolverFunctions&) = delete;
+
+  bool are_all_functions_loaded() const;
+
+  static const WinHttpProxyResolverFunctions& GetInstance();
+
+  using WinHttpCreateProxyResolverFunc = decltype(WinHttpCreateProxyResolver)*;
+  using WinHttpGetProxyForUrlExFunc = decltype(WinHttpGetProxyForUrlEx)*;
+  using WinHttpGetProxyResultFunc = decltype(WinHttpGetProxyResult)*;
+  using WinHttpFreeProxyResultFunc = decltype(WinHttpFreeProxyResult)*;
+
+  WinHttpCreateProxyResolverFunc create_proxy_resolver = nullptr;
+  WinHttpGetProxyForUrlExFunc get_proxy_for_url_ex = nullptr;
+  WinHttpGetProxyResultFunc get_proxy_result = nullptr;
+  WinHttpFreeProxyResultFunc free_proxy_result = nullptr;
+
+ private:
+  friend class base::NoDestructor<WinHttpProxyResolverFunctions>;
+
+  WinHttpProxyResolverFunctions();
+  ~WinHttpProxyResolverFunctions();
+};
+
+}  // namespace proxy_resolver_win
+
+#endif  // SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
\ No newline at end of file
diff --git a/services/shape_detection/face_detection_provider_win.cc b/services/shape_detection/face_detection_provider_win.cc
index 59e9eb36d95a5..dbe49923cf948 100644
--- a/services/shape_detection/face_detection_provider_win.cc
+++ b/services/shape_detection/face_detection_provider_win.cc
@@ -49,6 +49,11 @@ BitmapPixelFormat GetPreferredPixelFormat(IFaceDetectorStatics* factory) {
 void FaceDetectionProviderWin::CreateFaceDetection(
     mojo::PendingReceiver<shape_detection::mojom::FaceDetection> receiver,
     shape_detection::mojom::FaceDetectorOptionsPtr options) {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
   ComPtr<IFaceDetectorStatics> factory;
   HRESULT hr = GetActivationFactory<
       IFaceDetectorStatics,
diff --git a/services/shape_detection/text_detection_impl_win.cc b/services/shape_detection/text_detection_impl_win.cc
index a442dced19ad6..ca4d116a84863 100644
--- a/services/shape_detection/text_detection_impl_win.cc
+++ b/services/shape_detection/text_detection_impl_win.cc
@@ -42,6 +42,13 @@ using Microsoft::WRL::ComPtr;
 // static
 void TextDetectionImpl::Create(
     mojo::PendingReceiver<mojom::TextDetection> receiver) {
+
+if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
+
   // Text Detection specification only supports Latin-1 text as documented in
   // https://wicg.github.io/shape-detection-api/text.html#text-detection-api.
   // TODO(junwei.fu): https://crbug.com/794097 consider supporting other Latin
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index 7501833779338..615da0791475d 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -109,14 +109,14 @@ config("skia_config") {
     defines += [ "SK_DISABLE_LEGACY_INIT_DECODERS" ]
   }
 
-  if (is_component_build) {
+ # if (is_component_build) {
     defines += [ "SKIA_DLL" ]
     if (is_win) {
       defines += [ "SKCMS_API=__declspec(dllexport)" ]
     } else {
       defines += [ "SKCMS_API=__attribute__((visibility(\"default\")))" ]
     }
-  }
+ # }
 
   if (is_android) {
     defines += [
@@ -437,6 +437,7 @@ component("skia") {
   if (is_win) {
     # See SK_TYPEFACE_FACTORY_DIRECTWRITE
     sources += [
+      "//third_party/skia/src/ports/SkFontHost_win.cpp",
       "//third_party/skia/src/ports/SkFontMgr_win_dw.cpp",
       "//third_party/skia/src/ports/SkOSFile_win.cpp",
       "//third_party/skia/src/ports/SkRemotableFontMgr_win_dw.cpp",
diff --git a/skia/ext/font_utils.cc b/skia/ext/font_utils.cc
index 3631af6cc9587..01b12a8de68a3 100644
--- a/skia/ext/font_utils.cc
+++ b/skia/ext/font_utils.cc
@@ -32,6 +32,7 @@
 #endif
 
 #if BUILDFLAG(IS_WIN)
+#include "base/command_line.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -68,7 +69,9 @@ static sk_sp<SkFontMgr> fontmgr_factory() {
   base::ComponentContextForProcess()->svc()->Connect(provider.NewRequest());
   return SkFontMgr_New_Fuchsia(std::move(provider));
 #elif BUILDFLAG(IS_WIN)
-  return SkFontMgr_New_DirectWrite();
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("disable-direct-write"))
+	  return SkFontMgr_New_GDI();
+  return SkFontMgr_New_DirectWrite() ? SkFontMgr_New_DirectWrite() : SkFontMgr_New_GDI();
 #elif defined(SK_FONTMGR_FREETYPE_EMPTY_AVAILABLE)
   return SkFontMgr_New_Custom_Empty();
 #else
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index a66ddcf4d9031..c6ddb5b7e6061 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -20,6 +20,13 @@ struct DWriteFontStyle {
   uint8 font_stretch;
 };
 
+struct FallbackFamilyAndStyle {
+  string fallback_family_name;
+  uint16 weight;
+  uint8 width;
+  uint8 slant;
+};
+
 struct MapCharactersResult {
   uint32 family_index;
   mojo_base.mojom.String16 family_name;
@@ -28,6 +35,11 @@ struct MapCharactersResult {
   DWriteFontStyle font_style;
 };
 
+enum UniqueFontLookupMode {
+    kRetrieveTable,
+    kSingleLookups
+};
+
 interface DWriteFontProxy {
   // Locates the index of the specified font family within the system
   // collection.
@@ -51,14 +63,47 @@ interface DWriteFontProxy {
   GetFontFileHandles(uint32 family_index)
      => (array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
@@ -73,4 +118,18 @@ interface DWriteFontProxy {
                 uint32 reading_direction,
                 mojo_base.mojom.String16 base_family_name)
       => (MapCharactersResult out);
+
+  // For a given base family name, bcp47 language tag, and codepoint to look up,
+  // return a font family name that is available on the system to display the
+  // given codepoint. This internally calls Skia's
+  // SkFontMgr_DirectWrite::matchFamilyStyleCharacter which executes
+  // IDWriteTextLayout based fallback code, which cannot be run in the renderer
+  // due triggering loading the DWrite system font collection.
+  // Use only on Windows 8.0 and earlier - otherwise better fallback API is
+  // available through using a proxies IDWriteFontFallback.
+  [Sync]
+  FallbackFamilyAndStyleForCodepoint(string base_family_name,
+                                     string bcp47_language_tag,
+                                     uint32 codepoint)
+      => (FallbackFamilyAndStyle fallback_result);
 };
diff --git a/third_party/blink/public/platform/platform.h b/third_party/blink/public/platform/platform.h
index 52829e870d30a..ba31da5f16900 100644
--- a/third_party/blink/public/platform/platform.h
+++ b/third_party/blink/public/platform/platform.h
@@ -613,6 +613,11 @@ class BLINK_PLATFORM_EXPORT Platform {
                                             uint16_t* udp_max_port,
                                             bool* allow_mdns_obfuscation) {}
 
+  virtual bool IsWebRtcHWH264DecodingEnabled(
+      webrtc::VideoCodecType video_coded_type) {
+    return true;
+  }
+
   virtual bool IsWebRtcHWEncodingEnabled() { return true; }
 
   virtual bool IsWebRtcHWDecodingEnabled() { return true; }
diff --git a/third_party/blink/public/web/win/web_font_rendering.h b/third_party/blink/public/web/win/web_font_rendering.h
index 851b6c95d0c69..1c3135b59201f 100644
--- a/third_party/blink/public/web/win/web_font_rendering.h
+++ b/third_party/blink/public/web/win/web_font_rendering.h
@@ -18,6 +18,7 @@ class WebFontRenderingClient;
 
 class BLINK_EXPORT WebFontRendering {
  public:
+  static void setUseDirectWrite(bool);
   static void SetSkiaFontManager(sk_sp<SkFontMgr>);
   // Set an instance of |WebFontPrewarmer|. The instance must be kept alive
   // until the process exits.
@@ -34,6 +35,7 @@ class BLINK_EXPORT WebFontRendering {
                                    int32_t font_height);
   static void SetAntialiasedTextEnabled(bool);
   static void SetLCDTextEnabled(bool);
+  static void SetUseSkiaFontFallback(bool);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
index 178b04c75c258..de8cc3fcdc8ed 100644
--- a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
+++ b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
@@ -9,6 +9,12 @@
 
 namespace blink {
 
+// static
+void WebFontRendering::setUseDirectWrite(bool useDirectWrite)
+{
+    FontCache::setUseDirectWrite(useDirectWrite);
+}
+
 // static
 void WebFontRendering::SetSkiaFontManager(sk_sp<SkFontMgr> font_mgr) {
   FontCache::SetFontManager(std::move(font_mgr));
@@ -59,4 +65,9 @@ void WebFontRendering::SetLCDTextEnabled(bool enabled) {
   FontCache::SetLCDTextEnabled(enabled);
 }
 
+// static
+void WebFontRendering::SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+  FontCache::SetUseSkiaFontFallback(use_skia_font_fallback);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 17889a08bc6fb..3a5678361c3d6 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1640,6 +1640,8 @@ component("platform") {
     sources += [
       "fonts/win/dwrite_font_format_support.cc",
       "fonts/win/dwrite_font_format_support.h",
+      "fonts/win/fallback_family_style_cache_win.cc",
+      "fonts/win/fallback_family_style_cache_win.h",
       "fonts/win/font_cache_skia_win.cc",
       "fonts/win/font_fallback_win.cc",
       "fonts/win/font_fallback_win.h",
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index f2f90c197e28b..0344f989487a5 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -60,6 +60,7 @@
 #include "ui/gfx/font_list.h"
 
 #if BUILDFLAG(IS_WIN)
+#include <Windows.h>
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -78,8 +79,10 @@ float FontCache::device_scale_factor_ = 1.0;
 #endif
 
 #if BUILDFLAG(IS_WIN)
+bool FontCache::s_useDirectWrite = false;
 bool FontCache::antialiased_text_enabled_ = false;
 bool FontCache::lcd_text_enabled_ = false;
+bool FontCache::use_skia_font_fallback_ = false;
 static bool should_use_test_font_mgr = false;
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -90,13 +93,17 @@ FontCache& FontCache::Get() {
 FontCache::FontCache()
     : font_manager_(sk_ref_sp(static_font_manager_)),
       font_platform_data_cache_(FontPlatformDataCache::Create()),
-      font_data_cache_(FontDataCache::Create()) {
+      font_data_cache_(FontDataCache::Create()){
 #if BUILDFLAG(IS_WIN)
+  if (!s_useDirectWrite) {
+	  font_manager_ = SkFontMgr_New_GDI();
+  }
+
   if (!font_manager_ || should_use_test_font_mgr) {
     // This code path is only for unit tests. This SkFontMgr does not work in
     // sandboxed environments, but injecting this initialization code to all
     // unit tests isn't easy.
-    font_manager_ = SkFontMgr_New_DirectWrite();
+		font_manager_ = SkFontMgr_New_DirectWrite();
     // Set |is_test_font_mgr_| to capture if this is not happening in the
     // production code. crbug.com/561873
     is_test_font_mgr_ = true;
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index ecd92fe4b0cd3..efa1060c683b1 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -59,6 +59,11 @@
 #include "ui/gfx/font_fallback_linux.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+#endif
+
 class SkString;
 class SkTypeface;
 
@@ -197,8 +202,10 @@ class PLATFORM_EXPORT FontCache final {
 #if BUILDFLAG(IS_WIN)
   // TODO(https://crbug.com/808221) System font style configuration is not
   // related to FontCache. Move it somewhere else, e.g. to WebThemeEngine.
+  static bool useDirectWrite() { return s_useDirectWrite; }
   static bool AntialiasedTextEnabled() { return antialiased_text_enabled_; }
   static bool LcdTextEnabled() { return lcd_text_enabled_; }
+  static void setUseDirectWrite(bool useDirectWrite) { s_useDirectWrite = useDirectWrite; }
   static void SetAntialiasedTextEnabled(bool enabled) {
     antialiased_text_enabled_ = enabled;
   }
@@ -222,6 +229,13 @@ class PLATFORM_EXPORT FontCache final {
   static const AtomicString& StatusFontFamily() {
     return *status_font_family_name_;
   }
+  static void SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+    use_skia_font_fallback_ = use_skia_font_fallback;
+  }
+
+  // On Windows pre 8.1 establish a connection to the DWriteFontProxy service in
+  // order to retrieve family names for fallback lookup.
+  void EnsureServiceConnected();
 
   scoped_refptr<SimpleFontData> GetFallbackFamilyNameFromHardcodedChoices(
       const FontDescription&,
@@ -352,6 +366,7 @@ class PLATFORM_EXPORT FontCache final {
   static SkFontMgr* static_font_manager_;
 
 #if BUILDFLAG(IS_WIN)
+  static bool s_useDirectWrite;
   static WebFontPrewarmer* prewarmer_;
   static bool antialiased_text_enabled_;
   static bool lcd_text_enabled_;
@@ -362,10 +377,12 @@ class PLATFORM_EXPORT FontCache final {
   static int32_t small_caption_font_height_;
   static AtomicString* status_font_family_name_;
   static int32_t status_font_height_;
+  static bool use_skia_font_fallback_;
 
   // Windows creates an SkFontMgr for unit testing automatically. This flag is
   // to ensure it's not happening in the production from the crash log.
   bool is_test_font_mgr_ = false;
+  std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
index 275beac2b5d90..e2b1763bc7cf0 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
@@ -45,6 +45,9 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
 #include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
+#if BUILDFLAG(IS_WIN)
+#include "third_party/skia/include/ports/SkTypeface_win.h"
+#endif
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "v8/include/v8.h"
 
@@ -128,6 +131,34 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
   // now, going with a reasonable upper limit. Deduplication is
   // handled by Skia with priority given to the last occuring
   // assignment.
+  #if BUILDFLAG(IS_WIN)
+    if (!FontCache::useDirectWrite()) {
+        // FIXME: Skia currently renders synthetic bold and italics with
+        // hinting and without linear metrics on the windows GDI backend
+        // while the DirectWrite backend does the right thing. Using
+        // legacyCreateTypeface and specifying the bold/italics style allows
+        // for proper rendering of synthetic style. Once Skia has been
+        // updated this workaround will no longer be needed.
+        // http://crbug.com/332958
+        bool syntheticBold = bold && !return_typeface->isBold();
+        bool syntheticItalic = italic && !return_typeface->isItalic();
+        if (syntheticBold || syntheticItalic) {
+            SkString name;
+			sk_sp<SkFontMgr> font_mgr(SkFontMgr_New_GDI());
+            return_typeface->getFamilyName(&name);
+
+            SkFontStyle realStyle = return_typeface->fontStyle();
+            SkFontStyle syntheticStyle = SkFontStyle(
+                realStyle.weight() + (syntheticBold ? 200 : 0),
+                realStyle.width(),
+                syntheticItalic ? SkFontStyle::kItalic_Slant : realStyle.slant());
+            sk_sp<SkTypeface> typeface = font_mgr->legacyMakeTypeface(name.c_str(), syntheticStyle);
+            syntheticBold = false;
+            syntheticItalic = false;
+            return FontPlatformData(typeface, "", size, syntheticBold, syntheticItalic, text_rendering, resolved_font_features, orientation);
+        }
+    }
+  #endif
   FontFormatCheck::VariableFontSubType font_sub_type =
       FontFormatCheck::ProbeVariableFont(base_typeface_);
   bool synthetic_bold = bold;
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
index 5192a65c008ff..e01b47dc0f648 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
@@ -83,8 +83,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
 
   // Save first candidate to be returned if all other fonts fail, and we need
   // it to render the .notdef glyph.
-  if (!first_candidate_)
+  if (!first_candidate_) {
     first_candidate_ = candidate;
+  }
   return candidate;
 }
 
@@ -153,8 +154,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
   if (fallback_stage_ == kFirstCandidateForNotdefGlyph) {
     fallback_stage_ = kOutOfLuck;
-    if (!first_candidate_)
-      FontCache::CrashWithFontInfo(&font_description_);
+    if (!first_candidate_) {
+		FontCache::CrashWithFontInfo(&font_description_);
+	}
     return first_candidate_;
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
index fae5547d5ef83..4aa202fbc5640 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
@@ -116,6 +116,7 @@ FontPlatformData* FontPlatformDataCache::GetOrCreateFontPlatformData(
   FontPlatformData* const platform_data = GetOrCreateFontPlatformData(
       font_cache, font_description, create_by_alternate_family,
       AlternateFontName::kNoAlternate);
+
   if (!platform_data)
     return nullptr;
 
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index 1b7be19308566..3ea7a0003eac4 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -194,7 +194,6 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
                             AlternateFontName::kLastResort);
   }
 #endif
-
   DCHECK(font_platform_data);
   return FontDataFromFontPlatformData(font_platform_data, should_retain);
 }
@@ -220,7 +219,6 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   DCHECK_NE(family, font_family_names::kSystemUi);
   // convert the name to utf8
   name = family.Utf8();
-
 #if BUILDFLAG(IS_ANDROID)
   // If this is a locale-specific family, try looking up locale-specific
   // typeface first.
@@ -234,6 +232,12 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   // TODO(https://crbug.com/1425390: Assign FontCache::font_manager_ in the
   // ctor.
   auto font_manager = font_manager_ ? font_manager_ : skia::DefaultFontMgr();
+#if BUILDFLAG(IS_WIN)
+  if (!useDirectWrite()) {
+	return sk_sp<SkTypeface>(font_manager->legacyMakeTypeface(
+      name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
+  }
+#endif
   return sk_sp<SkTypeface>(font_manager->matchFamilyStyle(
       name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
 }
diff --git a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
index 747298f1903fb..e4063b8916588 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
+++ b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
@@ -144,7 +144,19 @@ bool WebFontTypefaceFactory::CreateTypeface(
     const FontFormatCheck& format_check,
     const FontInstantiator& instantiator) {
   CHECK(!typeface);
-
+#if BUILDFLAG(IS_WIN)
+  if (format_check.IsVariableFont() && !FontCache::useDirectWrite()) {
+    typeface = instantiator.make_system(data);
+    if (typeface) {
+      ReportInstantiationResult(
+          InstantiationResult::kSuccessConventionalWebFont);
+      return true;
+    }
+    // Not UMA reporting general decoding errors as these are already recorded
+    // as kPackageFormatUnknown in FontResource.cpp.
+    return false;
+  }
+#endif
   if (!format_check.IsVariableFont() && !format_check.IsColorFont() &&
       !format_check.IsCff2OutlineFont()) {
     typeface = instantiator.make_system(data);
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
new file mode 100644
index 0000000000000..2e8c855270541
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
@@ -0,0 +1,90 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+
+namespace blink {
+
+namespace {
+
+const wtf_size_t kMaxCacheSlots = 16;
+
+String makeCacheKey(FontDescription::GenericFamilyType generic_family,
+                    String bcp47_language_tag,
+                    FontFallbackPriority fallback_priority) {
+  StringBuilder cache_key;
+  cache_key.Append(bcp47_language_tag);
+  cache_key.AppendNumber(
+      static_cast<
+          std::underlying_type<FontDescription::GenericFamilyType>::type>(
+          generic_family));
+  cache_key.AppendNumber(
+      static_cast<std::underlying_type<FontFallbackPriority>::type>(
+          fallback_priority));
+  return cache_key.ToString();
+}
+
+void getFallbackFamilyAndStyle(SkTypeface* typeface,
+                               String* fallback_family,
+                               SkFontStyle* fallback_style) {
+  SkString family;
+  typeface->getFamilyName(&family);
+  *fallback_family = family.c_str();
+
+  *fallback_style = typeface->fontStyle();
+}
+}  // namespace
+
+FallbackFamilyStyleCache::FallbackFamilyStyleCache()
+    : recent_fallback_fonts_(kMaxCacheSlots) {}
+
+void FallbackFamilyStyleCache::Put(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    SkTypeface* typeface) {
+  String cache_key =
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority);
+
+  auto it = recent_fallback_fonts_.Get(cache_key);
+  if (it != recent_fallback_fonts_.end()) {
+    it->second.insert(0, sk_ref_sp(typeface));
+  } else {
+    TypefaceVector typefaces;
+    typefaces.push_back(sk_ref_sp(typeface));
+    recent_fallback_fonts_.Put(std::move(cache_key), std::move(typefaces));
+  }
+}
+
+void FallbackFamilyStyleCache::Get(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    UChar32 character,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  auto it = recent_fallback_fonts_.Get(
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority));
+  if (it == recent_fallback_fonts_.end())
+    return;
+  TypefaceVector& typefaces = it->second;
+  for (wtf_size_t i = 0; i < typefaces.size(); ++i) {
+    sk_sp<SkTypeface>& typeface = typefaces.at(i);
+    if (typeface->unicharToGlyph(character)) {
+      getFallbackFamilyAndStyle(typeface.get(), fallback_family,
+                                fallback_style);
+      sk_sp<SkTypeface> tmp_typeface(typeface);
+      // For the vector of typefaces for this specific language tag, since this
+      // SkTypeface had a glyph, move it to the beginning to accelerate
+      // subsequent lookups.
+      typefaces.EraseAt(i);
+      typefaces.insert(0, std::move(tmp_typeface));
+      return;
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
new file mode 100644
index 0000000000000..72e27fa69b27f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
@@ -0,0 +1,59 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+
+#include "base/containers/lru_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+using TypefaceVector = Vector<sk_sp<SkTypeface>>;
+using FallbackLruCache = base::HashingLRUCache<String, TypefaceVector>;
+
+class FallbackFamilyStyleCache {
+  USING_FAST_MALLOC(FallbackFamilyStyleCache);
+
+ public:
+  FallbackFamilyStyleCache();
+  FallbackFamilyStyleCache(const FallbackFamilyStyleCache&) = delete;
+  FallbackFamilyStyleCache& operator=(const FallbackFamilyStyleCache&) = delete;
+
+  // Places a SkTypeface object in the cache for specified language tag and
+  // fallback priority, taking a reference on SkTypeface. Adds the |SkTypeface|
+  // to the beginning of a list of typefaces if previous |SkTypefaces| objects
+  // where added for this set of parameters. Note, the internal list of
+  // typefaces for a language tag and fallback priority is not checked for
+  // duplicates when adding a |typeface| object.
+  void Put(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           SkTypeface* typeface);
+
+  // Fetches a |fallback_family| and |fallback_style| for a given language tag,
+  // fallback priority and codepoint. Checks the internal cache for whether a
+  // fallback font with glyph coverage for |character| is available for the
+  // given parameters, then returns its family name and style.
+  void Get(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           UChar32 character,
+           String* fallback_family,
+           SkFontStyle* fallback_style);
+
+  // Empties the internal cache, deleting keys and unrefing the typefaces that
+  // were placed in the cache.
+  void Clear();
+
+ private:
+  FallbackLruCache recent_fallback_fonts_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
new file mode 100644
index 0000000000000..0363fdca92dde
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
@@ -0,0 +1,99 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace {
+
+const char kHanSimplifiedLocale[] = "zh-Hans";
+const size_t kLruCacheTestSize = 5;
+const char kFontFamilyNameArial[] = "Arial";
+const UChar32 kFirstCJKIdeograph = 0x4E00;
+const UChar32 kSecondCJKIdeograph = kFirstCJKIdeograph + 1;
+
+sk_sp<SkTypeface> fallbackForLocale(String locale, UChar32 codepoint) {
+  sk_sp<SkFontMgr> font_mgr = SkFontMgr::RefDefault();
+  std::string locale_string(locale.Ascii());
+  const char* locale_char = locale_string.c_str();
+  return sk_sp<SkTypeface>(font_mgr->matchFamilyStyleCharacter(
+      kFontFamilyNameArial, SkFontStyle(), &locale_char, 1, codepoint));
+}
+
+void fillCacheWithDummies(blink::FallbackLruCache& lru_cache,
+                          const char* format_string,
+                          size_t count) {
+  for (size_t i = 0; i < count; ++i) {
+    blink::TypefaceVector dummy_typefaces;
+    dummy_typefaces.push_back(
+        SkTypeface::MakeFromName(kFontFamilyNameArial, SkFontStyle()));
+    lru_cache.Put(String::Format(format_string, i), std::move(dummy_typefaces));
+  }
+}
+
+}  // namespace
+
+namespace blink {
+
+TEST(FallbackLruCacheTest, KeepChineseWhenFetched) {
+  // Put a Chinese font in the cache, add size - 1 more dummy fallback fonts so
+  // that the cache is full. Get() and verify typeface for Chinese to move them
+  // up to the top of the cache. Then fill again with size - 1 items and verify
+  // that Chinese is still in the cache. Then fill with # size items to evict
+  // the Chinese font and ensure it's gone.
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  TypefaceVector fallback_typefaces_zh;
+  fallback_typefaces_zh.push_back(
+      fallbackForLocale(kHanSimplifiedLocale, kFirstCJKIdeograph));
+  lru_cache.Put(kHanSimplifiedLocale, std::move(fallback_typefaces_zh));
+
+  EXPECT_EQ(lru_cache.size(), 1u);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", kLruCacheTestSize - 1);
+  auto it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  TypefaceVector& chinese_typefaces = it->second;
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(0x4E01));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_2nd_%zu",
+                       kLruCacheTestSize - 1);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  chinese_typefaces = it->second;
+  EXPECT_EQ(chinese_typefaces.size(), 1u);
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(kSecondCJKIdeograph));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_3rd_%zu", kLruCacheTestSize);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it == lru_cache.end());
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+}
+
+TEST(FallbackLruCacheTest, LargeFillAndClear) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", 1000);
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+  lru_cache.Clear();
+  EXPECT_EQ(lru_cache.size(), 0u);
+}
+
+TEST(FallbackLruCacheTest, KeyOverride) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "same_locale", 10);
+  EXPECT_EQ(lru_cache.size(), 1u);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index 01e6acd3c8dbc..b7e2f9a024e08 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -42,6 +42,8 @@
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/trace_event/trace_event.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/web_font_prewarmer.h"
 #include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -247,30 +249,75 @@ scoped_refptr<SimpleFontData> FontCache::GetDWriteFallbackFamily(
       font_description, fallback_priority, codepoint);
   DCHECK(fallback_locale);
 
-  const std::string family_name = font_description.Family().FamilyName().Utf8();
+  // On Pre Windows 8.1 (where use_skia_font_fallback_ is false) we cannot call
+  // the Skia version, as there is no IDWriteFontFallback (which is
+  // proxyable). If no IDWriteFontFallback API exists in the DWrite Skia
+  // SkTypeface implemnetation it will proceed to call the layoutFallback method
+  // of SkTypeface DWrite implementation. This method we must not call in the
+  // renderer as it causes stability issues due to reaching a path that will try
+  // to load the system font collection in-process and thus load DLLs that are
+  // blocked in the renderer, see comment in dwrite_font_proxy_init_impl_win.cc
+  // InitializeDWriteFontProxy(). Hence, for Windows pre 8.1 we add a
+  // DWriteFontProxy code path to retrieve a family name as string for a
+  // character + language tag and call matchFamilyStyleCharacter on the browser
+  // side, where we can do that.
+  if (!use_skia_font_fallback_) {
+    String fallback_family;
+    SkFontStyle fallback_style;
+
+    if (UNLIKELY(!fallback_params_cache_)) {
+      fallback_params_cache_ = std::make_unique<FallbackFamilyStyleCache>();
+    }
 
-  Bcp47Vector locales;
-  locales.push_back(fallback_locale->LocaleForSkFontMgr());
-  sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
-      family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
-      locales.size(), codepoint));
+    fallback_params_cache_->Get(
+        font_description.GenericFamily(), fallback_locale->LocaleForSkFontMgr(),
+        fallback_priority, codepoint, &fallback_family, &fallback_style);
+    bool result_from_cache = !fallback_family.IsNull();
 
-  if (!typeface) {
-    return nullptr;
-  }
+    if (!result_from_cache) {
+        return nullptr;
+    }
+
+    FontFaceCreationParams create_by_family((AtomicString(fallback_family)));
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(fallback_style);
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+
+    if (!result_from_cache) {
+      fallback_params_cache_->Put(font_description.GenericFamily(),
+                                  fallback_locale->LocaleForSkFontMgr(),
+                                  fallback_priority, data->Typeface());
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  } else {
+    std::string family_name = font_description.Family().FamilyName().Utf8();
+
+    Bcp47Vector locales;
+    locales.push_back(fallback_locale->LocaleForSkFontMgr());
+    sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
+        family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+        locales.size(), codepoint));
+
+    if (!typeface)
+      return nullptr;
 
-  SkString skia_family;
-  typeface->getFamilyName(&skia_family);
-  FontDescription fallback_updated_font_description(font_description);
-  fallback_updated_font_description.UpdateFromSkiaFontStyle(
-      typeface->fontStyle());
-  const FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
-  FontPlatformData* data =
-      GetFontPlatformData(fallback_updated_font_description, create_by_family);
-  if (!data || !data->FontContainsCharacter(codepoint)) {
-    return nullptr;
+    SkString skia_family;
+    typeface->getFamilyName(&skia_family);
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(
+        typeface->fontStyle());
+    FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
   }
-  return FontDataFromFontPlatformData(data, kDoNotRetain);
+  NOTREACHED();
+  return nullptr;
 }
 
 // Given the desired base font, this will create a SimpleFontData for a specific
@@ -296,9 +343,10 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       GetFallbackFamilyNameFromHardcodedChoices(font_description, character,
                                                 fallback_priority);
 
-  // Fall through to running the API-based fallback.
+  // Fall through to running the API based fallback on Windows 8.1 and above
+  // where API fallback was previously available.
   if (RuntimeEnabledFeatures::LegacyWindowsDWriteFontFallbackEnabled() ||
-      !hardcoded_list_fallback_font) {
+      (!hardcoded_list_fallback_font && use_skia_font_fallback_)) {
     return GetDWriteFallbackFamily(font_description, character,
                                    fallback_priority);
   }
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
index fe7c9a5c819bd..12b8e76a39921 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
@@ -48,11 +48,19 @@ namespace blink {
 
 namespace {
 
+const char kArial[] = "Arial";
+const char kCourierNew[] = "Courier New";
+const char kTimesNewRoman[] = "Times New Roman";
+
 static inline bool IsFontPresent(const UChar* font_name,
                                  SkFontMgr* font_manager) {
   String family = font_name;
-  sk_sp<SkTypeface> tf(
-      font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle()));
+  sk_sp<SkTypeface> tf;
+  if (FontCache::useDirectWrite()) {
+	tf = font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle());
+  } else {
+	tf = font_manager->legacyMakeTypeface(family.Utf8().data(), SkFontStyle());
+  }
   if (!tf)
     return false;
 
@@ -538,4 +546,38 @@ const UChar* GetFallbackFamily(UChar32 character,
   return family;
 }
 
+bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& service,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  String base_family_name_approximation;
+  switch (generic_family) {
+    case FontDescription::kMonospaceFamily:
+      base_family_name_approximation = kCourierNew;
+      break;
+    case FontDescription::kSansSerifFamily:
+      base_family_name_approximation = kArial;
+      break;
+    default:
+      base_family_name_approximation = kTimesNewRoman;
+  }
+
+  mojom::blink::FallbackFamilyAndStylePtr fallback_family_and_style;
+  bool mojo_result = service->FallbackFamilyAndStyleForCodepoint(
+      base_family_name_approximation, bcp47_language_tag, character,
+      &fallback_family_and_style);
+
+  SECURITY_DCHECK(fallback_family);
+  SECURITY_DCHECK(fallback_style);
+  *fallback_family = fallback_family_and_style->fallback_family_name;
+  *fallback_style = SkFontStyle(
+      fallback_family_and_style->weight, fallback_family_and_style->width,
+      static_cast<SkFontStyle::Slant>(fallback_family_and_style->slant));
+  return mojo_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
index 6a51e150dc5b9..254eba78a3639 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
@@ -34,10 +34,13 @@
 #include <unicode/locid.h>
 #include <unicode/uscript.h>
 
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 class SkFontMgr;
 
@@ -55,6 +58,19 @@ PLATFORM_EXPORT const UChar* GetFallbackFamily(
     FontFallbackPriority,
     SkFontMgr* font_manager);
 
+// Return a font family that can render |character| based on what script
+// that characters belong to by performing an out of process lookup and using
+// system fallback API based on IDWriteTextLayout. This method is only to be
+// used on pre Windows 8.1, as otherwise IDWriteFontFallback API is available.
+PLATFORM_EXPORT bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& font_proxy,
+    String* fallback_family,
+    SkFontStyle* fallback_style);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_FALLBACK_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index f35e19882bc6c..3d3e1b1855192 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -11,6 +11,7 @@
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "skia/ext/font_utils.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
@@ -28,11 +29,14 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -45,6 +49,32 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  absl::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  sk_sp<SkFontMgr> mgr = skia::DefaultFontMgr();
+  return mgr->makeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -63,11 +93,52 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
-    EnsureServiceConnected();
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
+  }
+
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
   }
 
-  return true;
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -77,11 +148,66 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index 7b31b5af1cabc..abdf287af3677 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows Vista, 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,17 +32,32 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
+
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  absl::optional<bool> sync_available_;
+  absl::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
index a3aebc48df892..2b8cc22769a6d 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
@@ -500,6 +500,9 @@ std::unique_ptr<RTCVideoDecoderAdapter> RTCVideoDecoderAdapter::Create(
   const webrtc::VideoCodecType video_codec_type =
       webrtc::PayloadStringToCodecType(format.name);
 
+  if (!Platform::Current()->IsWebRtcHWH264DecodingEnabled(video_codec_type))
+    return nullptr;
+
   // Bail early for unknown codecs.
   if (WebRtcToMediaVideoCodec(video_codec_type) == media::VideoCodec::kUnknown)
     return nullptr;
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
index a6142fc23f148..ebf06eb9cf815 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
@@ -279,6 +279,9 @@ RTCVideoDecoderStreamAdapter::Create(
   const webrtc::VideoCodecType video_codec_type =
       webrtc::PayloadStringToCodecType(format.name);
 
+  if (!Platform::Current()->IsWebRtcHWH264DecodingEnabled(video_codec_type))
+    return nullptr;
+
   // Bail early for unknown codecs.
   if (WebRtcToMediaVideoCodec(video_codec_type) == media::VideoCodec::kUnknown)
     return nullptr;
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_win.cc b/third_party/crashpad/crashpad/client/crashpad_client_win.cc
index 9b52fcd0f4181..d3bfdbe614076 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_win.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_win.cc
@@ -456,7 +456,7 @@ bool StartHandlerProcess(
       initialize_proc_thread_attribute_list
           ? GET_FUNCTION(L"kernel32.dll", ::UpdateProcThreadAttribute)
           : nullptr;
-  if (!initialize_proc_thread_attribute_list || !update_proc_thread_attribute) {
+  if (!initialize_proc_thread_attribute_list || !update_proc_thread_attribute || !IsWindowsVistaOrGreater()) {
     // The OS doesn’t allow handle inheritance to be restricted, so the handler
     // will inherit every inheritable handle.
     creation_flags = 0;
diff --git a/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc b/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc
index 6c06165f6870b..071daa79d0e5e 100644
--- a/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc
+++ b/third_party/crashpad/crashpad/snapshot/win/process_snapshot_win.cc
@@ -287,10 +287,13 @@ void ProcessSnapshotWin::InitializeUnloadedModules() {
 #else
 #error port
 #endif
-
   ULONG* element_size;
   ULONG* element_count;
   void* event_trace_address;
+
+  if (!GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlGetUnloadEventTraceEx"))
+    return;
+
   RtlGetUnloadEventTraceEx(&element_size, &element_count, &event_trace_address);
 
   if (*element_size < sizeof(RTL_UNLOAD_EVENT_TRACE<Traits>)) {
diff --git a/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc b/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc
index 59a7bbdfbafb6..73da14d113644 100644
--- a/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc
+++ b/third_party/crashpad/crashpad/util/win/registration_protocol_win.cc
@@ -151,15 +151,16 @@ HANDLE CreateNamedPipeInstance(const std::wstring& pipe_name,
   SECURITY_ATTRIBUTES* security_attributes_pointer = nullptr;
 
   if (first_instance) {
-    // Pre-Vista does not have integrity levels.
-    if (IsWindowsVistaOrGreater()) {
+    // Pre-Vista does not have integrity levels. But we still need the crashpad
+    // process to inherit the handle.
       memset(&security_attributes, 0, sizeof(security_attributes));
       security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
+	  if (IsWindowsVistaOrGreater()) {
       security_attributes.lpSecurityDescriptor =
           const_cast<void*>(GetSecurityDescriptorForNamedPipeInstance(nullptr));
+	  }
       security_attributes.bInheritHandle = TRUE;
       security_attributes_pointer = &security_attributes;
-    }
   }
 
   return CreateNamedPipe(
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 1147a6e268f64..cec02efe6a5d1 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -1156,6 +1156,7 @@ test("ui_base_unittests") {
     ]
     if (is_win) {
       sources += [
+        "ime/win/imm32_manager_unittest.cc",
         "ime/win/on_screen_keyboard_display_manager_unittest.cc",
         "ime/win/tsf_input_scope_unittest.cc",
         "ime/win/tsf_text_store_unittest.cc",
diff --git a/ui/base/ime/init/input_method_factory.cc b/ui/base/ime/init/input_method_factory.cc
index c99fd18826153..deab646f928ad 100644
--- a/ui/base/ime/init/input_method_factory.cc
+++ b/ui/base/ime/init/input_method_factory.cc
@@ -13,6 +13,8 @@
 #include "ui/gfx/switches.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "ui/base/ime/win/input_method_win_imm32.h"
 #include "ui/base/ime/win/input_method_win_tsf.h"
 #elif BUILDFLAG(IS_APPLE)
 #include "ui/base/ime/mac/input_method_mac.h"
@@ -33,7 +35,12 @@ bool g_create_input_method_called = false;
 }  // namespace
 
 namespace ui {
-
+#if BUILDFLAG(IS_WIN)
+bool IsUsingTSFForIME() {
+    return base::win::GetVersion() >= base::win::Version::VISTA &&
+           base::FeatureList::IsEnabled(features::kTSFImeSupport);
+  }
+#endif
 std::unique_ptr<InputMethod> CreateInputMethod(
     ImeKeyEventDispatcher* ime_key_event_dispatcher,
     gfx::AcceleratedWidget widget) {
@@ -53,7 +60,12 @@ std::unique_ptr<InputMethod> CreateInputMethod(
     return base::WrapUnique(new MockInputMethod(ime_key_event_dispatcher));
 
 #if BUILDFLAG(IS_WIN)
-  return std::make_unique<InputMethodWinTSF>(ime_key_event_dispatcher, widget);
+  if (IsUsingTSFForIME()) {
+    return std::make_unique<InputMethodWinTSF>(ime_key_event_dispatcher,
+                                               widget);
+  }
+  return std::make_unique<InputMethodWinImm32>(ime_key_event_dispatcher,
+                                               widget);
 #elif BUILDFLAG(IS_APPLE)
   return std::make_unique<InputMethodMac>(ime_key_event_dispatcher);
 #elif BUILDFLAG(IS_OZONE)
diff --git a/ui/base/ime/win/BUILD.gn b/ui/base/ime/win/BUILD.gn
index 61d1e9b662430..1a2a40db4dae5 100644
--- a/ui/base/ime/win/BUILD.gn
+++ b/ui/base/ime/win/BUILD.gn
@@ -7,8 +7,12 @@ assert(is_win)
 component("win") {
   output_name = "ui_base_ime_win"
   sources = [
+    "imm32_manager.cc",
+    "imm32_manager.h",
     "input_method_win_base.cc",
     "input_method_win_base.h",
+    "input_method_win_imm32.cc",
+    "input_method_win_imm32.h",
     "input_method_win_tsf.cc",
     "input_method_win_tsf.h",
     "mock_tsf_bridge.cc",
@@ -37,4 +41,8 @@ component("win") {
     "//ui/base",
     "//ui/display",
   ]
+
+  libs = [ "imm32.lib" ]
+
+  ldflags = [ "/DELAYLOAD:imm32.dll" ]
 }
diff --git a/ui/base/ime/win/imm32_manager.cc b/ui/base/ime/win/imm32_manager.cc
new file mode 100644
index 0000000000000..af0e4318d606e
--- /dev/null
+++ b/ui/base/ime/win/imm32_manager.cc
@@ -0,0 +1,487 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/ime/win/imm32_manager.h"
+
+#include <stdint.h>
+
+#include <memory>
+#include <string>
+
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "third_party/skia/include/core/SkColor.h"
+#include "ui/base/ime/composition_text.h"
+
+///////////////////////////////////////////////////////////////////////////////
+// IMM32Manager
+
+namespace {
+
+// Determines whether or not the given attribute represents a target
+// (a.k.a. a selection).
+bool IsTargetAttribute(char attribute) {
+  return (attribute == ATTR_TARGET_CONVERTED ||
+          attribute == ATTR_TARGET_NOTCONVERTED);
+}
+
+// Helper function for IMM32Manager::GetCompositionInfo() method, to get the
+// target range that's selected by the user in the current composition string.
+void GetCompositionTargetRange(HIMC imm_context, int* target_start,
+                               int* target_end) {
+  int attribute_size = ::ImmGetCompositionString(imm_context, GCS_COMPATTR,
+                                                 NULL, 0);
+  if (attribute_size > 0) {
+    int start = 0;
+    int end = 0;
+    std::unique_ptr<char[]> attribute_data(new char[attribute_size]);
+    if (attribute_data.get()) {
+      ::ImmGetCompositionString(imm_context, GCS_COMPATTR,
+                                attribute_data.get(), attribute_size);
+      for (start = 0; start < attribute_size; ++start) {
+        if (IsTargetAttribute(attribute_data[start]))
+          break;
+      }
+      for (end = start; end < attribute_size; ++end) {
+        if (!IsTargetAttribute(attribute_data[end]))
+          break;
+      }
+    }
+    *target_start = start;
+    *target_end = end;
+  }
+}
+
+// Helper function for IMM32Manager::GetCompositionInfo() method, to get
+// underlines information of the current composition string.
+void GetImeTextSpans(HIMC imm_context,
+                     int target_start,
+                     int target_end,
+                     ui::ImeTextSpans* ime_text_spans) {
+  int clause_size = ::ImmGetCompositionString(imm_context, GCS_COMPCLAUSE,
+                                              NULL, 0);
+  int clause_length = clause_size / sizeof(uint32_t);
+  if (clause_length) {
+    std::unique_ptr<uint32_t[]> clause_data(new uint32_t[clause_length]);
+    if (clause_data.get()) {
+      ::ImmGetCompositionString(imm_context, GCS_COMPCLAUSE,
+                                clause_data.get(), clause_size);
+      for (int i = 0; i < clause_length - 1; ++i) {
+        ui::ImeTextSpan ime_text_span;
+        ime_text_span.start_offset = clause_data[i];
+        ime_text_span.end_offset = clause_data[i + 1];
+        ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThin;
+        ime_text_span.background_color = SK_ColorTRANSPARENT;
+
+        // Use thick underline for the target clause.
+        if (ime_text_span.start_offset >= static_cast<uint32_t>(target_start) &&
+            ime_text_span.end_offset <= static_cast<uint32_t>(target_end)) {
+          ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThick;
+        }
+        ime_text_spans->push_back(ime_text_span);
+      }
+    }
+  }
+}
+
+}  // namespace
+
+namespace ui {
+
+IMM32Manager::IMM32Manager()
+    : is_composing_(false),
+      input_language_id_(LANG_USER_DEFAULT),
+      system_caret_(false),
+      caret_rect_(-1, -1, 0, 0),
+      use_composition_window_(false) {
+}
+
+IMM32Manager::~IMM32Manager() {
+}
+
+void IMM32Manager::SetInputLanguage() {
+  // Retrieve the current input language from the system's keyboard layout.
+  // Using GetKeyboardLayoutName instead of GetKeyboardLayout, because
+  // the language from GetKeyboardLayout is the language under where the
+  // keyboard layout is installed. And the language from GetKeyboardLayoutName
+  // indicates the language of the keyboard layout itself.
+  // See crbug.com/344834.
+  WCHAR keyboard_layout[KL_NAMELENGTH];
+  if (::GetKeyboardLayoutNameW(keyboard_layout)) {
+    input_language_id_ =
+        static_cast<LANGID>(
+            wcstol(&keyboard_layout[KL_NAMELENGTH >> 1], nullptr, 16));
+  } else {
+    input_language_id_ = 0x0409;  // Fallback to en-US.
+  }
+}
+
+void IMM32Manager::CreateImeWindow(HWND window_handle) {
+  // When a user disables TSF (Text Service Framework) and CUAS (Cicero
+  // Unaware Application Support), Chinese IMEs somehow ignore function calls
+  // to ::ImmSetCandidateWindow(), i.e. they do not move their candidate
+  // window to the position given as its parameters, and use the position
+  // of the current system caret instead, i.e. it uses ::GetCaretPos() to
+  // retrieve the position of their IME candidate window.
+  // Therefore, we create a temporary system caret for Chinese IMEs and use
+  // it during this input context.
+  // Since some third-party Japanese IME also uses ::GetCaretPos() to determine
+  // their window position, we also create a caret for Japanese IMEs.
+  if (PRIMARYLANGID(input_language_id_) == LANG_CHINESE ||
+      PRIMARYLANGID(input_language_id_) == LANG_JAPANESE) {
+    if (!system_caret_) {
+      if (::CreateCaret(window_handle, NULL, 1, 1)) {
+        system_caret_ = true;
+      }
+    }
+  }
+  // Restore the positions of the IME windows.
+  UpdateImeWindow(window_handle);
+}
+
+LRESULT IMM32Manager::SetImeWindowStyle(HWND window_handle, UINT message,
+                                    WPARAM wparam, LPARAM lparam,
+                                    BOOL* handled) {
+  // To prevent the IMM (Input Method Manager) from displaying the IME
+  // composition window, Update the styles of the IME windows and EXPLICITLY
+  // call ::DefWindowProc() here.
+  // NOTE(hbono): We can NEVER let WTL call ::DefWindowProc() when we update
+  // the styles of IME windows because the 'lparam' variable is a local one
+  // and all its updates disappear in returning from this function, i.e. WTL
+  // does not call ::DefWindowProc() with our updated 'lparam' value but call
+  // the function with its original value and over-writes our window styles.
+  *handled = TRUE;
+  lparam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
+  return ::DefWindowProc(window_handle, message, wparam, lparam);
+}
+
+void IMM32Manager::DestroyImeWindow(HWND window_handle) {
+  // Destroy the system caret if we have created for this IME input context.
+  if (system_caret_) {
+    ::DestroyCaret();
+    system_caret_ = false;
+  }
+}
+
+void IMM32Manager::MoveImeWindow(HWND window_handle, HIMC imm_context) {
+  // Does nothing when the target window has no input focus. This is important
+  // because the renderer may issue SelectionBoundsChanged event even when it
+  // has no input focus. (e.g. the page update caused by incremental search.)
+  // So this event should be ignored when the |window_handle| no longer has the
+  // input focus.
+  if (GetFocus() != window_handle)
+    return;
+
+  int x = caret_rect_.x();
+  int y = caret_rect_.y();
+
+  const int kCaretMargin = 1;
+  if (!use_composition_window_ &&
+      PRIMARYLANGID(input_language_id_) == LANG_CHINESE) {
+    // As written in a comment in IMM32Manager::CreateImeWindow(),
+    // Chinese IMEs ignore function calls to ::ImmSetCandidateWindow()
+    // when a user disables TSF (Text Service Framework) and CUAS (Cicero
+    // Unaware Application Support).
+    // On the other hand, when a user enables TSF and CUAS, Chinese IMEs
+    // ignore the position of the current system caret and uses the
+    // parameters given to ::ImmSetCandidateWindow() with its 'dwStyle'
+    // parameter CFS_CANDIDATEPOS.
+    // Therefore, we do not only call ::ImmSetCandidateWindow() but also
+    // set the positions of the temporary system caret if it exists.
+    CANDIDATEFORM candidate_position = {0, CFS_CANDIDATEPOS, {x, y},
+                                        {0, 0, 0, 0}};
+    ::ImmSetCandidateWindow(imm_context, &candidate_position);
+  }
+  if (system_caret_) {
+    switch (PRIMARYLANGID(input_language_id_)) {
+      case LANG_JAPANESE:
+        ::SetCaretPos(x, y + caret_rect_.height());
+        break;
+      default:
+        ::SetCaretPos(x, y);
+        break;
+    }
+  }
+  if (use_composition_window_) {
+    // Moves the composition text window.
+    COMPOSITIONFORM cf = {CFS_POINT, {x, y}};
+    ::ImmSetCompositionWindow(imm_context, &cf);
+    // Don't need to set the position of candidate window.
+    return;
+  }
+
+  if (PRIMARYLANGID(input_language_id_) == LANG_KOREAN) {
+    // Chinese IMEs and Japanese IMEs require the upper-left corner of
+    // the caret to move the position of their candidate windows.
+    // On the other hand, Korean IMEs require the lower-left corner of the
+    // caret to move their candidate windows.
+    y += kCaretMargin;
+  }
+  // Japanese IMEs and Korean IMEs also use the rectangle given to
+  // ::ImmSetCandidateWindow() with its 'dwStyle' parameter CFS_EXCLUDE
+  // to move their candidate windows when a user disables TSF and CUAS.
+  // Therefore, we also set this parameter here.
+  CANDIDATEFORM exclude_rectangle = {0, CFS_EXCLUDE, {x, y},
+      {x, y, x + caret_rect_.width(), y + caret_rect_.height()}};
+  ::ImmSetCandidateWindow(imm_context, &exclude_rectangle);
+}
+
+void IMM32Manager::UpdateImeWindow(HWND window_handle) {
+  // Just move the IME window attached to the given window.
+  if (caret_rect_.x() >= 0 && caret_rect_.y() >= 0) {
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      MoveImeWindow(window_handle, imm_context);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+  }
+}
+
+void IMM32Manager::CleanupComposition(HWND window_handle) {
+  // Notify the IMM attached to the given window to complete the ongoing
+  // composition, (this case happens when the given window is de-activated
+  // while composing a text and re-activated), and reset the omposition status.
+  if (is_composing_) {
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      ::ImmNotifyIME(imm_context, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+    ResetComposition(window_handle);
+  }
+}
+
+void IMM32Manager::ResetComposition(HWND window_handle) {
+  // Currently, just reset the composition status.
+  is_composing_ = false;
+}
+
+void IMM32Manager::CompleteComposition(HWND window_handle, HIMC imm_context) {
+  // We have to confirm there is an ongoing composition before completing it.
+  // This is for preventing some IMEs from getting confused while completing an
+  // ongoing composition even if they do not have any ongoing compositions.)
+  if (is_composing_) {
+    ::ImmNotifyIME(imm_context, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+    ResetComposition(window_handle);
+  }
+}
+
+void IMM32Manager::GetCompositionInfo(HIMC imm_context,
+                                      LPARAM lparam,
+                                      CompositionText* composition) {
+  // We only care about GCS_COMPATTR, GCS_COMPCLAUSE and GCS_CURSORPOS, and
+  // convert them into composition underlines and selection range respectively.
+  composition->ime_text_spans.clear();
+
+  int length = static_cast<int>(composition->text.length());
+
+  // Find out the range selected by the user.
+  int target_start = length;
+  int target_end = length;
+  if (lparam & GCS_COMPATTR)
+    GetCompositionTargetRange(imm_context, &target_start, &target_end);
+
+  // Retrieve the selection range information. If CS_NOMOVECARET is specified,
+  // that means the cursor should not be moved, then we just place the caret at
+  // the beginning of the composition string. Otherwise we should honour the
+  // GCS_CURSORPOS value if it's available.
+  // TODO(suzhe): due to a bug of webkit, we currently can't use selection range
+  // with composition string. See: https://bugs.webkit.org/show_bug.cgi?id=40805
+  if (!(lparam & CS_NOMOVECARET) && (lparam & GCS_CURSORPOS)) {
+    // IMM32 does not support non-zero-width selection in a composition. So
+    // always use the caret position as selection range.
+    int cursor = ::ImmGetCompositionString(imm_context, GCS_CURSORPOS, NULL, 0);
+    composition->selection = gfx::Range(cursor);
+  } else {
+    composition->selection = gfx::Range(0);
+  }
+
+  // Retrieve the clause segmentations and convert them to ime_text_spans.
+  if (lparam & GCS_COMPCLAUSE) {
+    GetImeTextSpans(imm_context, target_start, target_end,
+                    &composition->ime_text_spans);
+  }
+
+  // Set default composition underlines in case there is no clause information.
+  if (!composition->ime_text_spans.empty())
+    return;
+
+  ImeTextSpan ime_text_span;
+  ime_text_span.underline_color = SK_ColorTRANSPARENT;
+  ime_text_span.background_color = SK_ColorTRANSPARENT;
+  if (target_start > 0) {
+    ime_text_span.start_offset = 0U;
+    ime_text_span.end_offset = static_cast<uint32_t>(target_start);
+    ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThin;
+    composition->ime_text_spans.push_back(ime_text_span);
+  }
+  if (target_end > target_start) {
+    ime_text_span.start_offset = static_cast<uint32_t>(target_start);
+    ime_text_span.end_offset = static_cast<uint32_t>(target_end);
+    ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThick;
+    composition->ime_text_spans.push_back(ime_text_span);
+  }
+  if (target_end < length) {
+    ime_text_span.start_offset = static_cast<uint32_t>(target_end);
+    ime_text_span.end_offset = static_cast<uint32_t>(length);
+    ime_text_span.thickness = ui::ImeTextSpan::Thickness::kThin;
+    composition->ime_text_spans.push_back(ime_text_span);
+  }
+}
+
+bool IMM32Manager::GetString(HIMC imm_context,
+                             WPARAM lparam,
+                             int type,
+                             std::u16string* result) {
+  if (!(lparam & type))
+    return false;
+  LONG string_size = ::ImmGetCompositionString(imm_context, type, NULL, 0);
+  if (string_size <= 0)
+    return false;
+  DCHECK_EQ(0u, string_size % sizeof(wchar_t));
+  ::ImmGetCompositionString(imm_context, type,
+                            base::as_writable_wcstr(base::WriteInto(
+                                result, (string_size / sizeof(wchar_t)) + 1)),
+                            string_size);
+  return true;
+}
+
+bool IMM32Manager::GetResult(HWND window_handle,
+                             LPARAM lparam,
+                             std::u16string* result) {
+  bool ret = false;
+  HIMC imm_context = ::ImmGetContext(window_handle);
+  if (imm_context) {
+    ret = GetString(imm_context, lparam, GCS_RESULTSTR, result);
+    ::ImmReleaseContext(window_handle, imm_context);
+  }
+  return ret;
+}
+
+bool IMM32Manager::GetComposition(HWND window_handle, LPARAM lparam,
+                              CompositionText* composition) {
+  bool ret = false;
+  HIMC imm_context = ::ImmGetContext(window_handle);
+  if (imm_context) {
+    // Copy the composition string to the CompositionText object.
+    ret = GetString(imm_context, lparam, GCS_COMPSTR, &composition->text);
+
+    if (ret) {
+      // This is a dirty workaround for facebook. Facebook deletes the
+      // placeholder character (U+3000) used by Traditional-Chinese IMEs at the
+      // beginning of composition text. This prevents WebKit from replacing this
+      // placeholder character with a Traditional-Chinese character, i.e. we
+      // cannot input any characters in a comment box of facebook with
+      // Traditional-Chinese IMEs. As a workaround, we replace U+3000 at the
+      // beginning of composition text with U+FF3F, a placeholder character used
+      // by Japanese IMEs.
+      if (input_language_id_ == MAKELANGID(LANG_CHINESE,
+                                           SUBLANG_CHINESE_TRADITIONAL) &&
+          composition->text[0] == 0x3000) {
+        composition->text[0] = 0xFF3F;
+      }
+
+      // Retrieve the IME text spans and selection range information.
+      GetCompositionInfo(imm_context, lparam, composition);
+
+      // Mark that there is an ongoing composition.
+      is_composing_ = true;
+    }
+
+    ::ImmReleaseContext(window_handle, imm_context);
+  }
+  return ret;
+}
+
+void IMM32Manager::DisableIME(HWND window_handle) {
+  // A renderer process have moved its input focus to a password input
+  // when there is an ongoing composition, e.g. a user has clicked a
+  // mouse button and selected a password input while composing a text.
+  // For this case, we have to complete the ongoing composition and
+  // clean up the resources attached to this object BEFORE DISABLING THE IME.
+  CleanupComposition(window_handle);
+  ::ImmAssociateContextEx(window_handle, NULL, 0);
+}
+
+void IMM32Manager::CancelIME(HWND window_handle) {
+  if (is_composing_) {
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      ::ImmNotifyIME(imm_context, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+    ResetComposition(window_handle);
+  }
+}
+
+void IMM32Manager::EnableIME(HWND window_handle) {
+  // Load the default IME context.
+  // NOTE(hbono)
+  //   IMM ignores this call if the IME context is loaded. Therefore, we do
+  //   not have to check whether or not the IME context is loaded.
+  ::ImmAssociateContextEx(window_handle, NULL, IACE_DEFAULT);
+}
+
+void IMM32Manager::UpdateCaretRect(HWND window_handle,
+                               const gfx::Rect& caret_rect) {
+  // Save the caret position, and Update the position of the IME window.
+  // This update is used for moving an IME window when a renderer process
+  // resize/moves the input caret.
+  if (caret_rect_ != caret_rect) {
+    caret_rect_ = caret_rect;
+    // Move the IME windows.
+    HIMC imm_context = ::ImmGetContext(window_handle);
+    if (imm_context) {
+      MoveImeWindow(window_handle, imm_context);
+      ::ImmReleaseContext(window_handle, imm_context);
+    }
+  }
+}
+
+void IMM32Manager::SetUseCompositionWindow(bool use_composition_window) {
+  use_composition_window_ = use_composition_window;
+}
+
+bool IMM32Manager::IsInputLanguageCJK() const {
+  LANGID lang = PRIMARYLANGID(input_language_id_);
+  return lang == LANG_CHINESE || lang == LANG_JAPANESE ||
+      lang == LANG_KOREAN;
+}
+
+void IMM32Manager::SetTextInputMode(HWND window_handle,
+                                    TextInputMode input_mode) {
+  if (input_mode == ui::TEXT_INPUT_MODE_DEFAULT)
+    return;
+
+  const HIMC imm_context = ::ImmGetContext(window_handle);
+  if (!imm_context)
+    return;
+
+  DWORD conversion_mode = 0;
+  DWORD sentence_mode = 0;
+  if (::ImmGetConversionStatus(imm_context, &conversion_mode, &sentence_mode)
+      == FALSE) {
+    return;
+  }
+
+  BOOL open = FALSE;
+  ConvertInputModeToImmFlags(input_mode, conversion_mode, &open,
+                             &conversion_mode),
+
+  ::ImmSetOpenStatus(imm_context, open);
+  if (open)
+    ::ImmSetConversionStatus(imm_context, conversion_mode, sentence_mode);
+  ::ImmReleaseContext(window_handle, imm_context);
+}
+
+// static
+void IMM32Manager::ConvertInputModeToImmFlags(TextInputMode input_mode,
+                                              DWORD initial_conversion_mode,
+                                              BOOL* open,
+                                              DWORD* new_conversion_mode) {
+  *open = FALSE;
+  *new_conversion_mode = initial_conversion_mode;
+}
+
+}  // namespace ui
diff --git a/ui/base/ime/win/imm32_manager.h b/ui/base/ime/win/imm32_manager.h
new file mode 100644
index 0000000000000..e8271a992d4b1
--- /dev/null
+++ b/ui/base/ime/win/imm32_manager.h
@@ -0,0 +1,308 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_IME_WIN_IMM32_MANAGER_H_
+#define UI_BASE_IME_WIN_IMM32_MANAGER_H_
+
+#include <windows.h>
+
+#include <string>
+#include <vector>
+
+#include "base/component_export.h"
+#include "base/i18n/rtl.h"
+#include "ui/base/ime/text_input_mode.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace ui {
+
+struct CompositionText;
+
+// This header file defines a struct and a class used for encapsulating IMM32
+// APIs, controls IMEs attached to a window, and enables the 'on-the-spot'
+// input without deep knowledge about the APIs, i.e. knowledge about the
+// language-specific and IME-specific behaviors.
+// The following items enumerates the simplest steps for an (window)
+// application to control its IMEs with the struct and the class defined
+// this file.
+// 1. Add an instance of the IMM32Manager class to its window class.
+//    (The IMM32Manager class needs a window handle.)
+// 2. Add messages handlers listed in the following subsections, follow the
+//    instructions written in each subsection, and use the IMM32Manager class.
+// 2.1. WM_IME_SETCONTEXT (0x0281)
+//      Call the functions listed below:
+//      - IMM32Manager::CreateImeWindow();
+//      - IMM32Manager::CleanupComposition(), and;
+//      - IMM32Manager::SetImeWindowStyle().
+//      An application MUST prevent from calling ::DefWindowProc().
+// 2.2. WM_IME_STARTCOMPOSITION (0x010D)
+//      Call the functions listed below:
+//      - IMM32Manager::CreateImeWindow(), and;
+//      - IMM32Manager::ResetComposition().
+//      An application MUST prevent from calling ::DefWindowProc().
+// 2.3. WM_IME_COMPOSITION (0x010F)
+//      Call the functions listed below:
+//      - IMM32Manager::UpdateImeWindow();
+//      - IMM32Manager::GetResult();
+//      - IMM32Manager::GetComposition(), and;
+//      - IMM32Manager::ResetComposition() (optional).
+//      An application MUST prevent from calling ::DefWindowProc().
+// 2.4. WM_IME_ENDCOMPOSITION (0x010E)
+//      Call the functions listed below:
+//      - IMM32Manager::ResetComposition(), and;
+//      - IMM32Manager::DestroyImeWindow().
+//      An application CAN call ::DefWindowProc().
+// 2.5. WM_INPUTLANGCHANGE (0x0051)
+//      Call the functions listed below:
+//      - IMM32Manager::SetInputLanguage().
+//      An application CAN call ::DefWindowProc().
+
+// This class controls the IMM (Input Method Manager) through IMM32 APIs and
+// enables it to retrieve the string being controled by the IMM. (I wrote
+// a note to describe the reason why I do not use 'IME' but 'IMM' below.)
+// NOTE(hbono):
+//   Fortunately or unfortunately, TSF (Text Service Framework) and
+//   CUAS (Cicero Unaware Application Support) allows IMM32 APIs for
+//   retrieving not only the inputs from IMEs (Input Method Editors), used
+//   only for inputting East-Asian language texts, but also the ones from
+//   tablets (on Windows XP Tablet PC Edition and Windows Vista), voice
+//   recognizers (e.g. ViaVoice and Microsoft Office), etc.
+//   We can disable TSF and CUAS in Windows XP Tablet PC Edition. On the other
+//   hand, we can NEVER disable either TSF or CUAS in Windows Vista, i.e.
+//   THIS CLASS IS NOT ONLY USED ON THE INPUT CONTEXTS OF EAST-ASIAN
+//   LANGUAGES BUT ALSO USED ON THE INPUT CONTEXTS OF ALL LANGUAGES.
+class COMPONENT_EXPORT(UI_BASE_IME_WIN) IMM32Manager {
+ public:
+  IMM32Manager();
+
+  IMM32Manager(const IMM32Manager&) = delete;
+  IMM32Manager& operator=(const IMM32Manager&) = delete;
+
+  virtual ~IMM32Manager();
+
+  // Retrieves whether or not there is an ongoing composition.
+  bool is_composing() const { return is_composing_; }
+
+  // Retrieves the input language from Windows and update it.
+  void SetInputLanguage();
+
+  // Creates the IME windows, and allocate required resources for them.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void CreateImeWindow(HWND window_handle);
+
+  // Updates the style of the IME windows.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * message [in] (UINT)
+  //   * wparam [in] (WPARAM)
+  //   * lparam [in] (LPARAM)
+  //     Represent the windows message of the caller.
+  //     These parameters are used for verifying if this function is called
+  //     in a handler function for WM_IME_SETCONTEXT messages because this
+  //     function uses ::DefWindowProc() to update the style.
+  //     A caller just has to pass the input parameters for the handler
+  //     function without modifications.
+  //   * handled [out] (BOOL*)
+  //     Returns ::DefWindowProc() is really called in this function.
+  //     PLEASE DO NOT CALL ::DefWindowProc() IF THIS VALUE IS TRUE!
+  //     All the window styles set in this function are over-written when
+  //     calling ::DefWindowProc() after returning this function.
+  // Returns the value returned by DefWindowProc.
+  LRESULT SetImeWindowStyle(HWND window_handle, UINT message,
+                            WPARAM wparam, LPARAM lparam, BOOL* handled);
+
+  // Destroys the IME windows and all the resources attached to them.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void DestroyImeWindow(HWND window_handle);
+
+  // Updates the position of the IME windows.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void UpdateImeWindow(HWND window_handle);
+
+  // Cleans up the all resources attached to the given IMM32Manager object, and
+  // reset its composition status.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void CleanupComposition(HWND window_handle);
+
+  // Resets the composition status.
+  // Cancel the ongoing composition if it exists.
+  // NOTE(hbono): This method does not release the allocated resources.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void ResetComposition(HWND window_handle);
+
+  // Retrieves a composition result of the ongoing composition if it exists.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * lparam [in] (LPARAM)
+  //     Specifies the updated members of the ongoing composition, and must be
+  //     the same parameter of a WM_IME_COMPOSITION message handler.
+  //     This parameter is used for checking if the ongoing composition has
+  //     its result string,
+  //   * result [out] (std::u16string)
+  //     Represents the object contains the composition result.
+  // Return values
+  //   * true
+  //     The ongoing composition has a composition result.
+  //   * false
+  //     The ongoing composition does not have composition results.
+  // Remarks
+  //   This function is designed for being called from WM_IME_COMPOSITION
+  //   message handlers.
+  bool GetResult(HWND window_handle, LPARAM lparam, std::u16string* result);
+
+  // Retrieves the current composition status of the ongoing composition.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * lparam [in] (LPARAM)
+  //     Specifies the updated members of the ongoing composition, and must be
+  //     the same parameter of a WM_IME_COMPOSITION message handler.
+  //     This parameter is used for checking if the ongoing composition has
+  //     its result string,
+  //   * composition [out] (Composition)
+  //     Represents the struct contains the composition status.
+  // Return values
+  //   * true
+  //     The status of the ongoing composition is updated.
+  //   * false
+  //     The status of the ongoing composition is not updated.
+  // Remarks
+  //   This function is designed for being called from WM_IME_COMPOSITION
+  //   message handlers.
+  bool GetComposition(HWND window_handle, LPARAM lparam,
+                      CompositionText* composition);
+
+  // Enables the IME attached to the given window, i.e. allows user-input
+  // events to be dispatched to the IME.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * complete [in] (bool)
+  //     Represents whether or not to complete the ongoing composition.
+  //     + true
+  //       After finishing the ongoing composition and close its IME windows,
+  //       start another composition and display its IME windows to the given
+  //       position.
+  //     + false
+  //       Just move the IME windows of the ongoing composition to the given
+  //       position without finishing it.
+  void EnableIME(HWND window_handle);
+
+  // Disables the IME attached to the given window, i.e. prohibits any
+  // user-input events from being dispatched to the IME.
+  // In Chrome, this function is used when:
+  //   * a renreder process sets its input focus to a password input.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void DisableIME(HWND window_handle);
+
+  // Cancels an ongoing composition of the IME attached to the given window.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  void CancelIME(HWND window_handle);
+
+  // Updates the caret position of the given window.
+  // Parameters
+  //   * window_handle [in] (HWND)
+  //     Represents the window handle of the caller.
+  //   * caret_rect [in] (const gfx::Rect&)
+  //     Represent the rectangle of the input caret.
+  //     This rectangle is used for controlling the positions of IME windows.
+  void UpdateCaretRect(HWND window_handle, const gfx::Rect& caret_rect);
+
+  // Updates the setting whether we want IME to render composition text.
+  void SetUseCompositionWindow(bool use_composition_window);
+
+  // Returns the current input language id.
+  LANGID input_language_id() const { return input_language_id_; }
+
+  // Returns whether the system's input language is CJK.
+  bool IsInputLanguageCJK() const;
+
+  // Sets conversion status corresponding to |input_mode|.
+  virtual void SetTextInputMode(HWND window_handle, TextInputMode input_mode);
+
+  // Helper functions ----------------------------------------------------------
+
+  // Gets parameters for ::ImmSetOpenStatus and ::ImmSetConversionStatus from
+  // |input_mode|.
+  static void ConvertInputModeToImmFlags(TextInputMode input_mode,
+                                         DWORD initial_conversion_mode,
+                                         BOOL* open,
+                                         DWORD* new_conversion_mode);
+
+ protected:
+  // Retrieves the composition information.
+  void GetCompositionInfo(HIMC imm_context, LPARAM lparam,
+                          CompositionText* composition);
+
+  // Updates the position of the IME windows.
+  void MoveImeWindow(HWND window_handle, HIMC imm_context);
+
+  // Completes the ongoing composition if it exists.
+  void CompleteComposition(HWND window_handle, HIMC imm_context);
+
+  // Retrieves a string from the IMM.
+  bool GetString(HIMC imm_context,
+                 WPARAM lparam,
+                 int type,
+                 std::u16string* result);
+
+ private:
+  // Represents whether or not there is an ongoing composition in a browser
+  // process, i.e. whether or not a browser process is composing a text.
+  bool is_composing_;
+
+  // The current input Language ID retrieved from Windows, which consists of:
+  //   * Primary Language ID (bit 0 to bit 9), which shows a natunal language
+  //     (English, Korean, Chinese, Japanese, etc.) and;
+  //   * Sub-Language ID (bit 10 to bit 15), which shows a geometrical region
+  //     the language is spoken (For English, United States, United Kingdom,
+  //     Australia, Canada, etc.)
+  // The following list enumerates some examples for the Language ID:
+  //   * "en-US" (0x0409)
+  //     MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
+  //   * "ko-KR" (0x0412)
+  //     MAKELANGID(LANG_KOREAN,  SUBLANG_KOREAN);
+  //   * "zh-TW" (0x0404)
+  //     MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
+  //   * "zh-CN" (0x0804)
+  //     MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
+  //   * "ja-JP" (0x0411)
+  //     MAKELANGID(LANG_JAPANESE, SUBLANG_JAPANESE_JAPAN), etc.
+  //   (See <winnt.h> for other available values.)
+  // This Language ID is used for processing language-specific operations in
+  // IME functions.
+  LANGID input_language_id_;
+
+  // Represents whether or not the current input context has created a system
+  // caret to set the position of its IME candidate window.
+  //   * true: it creates a system caret.
+  //   * false: it does not create a system caret.
+  bool system_caret_;
+
+  // The rectangle of the input caret retrieved from a renderer process.
+  gfx::Rect caret_rect_;
+
+  // Indicates whether or not we want IME to render composition text.
+  bool use_composition_window_;
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_IME_WIN_IMM32_MANAGER_H_
diff --git a/ui/base/ime/win/imm32_manager_unittest.cc b/ui/base/ime/win/imm32_manager_unittest.cc
new file mode 100644
index 0000000000000..4d40973c626ec
--- /dev/null
+++ b/ui/base/ime/win/imm32_manager_unittest.cc
@@ -0,0 +1,69 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/ime/win/imm32_manager.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace ui {
+namespace {
+
+struct InputModeTestCase {
+  TextInputMode input_mode;
+  DWORD conversion_mode;
+  BOOL expected_open;
+  DWORD expected_conversion_mode;
+};
+
+// Google Test pretty-printer.
+void PrintTo(const InputModeTestCase& data, std::ostream* os) {
+  *os << " input_mode: " << testing::PrintToString(data.input_mode)
+      << "; conversion_mode: " << testing::PrintToString(data.conversion_mode);
+}
+
+class IMM32ManagerTest
+    : public ::testing::TestWithParam<InputModeTestCase> {
+};
+
+const InputModeTestCase kInputModeTestCases[] = {
+    {TEXT_INPUT_MODE_DEFAULT, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_DEFAULT, IME_CMODE_NATIVE, FALSE, IME_CMODE_NATIVE},
+    {TEXT_INPUT_MODE_TEXT, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_TEXT, IME_CMODE_NATIVE, FALSE, IME_CMODE_NATIVE},
+    {TEXT_INPUT_MODE_NUMERIC, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_NUMERIC, IME_CMODE_FULLSHAPE, FALSE, IME_CMODE_FULLSHAPE},
+    {TEXT_INPUT_MODE_DECIMAL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_DECIMAL, IME_CMODE_FULLSHAPE, FALSE, IME_CMODE_FULLSHAPE},
+    {TEXT_INPUT_MODE_TEL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_TEL, IME_CMODE_ROMAN, FALSE, IME_CMODE_ROMAN},
+    {TEXT_INPUT_MODE_EMAIL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_EMAIL, IME_CMODE_CHARCODE, FALSE, IME_CMODE_CHARCODE},
+    {TEXT_INPUT_MODE_URL, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_URL, IME_CMODE_HANJACONVERT, FALSE,
+     IME_CMODE_HANJACONVERT},
+    {TEXT_INPUT_MODE_SEARCH, 0, FALSE, 0},
+    {TEXT_INPUT_MODE_SEARCH, IME_CMODE_CHARCODE, FALSE, IME_CMODE_CHARCODE},
+};
+
+TEST_P(IMM32ManagerTest, ConvertInputModeToImmFlags) {
+  const InputModeTestCase& test_case = GetParam();
+
+  BOOL open;
+  DWORD conversion_mode;
+  // Call testee method.
+  IMM32Manager::ConvertInputModeToImmFlags(test_case.input_mode,
+                                           test_case.conversion_mode,
+                                           &open,
+                                           &conversion_mode);
+
+  EXPECT_EQ(test_case.expected_open, open);
+  EXPECT_EQ(test_case.expected_conversion_mode, conversion_mode);
+}
+
+INSTANTIATE_TEST_SUITE_P(All,
+                         IMM32ManagerTest,
+                         ::testing::ValuesIn(kInputModeTestCases));
+
+}  // namespace
+}  // namespace ui
diff --git a/ui/base/ime/win/input_method_win_base.h b/ui/base/ime/win/input_method_win_base.h
index aeec7cbe8940d..d6ad5d11a5279 100644
--- a/ui/base/ime/win/input_method_win_base.h
+++ b/ui/base/ime/win/input_method_win_base.h
@@ -8,8 +8,8 @@
 #include <windows.h>
 
 #include "base/component_export.h"
-#include "base/i18n/rtl.h"
 #include "ui/base/ime/input_method_base.h"
+#include "ui/base/ime/win/imm32_manager.h"
 
 namespace ui {
 
diff --git a/ui/base/ime/win/input_method_win_imm32.cc b/ui/base/ime/win/input_method_win_imm32.cc
new file mode 100644
index 0000000000000..0aa096de50119
--- /dev/null
+++ b/ui/base/ime/win/input_method_win_imm32.cc
@@ -0,0 +1,349 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/ime/win/input_method_win_imm32.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "base/auto_reset.h"
+#include "base/command_line.h"
+#include "base/functional/bind.h"
+#include "ui/base/ime/text_input_client.h"
+#include "ui/base/ime/win/tsf_input_scope.h"
+#include "ui/display/win/screen_win.h"
+#include "ui/events/event.h"
+#include "ui/events/event_constants.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/keycodes/keyboard_codes.h"
+#include "ui/gfx/win/hwnd_util.h"
+
+namespace ui {
+
+InputMethodWinImm32::InputMethodWinImm32(
+    ImeKeyEventDispatcher* ime_key_event_dispatcher,
+    HWND attached_window_handle)
+    : InputMethodWinBase(ime_key_event_dispatcher, attached_window_handle),
+
+      enabled_(false),
+      is_candidate_popup_open_(false),
+      composing_window_handle_(NULL) {
+  imm32_manager_.SetInputLanguage();
+}
+
+InputMethodWinImm32::~InputMethodWinImm32() {}
+
+void InputMethodWinImm32::OnFocus() {
+  InputMethodBase::OnFocus();
+  RefreshInputLanguage();
+}
+
+bool InputMethodWinImm32::OnUntranslatedIMEMessage(
+    const CHROME_MSG event,
+    InputMethod::NativeEventResult* result) {
+  LRESULT original_result = 0;
+  BOOL handled = FALSE;
+
+  switch (event.message) {
+    case WM_IME_SETCONTEXT:
+      original_result = OnImeSetContext(event.hwnd, event.message, event.wParam,
+                                        event.lParam, &handled);
+      break;
+    case WM_IME_STARTCOMPOSITION:
+      original_result = OnImeStartComposition(
+          event.hwnd, event.message, event.wParam, event.lParam, &handled);
+      break;
+    case WM_IME_COMPOSITION:
+      original_result = OnImeComposition(event.hwnd, event.message,
+                                         event.wParam, event.lParam, &handled);
+      break;
+    case WM_IME_ENDCOMPOSITION:
+      original_result = OnImeEndComposition(
+          event.hwnd, event.message, event.wParam, event.lParam, &handled);
+      break;
+    case WM_IME_REQUEST:
+      original_result =
+          OnImeRequest(event.message, event.wParam, event.lParam, &handled);
+      break;
+    case WM_CHAR:
+    case WM_SYSCHAR:
+      original_result = OnChar(event.hwnd, event.message, event.wParam,
+                               event.lParam, event, &handled);
+      break;
+    case WM_IME_NOTIFY:
+      original_result =
+          OnImeNotify(event.message, event.wParam, event.lParam, &handled);
+      break;
+    default:
+      NOTREACHED() << "Unknown IME message:" << event.message;
+      break;
+  }
+  if (result)
+    *result = original_result;
+  return !!handled;
+}
+
+void InputMethodWinImm32::OnTextInputTypeChanged(TextInputClient* client) {
+  InputMethodBase::OnTextInputTypeChanged(client);
+  if (!IsTextInputClientFocused(client) || !IsWindowFocused(client))
+    return;
+  imm32_manager_.CancelIME(attached_window_handle_);
+  UpdateIMEState();
+}
+
+void InputMethodWinImm32::OnCaretBoundsChanged(const TextInputClient* client) {
+  if (!IsTextInputClientFocused(client) || !IsWindowFocused(client))
+    return;
+  NotifyTextInputCaretBoundsChanged(client);
+  if (!enabled_)
+    return;
+
+  // The current text input type should not be NONE if |client| is focused.
+  DCHECK(!IsTextInputTypeNone());
+  // Tentatively assume that the returned value is DIP (Density Independent
+  // Pixel). See the comment in text_input_client.h and http://crbug.com/360334.
+  const gfx::Rect dip_screen_bounds(GetTextInputClient()->GetCaretBounds());
+  const gfx::Rect screen_bounds = display::win::ScreenWin::DIPToScreenRect(
+      attached_window_handle_, dip_screen_bounds);
+
+  HWND attached_window = attached_window_handle_;
+  // TODO(ime): see comment in TextInputClient::GetCaretBounds(), this
+  // conversion shouldn't be necessary.
+  RECT r = {};
+  GetClientRect(attached_window, &r);
+  POINT window_point = {screen_bounds.x(), screen_bounds.y()};
+  ScreenToClient(attached_window, &window_point);
+  gfx::Rect caret_rect(gfx::Point(window_point.x, window_point.y),
+                       screen_bounds.size());
+  imm32_manager_.UpdateCaretRect(attached_window, caret_rect);
+}
+
+void InputMethodWinImm32::CancelComposition(const TextInputClient* client) {
+  if (IsTextInputClientFocused(client) && enabled_) {
+    imm32_manager_.CancelIME(attached_window_handle_);
+  }
+}
+
+void InputMethodWinImm32::OnInputLocaleChanged() {
+  // Note: OnInputLocaleChanged() is for capturing the input language which can
+  // be used to determine the appropriate TextInputType for Omnibox.
+  // See https://crbug.com/344834.
+  // Currently OnInputLocaleChanged() on Windows relies on WM_INPUTLANGCHANGED,
+  // which is known to be incompatible with TSF.
+  // TODO(shuchen): Use ITfLanguageProfileNotifySink instead.
+  OnInputMethodChanged();
+  RefreshInputLanguage();
+}
+
+bool InputMethodWinImm32::IsInputLocaleCJK() const {
+  return imm32_manager_.IsInputLanguageCJK();
+}
+
+bool InputMethodWinImm32::IsCandidatePopupOpen() const {
+  return is_candidate_popup_open_;
+}
+
+void InputMethodWinImm32::OnWillChangeFocusedClient(
+    TextInputClient* focused_before,
+    TextInputClient* focused) {
+  if (IsWindowFocused(focused_before))
+    ConfirmCompositionText();
+}
+
+void InputMethodWinImm32::OnDidChangeFocusedClient(
+    TextInputClient* focused_before,
+    TextInputClient* focused) {
+  if (IsWindowFocused(focused)) {
+    // Force to update the input type since client's TextInputStateChanged()
+    // function might not be called if text input types before the client loses
+    // focus and after it acquires focus again are the same.
+    OnTextInputTypeChanged(focused);
+
+    // Force to update caret bounds, in case the client thinks that the caret
+    // bounds has not changed.
+    OnCaretBoundsChanged(focused);
+  }
+  InputMethodWinBase::OnDidChangeFocusedClient(focused_before, focused);
+}
+
+LRESULT InputMethodWinImm32::OnImeSetContext(HWND window_handle,
+                                             UINT message,
+                                             WPARAM wparam,
+                                             LPARAM lparam,
+                                             BOOL* handled) {
+  if (!!wparam) {
+    imm32_manager_.CreateImeWindow(window_handle);
+    // Delay initialize the tsf to avoid perf regression.
+    // Loading tsf dll causes some time, so doing it in UpdateIMEState() will
+    // slow down the browser window creation.
+    // See https://crbug.com/509984.
+    tsf_inputscope::InitializeTsfForInputScopes();
+    tsf_inputscope::SetInputScopeForTsfUnawareWindow(
+        attached_window_handle_, GetTextInputType(), GetTextInputMode());
+  }
+
+  OnInputMethodChanged();
+  return imm32_manager_.SetImeWindowStyle(window_handle, message, wparam,
+                                          lparam, handled);
+}
+
+LRESULT InputMethodWinImm32::OnImeStartComposition(HWND window_handle,
+                                                   UINT message,
+                                                   WPARAM wparam,
+                                                   LPARAM lparam,
+                                                   BOOL* handled) {
+  // We have to prevent WTL from calling ::DefWindowProc() because the function
+  // calls ::ImmSetCompositionWindow() and ::ImmSetCandidateWindow() to
+  // over-write the position of IME windows.
+  *handled = TRUE;
+
+  // Reset the composition status and create IME windows.
+  composing_window_handle_ = window_handle;
+  imm32_manager_.CreateImeWindow(window_handle);
+  imm32_manager_.ResetComposition(window_handle);
+  return 0;
+}
+
+LRESULT InputMethodWinImm32::OnImeComposition(HWND window_handle,
+                                              UINT message,
+                                              WPARAM wparam,
+                                              LPARAM lparam,
+                                              BOOL* handled) {
+  // We have to prevent WTL from calling ::DefWindowProc() because we do not
+  // want for the IMM (Input Method Manager) to send WM_IME_CHAR messages.
+  *handled = TRUE;
+
+  // At first, update the position of the IME window.
+  imm32_manager_.UpdateImeWindow(window_handle);
+
+  // Retrieve the result string and its attributes of the ongoing composition
+  // and send it to a renderer process.
+  ui::CompositionText composition;
+  if (imm32_manager_.GetResult(window_handle, lparam, &composition.text)) {
+    if (!IsTextInputTypeNone())
+      GetTextInputClient()->InsertText(
+          composition.text,
+          ui::TextInputClient::InsertTextCursorBehavior::kMoveCursorAfterText);
+    imm32_manager_.ResetComposition(window_handle);
+    // Fall though and try reading the composition string.
+    // Japanese IMEs send a message containing both GCS_RESULTSTR and
+    // GCS_COMPSTR, which means an ongoing composition has been finished
+    // by the start of another composition.
+  }
+  // Retrieve the composition string and its attributes of the ongoing
+  // composition and send it to a renderer process.
+  if (imm32_manager_.GetComposition(window_handle, lparam, &composition) &&
+      !IsTextInputTypeNone())
+    GetTextInputClient()->SetCompositionText(composition);
+
+  return 0;
+}
+
+LRESULT InputMethodWinImm32::OnImeEndComposition(HWND window_handle,
+                                                 UINT message,
+                                                 WPARAM wparam,
+                                                 LPARAM lparam,
+                                                 BOOL* handled) {
+  // Let WTL call ::DefWindowProc() and release its resources.
+  *handled = FALSE;
+
+  composing_window_handle_ = NULL;
+
+  // This is a hack fix for MS Korean IME issue (https://crbug.com/647150).
+  // Messages received when hitting Space key during composition:
+  //   1. WM_IME_ENDCOMPOSITION (we usually clear composition for this MSG)
+  //   2. WM_IME_COMPOSITION with GCS_RESULTSTR (we usually commit composition)
+  // (Which is in the reversed order compared to MS Japanese and Chinese IME.)
+  // Hack fix:
+  //   * Discard WM_IME_ENDCOMPOSITION message if it's followed by a
+  //     WM_IME_COMPOSITION message with GCS_RESULTSTR.
+  // This works because we don't require WM_IME_ENDCOMPOSITION after committing
+  // composition (it doesn't do anything if there is no on-going composition).
+  // Also see Firefox's implementation:
+  // https://dxr.mozilla.org/mozilla-beta/source/widget/windows/IMMHandler.cpp#800
+  // TODO(crbug.com/654865): Further investigations and clean-ups required.
+  CHROME_MSG compositionMsg;
+  if (::PeekMessage(ChromeToWindowsType(&compositionMsg), window_handle,
+                    WM_IME_STARTCOMPOSITION, WM_IME_COMPOSITION, PM_NOREMOVE) &&
+      compositionMsg.message == WM_IME_COMPOSITION &&
+      (compositionMsg.lParam & GCS_RESULTSTR))
+    return 0;
+
+  if (!IsTextInputTypeNone() && GetTextInputClient()->HasCompositionText())
+    GetTextInputClient()->ClearCompositionText();
+
+  imm32_manager_.ResetComposition(window_handle);
+  imm32_manager_.DestroyImeWindow(window_handle);
+  return 0;
+}
+
+LRESULT InputMethodWinImm32::OnImeNotify(UINT message,
+                                         WPARAM wparam,
+                                         LPARAM lparam,
+                                         BOOL* handled) {
+  *handled = FALSE;
+
+  // Update |is_candidate_popup_open_|, whether a candidate window is open.
+  switch (wparam) {
+    case IMN_OPENCANDIDATE:
+      is_candidate_popup_open_ = true;
+      break;
+    case IMN_CLOSECANDIDATE:
+      is_candidate_popup_open_ = false;
+      break;
+  }
+
+  return 0;
+}
+
+void InputMethodWinImm32::RefreshInputLanguage() {
+  TextInputType type_original = GetTextInputType();
+  imm32_manager_.SetInputLanguage();
+  if (type_original != GetTextInputType()) {
+    // Only update the IME state when necessary.
+    // It's unnecessary to report IME state, when:
+    // 1) Switching betweeen 2 top-level windows, and the switched-away window
+    //    receives OnInputLocaleChanged.
+    // 2) The text input type is not changed by |SetInputLanguage|.
+    // Please refer to https://crbug.com/679564.
+    UpdateIMEState();
+  }
+}
+
+void InputMethodWinImm32::ConfirmCompositionText() {
+  // Makes sure the native IME app can be informed about the composition is
+  // cleared, so that it can clean up its internal states.
+  if (composing_window_handle_)
+    imm32_manager_.CleanupComposition(composing_window_handle_);
+}
+
+TextInputMode InputMethodWinImm32::GetTextInputMode() const {
+  TextInputClient* client = GetTextInputClient();
+  return client ? client->GetTextInputMode() : TEXT_INPUT_MODE_DEFAULT;
+}
+
+void InputMethodWinImm32::UpdateIMEState() {
+  // Use switch here in case we are going to add more text input types.
+  // We disable input method in password field.
+  const HWND window_handle = attached_window_handle_;
+  const TextInputType text_input_type = GetTextInputType();
+  const TextInputMode text_input_mode = GetTextInputMode();
+  switch (text_input_type) {
+    case ui::TEXT_INPUT_TYPE_NONE:
+    case ui::TEXT_INPUT_TYPE_PASSWORD:
+      imm32_manager_.DisableIME(window_handle);
+      enabled_ = false;
+      break;
+    default:
+      imm32_manager_.EnableIME(window_handle);
+      enabled_ = true;
+      break;
+  }
+
+  imm32_manager_.SetTextInputMode(window_handle, text_input_mode);
+  tsf_inputscope::SetInputScopeForTsfUnawareWindow(
+      window_handle, text_input_type, text_input_mode);
+}
+
+}  // namespace ui
diff --git a/ui/base/ime/win/input_method_win_imm32.h b/ui/base/ime/win/input_method_win_imm32.h
new file mode 100644
index 0000000000000..503399af4e060
--- /dev/null
+++ b/ui/base/ime/win/input_method_win_imm32.h
@@ -0,0 +1,104 @@
+// Copyright 2011 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_IME_WIN_INPUT_METHOD_WIN_IMM32_H_
+#define UI_BASE_IME_WIN_INPUT_METHOD_WIN_IMM32_H_
+
+#include <windows.h>
+
+#include "base/component_export.h"
+#include "ui/base/ime/win/imm32_manager.h"
+#include "ui/base/ime/win/input_method_win_base.h"
+
+namespace ui {
+
+// A common InputMethod implementation based on IMM32.
+class COMPONENT_EXPORT(UI_BASE_IME_WIN) InputMethodWinImm32
+    : public InputMethodWinBase {
+ public:
+  InputMethodWinImm32(ImeKeyEventDispatcher* ime_key_event_dispatcher,
+                      HWND attached_window_handle);
+
+  InputMethodWinImm32(const InputMethodWinImm32&) = delete;
+  InputMethodWinImm32& operator=(const InputMethodWinImm32&) = delete;
+
+  ~InputMethodWinImm32() override;
+
+  // Overridden from InputMethodBase:
+  void OnFocus() override;
+
+  // Overridden from InputMethod:
+  bool OnUntranslatedIMEMessage(const CHROME_MSG event,
+                                NativeEventResult* result) override;
+  void OnTextInputTypeChanged(TextInputClient* client) override;
+  void OnCaretBoundsChanged(const TextInputClient* client) override;
+  void CancelComposition(const TextInputClient* client) override;
+  void OnInputLocaleChanged() override;
+  bool IsInputLocaleCJK() const override;
+  bool IsCandidatePopupOpen() const override;
+
+ protected:
+  // Overridden from InputMethodBase:
+  // If a derived class overrides this method, it should call parent's
+  // implementation.
+  void OnWillChangeFocusedClient(TextInputClient* focused_before,
+                                 TextInputClient* focused) override;
+  void OnDidChangeFocusedClient(TextInputClient* focused_before,
+                                TextInputClient* focused) override;
+
+ private:
+  LRESULT OnImeSetContext(HWND window_handle,
+                          UINT message,
+                          WPARAM wparam,
+                          LPARAM lparam,
+                          BOOL* handled);
+  LRESULT OnImeStartComposition(HWND window_handle,
+                                UINT message,
+                                WPARAM wparam,
+                                LPARAM lparam,
+                                BOOL* handled);
+  LRESULT OnImeComposition(HWND window_handle,
+                           UINT message,
+                           WPARAM wparam,
+                           LPARAM lparam,
+                           BOOL* handled);
+  LRESULT OnImeEndComposition(HWND window_handle,
+                              UINT message,
+                              WPARAM wparam,
+                              LPARAM lparam,
+                              BOOL* handled);
+  LRESULT OnImeNotify(UINT message,
+                      WPARAM wparam,
+                      LPARAM lparam,
+                      BOOL* handled);
+
+  void RefreshInputLanguage();
+
+  // Enables or disables the IME according to the current text input type.
+  void UpdateIMEState();
+
+  void ConfirmCompositionText();
+
+  // Gets the text input mode of the focused text input client. Returns
+  // ui::TEXT_INPUT_MODE_DEFAULT if there is no focused client.
+  TextInputMode GetTextInputMode() const;
+
+  // Windows IMM32 wrapper.
+  // (See "ui/base/ime/win/ime_input.h" for its details.)
+  ui::IMM32Manager imm32_manager_;
+
+  // True when an IME should be allowed to process key events.
+  bool enabled_;
+
+  // True if we know for sure that a candidate window is open.
+  bool is_candidate_popup_open_;
+
+  // Window handle where composition is on-going. NULL when there is no
+  // composition.
+  HWND composing_window_handle_;
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_IME_WIN_INPUT_METHOD_WIN_IMM32_H_
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
index e079f9ccd09d2..ed9cb666ff09b 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
@@ -91,6 +91,11 @@ class OnScreenKeyboardDisplayManagerInputPane::VirtualKeyboardInputPane
     if (input_pane2_)
       return true;
 
+    if (!base::win::ResolveCoreWinRTDelayload() ||
+        !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+      return false;
+    }
+
     base::win::AssertComApartmentType(base::win::ComApartmentType::STA);
 
     base::win::ScopedHString input_pane_guid = base::win::ScopedHString::Create(
diff --git a/ui/base/ime/win/tsf_bridge.cc b/ui/base/ime/win/tsf_bridge.cc
index 8b3e5acd96ea1..944fde7fc17ed 100644
--- a/ui/base/ime/win/tsf_bridge.cc
+++ b/ui/base/ime/win/tsf_bridge.cc
@@ -16,6 +16,7 @@
 #include "base/threading/thread_local.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/scoped_variant.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ime/ime_key_event_dispatcher.h"
 #include "ui/base/ime/text_input_client.h"
 #include "ui/base/ime/win/mock_tsf_bridge.h"
@@ -196,6 +197,10 @@ TSFBridgeImpl::~TSFBridgeImpl() {
 
 HRESULT TSFBridgeImpl::Initialize() {
   DCHECK(base::CurrentUIThread::IsSet());
+
+// if (!features::IsUsingTSFForIME())
+ //    return E_FAIL;
+
   if (client_id_ != TF_CLIENTID_NULL) {
     DVLOG(1) << "Already initialized.";
     return S_OK;  // shouldn't return error code in this case.
@@ -716,6 +721,10 @@ HRESULT TSFBridge::Initialize() {
     return S_OK;
   }
 
+  // If we aren't supporting TSF early out.
+  if (!base::FeatureList::IsEnabled(features::kTSFImeSupport) || base::win::GetVersion() < base::win::Version::VISTA)
+    return E_FAIL;
+
   auto delegate = std::make_unique<TSFBridgeImpl>();
   HRESULT hr = delegate->Initialize();
   if (SUCCEEDED(hr)) {
@@ -729,6 +738,8 @@ void TSFBridge::InitializeForTesting() {
   if (!base::CurrentUIThread::IsSet()) {
     return;
   }
+  if (!base::FeatureList::IsEnabled(features::kTSFImeSupport))
+    return;
   ReplaceThreadLocalTSFBridge(std::make_unique<MockTSFBridge>());
 }
 
diff --git a/ui/base/ime/win/tsf_input_scope.cc b/ui/base/ime/win/tsf_input_scope.cc
index e2a79de6f846f..ea7ef9cc26f30 100644
--- a/ui/base/ime/win/tsf_input_scope.cc
+++ b/ui/base/ime/win/tsf_input_scope.cc
@@ -10,6 +10,7 @@
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
 #include "base/task/current_thread.h"
+#include "base/win/windows_version.h"
 
 namespace ui::tsf_inputscope {
 namespace {
@@ -108,6 +109,9 @@ typedef HRESULT (WINAPI *SetInputScopesFunc)(HWND window_handle,
                                              WCHAR*, /* unused */
                                              WCHAR* /* unused */);
 
+SetInputScopesFunc g_set_input_scopes = NULL;
+bool g_get_proc_done = false;
+
 InputScope ConvertTextInputTypeToInputScope(TextInputType text_input_type) {
   // Following mapping is based in IE10 on Windows 8.
   switch (text_input_type) {
@@ -149,6 +153,25 @@ InputScope ConvertTextInputModeToInputScope(TextInputMode text_input_mode) {
 
 }  // namespace
 
+void InitializeTsfForInputScopes() {
+  DCHECK(base::CurrentUIThread::IsSet());
+  // Thread safety is not required because this function is under UI thread.
+  if (!g_get_proc_done) {
+    g_get_proc_done = true;
+
+	// For stability reasons, we do not support Windows XP.
+    if (base::win::GetVersion() < base::win::Version::VISTA)
+      return;
+
+    HMODULE module = NULL;
+    if (GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_PIN, L"msctf.dll",
+        &module)) {
+      g_set_input_scopes = reinterpret_cast<SetInputScopesFunc>(
+          GetProcAddress(module, "SetInputScopes"));
+    }
+  }
+}
+
 std::vector<InputScope> GetInputScopes(TextInputType text_input_type,
                                        TextInputMode text_input_mode) {
   std::vector<InputScope> input_scopes;
@@ -178,4 +201,16 @@ ITfInputScope* CreateInputScope(TextInputType text_input_type,
   return new TSFInputScope(input_scopes);
 }
 
+void SetInputScopeForTsfUnawareWindow(HWND window_handle,
+                                      TextInputType text_input_type,
+                                      TextInputMode text_input_mode) {
+  if (!g_set_input_scopes)
+    return;
+
+  std::vector<InputScope> input_scopes = GetInputScopes(text_input_type,
+                                                        text_input_mode);
+  g_set_input_scopes(window_handle, &input_scopes[0], input_scopes.size(),
+                     NULL, 0, NULL, NULL);
+}
+
 }  // namespace ui::tsf_inputscope
diff --git a/ui/base/ime/win/tsf_input_scope.h b/ui/base/ime/win/tsf_input_scope.h
index f369f9a9341d9..e8c159f0844dc 100644
--- a/ui/base/ime/win/tsf_input_scope.h
+++ b/ui/base/ime/win/tsf_input_scope.h
@@ -16,6 +16,10 @@
 namespace ui {
 namespace tsf_inputscope {
 
+// Initializes the TSF for input scopes. It loads the tsf dll and get the
+// function pointer for setting the input scopes in TSF.
+COMPONENT_EXPORT(UI_BASE_IME_WIN) void InitializeTsfForInputScopes();
+
 // Returns InputScope list corresoponding to ui::TextInputType and
 // ui::TextInputMode.
 // This function is only used from following functions but declared for test.
@@ -34,6 +38,15 @@ ITfInputScope* CreateInputScope(TextInputType text_input_type,
                                 TextInputMode text_input_mode,
                                 bool should_do_learning);
 
+// A wrapper of the SetInputScopes API exported by msctf.dll.
+// http://msdn.microsoft.com/en-us/library/windows/desktop/ms629026.aspx
+// Does nothing on Windows XP in case TSF is disabled.
+// NOTE: For TSF-aware window, you should use ITfInputScope instead.
+COMPONENT_EXPORT(UI_BASE_IME_WIN)
+void SetInputScopeForTsfUnawareWindow(HWND window_handle,
+                                      TextInputType text_input_type,
+                                      TextInputMode text_input_mode);
+
 }  // namespace tsf_inputscope
 }  // namespace ui
 
diff --git a/ui/base/mojom/window_open_disposition_mojom_traits.h b/ui/base/mojom/window_open_disposition_mojom_traits.h
index 5d352b58257ef..cd238276358fc 100644
--- a/ui/base/mojom/window_open_disposition_mojom_traits.h
+++ b/ui/base/mojom/window_open_disposition_mojom_traits.h
@@ -5,6 +5,7 @@
 #ifndef UI_BASE_MOJOM_WINDOW_OPEN_DISPOSITION_MOJOM_TRAITS_H_
 #define UI_BASE_MOJOM_WINDOW_OPEN_DISPOSITION_MOJOM_TRAITS_H_
 
+#include "base/command_line.h"
 #include "base/notreached.h"
 #include "mojo/public/cpp/bindings/enum_traits.h"
 #include "ui/base/mojom/window_open_disposition.mojom.h"
@@ -30,6 +31,8 @@ struct EnumTraits<ui::mojom::WindowOpenDisposition, WindowOpenDisposition> {
       case WindowOpenDisposition::NEW_PICTURE_IN_PICTURE:
         return ui::mojom::WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
       case WindowOpenDisposition::NEW_POPUP:
+		if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+           return ui::mojom::WindowOpenDisposition::NEW_FOREGROUND_TAB;
         return ui::mojom::WindowOpenDisposition::NEW_POPUP;
       case WindowOpenDisposition::NEW_WINDOW:
         return ui::mojom::WindowOpenDisposition::NEW_WINDOW;
@@ -68,6 +71,8 @@ struct EnumTraits<ui::mojom::WindowOpenDisposition, WindowOpenDisposition> {
         return true;
       case ui::mojom::WindowOpenDisposition::NEW_POPUP:
         *out = WindowOpenDisposition::NEW_POPUP;
+		if (base::CommandLine::ForCurrentProcess()->HasSwitch("popups-to-tabs"))
+           *out = WindowOpenDisposition::NEW_FOREGROUND_TAB;
         return true;
       case ui::mojom::WindowOpenDisposition::NEW_WINDOW:
         *out = WindowOpenDisposition::NEW_WINDOW;
diff --git a/ui/base/ui_base_features.cc b/ui/base/ui_base_features.cc
index 152122c117cdd..a4ed4dcebce1e 100644
--- a/ui/base/ui_base_features.cc
+++ b/ui/base/ui_base_features.cc
@@ -11,6 +11,10 @@
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/build_info.h"
 #endif
@@ -78,6 +82,9 @@ bool IsNotificationsIgnoreRequireInteractionEnabled() {
   return base::FeatureList::IsEnabled(kNotificationsIgnoreRequireInteraction);
 }
 
+// Enables using TSF (over IMM32) for IME.
+BASE_FEATURE(kTSFImeSupport, "TSFImeSupport", base::FEATURE_ENABLED_BY_DEFAULT);
+
 BASE_FEATURE(kShortcutCustomizationApp,
              "ShortcutCustomizationApp",
              base::FEATURE_ENABLED_BY_DEFAULT);
@@ -253,9 +260,12 @@ BASE_FEATURE(kInputPaneOnScreenKeyboard,
 BASE_FEATURE(kPointerEventsForTouch,
              "PointerEventsForTouch",
              base::FEATURE_ENABLED_BY_DEFAULT);
+// Enables using TSF (over IMM32) for IME.
+BASE_FEATURE(kTSFImeSupport, "TSFImeSupport", base::FEATURE_ENABLED_BY_DEFAULT);
 
 bool IsUsingWMPointerForTouch() {
-  return base::FeatureList::IsEnabled(kPointerEventsForTouch);
+  return base::win::GetVersion() >= base::win::Version::WIN8 &&
+			base::FeatureList::IsEnabled(kPointerEventsForTouch);
 }
 
 #endif  // BUILDFLAG(IS_WIN)
@@ -592,6 +602,10 @@ BASE_FEATURE(kBubbleMetricsApi,
              "BubbleMetricsApi",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kThoriumCustomTabs,
+             "ThoriumCustomTabs",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
 #if BUILDFLAG(IS_MAC)
 // When enabled, images will be written to the system clipboard as both a TIFF
 // and a PNG (as opposed to just a TIFF). This requires encoding the sanitized
diff --git a/ui/base/ui_base_features.h b/ui/base/ui_base_features.h
index 67f99842c04e5..a8aac0c1e041f 100644
--- a/ui/base/ui_base_features.h
+++ b/ui/base/ui_base_features.h
@@ -57,6 +57,7 @@ BASE_DECLARE_FEATURE(kInputPaneOnScreenKeyboard);
 COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kPointerEventsForTouch);
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kScreenPowerListenerForNativeWinOcclusion);
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kTSFImeSupport);
 
 // Returns true if the system should use WM_POINTER events for touch events.
 COMPONENT_EXPORT(UI_BASE_FEATURES) bool IsUsingWMPointerForTouch();
@@ -286,6 +287,9 @@ ChromeRefresh2023Level GetChromeRefresh2023Level();
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kBubbleMetricsApi);
 
+// Enables customization of the shape of the browser tabs.
+COMPONENT_EXPORT(UI_BASE_FEATURES) BASE_DECLARE_FEATURE(kThoriumCustomTabs);
+
 #if BUILDFLAG(IS_MAC)
 COMPONENT_EXPORT(UI_BASE_FEATURES)
 BASE_DECLARE_FEATURE(kMacClipboardWriteImageWithPng);
diff --git a/ui/display/win/screen_win.cc b/ui/display/win/screen_win.cc
index 6b6189a124e3f..a587fc488cebc 100644
--- a/ui/display/win/screen_win.cc
+++ b/ui/display/win/screen_win.cc
@@ -46,13 +46,47 @@ namespace {
 // resolved with Desktop Aura and WindowTreeHost.
 ScreenWin* g_instance = nullptr;
 
+bool IsProcessPerMonitorDpiAware() {
+  enum class PerMonitorDpiAware {
+    UNKNOWN = 0,
+    PER_MONITOR_DPI_UNAWARE,
+    PER_MONITOR_DPI_AWARE,
+  };
+  static PerMonitorDpiAware per_monitor_dpi_aware = PerMonitorDpiAware::UNKNOWN;
+  if (per_monitor_dpi_aware == PerMonitorDpiAware::UNKNOWN) {
+    per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_UNAWARE;
+    HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    if (shcore_dll) {
+      auto get_process_dpi_awareness_func =
+          reinterpret_cast<decltype(::GetProcessDpiAwareness)*>(
+              ::GetProcAddress(shcore_dll, "GetProcessDpiAwareness"));
+      if (get_process_dpi_awareness_func) {
+        PROCESS_DPI_AWARENESS awareness;
+        if (SUCCEEDED(get_process_dpi_awareness_func(nullptr, &awareness)) &&
+            awareness == PROCESS_PER_MONITOR_DPI_AWARE)
+          per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+      }
+    }
+  }
+  return per_monitor_dpi_aware == PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+}
+
 // Gets the DPI for a particular monitor.
 absl::optional<int> GetPerMonitorDPI(HMONITOR monitor) {
+  if (!IsProcessPerMonitorDpiAware())
+    return absl::nullopt;
+
+  static auto get_dpi_for_monitor_func = []() {
+    const HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    return reinterpret_cast<decltype(&::GetDpiForMonitor)>(
+        shcore_dll ? ::GetProcAddress(shcore_dll, "GetDpiForMonitor")
+                   : nullptr);
+  }();
   UINT dpi_x, dpi_y;
-  if (!SUCCEEDED(
-          ::GetDpiForMonitor(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y))) {
+  if (!get_dpi_for_monitor_func ||
+      !SUCCEEDED(
+          get_dpi_for_monitor_func(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y)))
     return absl::nullopt;
-  }
 
   DCHECK_EQ(dpi_x, dpi_y);
   return static_cast<int>(dpi_x);
diff --git a/ui/display/win/uwp_text_scale_factor.cc b/ui/display/win/uwp_text_scale_factor.cc
index f6867edea301e..2d2d18c212bca 100644
--- a/ui/display/win/uwp_text_scale_factor.cc
+++ b/ui/display/win/uwp_text_scale_factor.cc
@@ -52,6 +52,13 @@ bool g_default_instance_cleaned_up = false;
 bool CreateUiSettingsComObject(ComPtr<IUISettings2>& ptr) {
   DCHECK(!ptr);
 
+  // This is required setup before using ScopedHString.
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
   // Create the COM object.
   auto hstring = base::win::ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UISettings);
diff --git a/ui/gfx/canvas.h b/ui/gfx/canvas.h
index 8b2004767a03a..b6b331b1ef9e7 100644
--- a/ui/gfx/canvas.h
+++ b/ui/gfx/canvas.h
@@ -82,6 +82,9 @@ class GFX_EXPORT Canvas {
     // when rendering text onto a fully- or partially-transparent background
     // that will later be blended with another image.
     NO_SUBPIXEL_RENDERING = 1 << 9,
+
+	// Workaround for GDI offset rendering issues.
+	GDI_OFFSET_RENDERING = 1 << 10,
   };
 
   // Creates an empty canvas with image_scale of 1x.
diff --git a/ui/gfx/canvas_skia.cc b/ui/gfx/canvas_skia.cc
index 11d7121476942..3a3e0119c198c 100644
--- a/ui/gfx/canvas_skia.cc
+++ b/ui/gfx/canvas_skia.cc
@@ -235,6 +235,10 @@ void Canvas::DrawStringRectWithFlags(const std::u16string& text,
                      render_text.get());
     if (range.IsValid())
       render_text->ApplyStyle(TEXT_STYLE_UNDERLINE, true, range);
+
+    if (flags & GDI_OFFSET_RENDERING)
+		render_text->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+
     render_text->Draw(this);
   }
 
diff --git a/ui/gfx/font_render_params_win.cc b/ui/gfx/font_render_params_win.cc
index db0200908f88a..32d3b94a06fc8 100644
--- a/ui/gfx/font_render_params_win.cc
+++ b/ui/gfx/font_render_params_win.cc
@@ -15,6 +15,7 @@
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/font_util_win.h"
 #include "ui/gfx/win/singleton_hwnd_observer.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace gfx {
 
@@ -77,7 +78,8 @@ class CachedFontRenderParams {
     BOOL enabled = false;
     if (SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &enabled, 0) && enabled) {
       params_->antialiasing = true;
-      params_->subpixel_positioning = true;
+      // GDI does not support subpixel positioning.
+      params_->subpixel_positioning = win::IsDirectWriteEnabled();
 
       UINT type = 0;
       if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index cf08dd7f0a3ad..4d745ea654673 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -12,6 +12,7 @@
 
 #include "base/check_op.h"
 #include "base/command_line.h"
+#include "base/feature_list.h"
 #include "base/i18n/break_iterator.h"
 #include "base/i18n/char_iterator.h"
 #include "base/i18n/rtl.h"
@@ -32,6 +33,7 @@
 #include "third_party/skia/include/core/SkTextBlob.h"
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "third_party/skia/include/effects/SkGradientShader.h"
+#include "ui/base/ui_base_features.h"
 #include "ui/gfx/canvas.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/size_conversions.h"
@@ -45,6 +47,10 @@
 #include "ui/gfx/text_utils.h"
 #include "ui/gfx/utf16_indexing.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -256,23 +262,25 @@ UChar32 ReplaceControlCharacter(UChar32 codepoint) {
     // Support Microsoft defined PUA on Windows.
     // see:
     // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
-    switch (codepoint) {
-      case 0xF093:  // ButtonA
-      case 0xF094:  // ButtonB
-      case 0xF095:  // ButtonY
-      case 0xF096:  // ButtonX
-      case 0xF108:  // LeftStick
-      case 0xF109:  // RightStick
-      case 0xF10A:  // TriggerLeft
-      case 0xF10B:  // TriggerRight
-      case 0xF10C:  // BumperLeft
-      case 0xF10D:  // BumperRight
-      case 0xF10E:  // Dpad
-      case 0xEECA:  // ButtonView2
-      case 0xEDE3:  // ButtonMenu
-        return codepoint;
-      default:
-        break;
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      switch (codepoint) {
+        case 0xF093:  // ButtonA
+        case 0xF094:  // ButtonB
+        case 0xF095:  // ButtonY
+        case 0xF096:  // ButtonX
+        case 0xF108:  // LeftStick
+        case 0xF109:  // RightStick
+        case 0xF10A:  // TriggerLeft
+        case 0xF10B:  // TriggerRight
+        case 0xF10C:  // BumperLeft
+        case 0xF10D:  // BumperRight
+        case 0xF10E:  // Dpad
+        case 0xEECA:  // ButtonView2
+        case 0xEDE3:  // ButtonMenu
+          return codepoint;
+        default:
+          break;
+      }
     }
 #endif
     const int8_t codepoint_category = u_charType(codepoint);
@@ -364,7 +372,7 @@ void SkiaTextRenderer::DrawPosText(const SkPoint* pos,
   static_assert(sizeof(*pos) == 2 * sizeof(*run_buffer.pos), "");
   memcpy(run_buffer.pos, pos, glyph_count * sizeof(*pos));
 
-  canvas_skia_->drawTextBlob(builder.make(), 0, 0, flags_);
+  canvas_skia_->drawTextBlob(builder.make(), 0, 0 + special_y_offset_, flags_);
 }
 
 void SkiaTextRenderer::DrawUnderline(int x,
@@ -997,7 +1005,7 @@ int RenderText::GetContentWidth() {
 int RenderText::GetBaseline() {
   if (baseline_ == kInvalidBaseline) {
     const int centering_height =
-        (vertical_alignment_ == ALIGN_MIDDLE)
+        (vertical_alignment_ == ALIGN_MIDDLE || vertical_alignment_ == ALIGN_SPECIAL || vertical_alignment_ == ALIGN_COMPACT)
             ? display_rect().height()
             : std::max(font_list().GetHeight(), min_line_height());
     baseline_ = DetermineBaselineCenteringText(centering_height, font_list());
@@ -1027,7 +1035,12 @@ void RenderText::Draw(Canvas* canvas, bool select_all) {
       draw_selections = GetAllSelections();
 
     DrawSelections(canvas, draw_selections);
+
     internal::SkiaTextRenderer renderer(canvas);
+
+	if (vertical_alignment_ == ALIGN_SPECIAL) {
+		renderer.SetSpecialYOffset(4); // This will push down the offending labels in GDI to the point that they will appear centred
+	}
     DrawVisualText(&renderer, draw_selections);
   }
 
@@ -1179,8 +1192,13 @@ Rect RenderText::GetCursorBounds(const SelectionModel& caret,
               base::ClampCeil(Clamp(xspan.GetMin()));
     }
   }
+
   Size line_size = gfx::ToCeiledSize(GetLineSizeF(caret));
   size_t line = GetLineContainingCaret(caret);
+
+  if (vertical_alignment_ == ALIGN_SPECIAL) {
+	  line_size.set_height(line_size.height() + 8);
+  }
   return Rect(ToViewPoint(PointF(x, 0), line), Size(width, line_size.height()));
 }
 
@@ -1861,6 +1879,8 @@ Vector2d RenderText::GetAlignmentOffset(size_t line_number) {
       offset.set_y(0);
       break;
     case ALIGN_MIDDLE:
+	case ALIGN_SPECIAL:
+	case ALIGN_COMPACT:
       if (multiline_)
         offset.set_y((display_rect_.height() - GetStringSize().height()) / 2);
       else
diff --git a/ui/gfx/render_text.h b/ui/gfx/render_text.h
index 5b3eda36fa332..6d691f7715052 100644
--- a/ui/gfx/render_text.h
+++ b/ui/gfx/render_text.h
@@ -73,6 +73,7 @@ class GFX_EXPORT SkiaTextRenderer {
                            bool subpixel_rendering_suppressed);
   void SetTypeface(sk_sp<SkTypeface> typeface);
   void SetTextSize(SkScalar size);
+  void SetSpecialYOffset(int y_offset) { special_y_offset_ = y_offset; }
   void SetForegroundColor(SkColor foreground);
   void SetShader(sk_sp<cc::PaintShader> shader);
   // TODO(vmpstr): Change this API to mimic SkCanvas::drawTextBlob instead.
@@ -89,6 +90,7 @@ class GFX_EXPORT SkiaTextRenderer {
   raw_ptr<cc::PaintCanvas> canvas_skia_;
   cc::PaintFlags flags_;
   SkFont font_;
+  int special_y_offset_ = 0;
 };
 
 struct TextToDisplayIndex {
@@ -1060,6 +1062,9 @@ class GFX_EXPORT RenderText {
 
   // Tell whether or not the |layout_text_| needs an update or is up to date.
   mutable bool layout_text_up_to_date_ = false;
+
+  // Offset of Y used for accurate font positioning in GDI.
+  int y_offset_;
 };
 
 }  // namespace gfx
diff --git a/ui/gfx/switches.cc b/ui/gfx/switches.cc
index 1bf6fffae1614..36866a98d1d24 100644
--- a/ui/gfx/switches.cc
+++ b/ui/gfx/switches.cc
@@ -9,6 +9,11 @@
 
 namespace switches {
 
+#if BUILDFLAG(IS_WIN)
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+#endif
+
 // Scale factor to apply to every animation duration. Must be >= 0.0. This will
 // only apply to LinearAnimation and its subclasses.
 const char kAnimationDurationScale[] = "animation-duration-scale";
diff --git a/ui/gfx/switches.h b/ui/gfx/switches.h
index 98697d908f507..d7ee70f862826 100644
--- a/ui/gfx/switches.h
+++ b/ui/gfx/switches.h
@@ -18,6 +18,10 @@ GFX_SWITCHES_EXPORT extern const char kEnableNativeGpuMemoryBuffers[];
 GFX_SWITCHES_EXPORT extern const char kForcePrefersReducedMotion[];
 GFX_SWITCHES_EXPORT extern const char kHeadless[];
 
+#if BUILDFLAG(IS_WIN)
+GFX_SWITCHES_EXPORT extern const char kDisableDirectWrite[];
+#endif
+
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 GFX_SWITCHES_EXPORT extern const char kX11Display[];
 GFX_SWITCHES_EXPORT extern const char kNoXshm[];
diff --git a/ui/gfx/text_constants.h b/ui/gfx/text_constants.h
index eaa6ea0c42037..275bd3708da69 100644
--- a/ui/gfx/text_constants.h
+++ b/ui/gfx/text_constants.h
@@ -70,6 +70,8 @@ enum VerticalAlignment {
   ALIGN_TOP = 0,  // Align the text's top edge with that of its display area.
   ALIGN_MIDDLE,   // Align the text's center with that of its display area.
   ALIGN_BOTTOM,   // Align the text's bottom edge with that of its display area.
+  ALIGN_SPECIAL,  // Special alignment, equivalent to ALIGN_MIDDLE, but for the GDI renderer.
+  ALIGN_COMPACT,  // Another special alignment for #compact-ui tabs.
 };
 
 // The directionality modes used to determine the base text direction.
diff --git a/ui/gfx/win/direct_write.cc b/ui/gfx/win/direct_write.cc
index cf0f70a55333a..24643275b66d5 100644
--- a/ui/gfx/win/direct_write.cc
+++ b/ui/gfx/win/direct_write.cc
@@ -8,10 +8,12 @@
 
 #include <string>
 
+#include "base/command_line.h"
 #include "base/debug/alias.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/font_utils.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
@@ -19,8 +21,22 @@
 namespace gfx {
 namespace win {
 
+GFX_EXPORT bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-direct-write");;
+}
+
 namespace {
 
+static bool dwrite_enabled = false;
+
 // Pointer to the global IDWriteFactory interface.
 IDWriteFactory* g_direct_write_factory = nullptr;
 
@@ -35,9 +51,24 @@ void SetDirectWriteFactory(IDWriteFactory* factory) {
 }  // anonymous namespace
 
 void CreateDWriteFactory(IDWriteFactory** factory) {
+  if (!gfx::win::ShouldUseDirectWrite())
+    return;
+
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
+
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
   Microsoft::WRL::ComPtr<IUnknown> factory_unknown;
+
   HRESULT hr =
-      DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+      dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                           &factory_unknown);
   if (FAILED(hr)) {
     base::debug::Alias(&hr);
@@ -56,12 +87,43 @@ void InitializeDirectWrite() {
 
   Microsoft::WRL::ComPtr<IDWriteFactory> factory;
   CreateDWriteFactory(&factory);
-  CHECK(!!factory);
+  if (factory == nullptr) {
+	  sk_sp<SkFontMgr> direct_write_font_mgr = SkFontMgr_New_GDI();
+	  skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
+	  return;
+  }
   SetDirectWriteFactory(factory.Get());
 
+// The skia call to create a new DirectWrite font manager instance can fail
+  // if we are unable to get the system font collection from the DirectWrite
+  // factory. The GetSystemFontCollection method in the IDWriteFactory
+  // interface fails with E_INVALIDARG on certain Windows 7 gold versions
+  // (6.1.7600.*).
   sk_sp<SkFontMgr> direct_write_font_mgr =
       SkFontMgr_New_DirectWrite(factory.Get());
-  CHECK(!!direct_write_font_mgr);
+
+  int iteration = 0;
+  if (!direct_write_font_mgr &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    // Windows (win7_rtm) may fail to map the service sections
+    // (crbug.com/956064).
+    constexpr int kMaxRetries = 5;
+    constexpr base::TimeDelta kRetrySleepTime = base::Microseconds(500);
+    while (iteration < kMaxRetries) {
+      base::PlatformThread::Sleep(kRetrySleepTime);
+      direct_write_font_mgr = SkFontMgr_New_DirectWrite(factory.Get());
+      if (direct_write_font_mgr)
+        break;
+      ++iteration;
+    }
+  }
+  if (!direct_write_font_mgr)
+    iteration = -1;
+  DCHECK(!!direct_write_font_mgr);
+  if (!direct_write_font_mgr)
+    direct_write_font_mgr = SkFontMgr_New_GDI();
+  else
+	dwrite_enabled = true;
 
   // Override the default skia font manager. This must be called before any
   // use of the skia font manager is done (e.g. before any call to
@@ -69,6 +131,10 @@ void InitializeDirectWrite() {
   skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
 }
 
+bool IsDirectWriteEnabled() {
+  return dwrite_enabled;
+}
+
 IDWriteFactory* GetDirectWriteFactory() {
   // Some unittests may access this accessor without any previous call to
   // |InitializeDirectWrite|. A call to |InitializeDirectWrite| after this
@@ -142,4 +208,4 @@ absl::optional<std::string> RetrieveLocalizedFontName(
 }
 
 }  // namespace win
-}  // namespace gfx
+}  // namespace gfx
\ No newline at end of file
diff --git a/ui/gfx/win/direct_write.h b/ui/gfx/win/direct_write.h
index 72022056d29c4..7a7727665b4d7 100644
--- a/ui/gfx/win/direct_write.h
+++ b/ui/gfx/win/direct_write.h
@@ -6,7 +6,7 @@
 #define UI_GFX_WIN_DIRECT_WRITE_H_
 
 #include <dwrite.h>
-
+#include "base/component_export.h"
 #include "base/strings/string_piece.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "ui/gfx/gfx_export.h"
@@ -14,9 +14,15 @@
 namespace gfx {
 namespace win {
 
+// Returns whether DirectWrite font rendering should be used.
+GFX_EXPORT bool ShouldUseDirectWrite();
+
 GFX_EXPORT void InitializeDirectWrite();
 
-// Creates a DirectWrite factory.
+// Returns true if we are using DirectWrite for font metrics and rendering.
+GFX_EXPORT bool IsDirectWriteEnabled();
+
+// Creates a DirectWrite factory, if using DirectWrite.
 GFX_EXPORT void CreateDWriteFactory(IDWriteFactory** factory);
 
 // Returns the global DirectWrite factory.
diff --git a/ui/native_theme/caption_style_win.cc b/ui/native_theme/caption_style_win.cc
index 2c27d56f29eaa..9c314a5185c7f 100644
--- a/ui/native_theme/caption_style_win.cc
+++ b/ui/native_theme/caption_style_win.cc
@@ -14,6 +14,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/color_utils.h"
@@ -172,8 +173,18 @@ std::string GetCssColorWithAlpha(CC::ClosedCaptionColor caption_color,
 
 absl::optional<CaptionStyle> InitializeFromSystemSettings() {
   TRACE_EVENT0("ui", "InitializeFromSystemSettings");
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
   DCHECK(base::FeatureList::IsEnabled(features::kSystemCaptionStyle));
 
+  // Need to do this check before using ScopedHString.
+  bool can_use_scoped_hstring =
+      base::win::ResolveCoreWinRTDelayload() &&
+      base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!can_use_scoped_hstring)
+    return absl::nullopt;
+
+
   base::win::ScopedHString closed_caption_properties_string =
       base::win::ScopedHString::Create(
           RuntimeClass_Windows_Media_ClosedCaptioning_ClosedCaptionProperties);
@@ -270,10 +281,12 @@ absl::optional<CaptionStyle> InitializeFromSystemSettings() {
 }  // namespace
 
 absl::optional<CaptionStyle> CaptionStyle::FromSystemSettings() {
-  if (base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
     return InitializeFromSystemSettings();
   }
-  // Return default CaptionStyle if kSystemCaptionStyle is not enabled.
+  // Return default CaptionStyle for pre Win10 versions since system settings
+  // don't allow caption styling.
   return absl::nullopt;
 }
 
diff --git a/ui/native_theme/native_theme_win.cc b/ui/native_theme/native_theme_win.cc
index 50647269ec84f..3ae513ec2c66b 100644
--- a/ui/native_theme/native_theme_win.cc
+++ b/ui/native_theme/native_theme_win.cc
@@ -268,26 +268,104 @@ void NativeThemeWin::Paint(cc::PaintCanvas* canvas,
   if (rect.IsEmpty())
     return;
 
-  switch (part) {
-    case kMenuPopupGutter:
-      PaintMenuGutter(canvas, color_provider, rect);
-      return;
-    case kMenuPopupSeparator:
-      PaintMenuSeparator(canvas, color_provider,
-                         absl::get<MenuSeparatorExtraParams>(extra));
-      return;
-    case kMenuPopupBackground:
-      PaintMenuBackground(canvas, color_provider, rect);
-      return;
-    case kMenuItemBackground:
-      CommonThemePaintMenuItemBackground(this, color_provider, canvas, state,
-                                         rect,
-                                         absl::get<MenuItemExtraParams>(extra));
-      return;
-    default:
-      PaintIndirect(canvas, part, state, rect, extra);
-      return;
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("native-ui-style")) {
+	  switch (part) {
+		case kMenuPopupGutter:
+		  PaintMenuGutter(canvas, color_provider, rect);
+		  return;
+		case kMenuPopupSeparator:
+		  PaintMenuSeparator(canvas, color_provider,
+							 absl::get<MenuSeparatorExtraParams>(extra));
+		  return;
+		case kMenuPopupBackground:
+		  PaintMenuBackground(canvas, color_provider, rect);
+		  return;
+		case kMenuItemBackground:
+		  CommonThemePaintMenuItemBackground(this, color_provider, canvas, state,
+											 rect,
+											 absl::get<MenuItemExtraParams>(extra));
+		  return;
+		default:
+		  break;
+	  }
+  }
+
+  PaintIndirect(canvas, part, state, rect, extra);
+  return;
+}
+
+HRESULT PaintMenuItemBackgroundClassic(
+    HDC hdc,
+    NativeThemeWin::State state,
+    const gfx::Rect& rect,
+    const NativeThemeWin::MenuItemExtraParams& extra) {
+  HANDLE handle = OpenThemeData(nullptr, L"Menu");
+  RECT rect_win = rect.ToRECT();
+  int state_id = MPI_NORMAL;
+  switch (state) {
+    case NativeThemeWin::kDisabled:
+      state_id = extra.is_selected ? MPI_DISABLEDHOT : MPI_DISABLED;
+      break;
+    case NativeThemeWin::kHovered:
+      state_id = MPI_HOT;
+      break;
+    case NativeThemeWin::kNormal:
+      break;
+    case NativeThemeWin::kPressed:
+    case NativeThemeWin::kNumStates:
+      NOTREACHED();
+      break;
   }
+
+  if (handle)
+    return DrawThemeBackground(handle, hdc, MENU_POPUPITEM, state_id, &rect_win, NULL);
+
+  if (state_id == MPI_HOT)
+    FillRect(hdc, &rect_win, GetSysColorBrush(COLOR_HIGHLIGHT));
+  return S_OK;
+}
+
+HRESULT PaintMenuBackgroundClassic(HDC hdc,
+                                   const gfx::Rect& rect) {
+  HANDLE handle = OpenThemeData(nullptr, L"MENU_POPUPBACKGROUND");
+  RECT rect_win = rect.ToRECT();
+  if (handle) {
+    HRESULT result = DrawThemeBackground(handle, hdc, MENU_POPUPBACKGROUND, 0,
+                                 &rect_win, NULL);
+    FrameRect(hdc, &rect_win, GetSysColorBrush(COLOR_3DSHADOW));
+    return result;
+  }
+
+  FillRect(hdc, &rect_win, GetSysColorBrush(COLOR_MENU));
+  DrawEdge(hdc, &rect_win, EDGE_RAISED, BF_RECT);
+  return S_OK;
+}
+
+HRESULT PaintMenuGutterClassic(HDC hdc,
+                                        const gfx::Rect& rect) {
+  RECT rect_win = rect.ToRECT();
+  HANDLE handle = OpenThemeData(nullptr, L"MENU_POPUPGUTTER");
+  return (handle) ?
+      DrawThemeBackground(handle, hdc, MENU_POPUPGUTTER, MPI_NORMAL, &rect_win, NULL) :
+      E_NOTIMPL;
+}
+
+HRESULT PaintMenuSeparatorClassic(
+    HDC hdc,
+    const gfx::Rect& rect) {
+  RECT rect_win = rect.ToRECT();
+
+  HANDLE handle = OpenThemeData(nullptr, L"MENU_POPUPSEPARATOR");
+  if (handle) {
+    // Delta is needed for non-classic to move separator up slightly.
+    --rect_win.top;
+    --rect_win.bottom;
+    return DrawThemeBackground(handle, hdc, MENU_POPUPSEPARATOR, MPI_NORMAL, &rect_win,
+                       NULL);
+  }
+
+  DrawEdge(hdc, &rect_win, EDGE_ETCHED, BF_TOP);
+  return S_OK;
 }
 
 NativeThemeWin::NativeThemeWin(bool configure_web_instance,
@@ -512,9 +590,13 @@ void NativeThemeWin::PaintDirect(SkCanvas* destination_canvas,
       case kTextField:
         break;  // Handled entirely below.
       case kMenuItemBackground:
+	     break;
       case kMenuPopupBackground:
+	     break;
       case kMenuPopupGutter:
+	     break;
       case kMenuPopupSeparator:
+	     break;
       case kScrollbarCorner:
       case kSliderTrack:
       case kSliderThumb:
@@ -631,9 +713,17 @@ void NativeThemeWin::PaintDirect(SkCanvas* destination_canvas,
     case kScrollbarVerticalGripper:
       return;  // No further painting necessary.
     case kMenuItemBackground:
+      PaintMenuItemBackgroundClassic(hdc, state, rect, absl::get<MenuItemExtraParams>(extra));
+      return;
     case kMenuPopupBackground:
+      PaintMenuBackgroundClassic(hdc, rect);
+      return;
     case kMenuPopupGutter:
+      PaintMenuGutterClassic(hdc, rect);
+      return;
     case kMenuPopupSeparator:
+      PaintMenuSeparatorClassic(hdc, rect);
+      return;
     case kScrollbarCorner:
     case kSliderTrack:
     case kSliderThumb:
@@ -921,6 +1011,46 @@ void NativeThemeWin::PaintScrollbarArrowClassic(HDC hdc,
                                                 Part part,
                                                 State state,
                                                 RECT* rect) const {
+  static const int state_id_matrix[4][4] = {
+      {ABS_DOWNDISABLED, ABS_DOWNHOT, ABS_DOWNNORMAL, ABS_DOWNPRESSED},
+	  {ABS_LEFTDISABLED, ABS_LEFTHOT, ABS_LEFTNORMAL, ABS_LEFTPRESSED},
+	  {ABS_RIGHTDISABLED, ABS_RIGHTHOT, ABS_RIGHTNORMAL, ABS_RIGHTPRESSED},
+	  {ABS_UPDISABLED, ABS_UPHOT, ABS_UPNORMAL, ABS_UPPRESSED}
+  };
+  HANDLE handle = OpenThemeData(nullptr, L"SCROLLBAR");
+  if (handle) {
+    int index = part - kScrollbarDownArrow;
+    DCHECK(index >=0 && index < 4);
+    int state_id = state_id_matrix[index][state];
+
+    // Hovering means that the cursor is over the scroolbar, but not over the
+    // specific arrow itself.  We don't want to show it "hot" mode, but only
+    // in "hover" mode.
+	/*
+    if (state == kHovered && extra.is_hovering) {
+      switch (part) {
+        case kScrollbarDownArrow:
+          state_id = ABS_DOWNHOVER;
+          break;
+        case kScrollbarLeftArrow:
+          state_id = ABS_LEFTHOVER;
+          break;
+        case kScrollbarRightArrow:
+          state_id = ABS_RIGHTHOVER;
+          break;
+        case kScrollbarUpArrow:
+          state_id = ABS_UPHOVER;
+          break;
+        default:
+          NOTREACHED() << "Invalid part: " << part;
+          break;
+      }
+    }
+    */
+    DrawThemeBackground(handle, hdc, SBP_ARROWBTN, state_id, rect, NULL);
+	return;
+  }
+
   int classic_state = DFCS_SCROLLDOWN;
   switch (part) {
     case kScrollbarDownArrow:
@@ -954,7 +1084,8 @@ void NativeThemeWin::PaintScrollbarArrowClassic(HDC hdc,
       NOTREACHED();
       break;
   }
-  DrawFrameControl(hdc, rect, DFC_SCROLL, classic_state);
+
+  DrawFrameControl(hdc, rect, DFC_SCROLL, classic_state | DFCS_BUTTONPUSH);
 }
 
 void NativeThemeWin::PaintScrollbarTrackClassic(
diff --git a/ui/shell_dialogs/execute_select_file_win.cc b/ui/shell_dialogs/execute_select_file_win.cc
index 9361287ac3411..4148c1cab9403 100644
--- a/ui/shell_dialogs/execute_select_file_win.cc
+++ b/ui/shell_dialogs/execute_select_file_win.cc
@@ -4,16 +4,20 @@
 
 #include "ui/shell_dialogs/execute_select_file_win.h"
 
+#include <Windows.h>
+#include <commdlg.h>
 #include <shlobj.h>
 #include <wrl/client.h>
 
 #include <memory>
 
 #include "base/check.h"
+#include "base/command_line.h"
 #include "base/feature_list.h"
 #include "base/files/file.h"
 #include "base/files/file_util.h"
 #include "base/functional/callback.h"
+#include "base/logging.h"
 #include "base/strings/string_util.h"
 #include "base/threading/hang_watcher.h"
 #include "base/win/com_init_util.h"
@@ -166,6 +170,221 @@ bool ConfigureDialog(IFileDialog* file_dialog,
          SetFilters(file_dialog, filter, filter_index);
 }
 
+// Configures a |file_dialog| object given the specified parameters.
+bool ConfigureDialog_Legacy(OPENFILENAME_NT4W* open_file_name,
+                     const std::u16string& title,
+					 const base::FilePath& default_path,
+                     const std::vector<FileFilterSpec>& filter,
+                     DWORD dialog_options) {
+  std::u16string filter_buffer;
+  open_file_name->lStructSize = sizeof(OPENFILENAME_NT4W);
+  // Set title.
+  if (!title.empty()) {
+    open_file_name->lpstrTitle = (LPCWSTR)title.c_str();
+  }
+
+  if (dialog_options & FOS_ALLOWMULTISELECT) {
+	open_file_name->Flags |= OFN_ALLOWMULTISELECT;
+  }
+
+  if (!default_path.empty()) {
+        open_file_name->lpstrInitialDir = (LPCWSTR)default_path.value().c_str();
+  }
+
+  if (filter.empty())
+    return true;
+
+  open_file_name->lpstrFilter = NULL;
+  filter_buffer.clear();
+
+ for (const auto& filter_spec : filter) {
+	std::u16string filter_str = filter_spec.description;
+    filter_buffer.append(filter_str);
+    filter_buffer.push_back(0);
+	filter_str = filter_spec.extension_spec;
+	filter_buffer.append(filter_str);
+	filter_buffer.push_back(0);
+  }
+  filter_buffer.push_back(0);
+
+  PWSTR c_filter_buffer = (PWSTR) ::HeapAlloc(::GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WCHAR)*filter_buffer.length());
+
+  for (size_t i = 0; i < filter_buffer.length(); i++)
+  {
+	  c_filter_buffer[i] = filter_buffer.at(i);
+  }
+
+  open_file_name->lpstrFilter = c_filter_buffer;
+
+  return true;
+}
+
+struct SelectFolderDialogOptions {
+  const wchar_t* default_path;
+  bool is_upload;
+};
+
+int CALLBACK BrowseCallbackProc(HWND window,
+                                UINT message,
+                                LPARAM parameter,
+                                LPARAM data) {
+  if (message == BFFM_INITIALIZED) {
+    SelectFolderDialogOptions* options =
+        reinterpret_cast<SelectFolderDialogOptions*>(data);
+    if (options->is_upload) {
+      SendMessage(window, BFFM_SETOKTEXT, 0,
+                  reinterpret_cast<LPARAM>(
+                      l10n_util::GetStringUTF16(
+                          IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON)
+                          .c_str()));
+    }
+    if (options->default_path) {
+      SendMessage(window, BFFM_SETSELECTION, TRUE,
+                  reinterpret_cast<LPARAM>(options->default_path));
+    }
+  }
+  return 0;
+}
+
+// Runs a Folder selection dialog box, passes back the selected folder in |path|
+// and returns true if the user clicks OK. If the user cancels the dialog box
+// the value in |path| is not modified and returns false. Run on the dialog
+// thread.
+bool ExecuteFolder_Legacy(HWND owner,
+                           const std::u16string& title,
+                           const base::FilePath& default_path,
+                           std::vector<base::FilePath>* paths) {
+  base::FilePath result_path;
+  base::win::AssertComInitialized();
+  DCHECK(paths);
+  std::u16string new_title = title;
+  wchar_t dir_buffer[MAX_PATH + 1];
+
+  bool result = false;
+  BROWSEINFO browse_info = {};
+  browse_info.hwndOwner = owner;
+  browse_info.lpszTitle = (LPCWSTR)new_title.c_str();
+  browse_info.pszDisplayName = dir_buffer;
+  browse_info.ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS;
+
+  // If uploading or a default path was provided, update the BROWSEINFO
+  // and set the callback function for the dialog so the strings can be set in
+  // the callback.
+  SelectFolderDialogOptions dialog_options = {};
+  if (!default_path.empty())
+    dialog_options.default_path = default_path.value().c_str();
+  browse_info.ulFlags |= BIF_NONEWFOLDERBUTTON;
+
+  if (dialog_options.default_path) {
+    browse_info.lParam = reinterpret_cast<LPARAM>(&dialog_options);
+    browse_info.lpfn = &BrowseCallbackProc;
+  }
+
+  LPITEMIDLIST list = SHBrowseForFolderW(&browse_info);
+  BaseShellDialogImpl::DisableOwner(owner);
+  if (list) {
+    STRRET out_dir_buffer = {};
+    out_dir_buffer.uType = STRRET_WSTR;
+    Microsoft::WRL::ComPtr<IShellFolder> shell_folder;
+    if (SUCCEEDED(SHGetDesktopFolder(&shell_folder))) {
+      HRESULT hr = shell_folder->GetDisplayNameOf(list, SHGDN_FORPARSING,
+                                                  &out_dir_buffer);
+      if (SUCCEEDED(hr) && out_dir_buffer.uType == STRRET_WSTR) {
+        paths->push_back(base::FilePath(out_dir_buffer.pOleStr));
+        CoTaskMemFree(out_dir_buffer.pOleStr);
+        result = true;
+      } else {
+        // Use old way if we don't get what we want.
+        wchar_t old_out_dir_buffer[MAX_PATH + 1];
+        if (SHGetPathFromIDList(list, old_out_dir_buffer)) {
+          paths->push_back(base::FilePath(old_out_dir_buffer));
+          result = true;
+        }
+      }
+
+      // According to MSDN, Win2000 will not resolve shortcuts, so we do it
+      // ourselves.
+      base::win::ResolveShortcut(paths->at(0), &paths->at(0), nullptr);
+
+    }
+    CoTaskMemFree(list);
+  }
+  return result;
+}
+
+// static
+std::vector<std::tuple<std::u16string, std::u16string>>
+GetFilters(const OPENFILENAME* openfilename) {
+  std::vector<std::tuple<std::u16string, std::u16string>> filters;
+
+  const char16_t* display_string = (char16_t*)openfilename->lpstrFilter;
+  if (!display_string) {
+    return filters;
+  }
+
+  while (*display_string) {
+    const char16_t* display_string_end = display_string;
+    while (*display_string_end)
+      ++display_string_end;
+    const char16_t* pattern = display_string_end + 1;
+    const char16_t* pattern_end = pattern;
+    while (*pattern_end)
+      ++pattern_end;
+    filters.push_back(
+        std::make_tuple(std::u16string(display_string, display_string_end),
+                  std::u16string(pattern, pattern_end)));
+    display_string = pattern_end + 1;
+  }
+
+  return filters;
+}
+
+// Given |extension|, if it's not empty, then remove the leading dot.
+std::wstring GetExtensionWithoutLeadingDot(const std::wstring& extension) {
+  DCHECK(extension.empty() || extension[0] == L'.');
+  return extension.empty() ? extension : extension.substr(1);
+}
+
+// This function takes the output of a SaveAs dialog: a filename, a filter and
+// the extension originally suggested to the user (shown in the dialog box) and
+// returns back the filename with the appropriate extension appended. If the
+// user requests an unknown extension and is not using the 'All files' filter,
+// the suggested extension will be appended, otherwise we will leave the
+// filename unmodified. |filename| should contain the filename selected in the
+// SaveAs dialog box and may include the path, |filter_selected| should be
+// '*.something', for example '*.*' or it can be blank (which is treated as
+// *.*). |suggested_ext| should contain the extension without the dot (.) in
+// front, for example 'jpg'.
+std::wstring AppendExtensionIfNeeded(const std::wstring& filename,
+                                     const std::wstring& filter_selected,
+                                     const std::wstring& suggested_ext) {
+  DCHECK(!filename.empty());
+  std::wstring return_value = filename;
+  LOG(ERROR) << filter_selected;
+  // If we wanted a specific extension, but the user's filename deleted it or
+  // changed it to something that the system doesn't understand, re-append.
+  // Careful: Checking net::GetMimeTypeFromExtension() will only find
+  // extensions with a known MIME type, which many "known" extensions on Windows
+  // don't have.  So we check directly for the "known extension" registry key.
+  std::wstring file_extension(
+      GetExtensionWithoutLeadingDot(base::FilePath(filename).Extension()));
+  std::wstring key(L"." + file_extension);
+  if (!(filter_selected.empty() || filter_selected == L"*.*") &&
+      !base::win::RegKey(HKEY_CLASSES_ROOT, key.c_str(), KEY_READ).Valid() &&
+      file_extension != suggested_ext) {
+    if (return_value.back() != L'.')
+      return_value.append(L".");
+    return_value.append(suggested_ext);
+  }
+
+  // Strip any trailing dots, which Windows doesn't allow.
+  size_t index = return_value.find_last_not_of(L'.');
+  if (index < return_value.size() - 1)
+    return_value.resize(index + 1);
+
+  return return_value;
+}
+
 // Prompt the user for location to save a file.
 // Callers should provide the filter string, and also a filter index.
 // The parameter |index| indicates the initial index of filter description and
@@ -185,56 +404,150 @@ bool RunSaveFileDialog(HWND owner,
                        int* filter_index,
                        base::FilePath* path) {
   Microsoft::WRL::ComPtr<IFileSaveDialog> file_save_dialog;
+  bool use_legacy_dialogs = false;
+  OPENFILENAME_NT4W open_file_name = {0};
   if (FAILED(::CoCreateInstance(CLSID_FileSaveDialog, nullptr,
                                 CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARGS(&file_save_dialog)))) {
-    return false;
-  }
-
-  if (!ConfigureDialog(file_save_dialog.Get(), title, std::u16string(),
-                       default_path, filter, *filter_index, dialog_options)) {
-    return false;
+    use_legacy_dialogs = true;
   }
 
-  file_save_dialog->SetDefaultExtension(def_ext.c_str());
-
-  // This handler auto-closes the file dialog if its owner window is closed.
-  auto auto_close_dialog_event_handler =
-      std::make_unique<ScopedAutoCloseDialogEventHandler>(
-          owner, file_save_dialog.Get());
-
-  // Never consider the current scope as hung. The hang watching deadline (if
-  // any) is not valid since the user can take unbounded time to choose the
-  // file.
-  base::HangWatcher::InvalidateActiveExpectations();
-
-  HRESULT hr = file_save_dialog->Show(owner);
-  BaseShellDialogImpl::DisableOwner(owner);
-
-  // Remove the event handler regardless of the return value of Show().
-  auto_close_dialog_event_handler = nullptr;
-
-  if (FAILED(hr))
-    return false;
-
-  UINT file_type_index;
-  if (FAILED(file_save_dialog->GetFileTypeIndex(&file_type_index)))
-    return false;
-
-  *filter_index = static_cast<int>(file_type_index);
-
-  Microsoft::WRL::ComPtr<IShellItem> result;
-  if (FAILED(file_save_dialog->GetResult(&result)))
-    return false;
-
-  base::win::ScopedCoMem<wchar_t> display_name;
-  if (FAILED(result->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
-                                    &display_name))) {
-    return false;
+  if (!use_legacy_dialogs) {
+	  if (!ConfigureDialog(file_save_dialog.Get(), title, std::u16string(),
+						   default_path, filter, *filter_index, dialog_options)) {
+		return false;
+	  }
+	} else {
+	  ConfigureDialog_Legacy(&open_file_name, title, default_path, filter, dialog_options);
+   }
+  if (!use_legacy_dialogs) {
+	  file_save_dialog->SetDefaultExtension(def_ext.c_str());
+
+	  // This handler auto-closes the file dialog if its owner window is closed.
+	  auto auto_close_dialog_event_handler =
+		  std::make_unique<ScopedAutoCloseDialogEventHandler>(
+			  owner, file_save_dialog.Get());
+	  // Never consider the current scope as hung. The hang watching deadline (if
+	  // any) is not valid since the user can take unbounded time to choose the
+	  // file.
+      base::HangWatcher::InvalidateActiveExpectations();
+	  HRESULT hr = file_save_dialog->Show(owner);
+	  BaseShellDialogImpl::DisableOwner(owner);
+
+	  // Remove the event handler regardless of the return value of Show().
+	  auto_close_dialog_event_handler = nullptr;
+
+	  if (FAILED(hr))
+		return false;
+
+	  UINT file_type_index;
+	  if (FAILED(file_save_dialog->GetFileTypeIndex(&file_type_index)))
+		return false;
+
+	  *filter_index = static_cast<int>(file_type_index);
+
+	  Microsoft::WRL::ComPtr<IShellItem> result;
+	  if (FAILED(file_save_dialog->GetResult(&result)))
+		return false;
+
+	  base::win::ScopedCoMem<wchar_t> display_name;
+	  if (FAILED(result->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
+										&display_name))) {
+		return false;
+	  }
+
+	  *path = base::FilePath(display_name.get());
+	  return true;
+  } else {
+	  base::HangWatcher::InvalidateActiveExpectations();
+	  open_file_name.hwndOwner = owner;
+	  open_file_name.Flags |= OFN_OVERWRITEPROMPT | OFN_EXPLORER |
+							  OFN_ENABLESIZING | OFN_NOCHANGEDIR |
+						      OFN_PATHMUSTEXIST;
+      wchar_t filename_buffer [UNICODE_STRING_MAX_CHARS];
+	  filename_buffer[0] = L'\0';
+	  if (!default_path.empty()) {
+		base::FilePath suggested_file_name;
+		base::FilePath suggested_directory;
+		if (IsDirectory(default_path)) {
+		  suggested_directory = default_path;
+		} else {
+		  suggested_directory = default_path.DirName();
+		  suggested_file_name = default_path.BaseName();
+		  // If the default_path is a root directory, |suggested_file_name| will be
+		  // '\', and the call to GetSaveFileName below will fail.
+		  if (suggested_file_name.value() == L"\\")
+			suggested_file_name.clear();
+		}
+		  open_file_name.lpstrInitialDir = NULL;
+
+		  if (!suggested_directory.empty()) {
+		  open_file_name.lpstrInitialDir = suggested_directory.value().c_str();
+
+			  if (!suggested_file_name.empty()) {
+			  // The filename is ignored if no initial directory is supplied.
+				  base::wcslcpy(filename_buffer,
+								suggested_file_name.value().c_str(),
+								sizeof(filename_buffer));
+			  }
+		  }
+	  }
+	  open_file_name.lpstrFile = filename_buffer;
+	  open_file_name.nMaxFile = UNICODE_STRING_MAX_CHARS;
+      if (!filter.empty() && ((int)filter.size() - 1) < *filter_index) {
+            *filter_index = filter.size() - 1;
+          }
+	 // open_file_name.lpstrFilter =
+	//	  filter.empty() ? nullptr : (LPCWSTR)filter.at(*filter_index).extension_spec.c_str();
+	  open_file_name.nFilterIndex = *filter_index;
+	  open_file_name.lpstrDefExt = &def_ext[0];
+
+	  BOOL success = ::GetSaveFileNameW((OPENFILENAMEW*)&open_file_name);
+	  BaseShellDialogImpl::DisableOwner(owner);
+	  if (!success) {
+		if (open_file_name.lpstrFilter) {
+		  ::HeapFree(::GetProcessHeap(), 0, (LPVOID)open_file_name.lpstrFilter);
+		  open_file_name.lpstrFilter = nullptr;
+	    }
+		return false;
+	  }
+
+	  // Return the user's choice.
+	  //*path = base::FilePath(open_file_name.lpstrFile);
+	  *filter_index = open_file_name.nFilterIndex;
+
+	  // Figure out what filter got selected. The filter index is 1-based.
+	  std::u16string filter_selected;
+	  if (*filter_index > 0) {
+		std::vector<std::tuple<std::u16string, std::u16string>> filters =
+			GetFilters((OPENFILENAMEW*)&open_file_name);
+		if (*filter_index > (long long)filters.size())
+		  NOTREACHED() << "Invalid filter index.";
+		else
+		  filter_selected = std::get<1>(filters[*filter_index - 1]);
+	  }
+
+	  // Get the extension that was suggested to the user (when the Save As dialog
+	  // was opened).
+	  std::wstring suggested_ext = GetExtensionWithoutLeadingDot(default_path.Extension());
+      LOG(ERROR) << suggested_ext;
+      LOG(ERROR) << filter_selected;
+	  // If we can't get the extension from the default_path, we use the default
+	  // extension passed in. This is to cover cases like when saving a web page,
+	  // where we get passed in a name without an extension and a default extension
+	  // along with it.
+	  if (suggested_ext.empty())
+		suggested_ext.append(def_ext);
+
+	  *path = base::FilePath(
+		  AppendExtensionIfNeeded(base::FilePath(open_file_name.lpstrFile).value(), std::wstring(filter_selected.begin(), filter_selected.end()), suggested_ext));
+
+    if (open_file_name.lpstrFilter) {
+        ::HeapFree(::GetProcessHeap(), 0, (LPVOID)open_file_name.lpstrFilter);
+        open_file_name.lpstrFilter = nullptr;
+    }
+	  return true;
   }
-
-  *path = base::FilePath(display_name.get());
-  return true;
 }
 
 // Runs an Open file dialog box, with similar semantics for input parameters as
@@ -248,10 +561,12 @@ bool RunOpenFileDialog(HWND owner,
                        int* filter_index,
                        std::vector<base::FilePath>* paths) {
   Microsoft::WRL::ComPtr<IFileOpenDialog> file_open_dialog;
+  bool use_legacy_dialogs = false;
+  OPENFILENAME_NT4W open_file_name = {0};
   if (FAILED(::CoCreateInstance(CLSID_FileOpenDialog, nullptr,
                                 CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARGS(&file_open_dialog)))) {
-    return false;
+    use_legacy_dialogs = true;
   }
 
   // The FOS_FORCEFILESYSTEM option ensures that if the user enters a URL in the
@@ -260,64 +575,124 @@ bool RunOpenFileDialog(HWND owner,
   // GetOpenFileName API.
   dialog_options |= FOS_FORCEFILESYSTEM;
 
-  if (!ConfigureDialog(file_open_dialog.Get(), title, ok_button_label,
-                       default_path, filter, *filter_index, dialog_options)) {
-    return false;
+  if (!use_legacy_dialogs) {
+	  if (!ConfigureDialog(file_open_dialog.Get(), title, ok_button_label,
+						   default_path, filter, *filter_index, dialog_options)) {
+		return false;
+	  }
+  } else {
+	  if (dialog_options & FOS_PICKFOLDERS)
+		  return ExecuteFolder_Legacy(owner, title, default_path, paths);
+	  ConfigureDialog_Legacy(&open_file_name, title, default_path, filter, dialog_options);
   }
 
-  // This handler auto-closes the file dialog if its owner window is closed.
-  auto auto_close_dialog_event_handler =
-      std::make_unique<ScopedAutoCloseDialogEventHandler>(
-          owner, file_open_dialog.Get());
+  if (!use_legacy_dialogs) {
+          // This handler auto-closes the file dialog if its owner window is
+          // closed.
+      auto auto_close_dialog_event_handler =
+              std::make_unique<ScopedAutoCloseDialogEventHandler>(
+                  owner, file_open_dialog.Get());
 
-  // Never consider the current scope as hung. The hang watching deadline (if
-  // any) is not valid since the user can take unbounded time to choose the
-  // file.
-  base::HangWatcher::InvalidateActiveExpectations();
+	  // Never consider the current scope as hung. The hang watching deadline (if
+	  // any) is not valid since the user can take unbounded time to choose the
+	  // file.
+	  base::HangWatcher::InvalidateActiveExpectations();
 
-  HRESULT hr = file_open_dialog->Show(owner);
-  BaseShellDialogImpl::DisableOwner(owner);
+	  HRESULT hr = file_open_dialog->Show(owner);
+	  BaseShellDialogImpl::DisableOwner(owner);
 
-  // Remove the event handler regardless of the return value of Show().
-  auto_close_dialog_event_handler = nullptr;
+	  // Remove the event handler regardless of the return value of Show().
+	  auto_close_dialog_event_handler = nullptr;
 
-  if (FAILED(hr))
-    return false;
+	  if (FAILED(hr))
+		return false;
 
-  UINT file_type_index;
-  if (FAILED(file_open_dialog->GetFileTypeIndex(&file_type_index)))
-    return false;
+	  UINT file_type_index;
+	  if (FAILED(file_open_dialog->GetFileTypeIndex(&file_type_index)))
+		return false;
 
-  *filter_index = static_cast<int>(file_type_index);
+	  *filter_index = static_cast<int>(file_type_index);
 
-  Microsoft::WRL::ComPtr<IShellItemArray> selected_items;
-  if (FAILED(file_open_dialog->GetResults(&selected_items)))
-    return false;
+	  Microsoft::WRL::ComPtr<IShellItemArray> selected_items;
+	  if (FAILED(file_open_dialog->GetResults(&selected_items)))
+		return false;
 
-  DWORD result_count;
-  if (FAILED(selected_items->GetCount(&result_count)))
-    return false;
+	  DWORD result_count;
+	  if (FAILED(selected_items->GetCount(&result_count)))
+		return false;
 
-  DCHECK(result_count == 1 || (dialog_options & FOS_ALLOWMULTISELECT));
+	  DCHECK(result_count == 1 || (dialog_options & FOS_ALLOWMULTISELECT));
 
-  std::vector<base::FilePath> result(result_count);
-  for (DWORD i = 0; i < result_count; ++i) {
-    Microsoft::WRL::ComPtr<IShellItem> shell_item;
-    if (FAILED(selected_items->GetItemAt(i, &shell_item)))
-      return false;
+	  std::vector<base::FilePath> result(result_count);
+	  for (DWORD i = 0; i < result_count; ++i) {
+		Microsoft::WRL::ComPtr<IShellItem> shell_item;
+		if (FAILED(selected_items->GetItemAt(i, &shell_item)))
+		  return false;
 
-    base::win::ScopedCoMem<wchar_t> display_name;
-    if (FAILED(shell_item->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
-                                          &display_name))) {
-      return false;
-    }
+		base::win::ScopedCoMem<wchar_t> display_name;
+		if (FAILED(shell_item->GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING,
+											  &display_name))) {
+		  return false;
+		}
 
-    result[i] = base::FilePath(display_name.get());
-  }
+		result[i] = base::FilePath(display_name.get());
+	  }
 
-  // Only modify the out parameter if the enumeration didn't fail.
-  *paths = std::move(result);
-  return !paths->empty();
+	  // Only modify the out parameter if the enumeration didn't fail.
+	  *paths = std::move(result);
+	  return !paths->empty();
+  } else {
+	  base::HangWatcher::InvalidateActiveExpectations();
+	  wchar_t filename_buffer [UNICODE_STRING_MAX_CHARS];
+	  filename_buffer[0] = '\0';
+	  open_file_name.hwndOwner = owner;
+	  open_file_name.lpstrFile = filename_buffer;
+	  open_file_name.nMaxFile = UNICODE_STRING_MAX_CHARS;
+	  open_file_name.Flags |= OFN_EXPLORER | OFN_HIDEREADONLY;
+	  bool success = ::GetOpenFileNameW((OPENFILENAMEW*)&open_file_name);
+	  BaseShellDialogImpl::DisableOwner(owner);
+
+	  if (open_file_name.lpstrFilter) {
+		  ::HeapFree(::GetProcessHeap(), 0, (LPVOID)open_file_name.lpstrFilter);
+		  open_file_name.lpstrFilter = nullptr;
+	  }
+
+	  if (success) {
+		  base::FilePath directory;
+          std::vector<base::FilePath> filenames;
+		  const wchar_t* selection = open_file_name.lpstrFile;
+		  // The return value of |open_file_name.lpstrFile| is dependent on the
+		  // value of the Multi-Select flag within |open_file_name|. If the flag is
+		  // not set the return value will be a single null-terminated wide string.
+		  // If it is set it will be more than one null-terminated wide string, itself
+		  // terminated by an empty null-terminated wide string.
+		  if (open_file_name.Flags & OFN_ALLOWMULTISELECT) {
+			while (*selection) {  // Empty string indicates end of list.
+			  filenames.push_back(base::FilePath(selection));
+			  // Skip over filename and null-terminator.
+			  selection += filenames.back().value().length() + 1;
+			}
+		  } else {
+			filenames.push_back(base::FilePath(selection));
+		  }
+		  if (filenames.size() == 1) {
+			// When there is one file, it contains the path and filename.
+			directory = filenames.at(0).DirName();
+			filenames.at(0) = filenames.at(0).BaseName();
+		  } else if (filenames.size() > 1) {
+			// Otherwise, the first string is the path, and the remainder are
+			// filenames.
+			directory = filenames.at(0);
+			filenames.erase(filenames.begin());
+		  }
+		 for (std::vector<base::FilePath>::iterator it = filenames.begin();
+			   it != filenames.end(); ++it) {
+			paths->push_back(directory.Append(*it));
+		  }
+	  }
+
+	   return !paths->empty();
+   }
 }
 
 // Runs a Folder selection dialog box, passes back the selected folder in |path|
diff --git a/ui/snapshot/snapshot_win.cc b/ui/snapshot/snapshot_win.cc
index 37b31f022ef3c..bdf1269919100 100644
--- a/ui/snapshot/snapshot_win.cc
+++ b/ui/snapshot/snapshot_win.cc
@@ -27,6 +27,7 @@ void GrabHwndSnapshot(HWND window_handle,
                       const gfx::Rect& snapshot_bounds_in_pixels,
                       const gfx::Rect& clip_rect_in_pixels,
                       gfx::Image* image) {
+  BOOL result = false;
   gfx::Rect snapshot_bounds_in_window =
       snapshot_bounds_in_pixels + clip_rect_in_pixels.OffsetFromOrigin();
   gfx::Size bitmap_size(snapshot_bounds_in_window.right(),
@@ -42,7 +43,31 @@ void GrabHwndSnapshot(HWND window_handle,
   // the window that are drawn using DirectComposition.
   UINT flags = PW_CLIENTONLY | PW_RENDERFULLCONTENT;
 
-  BOOL result = PrintWindow(window_handle, mem_hdc, flags);
+  if (base::win::GetVersion() >= base::win::Version::WIN8_1){
+	result = PrintWindow(window_handle, mem_hdc, flags);
+  }
+  else {
+	// PrintWindow does not work for pre-Windows 8.1. So we'll use BitBlt.
+	// Copying from the window's actual HDC doesn't work so let's just use the full screen HDC.
+	// When a snapshot is captured the focus should be on the browser window anyway.
+	HDC window_hdc = GetDC(NULL);
+
+	RECT window_rect;
+
+	memset(&window_rect, 0, sizeof(RECT));
+
+	result = GetWindowRect(window_handle, &window_rect);
+
+	 if (!result) {
+    PLOG(ERROR) << "Failed to get valid rect for snapshot area.";
+    return;
+    }
+	// The left of the snapshot "window" rect is offset by 8 pixels to remove a bit of the dark grey showing through.
+	result = BitBlt(mem_hdc, 0, 0, bitmap_size.width(), bitmap_size.height(),
+					window_hdc, window_rect.left + 8, window_rect.top, SRCCOPY);
+
+	DeleteDC(window_hdc);
+  }
   if (!result) {
     PLOG(ERROR) << "Failed to print window";
     return;
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 3600dd711ffdd..6d705c31a7027 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -764,6 +764,7 @@ component("views") {
       "accessibility/ax_widget_obj_wrapper.h",
       "accessibility/ax_window_obj_wrapper.h",
       "controls/native/native_view_host_aura.h",
+      "corewm/cursor_height_provider_win.h",
       "corewm/tooltip.h",
       "corewm/tooltip_controller.h",
       "corewm/tooltip_state_manager.h",
@@ -808,6 +809,13 @@ component("views") {
       "widget/window_reorderer.cc",
       "windows_stationarity_monitor_aura.cc",
     ]
+    if (is_win) {
+      public += [ "corewm/tooltip_win.h" ]
+      sources += [
+        "corewm/cursor_height_provider_win.cc",
+        "corewm/tooltip_win.cc",
+      ]
+    }
     if (!is_chromeos_ash) {
       sources += [
         "accessibility/views_ax_tree_manager.cc",
diff --git a/ui/views/controls/combobox/combobox.cc b/ui/views/controls/combobox/combobox.cc
index 43dbb0cbb9c04..323fedf58344d 100644
--- a/ui/views/controls/combobox/combobox.cc
+++ b/ui/views/controls/combobox/combobox.cc
@@ -52,6 +52,10 @@
 #include "ui/views/view_utils.h"
 #include "ui/views/widget/widget.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace views {
 
 namespace {
@@ -643,7 +647,14 @@ void Combobox::PaintIconAndText(gfx::Canvas* canvas) {
 
   gfx::Rect text_bounds(x, y, text_width, contents_height);
   AdjustBoundsForRTLUI(&text_bounds);
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled())
+	canvas->DrawStringRectWithFlags(text, font_list, text_color, text_bounds, gfx::Canvas::GDI_OFFSET_RENDERING);
+  else
+	canvas->DrawStringRect(text, font_list, text_color, text_bounds);
+  #else
   canvas->DrawStringRect(text, font_list, text_color, text_bounds);
+  #endif
 
   // Draw the arrow.
   // TODO(crbug.com/1392549): Replace placeholder spacing and color values for
diff --git a/ui/views/controls/label.cc b/ui/views/controls/label.cc
index bee3e8a14eb85..16ef9ce056c3b 100644
--- a/ui/views/controls/label.cc
+++ b/ui/views/controls/label.cc
@@ -11,6 +11,7 @@
 #include <limits>
 #include <utility>
 
+#include "base/command_line.h"
 #include "base/i18n/rtl.h"
 #include "base/strings/string_split.h"
 #include "base/strings/utf_string_conversions.h"
@@ -39,6 +40,10 @@
 #include "ui/views/selection_controller.h"
 #include "ui/views/style/typography_provider.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace {
 
 // An enum giving different RenderText properties unique keys for the
@@ -805,7 +810,18 @@ int Label::GetFontListY() const {
 
 void Label::PaintText(gfx::Canvas* canvas) {
   MaybeBuildDisplayText();
-
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled()) {
+    if (text_context_ == style::CONTEXT_BUTTON || text_context_ == style::CONTEXT_LABEL ||
+			text_context_ == style::CONTEXT_BUTTON_MD)
+	  display_text_->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+    // The bookmark bar labels and some of the side text in the menus are CONTEXT_BUTTON.
+	// The "new tab" labels are CONTEXT_LABEL.
+	// Of note, some UI elements such as the placeholder text in the address bar were not being
+	// having the proper offset applied so the few elements that do not require offsets are
+	// singled out and the rest are given the 4px offset.
+  }
+  #endif
   if (display_text_)
     display_text_->Draw(canvas);
 
diff --git a/ui/views/controls/scrollbar/scroll_bar.cc b/ui/views/controls/scrollbar/scroll_bar.cc
index 9ecb251570e68..f4fe1907fdcef 100644
--- a/ui/views/controls/scrollbar/scroll_bar.cc
+++ b/ui/views/controls/scrollbar/scroll_bar.cc
@@ -438,6 +438,11 @@ void ScrollBar::TrackClicked() {
 
 void ScrollBar::ScrollContentsToOffset() {
   ScrollToPosition(contents_scroll_offset_);
+  // Safeguard against a divide-by-zero bug that happens when separating
+  // multiple tabs into separate windows.
+  contents_size_ = std::max(1, contents_size_);
+  viewport_size_ = std::max(1, viewport_size_);
+
   thumb_->SetPosition(CalculateThumbPosition(contents_scroll_offset_));
 }
 
@@ -459,6 +464,7 @@ int ScrollBar::CalculateThumbPosition(int contents_scroll_offset) const {
   if (viewport_size_ == contents_size_) {
     return 0;
   }
+
   return (contents_scroll_offset * thumb_max) /
          (contents_size_ - viewport_size_);
 }
diff --git a/ui/views/controls/textfield/textfield.cc b/ui/views/controls/textfield/textfield.cc
index 81d64b019fce3..82b3cde1d081e 100644
--- a/ui/views/controls/textfield/textfield.cc
+++ b/ui/views/controls/textfield/textfield.cc
@@ -82,6 +82,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/win_util.h"
+#include "ui/gfx/win/direct_write.h"
 #endif
 
 #if BUILDFLAG(IS_LINUX)
@@ -615,7 +616,11 @@ void Textfield::FitToLocalBounds() {
     // the vertical insets.
     bounds.Inset(gfx::Insets::TLBR(0, insets.left(), 0, insets.right()));
   }
-
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled()) {
+	   GetRenderText()->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+  }
+  #endif
   bounds.set_x(GetMirroredXForRect(bounds));
   GetRenderText()->SetDisplayRect(bounds);
   UpdateAfterChange(TextChangeType::kNone, true);
@@ -1821,6 +1826,7 @@ bool Textfield::ChangeTextDirectionAndLayoutAlignment(
       modes_match && GetHorizontalAlignment() == gfx::ALIGN_TO_HEAD;
   if (!dir_from_text && GetHorizontalAlignment() != gfx::ALIGN_CENTER)
     SetHorizontalAlignment(default_rtl ? gfx::ALIGN_RIGHT : gfx::ALIGN_LEFT);
+
   SchedulePaint();
   return true;
 }
@@ -2703,6 +2709,13 @@ void Textfield::PaintTextAndCursor(gfx::Canvas* canvas) {
     if (SkColorGetA(GetBackgroundColor()) != SK_AlphaOPAQUE)
       placeholder_text_draw_flags |= gfx::Canvas::NO_SUBPIXEL_RENDERING;
 
+    #if BUILDFLAG(IS_WIN)
+    if (!gfx::win::IsDirectWriteEnabled()) {
+	   render_text->SetVerticalAlignment(gfx::ALIGN_SPECIAL);
+	   placeholder_text_draw_flags |= gfx::Canvas::GDI_OFFSET_RENDERING;
+    }
+    #endif
+
     canvas->DrawStringRectWithFlags(
         GetPlaceholderText(), placeholder_font_list_.value_or(GetFontList()),
         placeholder_text_color_.value_or(
diff --git a/ui/views/corewm/cursor_height_provider_win.cc b/ui/views/corewm/cursor_height_provider_win.cc
new file mode 100644
index 0000000000000..aed9fdce181db
--- /dev/null
+++ b/ui/views/corewm/cursor_height_provider_win.cc
@@ -0,0 +1,178 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/corewm/cursor_height_provider_win.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <windows.h>
+
+#include <algorithm>
+#include <map>
+#include <memory>
+
+#include "base/numerics/safe_conversions.h"
+#include "base/win/scoped_hdc.h"
+
+namespace {
+using PixelData = std::unique_ptr<uint32_t[]>;
+using HeightStorage = std::map<HCURSOR, int>;
+
+const uint32_t kBitsPeruint32 = sizeof(uint32_t) * 8;
+// All bits are 1 for transparent portion of monochromatic mask.
+constexpr uint32_t kTransparentMask = 0xffffffff;
+// This is height of default pointer arrow in Windows 7.
+constexpr int kDefaultHeight = 20;
+// Masks are monochromatic.
+constexpr size_t kNumberOfColors = 2;
+const size_t kHeaderAndPalette =
+    sizeof(BITMAPINFOHEADER) + kNumberOfColors * sizeof(RGBQUAD);
+
+HeightStorage* cached_heights = nullptr;
+
+// Extracts the pixel data of provided bitmap
+PixelData GetBitmapData(HBITMAP handle, const BITMAPINFO& info, HDC hdc) {
+  PixelData data;
+  // Masks are monochromatic.
+  DCHECK_EQ(info.bmiHeader.biBitCount, 1);
+  if (info.bmiHeader.biBitCount != 1)
+    return data;
+
+  // When getting pixel data palette is appended to memory pointed by
+  // BITMAPINFO passed so allocate additional memory to store additional data.
+  auto header = std::make_unique<char[]>(kHeaderAndPalette);
+  memcpy(header.get(), &(info.bmiHeader), sizeof(info.bmiHeader));
+
+  data = std::make_unique<uint32_t[]>(info.bmiHeader.biSizeImage /
+                                      sizeof(uint32_t));
+
+  int result = GetDIBits(
+      hdc, handle, 0, static_cast<UINT>(info.bmiHeader.biHeight), data.get(),
+      reinterpret_cast<BITMAPINFO*>(header.get()), DIB_RGB_COLORS);
+
+  if (result == 0)
+    data.reset();
+
+  return data;
+}
+
+// Checks if the specifed row is transparent in provided bitmap.
+bool IsRowTransparent(const PixelData& data,
+                      const uint32_t row_size,
+                      const uint32_t last_byte_mask,
+                      const uint32_t y) {
+  // Set the padding bits to 1 to make mask matching easier.
+  *(data.get() + (y + 1) * row_size - 1) |= last_byte_mask;
+  for (uint32_t i = y * row_size; i < (y + 1) * row_size; ++i) {
+    if (*(data.get() + i) != kTransparentMask)
+      return false;
+  }
+  return true;
+}
+
+// Gets the vertical offset between specified cursor's hotpoint and its bottom.
+//
+// Gets the cursor image data and extract cursor's visible height.
+// Based on that gets what should be the vertical offset between cursor's
+// hot point and the tooltip.
+int CalculateCursorHeight(HCURSOR cursor_handle) {
+  base::win::ScopedGetDC hdc(nullptr);
+
+  ICONINFO icon = {0};
+  GetIconInfo(cursor_handle, &icon);
+
+  BITMAPINFO bitmap_info = {};
+  bitmap_info.bmiHeader.biSize = sizeof(bitmap_info.bmiHeader);
+  if (GetDIBits(hdc, icon.hbmMask, 0, 0, nullptr, &bitmap_info,
+                DIB_RGB_COLORS) == 0)
+    return kDefaultHeight;
+
+  // Rows are padded to full DWORDs. OR with this mask will set them to 1
+  // to simplify matching with |transparent_mask|.
+  uint32_t last_byte_mask = 0xFFFFFFFF;
+  const auto width = static_cast<uint32_t>(bitmap_info.bmiHeader.biWidth);
+  const unsigned char bits_to_shift =
+      sizeof(last_byte_mask) * 8 - (width % kBitsPeruint32);
+  if (bits_to_shift != kBitsPeruint32)
+    last_byte_mask = (last_byte_mask << bits_to_shift);
+  else
+    last_byte_mask = 0;
+
+  const uint32_t row_size = (width + kBitsPeruint32 - 1) / kBitsPeruint32;
+  PixelData data(GetBitmapData(icon.hbmMask, bitmap_info, hdc));
+  if (data == nullptr)
+    return kDefaultHeight;
+
+  // There are 2 types of cursors: Ones that cover the area underneath
+  // completely (i.e. hand cursor) and ones that partially cover
+  // and partially blend with background (i. e. I-beam cursor).
+  // These will have either 1 square mask or 2 masks stacked on top
+  // of each other (xor mask and and mask).
+  const bool has_xor_mask =
+      bitmap_info.bmiHeader.biHeight == 2 * bitmap_info.bmiHeader.biWidth;
+  const auto height = static_cast<uint32_t>(bitmap_info.bmiHeader.biHeight);
+  const uint32_t cursor_height = has_xor_mask ? height / 2 : height;
+  uint32_t xor_offset;
+  if (has_xor_mask) {
+    for (xor_offset = 0; xor_offset < cursor_height; ++xor_offset) {
+      const uint32_t row_start = row_size * xor_offset;
+      const uint32_t row_boundary = row_start + row_size;
+      for (uint32_t i = row_start; i < row_boundary; ++i)
+        data.get()[i] = ~(data.get()[i]);
+      if (!IsRowTransparent(data, row_size, last_byte_mask, xor_offset)) {
+        break;
+      }
+    }
+  } else {
+    xor_offset = cursor_height;
+  }
+
+  uint32_t and_offset;
+
+  for (and_offset = has_xor_mask ? cursor_height : 0; and_offset < height;
+       ++and_offset) {
+    if (!IsRowTransparent(data, row_size, last_byte_mask, and_offset)) {
+      break;
+    }
+  }
+  if (has_xor_mask) {
+    and_offset -= cursor_height;
+  }
+  const uint32_t offset = std::min(xor_offset, and_offset);
+
+  DeleteObject(icon.hbmColor);
+  DeleteObject(icon.hbmMask);
+
+  // Apparently it's possible for the calculation here to underflow, and thus
+  // result in a negative value, maybe if the hotspot is below any visible
+  // portion of the cursor.  Not sure if this case should return 0 instead.
+  return static_cast<int>(cursor_height - offset - icon.yHotspot + 1);
+}
+
+}  // namespace
+
+namespace views {
+namespace corewm {
+
+int GetCurrentCursorVisibleHeight() {
+  CURSORINFO cursor = {0};
+  cursor.cbSize = sizeof(cursor);
+  GetCursorInfo(&cursor);
+
+  if (cached_heights == nullptr)
+    cached_heights = new HeightStorage;
+
+  HeightStorage::const_iterator cached_height =
+      cached_heights->find(cursor.hCursor);
+  if (cached_height != cached_heights->end())
+    return cached_height->second;
+
+  const int height = CalculateCursorHeight(cursor.hCursor);
+  (*cached_heights)[cursor.hCursor] = height;
+
+  return height;
+}
+
+}  // namespace corewm
+}  // namespace views
diff --git a/ui/views/corewm/cursor_height_provider_win.h b/ui/views/corewm/cursor_height_provider_win.h
new file mode 100644
index 0000000000000..ce0bf65a96948
--- /dev/null
+++ b/ui/views/corewm/cursor_height_provider_win.h
@@ -0,0 +1,21 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
+#define UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
+
+namespace views {
+namespace corewm {
+
+// Gets the visible height of current cursor.
+//
+// The height is offset between cursor's hot point and it's
+// bottom edge, derived from first non-transparent row of cursor's mask.
+
+int GetCurrentCursorVisibleHeight();
+
+}  // namespace corewm
+}  // namespace views
+
+#endif  // UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
diff --git a/ui/views/corewm/tooltip_win.cc b/ui/views/corewm/tooltip_win.cc
new file mode 100644
index 0000000000000..2d3f0f52dc16a
--- /dev/null
+++ b/ui/views/corewm/tooltip_win.cc
@@ -0,0 +1,186 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/corewm/tooltip_win.h"
+
+#include "base/i18n/rtl.h"
+#include "base/logging.h"
+#include "base/strings/string_util_win.h"
+#include "base/win/windowsx_shim.h"
+#include "ui/aura/window.h"
+#include "ui/base/l10n/l10n_util_win.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/display/win/screen_win.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/system_fonts_win.h"
+#include "ui/views/corewm/cursor_height_provider_win.h"
+
+namespace views::corewm {
+
+TooltipWin::TooltipWin(HWND parent)
+    : parent_hwnd_(parent), tooltip_hwnd_(nullptr), showing_(false) {
+  memset(&toolinfo_, 0, sizeof(toolinfo_));
+  toolinfo_.cbSize = sizeof(toolinfo_);
+  toolinfo_.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_ABSOLUTE;
+  toolinfo_.uId = reinterpret_cast<UINT_PTR>(parent_hwnd_);
+  toolinfo_.hwnd = parent_hwnd_;
+  toolinfo_.lpszText = nullptr;
+  toolinfo_.lpReserved = nullptr;
+  SetRectEmpty(&toolinfo_.rect);
+}
+
+TooltipWin::~TooltipWin() {
+  if (tooltip_hwnd_)
+    DestroyWindow(tooltip_hwnd_);
+}
+
+bool TooltipWin::HandleNotify(int w_param, NMHDR* l_param, LRESULT* l_result) {
+  if (tooltip_hwnd_ == nullptr)
+    return false;
+
+  switch (l_param->code) {
+    case TTN_POP:
+      showing_ = false;
+      return true;
+    case TTN_SHOW:
+      *l_result = TRUE;
+      PositionTooltip();
+      showing_ = true;
+      return true;
+    default:
+      break;
+  }
+  return false;
+}
+
+bool TooltipWin::EnsureTooltipWindow() {
+  if (tooltip_hwnd_)
+    return true;
+
+  tooltip_hwnd_ =
+      CreateWindowEx(WS_EX_TRANSPARENT | l10n_util::GetExtendedTooltipStyles(),
+                     TOOLTIPS_CLASS, nullptr, TTS_NOPREFIX | WS_POPUP, 0, 0, 0,
+                     0, parent_hwnd_, nullptr, nullptr, nullptr);
+  if (!tooltip_hwnd_) {
+    PLOG(WARNING) << "tooltip creation failed, disabling tooltips";
+    return false;
+  }
+
+  MaybeOverrideFont();
+
+  SendMessage(tooltip_hwnd_, TTM_ADDTOOL, 0,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+  return true;
+}
+
+void TooltipWin::PositionTooltip() {
+  gfx::Point screen_point =
+      display::win::ScreenWin::DIPToScreenPoint(anchor_point_);
+  const int cursoroffset = GetCurrentCursorVisibleHeight();
+  screen_point.Offset(0, cursoroffset);
+
+  LRESULT tooltip_size = SendMessage(tooltip_hwnd_, TTM_GETBUBBLESIZE, 0,
+                                     reinterpret_cast<LPARAM>(&toolinfo_));
+  const gfx::Size size(LOWORD(tooltip_size), HIWORD(tooltip_size));
+
+  const display::Display display(
+      display::Screen::GetScreen()->GetDisplayNearestPoint(anchor_point_));
+
+  gfx::Rect tooltip_bounds(screen_point, size);
+  // Align the center of the tooltip with the position when the tooltip is not
+  // following the cursor.
+  if (trigger_ == TooltipTrigger::kKeyboard)
+    tooltip_bounds.Offset(-size.width() / 2, 0);
+  else if (base::i18n::IsRTL())
+    tooltip_bounds.Offset(-size.width(), 0);
+  tooltip_bounds.AdjustToFit(display::win::ScreenWin::DIPToScreenRect(
+      parent_hwnd_, display.work_area()));
+  SetWindowPos(tooltip_hwnd_, nullptr, tooltip_bounds.x(), tooltip_bounds.y(),
+               0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
+
+  MaybeOverrideFont();
+}
+
+void TooltipWin::MaybeOverrideFont() {
+ // gfx::win::FontAdjustment font_adjustment;
+ // const HFONT old_font = GetWindowFont(tooltip_hwnd_);
+
+  // Determine if we need to override the font.
+ // if ((!override_font_.get() || override_font_.get() != old_font) &&
+ //     l10n_util::NeedOverrideDefaultUIFont(
+//          &font_adjustment.font_family_override, &font_adjustment.font_scale)) {
+    // Determine if we need to regenerate the font.
+    // There are a number of situations under which Windows can replace the
+    // font in a tooltip, but we don't actually need to regenerate our override
+    // font unless the underlying text/DPI scale of the window has changed.
+//    const float current_scale =
+ //       display::win::ScreenWin::GetScaleFactorForHWND(tooltip_hwnd_);
+//    if (!override_font_.get() || current_scale != override_scale_) {
+  //    override_font_.reset(
+  //        gfx::win::AdjustExistingSystemFont(old_font, font_adjustment));
+//      override_scale_ = current_scale;
+ //   }
+
+    // Override the font in the tooltip.
+//    SetWindowFont(tooltip_hwnd_, override_font_.get(), FALSE);
+  }
+//}
+
+int TooltipWin::GetMaxWidth(const gfx::Point& location) const {
+  const gfx::Point screen_point =
+      display::win::ScreenWin::DIPToScreenPoint(location);
+  display::Display display(
+      display::Screen::GetScreen()->GetDisplayNearestPoint(screen_point));
+  const gfx::Rect monitor_bounds = display.bounds();
+  return (monitor_bounds.width() + 1) / 2;
+}
+
+void TooltipWin::Update(aura::Window* window,
+                        const std::u16string& tooltip_text,
+                        const gfx::Point& position,
+                        const TooltipTrigger trigger) {
+  if (!EnsureTooltipWindow())
+    return;
+
+  // See comment in header for details on why `anchor_point_` and `trigger_` are
+  // needed here.
+  anchor_point_ = position + window->GetBoundsInScreen().OffsetFromOrigin();
+  trigger_ = trigger;
+
+  std::u16string adjusted_text(tooltip_text);
+  base::i18n::AdjustStringForLocaleDirection(&adjusted_text);
+  toolinfo_.lpszText = base::as_writable_wcstr(adjusted_text);
+  SendMessage(tooltip_hwnd_, TTM_SETTOOLINFO, 0,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+
+  int max_width = GetMaxWidth(anchor_point_);
+  SendMessage(tooltip_hwnd_, TTM_SETMAXTIPWIDTH, 0, max_width);
+}
+
+void TooltipWin::Show() {
+  if (!EnsureTooltipWindow())
+    return;
+
+  SendMessage(tooltip_hwnd_, TTM_TRACKACTIVATE, TRUE,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+
+  // Bring the window to the front.
+  SetWindowPos(tooltip_hwnd_, HWND_TOPMOST, 0, 0, 0, 0,
+               SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);
+}
+
+void TooltipWin::Hide() {
+  if (!tooltip_hwnd_)
+    return;
+
+  SendMessage(tooltip_hwnd_, TTM_TRACKACTIVATE, FALSE,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+}
+
+bool TooltipWin::IsVisible() {
+  return showing_;
+}
+
+}  // namespace views::corewm
diff --git a/ui/views/corewm/tooltip_win.h b/ui/views/corewm/tooltip_win.h
new file mode 100644
index 0000000000000..8f131b8d1bf86
--- /dev/null
+++ b/ui/views/corewm/tooltip_win.h
@@ -0,0 +1,92 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_COREWM_TOOLTIP_WIN_H_
+#define UI_VIEWS_COREWM_TOOLTIP_WIN_H_
+
+#include <windows.h>  // Must come before other Windows system headers.
+
+#include <commctrl.h>
+
+#include <string>
+
+#include "base/win/scoped_gdi_object.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/views/corewm/tooltip.h"
+
+namespace wm {
+class TooltipObserver;
+}
+
+namespace views::corewm {
+
+// Implementation of Tooltip that uses the native win32 control for showing the
+// tooltip.
+class VIEWS_EXPORT TooltipWin : public Tooltip {
+ public:
+  explicit TooltipWin(HWND parent);
+
+  TooltipWin(const TooltipWin&) = delete;
+  TooltipWin& operator=(const TooltipWin&) = delete;
+
+  ~TooltipWin() override;
+
+  void AddObserver(wm::TooltipObserver* observer) override {}
+  void RemoveObserver(wm::TooltipObserver* observer) override {}
+
+  // HandleNotify() is forwarded from DesktopWindowTreeHostWin to keep the
+  // native tooltip in sync.
+  bool HandleNotify(int w_param, NMHDR* l_param, LRESULT* l_result);
+
+ private:
+  // Ensures |tooltip_hwnd_| is valid. Returns true if valid, false if there
+  // a problem creating |tooltip_hwnd_|.
+  bool EnsureTooltipWindow();
+
+  // Sets the position of the tooltip.
+  void PositionTooltip();
+
+  // Might override the font size for localization (e.g. Hindi).
+  void MaybeOverrideFont();
+
+  // Tooltip:
+  int GetMaxWidth(const gfx::Point& location) const override;
+  void Update(aura::Window* window,
+              const std::u16string& tooltip_text,
+              const gfx::Point& position,
+              const TooltipTrigger trigger) override;
+  void Show() override;
+  void Hide() override;
+  bool IsVisible() override;
+
+  // Font we're currently overriding our UI font with.
+  // Should outlast |tooltip_hwnd_|.
+  base::win::ScopedHFONT override_font_;
+
+  // The window |tooltip_hwnd_| is parented to.
+  HWND parent_hwnd_;
+
+  // Shows the tooltip.
+  HWND tooltip_hwnd_;
+
+  // Used to modify the tooltip.
+  TOOLINFO toolinfo_;
+
+  // Is the tooltip showing?
+  bool showing_;
+
+  // In order to position the tooltip we need to know the size. The size is only
+  // available from TTN_SHOW, so we have to cache `anchor_point_` and `trigger_`
+  // which are required to calculate its position.
+  gfx::Point anchor_point_;
+  TooltipTrigger trigger_ = TooltipTrigger::kCursor;
+
+  // What the scale was the last time we overrode the font, to see if we can
+  // re-use our previous override.
+  float override_scale_ = 0.0f;
+};
+
+}  // namespace views::corewm
+
+#endif  // UI_VIEWS_COREWM_TOOLTIP_WIN_H_
diff --git a/ui/views/layout/layout_provider.cc b/ui/views/layout/layout_provider.cc
index 5319192415a63..4245bf02d66f3 100644
--- a/ui/views/layout/layout_provider.cc
+++ b/ui/views/layout/layout_provider.cc
@@ -6,6 +6,8 @@
 
 #include <algorithm>
 
+#include "base/command_line.h"
+#include "base/environment.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/logging.h"
 #include "ui/base/ui_base_features.h"
@@ -23,6 +25,11 @@ LayoutProvider* g_layout_delegate = nullptr;
 }  // namespace
 
 LayoutProvider::LayoutProvider() {
+  // On creation of the LayoutProvider object, update the metrics with user preferences if applicable.
+  // std::string corner_metrics;
+  // auto env = base::Environment::Create();
+  // if (env->GetVar("davenport_corner_metrics", &corner_metrics))
+    // kMenuCornerRadius = std::stoi(corner_metrics);
   g_layout_delegate = this;
 }
 
@@ -221,9 +228,17 @@ int LayoutProvider::GetCornerRadiusMetric(ShapeContextTokens id,
       case ShapeContextTokens::kMenuTouchRadius:
         return GetCornerRadiusMetric(Emphasis::kHigh);
       case ShapeContextTokens::kOmniboxExpandedRadius:
-        return 16;
+        if (base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox")) {
+          return 3;
+        } else {
+          return 16;
+        }
       case ShapeContextTokens::kTextfieldRadius:
-        return FocusRing::kDefaultCornerRadiusDp;
+        if (base::CommandLine::ForCurrentProcess()->HasSwitch("classic-omnibox")) {
+          return 3;
+        } else {
+          return FocusRing::kDefaultCornerRadiusDp;
+        }
       case ShapeContextTokens::kSidePanelContentRadius:
         return GetCornerRadiusMetric(Emphasis::kMedium);
       default:
diff --git a/ui/views/layout/layout_provider.h b/ui/views/layout/layout_provider.h
index 87259be15b9b1..b7200add941dd 100644
--- a/ui/views/layout/layout_provider.h
+++ b/ui/views/layout/layout_provider.h
@@ -234,6 +234,7 @@ class VIEWS_EXPORT LayoutProvider {
 
  private:
   TypographyProvider typography_provider_;
+  int kMenuCornerRadius = 3;
 };
 
 }  // namespace views
diff --git a/ui/views/views_features.cc b/ui/views/views_features.cc
index e4314c4d46b43..ea5fd1688e907 100644
--- a/ui/views/views_features.cc
+++ b/ui/views/views_features.cc
@@ -42,4 +42,9 @@ BASE_FEATURE(kWidgetLayering,
              "WidgetLayering",
              base::FEATURE_ENABLED_BY_DEFAULT);
 
+// When enabled, widgets inherit the theme from their parent widget.
+BASE_FEATURE(kInheritNativeThemeFromParentWidget,
+			 "InheritNativeThemeFromParentWidget",
+			 base::FEATURE_ENABLED_BY_DEFAULT);
+
 }  // namespace views::features
diff --git a/ui/views/views_features.h b/ui/views/views_features.h
index 0e01068424722..622765401a806 100644
--- a/ui/views/views_features.h
+++ b/ui/views/views_features.h
@@ -17,6 +17,7 @@ VIEWS_EXPORT BASE_DECLARE_FEATURE(kEnablePlatformHighContrastInkDrop);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kEnableViewPaintOptimization);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kKeyboardAccessibleTooltipInViews);
 VIEWS_EXPORT BASE_DECLARE_FEATURE(kWidgetLayering);
+VIEWS_EXPORT BASE_DECLARE_FEATURE(kInheritNativeThemeFromParentWidget);
 
 }  // namespace views::features
 
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
index d877d237b2c16..754512f583beb 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
@@ -8,6 +8,7 @@
 #include <utility>
 #include <vector>
 
+#include "base/command_line.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
@@ -16,6 +17,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkRegion.h"
 #include "ui/aura/client/aura_constants.h"
@@ -43,6 +45,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/path_win.h"
 #include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/corewm/tooltip_win.h"
 #include "ui/views/views_features.h"
 #include "ui/views/views_switches.h"
 #include "ui/views/widget/desktop_aura/desktop_drag_drop_client_win.h"
@@ -130,7 +133,8 @@ DesktopWindowTreeHostWin::DesktopWindowTreeHostWin(
       drag_drop_client_(nullptr),
       should_animate_window_close_(false),
       pending_close_(false),
-      has_non_client_view_(false) {}
+      has_non_client_view_(false),
+      tooltip_(nullptr) {}
 
 DesktopWindowTreeHostWin::~DesktopWindowTreeHostWin() {
   desktop_native_widget_aura_->OnDesktopWindowTreeHostDestroyed(this);
@@ -230,7 +234,14 @@ void DesktopWindowTreeHostWin::OnActiveWindowChanged(bool active) {}
 void DesktopWindowTreeHostWin::OnWidgetInitDone() {}
 
 std::unique_ptr<corewm::Tooltip> DesktopWindowTreeHostWin::CreateTooltip() {
-  return std::make_unique<corewm::TooltipAura>();
+  bool force_legacy_tooltips =
+      (base::win::GetVersion() < base::win::Version::WIN8) || base::CommandLine::ForCurrentProcess()->HasSwitch("legacy-tooltips-win");
+  if (!force_legacy_tooltips)
+    return std::make_unique<corewm::TooltipAura>();
+
+  DCHECK(!tooltip_);
+  tooltip_ = new corewm::TooltipWin(GetAcceleratedWidget());
+  return base::WrapUnique(tooltip_.get());
 }
 
 std::unique_ptr<aura::client::DragDropClient>
@@ -1159,6 +1170,12 @@ void DesktopWindowTreeHostWin::HandlePaintAccelerated(
     compositor()->ScheduleRedrawRect(invalid_rect);
 }
 
+bool DesktopWindowTreeHostWin::HandleTooltipNotify(int w_param,
+                                                   NMHDR* l_param,
+                                                   LRESULT* l_result) {
+  return tooltip_ && tooltip_->HandleNotify(w_param, l_param, l_result);
+}
+
 void DesktopWindowTreeHostWin::HandleMenuLoop(bool in_menu_loop) {
   if (in_menu_loop) {
     tooltip_disabler_ = std::make_unique<wm::ScopedTooltipDisabler>(window());
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
index e963c861f7099..b72ed56d00917 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
@@ -38,6 +38,10 @@ class DesktopDragDropClientWin;
 class HWNDMessageHandler;
 class NonClientFrameView;
 
+namespace corewm {
+class TooltipWin;
+}
+
 namespace test {
 class DesktopWindowTreeHostWinTestApi;
 }
@@ -249,6 +253,9 @@ class VIEWS_EXPORT DesktopWindowTreeHostWin
   void HandleInputLanguageChange(DWORD character_set,
                                  HKL input_language_id) override;
   void HandlePaintAccelerated(const gfx::Rect& invalid_rect) override;
+  bool HandleTooltipNotify(int w_param,
+                           NMHDR* l_param,
+                           LRESULT* l_result) override;
   void HandleMenuLoop(bool in_menu_loop) override;
   bool PreHandleMSG(UINT message,
                     WPARAM w_param,
@@ -322,6 +329,10 @@ class VIEWS_EXPORT DesktopWindowTreeHostWin
   // True if the window should have the frame removed.
   bool remove_standard_frame_;
 
+  // Owned by TooltipController, but we need to forward events to it so we keep
+  // a reference.
+  raw_ptr<corewm::TooltipWin> tooltip_;
+
   // Visibility of the cursor. On Windows we can have multiple root windows and
   // the implementation of ::ShowCursor() is based on a counter, so making this
   // member static ensures that ::ShowCursor() is always called exactly once
diff --git a/ui/views/widget/widget.cc b/ui/views/widget/widget.cc
index 5093dee22b9da..15431b8de20e8 100644
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -11,6 +11,7 @@
 #include "base/auto_reset.h"
 #include "base/check_op.h"
 #include "base/containers/adapters.h"
+#include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/i18n/rtl.h"
 #include "base/notreached.h"
@@ -2090,7 +2091,9 @@ const ui::NativeTheme* Widget::GetNativeTheme() const {
   if (native_theme_)
     return native_theme_;
 
-  if (parent_)
+if (base::FeatureList::IsEnabled(
+          features::kInheritNativeThemeFromParentWidget) &&
+      parent_)
     return parent_->GetNativeTheme();
 
 #if BUILDFLAG(IS_LINUX)
diff --git a/ui/views/widget/widget_interactive_uitest.cc b/ui/views/widget/widget_interactive_uitest.cc
index 1ba89332791a7..79771ccb861e3 100644
--- a/ui/views/widget/widget_interactive_uitest.cc
+++ b/ui/views/widget/widget_interactive_uitest.cc
@@ -18,6 +18,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/time/time.h"
 #include "base/timer/timer.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "ui/base/ime/input_method.h"
@@ -445,6 +446,11 @@ class TouchEventHandler : public ui::EventHandler {
 
 // TODO(dtapuska): Disabled due to it being flaky crbug.com/817531
 TEST_F(DesktopWidgetTestInteractive, DISABLED_TouchNoActivateWindow) {
+  // ui_controls::SendTouchEvents which uses InjectTouchInput API only works
+  // on Windows 8 and up.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   View* focusable_view = new View;
   focusable_view->SetFocusBehavior(View::FocusBehavior::ALWAYS);
   WidgetAutoclosePtr widget(CreateTopLevelNativeWidget());
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 36a6e980495ea..a499d9e470c26 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -30,6 +30,8 @@
 #include "base/win/dark_mode_support.h"
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
+#include "chrome/browser/win/titlebar_config.h"
 #include "services/tracing/public/cpp/perfetto/macros.h"
 #include "third_party/perfetto/protos/perfetto/trace/track_event/chrome_window_handle_event_info.pbzero.h"
 #include "third_party/skia/include/core/SkPath.h"
@@ -345,7 +347,8 @@ class HWNDMessageHandler::ScopedRedrawLock {
         hwnd_(owner_->hwnd()),
         should_lock_(owner_->IsVisible() && !owner->HasChildRenderingWindow() &&
                      ::IsWindow(hwnd_) && !owner_->IsHeadless() &&
-                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION))) {
+                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION) ||
+					  ShouldCustomDrawSystemTitlebar())) {
     if (should_lock_)
       owner_->LockUpdates();
   }
@@ -598,7 +601,8 @@ void HWNDMessageHandler::SetParentOrOwner(HWND new_parent) {
 }
 
 void HWNDMessageHandler::SetDwmFrameExtension(DwmFrameState state) {
-  if (!delegate_->HasFrame() && !is_translucent_) {
+  if (!delegate_->HasFrame() && !ShouldCustomDrawSystemTitlebar() &&
+	  !is_translucent_) {
     MARGINS m = {0, 0, 0, 0};
     if (state == DwmFrameState::kOn && !IsMaximized())
       m = {0, 0, 1, 0};
@@ -1864,7 +1868,8 @@ void HWNDMessageHandler::OnEnterSizeMove() {
 
 LRESULT HWNDMessageHandler::OnEraseBkgnd(HDC dc) {
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
+  if (!ShouldCustomDrawSystemTitlebar() &&
+	  delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
       needs_dwm_frame_clear_) {
     // This is necessary to avoid white flashing in the titlebar area around the
     // minimize/maximize/close buttons.
@@ -2090,8 +2095,12 @@ LRESULT HWNDMessageHandler::OnMouseRange(UINT message,
 LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
                                               WPARAM w_param,
                                               LPARAM l_param) {
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     return PA_NOACTIVATE;
   }
@@ -2099,18 +2108,30 @@ LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
   return -1;
 }
 
+
 LRESULT HWNDMessageHandler::OnPointerEvent(UINT message,
                                            WPARAM w_param,
                                            LPARAM l_param) {
+  // WM_POINTER is not supported on Windows 7.
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    SetMsgHandled(FALSE);
+    return -1;
+  }
+
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   POINTER_INPUT_TYPE pointer_type;
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
   // If the WM_POINTER messages are not sent from a stylus device, then we do
   // not handle them to make sure we do not change the current behavior of
   // touch and mouse inputs.
-  if (!::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type)) {
+  if (!get_pointer_type || !get_pointer_type(pointer_id, &pointer_type)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   // |HandlePointerEventTypePenClient| assumes all pen events happen on the
   // client area, so WM_NCPOINTER messages sent to it would eventually be
   // dropped and the native frame wouldn't be able to respond to pens.
@@ -2430,6 +2451,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
   // It's required to avoid some native painting artifacts from appearing when
   // the window is resized.
   if (!delegate_->HasNonClientView() || IsFrameSystemDrawn()) {
+	  if (!ShouldCustomDrawSystemTitlebar()) {
     // The default WM_NCPAINT handler under Aero Glass doesn't clear the
     // nonclient area, so it'll remain the default white color. That area is
     // invisible initially (covered by the window border) but can become
@@ -2452,6 +2474,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
     ::FillRect(dc, &dirty_region, brush);
     ::DeleteObject(brush);
     ::ReleaseDC(hwnd(), dc);
+	}
     SetMsgHandled(FALSE);
     return;
   }
@@ -2492,6 +2515,12 @@ LRESULT HWNDMessageHandler::OnNCUAHDrawFrame(UINT message,
   return 0;
 }
 
+LRESULT HWNDMessageHandler::OnNotify(int w_param, NMHDR* l_param) {
+  LRESULT l_result = 0;
+  SetMsgHandled(delegate_->HandleTooltipNotify(w_param, l_param, &l_result));
+  return l_result;
+}
+
 void HWNDMessageHandler::OnPaint(HDC dc) {
   // Call BeginPaint()/EndPaint() around the paint handling, as that seems
   // to do more to actually validate the window's drawing region. This only
@@ -2800,6 +2829,18 @@ LRESULT HWNDMessageHandler::OnTouchEvent(UINT message,
       POINT point;
       point.x = TOUCH_COORD_TO_PIXEL(input[i].x);
       point.y = TOUCH_COORD_TO_PIXEL(input[i].y);
+
+	  if (base::win::GetVersion() == base::win::Version::WIN7) {
+		  // Windows 7 sends touch events for NC area touches but Win8+ do not.
+		  // This code will be used to make Windows 7 ignore these touches as well.
+
+		  LPARAM l_param_ht = MAKELPARAM(point.x, point.y);
+		  LRESULT hittest = SendMessage(hwnd(), WM_NCHITTEST, 0, l_param_ht);
+
+		  if (hittest != HTCLIENT)
+			  return 0;
+	  }
+
       ScreenToClient(hwnd(), &point);
 
       last_touch_or_pen_message_time_ = ::GetMessageTime();
@@ -3443,12 +3484,18 @@ LRESULT HWNDMessageHandler::HandlePointerEventTypePenClient(UINT message,
                                                             WPARAM w_param,
                                                             LPARAM l_param) {
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerPenInfoFn = BOOL(WINAPI*)(UINT32, POINTER_PEN_INFO*);
   POINTER_PEN_INFO pointer_pen_info;
-  if (!GetPointerPenInfo(pointer_id, &pointer_pen_info)) {
+  static const auto get_pointer_pen_info =
+      reinterpret_cast<GetPointerPenInfoFn>(
+          base::win::GetUser32FunctionPointer("GetPointerPenInfo"));
+  if (!get_pointer_pen_info ||
+      !get_pointer_pen_info(pointer_id, &pointer_pen_info)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   return HandlePointerEventTypePen(message, pointer_id, pointer_pen_info);
 }
 
@@ -3474,7 +3521,6 @@ bool HWNDMessageHandler::IsSynthesizedMouseMessage(unsigned int message,
 }
 
 void HWNDMessageHandler::PerformDwmTransition() {
-  CHECK(IsFrameSystemDrawn());
 
   dwm_transition_desired_ = false;
   delegate_->HandleFrameChanged();
@@ -3485,7 +3531,8 @@ void HWNDMessageHandler::UpdateDwmFrame() {
   TRACE_EVENT0("ui", "HWNDMessageHandler::UpdateDwmFrame");
 
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets)) {
+  if (!ShouldCustomDrawSystemTitlebar() &&
+      delegate_->GetDwmFrameInsetsInPixels(&insets)) {
     MARGINS margins = {insets.left(), insets.right(), insets.top(),
                        insets.bottom()};
     DwmExtendFrameIntoClientArea(hwnd(), &margins);
diff --git a/ui/views/win/hwnd_message_handler.h b/ui/views/win/hwnd_message_handler.h
index 060b8b90c0479..c1f3e18e20c95 100644
--- a/ui/views/win/hwnd_message_handler.h
+++ b/ui/views/win/hwnd_message_handler.h
@@ -474,6 +474,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
     CR_MSG_WM_NCCREATE(OnNCCreate)
     CR_MSG_WM_NCHITTEST(OnNCHitTest)
     CR_MSG_WM_NCPAINT(OnNCPaint)
+    CR_MSG_WM_NOTIFY(OnNotify)
     CR_MSG_WM_PAINT(OnPaint)
     CR_MSG_WM_SETFOCUS(OnSetFocus)
     CR_MSG_WM_SETICON(OnSetIcon)
@@ -530,6 +531,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
   void OnNCPaint(HRGN rgn);
   LRESULT OnNCUAHDrawCaption(UINT message, WPARAM w_param, LPARAM l_param);
   LRESULT OnNCUAHDrawFrame(UINT message, WPARAM w_param, LPARAM l_param);
+  LRESULT OnNotify(int w_param, NMHDR* l_param);
   void OnPaint(HDC dc);
   LRESULT OnReflectedMessage(UINT message, WPARAM w_param, LPARAM l_param);
   LRESULT OnScrollMessage(UINT message, WPARAM w_param, LPARAM l_param);
diff --git a/ui/views/win/hwnd_message_handler_delegate.h b/ui/views/win/hwnd_message_handler_delegate.h
index fde18715e33ee..94dd1e636eb27 100644
--- a/ui/views/win/hwnd_message_handler_delegate.h
+++ b/ui/views/win/hwnd_message_handler_delegate.h
@@ -216,6 +216,11 @@ class VIEWS_EXPORT HWNDMessageHandlerDelegate {
   // Called to compel the delegate to paint |invalid_rect| accelerated.
   virtual void HandlePaintAccelerated(const gfx::Rect& invalid_rect) = 0;
 
+  // Called to forward a WM_NOTIFY message to the tooltip manager.
+  virtual bool HandleTooltipNotify(int w_param,
+                                   NMHDR* l_param,
+                                   LRESULT* l_result) = 0;
+
   // Invoked on entering/exiting a menu loop.
   virtual void HandleMenuLoop(bool in_menu_loop) = 0;
 
diff --git a/ui/views/win/pen_id_handler.cc b/ui/views/win/pen_id_handler.cc
index 3327d96ad2970..34fd76937b5da 100644
--- a/ui/views/win/pen_id_handler.cc
+++ b/ui/views/win/pen_id_handler.cc
@@ -39,7 +39,15 @@ class PenIdStatics {
     if (skip_initialization_) {
       return;
     }
+
     SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+    if (!base::win::ResolveCoreWinRTDelayload()){
+	  pen_device_statics_ = nullptr;
+	  pointer_point_statics_ = nullptr;
+	  return;
+    }
+
     base::win::AssertComInitialized();
     base::win::RoGetActivationFactory(
         base::win::HStringReference(
@@ -274,4 +282,4 @@ void PenIdHandler::InitPenIdStatics() {
       base::BindOnce(base::IgnoreResult(&PenIdStatics::GetInstance)));
 }
 
-}  // namespace views
+}  // namespace views
\ No newline at end of file
