diff --git a/ash/style/ash_color_mixer.cc b/ash/style/ash_color_mixer.cc
index ff6539bce16a7..c13a7c50a036e 100644
--- a/ash/style/ash_color_mixer.cc
+++ b/ash/style/ash_color_mixer.cc
@@ -787,14 +787,13 @@ void AddAshColorMixer(ui::ColorProvider* provider,
   mixer[ui::kColorTooltipBackground] = {cros_tokens::kCrosSysOnSurface};
   mixer[ui::kColorTooltipForeground] = {cros_tokens::kCrosSysInverseOnSurface};
 
-  if (is_jelly_enabled && !key.custom_theme &&
-      key.user_color_source == ui::ColorProviderKey::UserColorSource::kAccent) {
+  if (is_jelly_enabled && !key.custom_theme && !key.is_grayscale) {
     // Only override frame color if there's no custom theme or we'll override
     // the value from the theme. Fallback to the default ui/color definition for
-    // baseline and grayscale headers.
+    // grayscale headers.
     mixer[ui::kColorFrameActive] = {cros_tokens::kCrosSysHeader};
     mixer[ui::kColorFrameInactive] = {cros_tokens::kCrosSysHeaderUnfocused};
   }
 }
 
-}  // namespace ash
+}  // namespace ash
\ No newline at end of file
diff --git a/base/BUILD.gn b/base/BUILD.gn
index 82cb596dcbb36..b67be9512fc4f 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -146,11 +146,6 @@ if (is_win) {
     ldflags = [
       # Linking with shcore.lib causes the shcore api forwarder dll to load.
       "/DELAYLOAD:api-ms-win-shcore-scaling-l1-1-1.dll",
-
-      # Linking with OneCore.lib causes the next three dlls to load.
-      "/DELAYLOAD:api-ms-win-core-realtime-l1-1-1.dll",
-      "/DELAYLOAD:api-ms-win-power-base-l1-1-0.dll",
-      "/DELAYLOAD:api-ms-win-power-setting-l1-1-0.dll",
       "/DELAYLOAD:cfgmgr32.dll",
       "/DELAYLOAD:powrprof.dll",
       "/DELAYLOAD:setupapi.dll",
@@ -1914,7 +1909,6 @@ component("base") {
     libs += [
       "cfgmgr32.lib",
       "ntdll.lib",
-      "onecore.lib",
       "powrprof.lib",
       "propsys.lib",
       "setupapi.lib",
diff --git a/base/allocator/partition_allocator/page_allocator_internals_win.h b/base/allocator/partition_allocator/page_allocator_internals_win.h
index 1ac45fbe20bd8..57f6d86a34330 100644
--- a/base/allocator/partition_allocator/page_allocator_internals_win.h
+++ b/base/allocator/partition_allocator/page_allocator_internals_win.h
@@ -5,6 +5,8 @@
 #ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 #define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 
+#include <versionhelpers.h>
+
 #include <cstdint>
 
 #include "base/allocator/partition_allocator/oom.h"
@@ -16,6 +18,17 @@
 
 namespace partition_alloc::internal {
 
+namespace {
+
+// On Windows, discarded pages are not returned to the system immediately and
+// not guaranteed to be zeroed when returned to the application.
+using DiscardVirtualMemoryFunction = DWORD(WINAPI*)(PVOID virtualAddress,
+                                                    SIZE_T size);
+DiscardVirtualMemoryFunction s_discard_virtual_memory =
+    reinterpret_cast<DiscardVirtualMemoryFunction>(-1);
+
+}  // namespace
+
 // |VirtualAlloc| will fail if allocation at the hint address is blocked.
 constexpr bool kHintIsAdvisory = false;
 std::atomic<int32_t> s_allocPageErrorCode{ERROR_SUCCESS};
@@ -224,12 +237,27 @@ bool TryRecommitSystemPagesInternal(
 }
 
 void DiscardSystemPagesInternal(uintptr_t address, size_t length) {
+  if (s_discard_virtual_memory ==
+      reinterpret_cast<DiscardVirtualMemoryFunction>(-1)) {
+    // DiscardVirtualMemory's minimum supported client is Windows 8.1 Update.
+    // So skip GetProcAddress("DiscardVirtualMemory") if windows version is
+    // smaller than Windows 8.1.
+    if (IsWindows8Point1OrGreater()) {
+      s_discard_virtual_memory =
+          reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+              GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+    } else {
+      s_discard_virtual_memory = nullptr;
+    }
+  }
+
   void* ptr = reinterpret_cast<void*>(address);
   // Use DiscardVirtualMemory when available because it releases faster than
   // MEM_RESET.
-  DWORD ret = DiscardVirtualMemory(ptr, length);
-  // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
-  // failure.
+  DWORD ret = 1;
+  if (s_discard_virtual_memory) {
+    ret = s_discard_virtual_memory(ptr, length);
+  }
   if (ret) {
     PA_CHECK(VirtualAllocWithRetry(ptr, length, MEM_RESET, PAGE_READWRITE));
   }
diff --git a/base/allocator/partition_allocator/partition_address_space.cc b/base/allocator/partition_allocator/partition_address_space.cc
index fe5ebd51f3af1..398e6a66b6797 100644
--- a/base/allocator/partition_allocator/partition_address_space.cc
+++ b/base/allocator/partition_allocator/partition_address_space.cc
@@ -43,6 +43,34 @@ namespace {
 
 #if BUILDFLAG(IS_WIN)
 
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+bool IsLegacyWindowsVersion() {
+  // Use ::RtlGetVersion instead of ::GetVersionEx or helpers from
+  // VersionHelpers.h because those alternatives change their behavior depending
+  // on whether or not the calling executable has a compatibility manifest
+  // resource. It's better for the allocator to not depend on that to decide the
+  // pool size.
+  // Assume legacy if ::RtlGetVersion is not available or it fails.
+  using RtlGetVersion = LONG(WINAPI*)(OSVERSIONINFOEX*);
+  const RtlGetVersion rtl_get_version = reinterpret_cast<RtlGetVersion>(
+      ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"), "RtlGetVersion"));
+  if (!rtl_get_version) {
+    return true;
+  }
+
+  OSVERSIONINFOEX version_info = {};
+  version_info.dwOSVersionInfoSize = sizeof(version_info);
+  if (rtl_get_version(&version_info) != ERROR_SUCCESS) {
+    return true;
+  }
+
+  // Anything prior to Windows 8.1 is considered legacy for the allocator.
+  // Windows 8.1 is major 6 with minor 3.
+  return version_info.dwMajorVersion < 6 ||
+         (version_info.dwMajorVersion == 6 && version_info.dwMinorVersion < 3);
+}
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+
 PA_NOINLINE void HandlePoolAllocFailureOutOfVASpace() {
   PA_NO_CODE_FOLDING();
   PA_CHECK(false);
@@ -66,9 +94,9 @@ PA_NOINLINE void HandlePoolAllocFailure() {
     // it must be VA space exhaustion.
     HandlePoolAllocFailureOutOfVASpace();
   } else if (alloc_page_error_code == ERROR_COMMITMENT_LIMIT) {
-    // Should not happen, since as of Windows 8.1+, reserving address space
-    // should not be charged against the commit limit, aside from a very small
-    // amount per 64kiB block. Keep this path anyway, to check in crash reports.
+    // On Windows <8.1, MEM_RESERVE increases commit charge to account for
+    // not-yet-committed PTEs needed to cover that VA space, if it was to be
+    // committed (see crbug.com/1101421#c16).
     HandlePoolAllocFailureOutOfCommitCharge();
   } else
 #endif  // BUILDFLAG(IS_WIN)
@@ -87,10 +115,7 @@ std::ptrdiff_t PartitionAddressSpace::brp_pool_shadow_offset_ = 0;
 #endif
 
 #if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
-#if !BUILDFLAG(IS_IOS)
-#error Dynamic pool size is only supported on iOS.
-#endif
-
+#if BUILDFLAG(IS_IOS)
 namespace {
 bool IsIOSTestProcess() {
   // On iOS, only applications with the extended virtual addressing entitlement
@@ -132,6 +157,15 @@ PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
 PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
   return IsIOSTestProcess() ? kBRPPoolSizeForIOSTestProcess : kBRPPoolSize;
 }
+#else
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
+  return IsLegacyWindowsVersion() ? kRegularPoolSizeForLegacyWindows
+                                  : kRegularPoolSize;
+}
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
+  return IsLegacyWindowsVersion() ? kBRPPoolSizeForLegacyWindows : kBRPPoolSize;
+}
+#endif  // BUILDFLAG(IS_IOS)
 #endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
 
 void PartitionAddressSpace::Init() {
diff --git a/base/allocator/partition_allocator/partition_address_space.h b/base/allocator/partition_allocator/partition_address_space.h
index 53c116fb69160..008091fc0732f 100644
--- a/base/allocator/partition_allocator/partition_address_space.h
+++ b/base/allocator/partition_allocator/partition_address_space.h
@@ -277,6 +277,16 @@ class PA_COMPONENT_EXPORT(PARTITION_ALLOC) PartitionAddressSpace {
   static constexpr size_t kThreadIsolatedPoolSize = kGiB / 4;
   static_assert(base::bits::IsPowerOfTwo(kThreadIsolatedPoolSize));
 #endif
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+  // We can't afford pool sizes as large as kPoolMaxSize on Windows <8.1 (see
+  // crbug.com/1101421 and crbug.com/1217759).
+  static constexpr size_t kRegularPoolSizeForLegacyWindows = 1 * kGiB;
+  static constexpr size_t kBRPPoolSizeForLegacyWindows = 1 * kGiB;
+  static_assert(kRegularPoolSizeForLegacyWindows < kRegularPoolSize);
+  static_assert(kBRPPoolSizeForLegacyWindows < kBRPPoolSize);
+  static_assert(base::bits::IsPowerOfTwo(kRegularPoolSizeForLegacyWindows));
+  static_assert(base::bits::IsPowerOfTwo(kBRPPoolSizeForLegacyWindows));
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
   static constexpr size_t kConfigurablePoolMaxSize = kPoolMaxSize;
   static constexpr size_t kConfigurablePoolMinSize = 1 * kGiB;
   static_assert(kConfigurablePoolMinSize <= kConfigurablePoolMaxSize);
diff --git a/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc b/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
index c6071fa8b092f..0ebac44dab4c7 100644
--- a/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
+++ b/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
@@ -8,36 +8,31 @@
 #include <stdint.h>
 #include <windows.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <limits>
 
 #include "base/allocator/partition_allocator/partition_alloc_base/check.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace partition_alloc::internal::base {
 
 void RandBytes(void* output, size_t output_length) {
-  // Import bcryptprimitives directly rather than cryptbase to avoid opening a
-  // handle to \\Device\KsecDD in the renderer.
-  // Note: we cannot use a magic static here as PA runs too early in process
-  // startup, but this should be safe as the process will be single-threaded
-  // when this first runs.
-  static decltype(&ProcessPrng) process_prng_fn = nullptr;
-  if (!process_prng_fn) {
-    HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-    PA_BASE_CHECK(hmod);
-    process_prng_fn = reinterpret_cast<decltype(&ProcessPrng)>(
-        GetProcAddress(hmod, "ProcessPrng"));
-    PA_BASE_CHECK(process_prng_fn);
+  char* output_ptr = static_cast<char*>(output);
+  while (output_length > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    PA_BASE_CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
   }
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  PA_BASE_CHECK(success);
 }
 
 }  // namespace partition_alloc::internal::base
diff --git a/base/allocator/partition_allocator/partition_alloc_config.h b/base/allocator/partition_allocator/partition_alloc_config.h
index bb6195f590759..224a3507195c7 100644
--- a/base/allocator/partition_allocator/partition_alloc_config.h
+++ b/base/allocator/partition_allocator/partition_alloc_config.h
@@ -32,7 +32,7 @@
 static_assert(sizeof(void*) == 8, "");
 #else
 static_assert(sizeof(void*) != 8, "");
-#endif  // PA_CONFIG(HAS_64_BITS_POINTERS)
+#endif  // BUILDFLAG(HAS_64_BITS_POINTERS)
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (defined(__ARM_NEON) || defined(__ARM_NEON__)) && defined(__ARM_FP)
@@ -41,18 +41,23 @@ static_assert(sizeof(void*) != 8, "");
 #define PA_CONFIG_STARSCAN_NEON_SUPPORTED() 0
 #endif
 
-#if BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#if BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) || BUILDFLAG(IS_WIN))
 // Allow PA to select an alternate pool size at run-time before initialization,
 // rather than using a single constexpr value.
 //
 // This is needed on iOS because iOS test processes can't handle large pools
 // (see crbug.com/1250788).
 //
+// This is needed on Windows, because OS versions <8.1 incur commit charge even
+// on reserved address space, thus don't handle large pools well (see
+// crbug.com/1101421 and crbug.com/1217759).
+//
 // This setting is specific to 64-bit, as 32-bit has a different implementation.
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 1
 #else
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 0
-#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) ||
+        // BUILDFLAG(IS_WIN))
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_ANDROID))
diff --git a/base/command_line.cc b/base/command_line.cc
index d762b168a9ccf..324f8e574be6f 100644
--- a/base/command_line.cc
+++ b/base/command_line.cc
@@ -29,6 +29,7 @@
 #include <shellapi.h>
 
 #include "base/strings/string_util_win.h"
+#include "base/win/windows_version.h"
 #endif  // BUILDFLAG(IS_WIN)
 
 namespace base {
diff --git a/base/features.cc b/base/features.cc
index bffd3ca9e9211..2b3f55651181e 100644
--- a/base/features.cc
+++ b/base/features.cc
@@ -32,6 +32,10 @@ BASE_FEATURE(kSupportsUserDataFlatHashMap,
              "SupportsUserDataFlatHashMap",
              FEATURE_DISABLED_BY_DEFAULT);
 
+BASE_FEATURE(kForceDarkModeFlag,
+             "ForceDarkModeFlag",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
 #if BUILDFLAG(IS_ANDROID)
 // Force to enable LowEndDeviceMode partially on Android mid-range devices.
 // Such devices aren't considered low-end, but we'd like experiment with
diff --git a/base/features.h b/base/features.h
index 90a69b41cb86e..1e30223b26023 100644
--- a/base/features.h
+++ b/base/features.h
@@ -23,6 +23,8 @@ BASE_EXPORT BASE_DECLARE_FEATURE(kOptimizeDataUrls);
 
 BASE_EXPORT BASE_DECLARE_FEATURE(kSupportsUserDataFlatHashMap);
 
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceDarkModeFlag);
+
 #if BUILDFLAG(IS_ANDROID)
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOnMidRangeDevices);
 extern const BASE_EXPORT FeatureParam<bool>
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index d7b5fb20aeb34..71375eb5c5fcd 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -1104,11 +1104,38 @@ bool SetNonBlocking(int fd) {
   return false;
 }
 
+namespace {
+
+// ::PrefetchVirtualMemory() is only available on Windows 8 and above. Chrome
+// supports Windows 7, so we need to check for the function's presence
+// dynamically.
+using PrefetchVirtualMemoryPtr = decltype(&::PrefetchVirtualMemory);
+
+// Returns null if ::PrefetchVirtualMemory() is not available.
+PrefetchVirtualMemoryPtr GetPrefetchVirtualMemoryPtr() {
+  HMODULE kernel32_dll = ::GetModuleHandleA("kernel32.dll");
+  return reinterpret_cast<PrefetchVirtualMemoryPtr>(
+      GetProcAddress(kernel32_dll, "PrefetchVirtualMemory"));
+}
+
+}  // namespace
+
 bool PreReadFile(const FilePath& file_path,
                  bool is_executable,
                  int64_t max_bytes) {
   DCHECK_GE(max_bytes, 0);
 
+  // On Win8 and higher use ::PrefetchVirtualMemory(). This is better than a
+  // simple data file read, more from a RAM perspective than CPU. This is
+  // because reading the file as data results in double mapping to
+  // Image/executable pages for all pages of code executed.
+  static PrefetchVirtualMemoryPtr prefetch_virtual_memory =
+      GetPrefetchVirtualMemoryPtr();
+
+  if (prefetch_virtual_memory == nullptr) {
+    return internal::PreReadFileSlow(file_path, max_bytes);
+  }
+
   if (max_bytes == 0) {
     // ::PrefetchVirtualMemory() fails when asked to read zero bytes.
     // base::MemoryMappedFile::Initialize() fails on an empty file.
@@ -1131,7 +1158,7 @@ bool PreReadFile(const FilePath& file_path,
   // simple data file read, more from a RAM perspective than CPU. This is
   // because reading the file as data results in double mapping to
   // Image/executable pages for all pages of code executed.
-  if (!::PrefetchVirtualMemory(::GetCurrentProcess(),
+  if (!prefetch_virtual_memory(::GetCurrentProcess(),
                                /*NumberOfEntries=*/1, &address_range,
                                /*Flags=*/0)) {
     return internal::PreReadFileSlow(file_path, max_bytes);
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index 23c95bad719c7..62a0b3c1f1d17 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -422,11 +422,23 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 #elif BUILDFLAG(IS_WIN)
   // On Windows, discarded pages are not returned to the system immediately and
   // not guaranteed to be zeroed when returned to the application.
+  using DiscardVirtualMemoryFunction =
+      DWORD(WINAPI*)(PVOID virtualAddress, SIZE_T size);
+  static DiscardVirtualMemoryFunction discard_virtual_memory =
+      reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+          GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+
   char* address = static_cast<char*>(shared_memory_mapping_.memory()) +
                   AlignToPageSize(sizeof(SharedState));
   size_t length = AlignToPageSize(mapped_size_);
 
-  DWORD ret = DiscardVirtualMemory(address, length);
+  // Use DiscardVirtualMemory when available because it releases faster than
+  // MEM_RESET.
+  DWORD ret = ERROR_NOT_SUPPORTED;
+  if (discard_virtual_memory) {
+    ret = discard_virtual_memory(address, length);
+  }
+
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret != ERROR_SUCCESS) {
diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index e387015249731..74269ce1c8eb8 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,7 +14,11 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 
 namespace base::subtle {
 
@@ -73,6 +77,8 @@ HANDLE CreateFileMappingWithReducedPermissions(SECURITY_ATTRIBUTES* sa,
   HANDLE h = CreateFileMapping(INVALID_HANDLE_VALUE, sa, PAGE_READWRITE, 0,
                                static_cast<DWORD>(rounded_size), name);
   if (!h) {
+    LOG(ERROR) << "CreateFileMappingW failed with error " << GetLastError()
+               << ".";
     return nullptr;
   }
 
@@ -211,6 +217,17 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(&rand_values, sizeof(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
diff --git a/base/power_monitor/power_monitor_device_source_win.cc b/base/power_monitor/power_monitor_device_source_win.cc
index 4e7b6563bc229..c40c42abeea04 100644
--- a/base/power_monitor/power_monitor_device_source_win.cc
+++ b/base/power_monitor/power_monitor_device_source_win.cc
@@ -32,9 +32,10 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
       power_event = PowerMonitorSource::POWER_STATE_EVENT;
       break;
     case PBT_APMRESUMEAUTOMATIC:  // Resume from suspend.
-      // We don't notify for PBT_APMRESUMESUSPEND
-      // because, if it occurs, it is always sent as a
-      // second event after PBT_APMRESUMEAUTOMATIC.
+      // case PBT_APMRESUMESUSPEND:  // User-initiated resume from suspend.
+      //  We don't notify for this latter event
+      //  because if it occurs it is always sent as a
+      //  second event after PBT_APMRESUMEAUTOMATIC.
       power_event = PowerMonitorSource::RESUME_EVENT;
       break;
     case PBT_APMSUSPEND:  // System has been suspended.
@@ -55,6 +56,30 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
   ProcessPowerEventHelper(power_event);
 }
 
+HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags) {
+  const auto register_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::RegisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "RegisterSuspendResumeNotification"));
+  if (!register_suspend_resume_notification_ptr) {
+    return nullptr;
+  }
+
+  return register_suspend_resume_notification_ptr(hRecipient, Flags);
+}
+
+BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle) {
+  const auto unregister_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::UnregisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "UnregisterSuspendResumeNotification"));
+  if (!unregister_suspend_resume_notification_ptr) {
+    return FALSE;
+  }
+
+  return unregister_suspend_resume_notification_ptr(Handle);
+}
+
 }  // namespace
 
 void PowerMonitorDeviceSource::PlatformInit() {
@@ -79,7 +104,7 @@ void PowerMonitorDeviceSource::PlatformDestroy() {
 // battery power.  Returns true if running on battery.
 bool PowerMonitorDeviceSource::IsOnBatteryPower() {
   SYSTEM_POWER_STATUS status;
-  if (!::GetSystemPowerStatus(&status)) {
+  if (!GetSystemPowerStatus(&status)) {
     DPLOG(ERROR) << "GetSystemPowerStatus failed";
     return false;
   }
@@ -92,7 +117,8 @@ int PowerMonitorDeviceSource::GetInitialSpeedLimit() {
   return PowerThermalObserver::kSpeedLimitMax;
 }
 
-PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
+PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow()
+    : instance_(NULL), message_hwnd_(NULL) {
   if (!CurrentUIThread::IsSet()) {
     // Creating this window in (e.g.) a renderer inhibits shutdown on Windows.
     // See http://crbug.com/230122. TODO(vandebo): http://crbug.com/236031
@@ -105,18 +131,20 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
       kWindowClassName,
       &base::win::WrappedWindowProc<
           PowerMonitorDeviceSource::PowerMessageWindow::WndProcThunk>,
-      0, 0, 0, nullptr, nullptr, nullptr, nullptr, nullptr, &window_class);
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL, &window_class);
   instance_ = window_class.hInstance;
-  ATOM clazz = ::RegisterClassEx(&window_class);
+  ATOM clazz = RegisterClassEx(&window_class);
   DCHECK(clazz);
 
   message_hwnd_ =
-      ::CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, nullptr, WS_POPUP, 0,
-                       0, 0, 0, nullptr, nullptr, instance_, nullptr);
+      CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, NULL, WS_POPUP, 0, 0,
+                     0, 0, NULL, NULL, instance_, NULL);
   if (message_hwnd_) {
-    // On machines with modern standby calling RegisterSuspendResumeNotification
-    // is required in order to get the PBT_APMSUSPEND message.
-    power_notify_handle_ = ::RegisterSuspendResumeNotification(
+    // On machines with modern standby and Win8+, calling
+    // RegisterSuspendResumeNotification is required in order to get the
+    // PBT_APMSUSPEND message. The notification is no longer automatically
+    // fired.
+    power_notify_handle_ = base::RegisterSuspendResumeNotification(
         message_hwnd_, DEVICE_NOTIFY_WINDOW_HANDLE);
   }
 }
@@ -124,10 +152,10 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
 PowerMonitorDeviceSource::PowerMessageWindow::~PowerMessageWindow() {
   if (message_hwnd_) {
     if (power_notify_handle_)
-      ::UnregisterSuspendResumeNotification(power_notify_handle_);
+      base::UnregisterSuspendResumeNotification(power_notify_handle_);
 
-    ::DestroyWindow(message_hwnd_);
-    ::UnregisterClass(kWindowClassName, instance_);
+    DestroyWindow(message_hwnd_);
+    UnregisterClass(kWindowClassName, instance_);
   }
 }
 
diff --git a/base/process/process_win.cc b/base/process/process_win.cc
index 9a414d886f779..0487313f658cc 100644
--- a/base/process/process_win.cc
+++ b/base/process/process_win.cc
@@ -265,35 +265,14 @@ bool Process::SetPriority(Priority priority) {
   // priority inversion, and having a process put itself in background mode is
   // broken in Windows 11 22H2. So, it is no longer supported. See
   // https://crbug.com/1396155 for details.
+  // NOTE: NtSetInformationProcess call (SetProcessInformation really) using
+  // ProcessPowerThrottling class removed because it is useless before
+  // Windows 10.
   DCHECK(!is_current());
   const DWORD priority_class = priority == Priority::kBestEffort
                                    ? IDLE_PRIORITY_CLASS
                                    : NORMAL_PRIORITY_CLASS;
 
-  if (base::win::OSInfo::GetInstance()->version() >=
-          base::win::Version::WIN11 &&
-      FeatureList::IsEnabled(kUseEcoQoSForBackgroundProcess)) {
-    PROCESS_POWER_THROTTLING_STATE power_throttling;
-    RtlZeroMemory(&power_throttling, sizeof(power_throttling));
-    power_throttling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;
-
-    if (priority == Priority::kBestEffort) {
-      // Sets Eco QoS level.
-      power_throttling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-      power_throttling.StateMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-    } else {
-      // Uses system default.
-      power_throttling.ControlMask = 0;
-      power_throttling.StateMask = 0;
-    }
-    bool ret =
-        ::SetProcessInformation(Handle(), ProcessPowerThrottling,
-                                &power_throttling, sizeof(power_throttling));
-    if (ret == 0) {
-      DPLOG(ERROR) << "Setting process QoS policy fails";
-    }
-  }
-
   return (::SetPriorityClass(Handle(), priority_class) != 0);
 }
 
diff --git a/base/rand_util_win.cc b/base/rand_util_win.cc
index 549f4362af8b6..2d9a1633b564f 100644
--- a/base/rand_util_win.cc
+++ b/base/rand_util_win.cc
@@ -9,6 +9,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <atomic>
 #include <limits>
@@ -18,12 +25,6 @@
 #include "third_party/boringssl/src/include/openssl/crypto.h"
 #include "third_party/boringssl/src/include/openssl/rand.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace base {
 
 namespace internal {
@@ -53,18 +54,6 @@ bool UseBoringSSLForRandBytes() {
 
 namespace {
 
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
 void RandBytes(void* output, size_t output_length, bool avoid_allocation) {
   if (!avoid_allocation && internal::UseBoringSSLForRandBytes()) {
     // Ensure BoringSSL is initialized so it can use things like RDRAND.
@@ -74,10 +63,16 @@ void RandBytes(void* output, size_t output_length, bool avoid_allocation) {
     return;
   }
 
-  static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  CHECK(success);
+  char* output_ptr = static_cast<char*>(output);
+  while (output_length > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+  }
 }
 
 }  // namespace
diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 7e9dd368eb0ec..b19b3c8cbdc2f 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -16,7 +16,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base {
@@ -329,8 +331,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
   }
 
   DCHECK(!scoped_environment || scoped_environment->Succeeded());
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index 83a1402780b0d..a7cdeb078197f 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -50,6 +50,13 @@ namespace {
 // Flag used to set thread priority to |THREAD_PRIORITY_LOWEST| for
 // |kUseThreadPriorityLowest| Feature.
 std::atomic<bool> g_use_thread_priority_lowest{false};
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
 // Flag used to map Compositing ThreadType |THREAD_PRIORITY_ABOVE_NORMAL| on the
 // UI thread for |kAboveNormalCompositingBrowserWin| Feature.
 std::atomic<bool> g_above_normal_compositing_browser{true};
@@ -236,7 +243,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -536,8 +546,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
     return ThreadPriorityForTest::kBackground;
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinDisplayPriority1:
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
index c6540592a5c18..f453dc2ed20cf 100644
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -646,11 +646,11 @@ TimeTicks::Clock TimeTicks::GetClock() {
 
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
-  ULONGLONG unbiased_interrupt_time;
-  QueryUnbiasedInterruptTimePrecise(&unbiased_interrupt_time);
+  LARGE_INTEGER unbiased_interrupt_time;
+  QueryPerformanceCounter(&unbiased_interrupt_time);
   // QueryUnbiasedInterruptTimePrecise gets the interrupt time in system time
   // units of 100 nanoseconds.
-  return LiveTicks() + Nanoseconds(unbiased_interrupt_time * 100);
+  return LiveTicks() + Nanoseconds(unbiased_interrupt_time.QuadPart * 100);
 }
 }  // namespace subtle
 
diff --git a/base/trace_event/trace_logging_minimal_win.cc b/base/trace_event/trace_logging_minimal_win.cc
index 5fb2a8c3bbc7b..4527a414a7d43 100644
--- a/base/trace_event/trace_logging_minimal_win.cc
+++ b/base/trace_event/trace_logging_minimal_win.cc
@@ -10,6 +10,61 @@
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
 
+/*
+EventSetInformation configuration macros:
+
+TraceLogging works best if the EventSetInformation API can be used to notify
+ETW that the provider uses TraceLogging event encoding.
+
+The EventSetInformation API is available on Windows 8 and later. (It is also
+available on fully-patched Windows 7, but not on Windows 7 RTM).
+
+The TLM_HAVE_EVENT_SET_INFORMATION and TLM_EVENT_SET_INFORMATION macros can
+be set before compiling this file to  control how the TlmProvider class deals
+with the EventSetInformation API.
+
+If these macros are not set, the default behavior is to check the WINVER
+macro at compile time:
+
+- If WINVER is set to Windows 7 or before, TlmProvider will use GetProcAddress
+  to locate EventSetInformation, and then invoke it if present. This is less
+  efficient, but works on older versions of Windows.
+- If WINVER is set to Windows 8 or later, TlmProvider will directly invoke
+  EventSetInformation. This is more efficient, but the resulting application
+  will only work correctly on newer versions of Windows.
+
+If you need to run on Windows 7 RTM, but for some reason need to set WINVER to
+Windows 8 or higher, you can override the default behavior by defining
+TLM_HAVE_EVENT_SET_INFORMATION=2 when compiling this file.
+
+Details:
+- The TLM_EVENT_SET_INFORMATION macro can be set the name of a replacement
+  function that TlmProvider should use instead of EventSetInformation.
+- The TLM_HAVE_EVENT_SET_INFORMATION macro can be set to 0 (disable the use of
+  EventSetInformation), 1 (directly invoke EventSetInformation), or 2 (try to
+  locate EventSetInformation via GetProcAddress, and invoke if found).
+*/
+
+// This code needs to run on Windows 7 and this is magic which
+// removes static linking to EventSetInformation
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+
+#ifndef TLM_EVENT_SET_INFORMATION
+#define TLM_EVENT_SET_INFORMATION EventSetInformation
+#ifndef TLM_HAVE_EVENT_SET_INFORMATION
+#if WINVER < 0x0602 || !defined(EVENT_FILTER_TYPE_SCHEMATIZED)
+// Find "EventSetInformation" via GetModuleHandleExW+GetProcAddress
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+#else
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+#endif
+#elif !defined(TLM_HAVE_EVENT_SET_INFORMATION)
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+
 TlmProvider::~TlmProvider() {
   Unregister();
 }
@@ -20,7 +75,7 @@ TlmProvider::TlmProvider(const char* provider_name,
                          void* enable_callback_context) noexcept {
   ULONG status = Register(provider_name, provider_guid, enable_callback,
                           enable_callback_context);
-  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider resistration failure";
+  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider registration failure";
 }
 
 // Appends a nul-terminated string to a metadata block.
@@ -79,9 +134,42 @@ ULONG TlmProvider::Register(const char* provider_name,
   if (status != ERROR_SUCCESS)
     return status;
 
+#if TLM_HAVE_EVENT_SET_INFORMATION == 1
+
   // Best-effort, ignore failure.
-  return ::EventSetInformation(reg_handle_, EventProviderSetTraits,
-                               provider_metadata_, provider_metadata_size_);
+  status =
+      TLM_EVENT_SET_INFORMATION(reg_handle_, EventProviderSetTraits,
+                                provider_metadata_, provider_metadata_size_);
+
+#elif TLM_HAVE_EVENT_SET_INFORMATION == 2
+
+  HMODULE eventing_lib;
+  if (GetModuleHandleExW(0, L"api-ms-win-eventing-provider-l1-1-0.dll",
+                         &eventing_lib) ||
+      GetModuleHandleExW(0, L"advapi32.dll", &eventing_lib)) {
+    typedef ULONG(WINAPI * PFEventSetInformation)(
+        REGHANDLE reg_handle, EVENT_INFO_CLASS information_class,
+        PVOID event_information, ULONG information_length);
+    PFEventSetInformation event_set_information_ptr =
+        reinterpret_cast<decltype(&::EventSetInformation)>(
+            GetProcAddress(eventing_lib, "EventSetInformation"));
+    if (event_set_information_ptr) {
+      // Best-effort, ignore failure.
+      status = event_set_information_ptr(reg_handle_, EventProviderSetTraits,
+                                         provider_metadata_,
+                                         provider_metadata_size_);
+    }
+
+    FreeLibrary(eventing_lib);
+  }
+
+#else  // TLM_HAVE_EVENT_SET_INFORMATION == 0
+
+    // Make no attempt to invoke EventSetInformation.
+
+#endif  // TLM_HAVE_EVENT_SET_INFORMATION
+
+  return status;
 }
 
 bool TlmProvider::IsEnabled() const noexcept {
diff --git a/base/win/core_winrt_util.cc b/base/win/core_winrt_util.cc
index 25f5885bf2f40..6ef060ce54da5 100644
--- a/base/win/core_winrt_util.cc
+++ b/base/win/core_winrt_util.cc
@@ -3,17 +3,56 @@
 // found in the LICENSE file.
 
 #include "base/win/core_winrt_util.h"
+#include "base/threading/scoped_thread_priority.h"
 
 namespace base::win {
 
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoActivateInstance) GetRoActivateInstanceFunction() {
+  static decltype(&::RoActivateInstance) const function =
+      reinterpret_cast<decltype(&::RoActivateInstance)>(
+          LoadComBaseFunction("RoActivateInstance"));
+  return function;
+}
+
+decltype(&::RoGetActivationFactory) GetRoGetActivationFactoryFunction() {
+  static decltype(&::RoGetActivationFactory) const function =
+      reinterpret_cast<decltype(&::RoGetActivationFactory)>(
+          LoadComBaseFunction("RoGetActivationFactory"));
+  return function;
+}
+
+bool ResolveCoreWinRTDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+  return GetRoActivateInstanceFunction() && GetRoGetActivationFactoryFunction();
+}
+
 HRESULT RoGetActivationFactory(HSTRING class_id,
                                const IID& iid,
                                void** out_factory) {
-  return ::RoGetActivationFactory(class_id, iid, out_factory);
+  auto get_factory_func = GetRoGetActivationFactoryFunction();
+  if (!get_factory_func) {
+    return E_FAIL;
+  }
+  return get_factory_func(class_id, iid, out_factory);
 }
 
 HRESULT RoActivateInstance(HSTRING class_id, IInspectable** instance) {
-  return ::RoActivateInstance(class_id, instance);
+  auto activate_instance_func = GetRoActivateInstanceFunction();
+  if (!activate_instance_func) {
+    return E_FAIL;
+  }
+  return activate_instance_func(class_id, instance);
 }
 
 }  // namespace base::win
diff --git a/base/win/core_winrt_util.h b/base/win/core_winrt_util.h
index 3a6e0c9f3774c..c4a802c85d6ed 100644
--- a/base/win/core_winrt_util.h
+++ b/base/win/core_winrt_util.h
@@ -15,6 +15,8 @@
 
 namespace base::win {
 
+BASE_EXPORT bool ResolveCoreWinRTDelayload();
+
 // The following stubs are provided for when component build is enabled, in
 // order to avoid the propagation of delay-loading CoreWinRT to other modules.
 
diff --git a/base/win/hstring_reference.cc b/base/win/hstring_reference.cc
index b254fc64310a1..edb7bf7f11b9a 100644
--- a/base/win/hstring_reference.cc
+++ b/base/win/hstring_reference.cc
@@ -12,18 +12,53 @@
 #include "base/check_op.h"
 #include "base/numerics/safe_conversions.h"
 
-namespace base::win {
+namespace base {
+namespace {
+
+bool g_winrt_string_loaded = false;
+
+decltype(&::WindowsCreateStringReference) GetWindowsCreateStringReference() {
+  static auto const create_string_reference_func =
+      []() -> decltype(&::WindowsCreateStringReference) {
+    const HMODULE handle =
+        ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    if (handle) {
+      return reinterpret_cast<decltype(&::WindowsCreateStringReference)>(
+          ::GetProcAddress(handle, "WindowsCreateStringReference"));
+    }
+    return nullptr;
+  }();
+  return create_string_reference_func;
+}
+
+}  // namespace
+
+namespace win {
+
+// static
+bool HStringReference::ResolveCoreWinRTStringDelayload() {
+  g_winrt_string_loaded = GetWindowsCreateStringReference() != nullptr;
+  return g_winrt_string_loaded;
+}
 
 HStringReference::HStringReference(const wchar_t* str, size_t length) {
+  // This was added because otherwise, the checks below would consistently fail.
+  ResolveCoreWinRTStringDelayload();
+  DCHECK(g_winrt_string_loaded);
   // String must be null terminated for WindowsCreateStringReference.
   // nullptr str is OK so long as the length is 0.
   DCHECK(str ? str[length] == L'\0' : length == 0);
-  const HRESULT hr = ::WindowsCreateStringReference(
+  // If you nullptr crash here, you've failed to call
+  // ResolveCoreWinRTStringDelayLoad and check its return value.
+  const HRESULT hr = GetWindowsCreateStringReference()(
       str, checked_cast<UINT32>(length), &hstring_header_, &hstring_);
+  // All failure modes of WindowsCreateStringReference are handled gracefully
+  // but this class.
   DCHECK_EQ(hr, S_OK);
 }
 
 HStringReference::HStringReference(const wchar_t* str)
     : HStringReference(str, str ? wcslen(str) : 0) {}
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_reference.h b/base/win/hstring_reference.h
index 3cde4acef6f2e..2366a681e72c0 100644
--- a/base/win/hstring_reference.h
+++ b/base/win/hstring_reference.h
@@ -9,7 +9,8 @@
 
 #include "base/base_export.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 // HStringReference is an HSTRING representation of a null terminated
 // string backed by memory that outlives the HStringReference instance.
@@ -17,12 +18,31 @@ namespace base::win {
 // If you need an HSTRING class that manages its own memory, you should
 // use ScopedHString instead.
 //
+// Note that HStringReference requires certain functions that are only
+// available on Windows 8 and later, and that these functions need to be
+// delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using HStringReference.
+//
+// One-time Initialization for HStringReference:
+//
+//   const bool success = HStringReference::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // HStringReference can be used.
+//   } else {
+//     // Handle error.
+//   }
+//
 // Example use:
 //
 //   HStringReference string(L"abc");
 //
 class BASE_EXPORT HStringReference {
  public:
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  static bool ResolveCoreWinRTStringDelayload();
+
   HStringReference(const wchar_t* str, size_t len);
   explicit HStringReference(const wchar_t* str);
 
@@ -47,6 +67,7 @@ class BASE_EXPORT HStringReference {
   HSTRING_HEADER hstring_header_;
 };
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
 
 #endif  // BASE_WIN_HSTRING_REFERENCE_H_
diff --git a/base/win/registry.cc b/base/win/registry.cc
index c33cda7211238..42bd3d45c1213 100644
--- a/base/win/registry.cc
+++ b/base/win/registry.cc
@@ -23,6 +23,7 @@
 #include "base/win/object_watcher.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 
 extern "C" NTSTATUS WINAPI NtDeleteKey(IN HANDLE KeyHandle);
 
@@ -87,8 +88,10 @@ bool RegKey::Watcher::StartWatching(HKEY key, ChangeCallback callback) {
   }
 
   DWORD filter = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
-                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY |
-                 REG_NOTIFY_THREAD_AGNOSTIC;
+                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY;
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    filter |= REG_NOTIFY_THREAD_AGNOSTIC;
+  }
   // Watch the registry key for a change of value.
   LONG result =
       RegNotifyChangeKeyValue(key, /*bWatchSubtree=*/TRUE, filter,
diff --git a/base/win/scoped_hstring.cc b/base/win/scoped_hstring.cc
index 042768f2b249e..c09195f605b59 100644
--- a/base/win/scoped_hstring.cc
+++ b/base/win/scoped_hstring.cc
@@ -18,24 +18,90 @@
 
 namespace base {
 
+namespace {
+
+static bool g_load_succeeded = false;
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle =
+      ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::WindowsCreateString) GetWindowsCreateString() {
+  static decltype(&::WindowsCreateString) const function =
+      reinterpret_cast<decltype(&::WindowsCreateString)>(
+          LoadComBaseFunction("WindowsCreateString"));
+  return function;
+}
+
+decltype(&::WindowsDeleteString) GetWindowsDeleteString() {
+  static decltype(&::WindowsDeleteString) const function =
+      reinterpret_cast<decltype(&::WindowsDeleteString)>(
+          LoadComBaseFunction("WindowsDeleteString"));
+  return function;
+}
+
+decltype(&::WindowsGetStringRawBuffer) GetWindowsGetStringRawBuffer() {
+  static decltype(&::WindowsGetStringRawBuffer) const function =
+      reinterpret_cast<decltype(&::WindowsGetStringRawBuffer)>(
+          LoadComBaseFunction("WindowsGetStringRawBuffer"));
+  return function;
+}
+
+HRESULT WindowsCreateString(const wchar_t* src,
+                            uint32_t len,
+                            HSTRING* out_hstr) {
+  decltype(&::WindowsCreateString) create_string_func =
+      GetWindowsCreateString();
+  if (!create_string_func) {
+    return E_FAIL;
+  }
+  return create_string_func(src, len, out_hstr);
+}
+
+HRESULT WindowsDeleteString(HSTRING hstr) {
+  decltype(&::WindowsDeleteString) delete_string_func =
+      GetWindowsDeleteString();
+  if (!delete_string_func) {
+    return E_FAIL;
+  }
+  return delete_string_func(hstr);
+}
+
+const wchar_t* WindowsGetStringRawBuffer(HSTRING hstr, uint32_t* out_len) {
+  decltype(&::WindowsGetStringRawBuffer) get_string_raw_buffer_func =
+      GetWindowsGetStringRawBuffer();
+  if (!get_string_raw_buffer_func) {
+    *out_len = 0;
+    return nullptr;
+  }
+  return get_string_raw_buffer_func(hstr, out_len);
+}
+
+}  // namespace
+
 namespace internal {
 
 // static
 void ScopedHStringTraits::Free(HSTRING hstr) {
-  ::WindowsDeleteString(hstr);
+  base::WindowsDeleteString(hstr);
 }
 
 }  // namespace internal
 
 namespace win {
 
-ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {}
+ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {
+  DCHECK(g_load_succeeded);
+}
 
 // static
 ScopedHString ScopedHString::Create(WStringPiece str) {
+  DCHECK(g_load_succeeded);
   HSTRING hstr;
-  HRESULT hr = ::WindowsCreateString(str.data(),
-                                     checked_cast<UINT32>(str.length()), &hstr);
+  HRESULT hr = base::WindowsCreateString(
+      str.data(), checked_cast<UINT32>(str.length()), &hstr);
   if (SUCCEEDED(hr))
     return ScopedHString(hstr);
 
@@ -57,9 +123,21 @@ ScopedHString ScopedHString::Create(StringPiece str) {
 }
 
 // static
+bool ScopedHString::ResolveCoreWinRTStringDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+
+  static const bool load_succeeded = []() {
+    bool success = GetWindowsCreateString() && GetWindowsDeleteString() &&
+                   GetWindowsGetStringRawBuffer();
+    g_load_succeeded = success;
+    return success;
+  }();
+  return load_succeeded;
+}
+
 WStringPiece ScopedHString::Get() const {
   UINT32 length = 0;
-  const wchar_t* buffer = ::WindowsGetStringRawBuffer(get(), &length);
+  const wchar_t* buffer = base::WindowsGetStringRawBuffer(get(), &length);
   return WStringPiece(buffer, length);
 }
 
diff --git a/base/win/scoped_hstring.h b/base/win/scoped_hstring.h
index 95bc98bc2cf09..4ba6e23d08272 100644
--- a/base/win/scoped_hstring.h
+++ b/base/win/scoped_hstring.h
@@ -27,7 +27,21 @@ struct BASE_EXPORT ScopedHStringTraits {
 
 namespace win {
 
-// ScopedHString is a wrapper around an HSTRING.
+// ScopedHString is a wrapper around an HSTRING. Note that it requires certain
+// functions that are only available on Windows 8 and later, and that these
+// functions need to be delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using ScopedHString.
+//
+// One-time Initialization for ScopedHString:
+//
+//   bool success = ScopedHString::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // ScopeHString can be used.
+//   } else {
+//     // Handle error.
+//   }
 //
 // Example use:
 //
@@ -48,6 +62,9 @@ class BASE_EXPORT ScopedHString
   static ScopedHString Create(WStringPiece str);
   static ScopedHString Create(StringPiece str);
 
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  [[nodiscard]] static bool ResolveCoreWinRTStringDelayload();
+
   // Returns a view into the memory buffer managed by the instance. The returned
   // StringPiece is only valid during the lifetime of this ScopedHString
   // instance.
diff --git a/base/win/scoped_winrt_initializer.cc b/base/win/scoped_winrt_initializer.cc
index 4c93dcfabf658..2fc327d632088 100644
--- a/base/win/scoped_winrt_initializer.cc
+++ b/base/win/scoped_winrt_initializer.cc
@@ -5,14 +5,63 @@
 #include "base/win/scoped_winrt_initializer.h"
 
 #include <roapi.h>
+#include <windows.h>
+
+#include <ostream>
 
 #include "base/check_op.h"
+#include "base/threading/scoped_thread_priority.h"
 #include "base/win/com_init_util.h"
+#include "base/win/core_winrt_util.h"
 
 namespace base::win {
 
+namespace {
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoInitialize) GetRoInitializeFunction() {
+  static decltype(&::RoInitialize) const function =
+      reinterpret_cast<decltype(&::RoInitialize)>(
+          LoadComBaseFunction("RoInitialize"));
+  return function;
+}
+
+decltype(&::RoUninitialize) GetRoUninitializeFunction() {
+  static decltype(&::RoUninitialize) const function =
+      reinterpret_cast<decltype(&::RoUninitialize)>(
+          LoadComBaseFunction("RoUninitialize"));
+  return function;
+}
+
+HRESULT CallRoInitialize(RO_INIT_TYPE init_type) {
+  auto ro_initialize_func = GetRoInitializeFunction();
+  if (!ro_initialize_func) {
+    return E_FAIL;
+  }
+  return ro_initialize_func(init_type);
+}
+
+void CallRoUninitialize() {
+  auto ro_uninitialize_func = GetRoUninitializeFunction();
+  if (ro_uninitialize_func) {
+    ro_uninitialize_func();
+  }
+}
+
+}  // namespace
+
 ScopedWinrtInitializer::ScopedWinrtInitializer()
-    : hr_(::RoInitialize(RO_INIT_MULTITHREADED)) {
+    : hr_(CallRoInitialize(RO_INIT_MULTITHREADED)) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 #if DCHECK_IS_ON()
   if (SUCCEEDED(hr_))
@@ -25,7 +74,7 @@ ScopedWinrtInitializer::ScopedWinrtInitializer()
 ScopedWinrtInitializer::~ScopedWinrtInitializer() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (SUCCEEDED(hr_))
-    ::RoUninitialize();
+    CallRoUninitialize();
 }
 
 bool ScopedWinrtInitializer::Succeeded() const {
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 0d81e7c0a268e..151735928d080 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -67,6 +67,22 @@ namespace win {
 
 namespace {
 
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+
+bool ShouldUseDirectWrite() {
+  // If the flag is currently on, and we're on WinVista or above, we enable
+  // DirectWrite. There is no reason to not install Platform Update or
+  // even use the Windows 7 Platform Update dwrite.dll with the extended kernel.
+  if (GetVersion() < base::win::Version::VISTA) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch(kDisableDirectWrite);
+}
+
 // Sets the value of |property_key| to |property_value| in |property_store|.
 bool SetPropVariantValueForPropertyStore(
     IPropertyStore* property_store,
@@ -95,10 +111,42 @@ void __cdecl ForceCrashOnSigAbort(int) {
   *((volatile int*)nullptr) = 0x1337;
 }
 
-// Returns the current platform role. We use the PowerDeterminePlatformRoleEx
+// Returns the current platform role. We use the PowerDeterminePlatformRole
 // API for that.
 POWER_PLATFORM_ROLE GetPlatformRole() {
-  return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
+  return PowerDeterminePlatformRole();
+}
+
+// Because we used to support versions earlier than 8.1, we dynamically load
+// this function from user32.dll, so it won't fail to load in runtime.
+// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  if (!IsUser32AndGdi32Available()) {
+    return false;
+  }
+
+  static const auto set_process_dpi_awareness_func =
+      reinterpret_cast<decltype(&::SetProcessDpiAwareness)>(
+          GetUser32FunctionPointer("SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr)) {
+      return true;
+    }
+    DLOG_IF(ERROR, hr == E_ACCESSDENIED)
+        << "Access denied error from SetProcessDpiAwarenessInternal. "
+           "Function called twice, or manifest was used.";
+    NOTREACHED()
+        << "SetProcessDpiAwarenessInternal failed with unexpected error: "
+        << hr;
+    return false;
+  }
+
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
+
+  return false;
 }
 
 // Enable V2 per-monitor high-DPI support for the process. This will cause
@@ -238,11 +286,16 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
            IsDeviceUsedAsATablet(/*reason=*/nullptr);
   }
 
+  if (!ResolveCoreWinRTDelayload() ||
+      !ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
   ScopedHString view_settings_guid = ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UIViewSettings);
   Microsoft::WRL::ComPtr<IUIViewSettingsInterop> view_settings_interop;
-  HRESULT hr = ::RoGetActivationFactory(view_settings_guid.get(),
-                                        IID_PPV_ARGS(&view_settings_interop));
+  HRESULT hr = win::RoGetActivationFactory(
+      view_settings_guid.get(), IID_PPV_ARGS(&view_settings_interop));
   if (FAILED(hr))
     return false;
 
@@ -606,10 +659,22 @@ bool IsJoinedToAzureAD() {
 bool IsUser32AndGdi32Available() {
   static auto is_user32_and_gdi32_available = []() {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
+    if (!ShouldUseDirectWrite()) {
+      return true;
+    }
+    auto get_process_mitigation_policy =
+        reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(
+            ::GetProcAddress(::GetModuleHandleA("kernel32.dll"),
+                             "GetProcessMitigationPolicy"));
+
+    if (!get_process_mitigation_policy) {
+      return true;
+    }
+
     PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                     ProcessSystemCallDisablePolicy, &policy,
-                                     sizeof(policy))) {
+    if (get_process_mitigation_policy(GetCurrentProcess(),
+                                      ProcessSystemCallDisablePolicy, &policy,
+                                      sizeof(policy))) {
       return policy.DisallowWin32kSystemCalls == 0;
     }
 
@@ -673,8 +738,9 @@ void DisableFlicks(HWND hwnd) {
 }
 
 void EnableHighDPISupport() {
-  if (!IsUser32AndGdi32Available())
+  if (!IsUser32AndGdi32Available() || GetVersion() < Version::VISTA) {
     return;
+  }
 
   // Enable per-monitor V2 if it is available (Win10 1703 or later).
   if (EnablePerMonitorV2())
@@ -682,7 +748,7 @@ void EnableHighDPISupport() {
 
   // Fall back to per-monitor DPI for older versions of Win10.
   PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
-  if (!::SetProcessDpiAwareness(process_dpi_awareness)) {
+  if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
     // For windows versions where SetProcessDpiAwareness fails, try its
     // predecessor.
     BOOL result = ::SetProcessDPIAware();
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 7574fc11e1f61..4d769990daba7 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -16,6 +16,7 @@
 #include "base/base_switches.h"
 #include "base/command_line.h"
 #include "base/feature_list.h"
+#include "base/features.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
 #include "base/i18n/base_i18n_switches.h"
@@ -5363,6 +5364,14 @@ const FeatureEntry kFeatureEntries[] = {
                                     kForceDarkVariations,
                                     "ForceDarkVariations")},
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+    {"force-dark-mode", flag_descriptions::kForceDarkModeFlagName,
+     flag_descriptions::kForceDarkModeFlagDescription, kOsAll,
+     FEATURE_VALUE_TYPE(base::features::kForceDarkModeFlag)},
+#if BUILDFLAG(IS_WIN)
+    {"force-xp-theme", flag_descriptions::kForceXpThemeName,
+     flag_descriptions::kForceXpThemeDescription, kOsWin,
+     FEATURE_VALUE_TYPE(kForceXpTheme)},
+#endif
 #if BUILDFLAG(IS_ANDROID)
     {"enable-accessibility-page-zoom",
      flag_descriptions::kAccessibilityPageZoomName,
@@ -6980,10 +6989,6 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableWindowsGamingInputDataFetcherName,
      flag_descriptions::kEnableWindowsGamingInputDataFetcherDescription, kOsWin,
      FEATURE_VALUE_TYPE(features::kEnableWindowsGamingInputDataFetcher)},
-
-    {"windows11-mica-titlebar", flag_descriptions::kWindows11MicaTitlebarName,
-     flag_descriptions::kWindows11MicaTitlebarDescription, kOsWin,
-     FEATURE_VALUE_TYPE(kWindows11MicaTitlebar)},
 #endif
 
 #if BUILDFLAG(IS_ANDROID)
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 6f989cff781d7..9d11d76b4e997 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -4449,6 +4449,13 @@ std::string ChromeContentBrowserClient::GetDefaultDownloadName() {
   return l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME);
 }
 
+base::FilePath ChromeContentBrowserClient::GetFontLookupTableCacheDir() {
+  base::FilePath user_data_dir;
+  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+  DCHECK(!user_data_dir.empty());
+  return user_data_dir.Append(FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
   base::FilePath user_data_dir;
   base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index 28633d6bd4cb9..dac5d1f8f4164 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -429,6 +429,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void BrowserURLHandlerCreated(content::BrowserURLHandler* handler) override;
   base::FilePath GetDefaultDownloadDirectory() override;
   std::string GetDefaultDownloadName() override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   base::FilePath GetShaderDiskCacheDirectory() override;
   base::FilePath GetGrShaderDiskCacheDirectory() override;
   base::FilePath GetGraphiteDawnDiskCacheDirectory() override;
diff --git a/chrome/browser/device_reauth/win/authenticator_win.cc b/chrome/browser/device_reauth/win/authenticator_win.cc
index 1d9342a94ad70..c12ef488478df 100644
--- a/chrome/browser/device_reauth/win/authenticator_win.cc
+++ b/chrome/browser/device_reauth/win/authenticator_win.cc
@@ -45,6 +45,11 @@ using ABI::Windows::Security::Credentials::UI::
     UserConsentVerifierAvailability_NotConfiguredForUser;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 BiometricAuthenticationStatusWin ConvertUserConsentVerifierAvailability(
     UserConsentVerifierAvailability availability) {
   switch (availability) {
@@ -93,6 +98,11 @@ void GetBiometricAvailabilityFromWindows(
   // (http://crbug/973868).
   SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
 
+  if (!ResolveCoreWinRT()) {
+    ReportCantCheckAvailability(thread, std::move(callback));
+    return;
+  }
+
   ComPtr<IUserConsentVerifierStatics> factory;
   HRESULT hr = base::win::GetActivationFactory<
       IUserConsentVerifierStatics,
diff --git a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
index cfe13c30f9758..558204405c415 100644
--- a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
+++ b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
@@ -88,6 +88,13 @@ class WebAccountSupportFinder
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
 
+    if (!base::win::ResolveCoreWinRTDelayload()) {
+      return;  // Unsupported.
+    }
+    if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+      return;  // Unsupported.
+    }
+
     // Get the `WebAuthenticationCoreManager`.
     ComPtr<IWebAuthenticationCoreManagerStatics> auth_manager;
     HRESULT hresult = base::win::GetActivationFactory<
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index 0b3534db8e5db..57438687579ab 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -4546,6 +4546,11 @@
     "owners": [ "chromeos-camera-eng@google.com" ],
     "expiry_milestone": 120
   },
+  {
+    "name": "force-dark-mode",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "force-enable-fast-checkout-capabilities",
     "owners": [ "vizcay@google.com", "bwolfgang@google.com", "jkeitel@google.com" ],
@@ -4612,6 +4617,11 @@
     // have no access to commandline flags.
     "expiry_milestone": -1
   },
+  {
+    "name": "force-xp-theme",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "forced-colors",
     "owners": [ "almaher@microsoft.com" ],
diff --git a/chrome/browser/flag-never-expire-list.json b/chrome/browser/flag-never-expire-list.json
index 296c1a9d26c82..acc079e787890 100644
--- a/chrome/browser/flag-never-expire-list.json
+++ b/chrome/browser/flag-never-expire-list.json
@@ -76,12 +76,14 @@
   "extensions-on-chrome-urls",
   "external-navigation-debug-logs",
   "force-color-profile",
+  "force-dark-mode",
   "force-effective-connection-type",
   "force-show-update-menu-badge",
   "force-startup-signin-promo",
   "force-text-direction",
   "force-ui-direction",
   "force-update-menu-type",
+  "force-xp-theme",
   "fullscreen-promos-manager-skip-internal-limits",
   "fullscreen-viewport-adjustment-experiment",
   "gesture-properties-dbus-service",
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 5829b6a0b3401..6ec6342d8201a 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2798,6 +2798,16 @@ const char kAutoWebContentsDarkModeName[] = "Auto Dark Mode for Web Contents";
 const char kAutoWebContentsDarkModeDescription[] =
     "Automatically render all web contents using a dark theme.";
 
+const char kForceDarkModeFlagName[] = "Forced Dark Mode for UI";
+const char kForceDarkModeFlagDescription[] =
+    "Enables dark mode for all UI elements (but not web contents - "
+    "enable #enable-force-dark for darkening web contents).";
+
+const char kForceXpThemeName[] = "Use Classic Theme";
+const char kForceXpThemeDescription[] =
+    "Use the classic Chrome theme designed to mimick \"Aero\" window controls. "
+    "Typically used when desktop composition is disabled or unavailable.";
+
 const char kForcedColorsName[] = "Forced Colors";
 const char kForcedColorsDescription[] =
     "Enables forced colors mode for web content.";
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index ff72a308d37e7..233e52c6dd4fd 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1596,6 +1596,12 @@ extern const char kBookmarksRefreshDescription[];
 extern const char kAutoWebContentsDarkModeName[];
 extern const char kAutoWebContentsDarkModeDescription[];
 
+extern const char kForceDarkModeFlagName[];
+extern const char kForceDarkModeFlagDescription[];
+
+extern const char kForceXpThemeName[];
+extern const char kForceXpThemeDescription[];
+
 extern const char kForcedColorsName[];
 extern const char kForcedColorsDescription[];
 
diff --git a/chrome/browser/notifications/notification_platform_bridge_win.cc b/chrome/browser/notifications/notification_platform_bridge_win.cc
index 5bb38415f8739..5a05b59e6d637 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win.cc
@@ -702,7 +702,9 @@ class NotificationPlatformBridgeWinImpl
         InstallUtil::IsStartMenuShortcutWithActivatorGuidInstalled();
 
     int status = static_cast<int>(SetReadyCallbackStatus::kSuccess);
-    bool enabled = activator_registered && shortcut_installed;
+    bool enabled = base::win::ResolveCoreWinRTDelayload() &&
+                   ScopedHString::ResolveCoreWinRTStringDelayload() &&
+                   activator_registered && shortcut_installed;
 
     if (!enabled) {
       if (!shortcut_installed) {
@@ -713,6 +715,10 @@ class NotificationPlatformBridgeWinImpl
         status |= static_cast<int>(
             SetReadyCallbackStatus::kComServerMisconfiguration);
       }
+      if (!(base::win::ResolveCoreWinRTDelayload() &&
+            ScopedHString::ResolveCoreWinRTStringDelayload())) {
+        status |= static_cast<int>(SetReadyCallbackStatus::kComNotInitialized);
+      }
     }
 
     LogSetReadyCallbackStatus(static_cast<SetReadyCallbackStatus>(status));
diff --git a/chrome/browser/notifications/win/notification_metrics.h b/chrome/browser/notifications/win/notification_metrics.h
index 8dfbaea83d66c..aab0938792430 100644
--- a/chrome/browser/notifications/win/notification_metrics.h
+++ b/chrome/browser/notifications/win/notification_metrics.h
@@ -137,8 +137,8 @@ enum class SetReadyCallbackStatus {
   kSuccess = 0,
   kShortcutMisconfiguration = 1 << 0,
   kComServerMisconfiguration = 1 << 1,
-  kComNotInitializedObsolete = 1 << 2,  // No longer possible w/ Win10+ only.
-  kMaxValue = kComNotInitializedObsolete,
+  kComNotInitialized = 1 << 2,
+  kMaxValue = kComNotInitialized,
 };
 
 // These values are persisted to logs. Entries should not be renumbered and
diff --git a/chrome/browser/obsolete_system/obsolete_system_win.cc b/chrome/browser/obsolete_system/obsolete_system_win.cc
index eb373d6316c13..9e36da7040451 100644
--- a/chrome/browser/obsolete_system/obsolete_system_win.cc
+++ b/chrome/browser/obsolete_system/obsolete_system_win.cc
@@ -22,16 +22,12 @@ base::win::Version GetRealOSVersion() {
   return base::win::OSInfo::Kernel32Version();
 }
 
-bool IsObsoleteOsVersion() {
-  return GetRealOSVersion() < base::win::Version::WIN10;
-}
-
 }  // namespace
 
 namespace ObsoleteSystem {
 
 bool IsObsoleteNowOrSoon() {
-  return IsObsoleteOsVersion();
+  return false;
 }
 
 std::u16string LocalizedObsoleteString() {
@@ -52,7 +48,7 @@ bool IsEndOfTheLine() {
   // M109 was the last milestone to support Win 7/8/8.1, the last deprecated
   // Windows version. Future deprecations should update this to the last
   // milestone that supports the soon-to-be-deprecated Windows version.
-  return CHROME_VERSION_MAJOR >= 109;
+  return false;
 }
 
 const char* GetLinkURL() {
diff --git a/chrome/browser/themes/theme_helper_win.cc b/chrome/browser/themes/theme_helper_win.cc
index 259668e16470f..c8e6e79f823b3 100644
--- a/chrome/browser/themes/theme_helper_win.cc
+++ b/chrome/browser/themes/theme_helper_win.cc
@@ -4,11 +4,14 @@
 
 #include "chrome/browser/themes/theme_helper_win.h"
 
+#include "base/win/windows_version.h"
 #include "chrome/browser/themes/custom_theme_supplier.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/theme_resources.h"
 
+BASE_FEATURE(kForceXpTheme, "ForceXpTheme", base::FEATURE_DISABLED_BY_DEFAULT);
+
 int ThemeHelperWin::GetDefaultDisplayProperty(int id) const {
   if (id == ThemeProperties::SHOULD_FILL_BACKGROUND_TAB_COLOR) {
     return !ShouldDefaultThemeUseMicaTitlebar();
@@ -19,5 +22,12 @@ int ThemeHelperWin::GetDefaultDisplayProperty(int id) const {
 
 bool ThemeHelperWin::ShouldUseNativeFrame(
     const CustomThemeSupplier* theme_supplier) const {
-  return true;
+  // If it returns false, the XP fallback theme is used.
+  // And yes, Chromium has muddied the waters of what is considered "native".
+  // Aero Glass is "native", Mica is "native", and so is the Windows 10-style
+  // theme that is drawn by Chromium itself. Only the "original" Chromium theme
+  // that mimicks Aero is not considered native.
+  return (!HasCustomImage(IDR_THEME_FRAME, theme_supplier) &&
+          (base::win::GetVersion() >= base::win::Version::VISTA)) &&
+         !base::FeatureList::IsEnabled(kForceXpTheme);
 }
diff --git a/chrome/browser/themes/theme_service.cc b/chrome/browser/themes/theme_service.cc
index dbd628982e216..3d5bd977ff841 100644
--- a/chrome/browser/themes/theme_service.cc
+++ b/chrome/browser/themes/theme_service.cc
@@ -385,9 +385,9 @@ void ThemeService::UseSystemTheme() {
 }
 
 void ThemeService::UseDeviceTheme(bool follow) {
-#if BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_WIN)
-  // This toggle is currently supported on ChromeOS and Windows and we only want
-  // platforms to set the value if they have a visible toggle.
+#if BUILDFLAG(IS_CHROMEOS)
+  // This toggle is currently only on ChromeOS and we only want platforms to set
+  // the value if they have a visible toggle.
   profile_->GetPrefs()->SetBoolean(prefs::kBrowserFollowsSystemThemeColors,
                                    follow);
   NotifyThemeChanged();
@@ -401,18 +401,13 @@ bool ThemeService::UsingDeviceTheme() const {
   // Ensure we respect previous theme settings for an unset follow theme
   // value.
   if (pref->IsDefaultValue()) {
-    return GetIsBaseline() && !UsingExtensionTheme();
+    return GetIsBaseline() && !UsingExtensionTheme() &&
+           !UsingAutogeneratedTheme();
   }
+
   return pref->GetValue()->GetBool();
-#elif BUILDFLAG(IS_WIN)
-  // Always respect the profile preference on Windows. In the default case the
-  // preference starts disabled.
-  return profile_->GetPrefs()
-      ->FindPreference(prefs::kBrowserFollowsSystemThemeColors)
-      ->GetValue()
-      ->GetBool();
 #else
-  // Only ChromeOS and Windows have this toggle.
+  // Only ChromeOS has this toggle.
   return false;
 #endif
 }
@@ -640,9 +635,8 @@ bool ThemeService::GetIsGrayscale() const {
 }
 
 bool ThemeService::GetIsBaseline() const {
-  // Baseline is defined by the absence of a user color set by the corresponding
-  // profile pref or the autogenerated theme.
-  return !GetUserColor().has_value() && !UsingAutogeneratedTheme();
+  // Baseline is represented as a missing user_color in prefs.
+  return !GetUserColor().has_value();
 }
 
 // static
@@ -1004,4 +998,4 @@ bool ThemeService::DisableExtension(const std::string& extension_id) {
     return true;
   }
   return false;
-}
+}
\ No newline at end of file
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index c6da605fb1f1e..a300b6e8418c8 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -8,12 +8,12 @@
 #include "base/functional/bind.h"
 #include "base/no_destructor.h"
 #include "base/win/windows_version.h"
+#include "chrome/browser/themes/browser_theme_pack.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/theme_resources.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
-#include "ui/base/ui_base_features.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_mixer.h"
 #include "ui/color/color_provider.h"
@@ -45,6 +45,13 @@ class FrameColorHelper {
   static FrameColorHelper* Get();
 
  private:
+  // Returns whether there is a custom image provided for the given id.
+  bool HasCustomImage(int id, const ui::ColorProviderKey& key) const;
+
+  // Returns true if colors from DWM can be used, i.e. this is a native frame
+  // on Windows 8+.
+  bool DwmColorsAllowed(const ui::ColorProviderKey& key) const;
+
   // Returns the Tint for the given |id|. If there is no tint, the identity tint
   // {-1, -1, -1} is returned and won't tint the color on which it is used.
   color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) const;
@@ -69,7 +76,7 @@ class FrameColorHelper {
   absl::optional<SkColor> dwm_inactive_frame_color_;
 
   // The DWM accent border color, if available; white otherwise.
-  SkColor dwm_accent_border_color_ = SK_ColorWHITE;
+  SkColor dwm_accent_border_color_;
 };
 
 FrameColorHelper::FrameColorHelper() {
@@ -89,43 +96,38 @@ void FrameColorHelper::AddNativeChromeColors(
     return absl::nullopt;
   };
 
-  // When we're custom-drawing the titlebar we want to use either the colors
-  // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
-  // custom-drawing the titlebar we want to match the color Windows actually
-  // uses because some things (like the incognito icon) use this color to
-  // decide whether they should draw in light or dark mode. Incognito colors
-  // should be the same as non-incognito in all cases here.
-
-  constexpr SkColor kSystemMicaLightFrameColor =
-      SkColorSetRGB(0xE8, 0xE8, 0xE8);
-  constexpr SkColor kSystemMicaDarkFrameColor = SkColorSetRGB(0x20, 0x20, 0x20);
-
-  // Dwm colors should always be applied if present for pervasive accent colors
-  // pre-refresh. With refresh enabled we should only attempt to paint
-  // system-style frames if configured to do so in the key.
-  const bool use_native_colors =
-      !features::IsChromeRefresh2023() ||
-      (key.frame_type == ui::ColorProviderKey::FrameType::kChromium &&
-       key.frame_style == ui::ColorProviderKey::FrameStyle::kSystem);
-
-  absl::optional<ui::ColorTransform> active_frame_transform;
-  if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE)) {
-    active_frame_transform = {color.value()};
-  } else if (use_native_colors) {
-    if (dwm_frame_color_) {
+  if (DwmColorsAllowed(key)) {
+    // When we're custom-drawing the titlebar we want to use either the colors
+    // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
+    // custom-drawing the titlebar we want to match the color Windows actually
+    // uses because some things (like the incognito icon) use this color to
+    // decide whether they should draw in light or dark mode. Incognito colors
+    // should be the same as non-incognito in all cases here.
+
+    constexpr SkColor kSystemSolidLightFrameColor = SK_ColorWHITE;
+    constexpr SkColor kSystemSolidDarkInactiveFrameColor =
+        SkColorSetRGB(0x2B, 0x2B, 0x2B);
+
+    constexpr SkColor kSystemMicaLightFrameColor =
+        SkColorSetRGB(0xE8, 0xE8, 0xE8);
+    constexpr SkColor kSystemMicaDarkFrameColor =
+        SkColorSetRGB(0x20, 0x20, 0x20);
+
+    absl::optional<ui::ColorTransform> active_frame_transform;
+    if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE)) {
+      active_frame_transform = {color.value()};
+    } else if (dwm_frame_color_) {
       active_frame_transform = {dwm_frame_color_.value()};
     } else if (ShouldDefaultThemeUseMicaTitlebar()) {
       active_frame_transform = {key.color_mode == ColorMode::kDark
                                     ? kSystemMicaDarkFrameColor
                                     : kSystemMicaLightFrameColor};
     }
-  }
 
-  absl::optional<ui::ColorTransform> inactive_frame_transform;
-  if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
-    inactive_frame_transform = {color.value()};
-  } else if (use_native_colors) {
-    if (dwm_inactive_frame_color_) {
+    absl::optional<ui::ColorTransform> inactive_frame_transform;
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      inactive_frame_transform = {color.value()};
+    } else if (dwm_inactive_frame_color_) {
       inactive_frame_transform = {dwm_inactive_frame_color_.value()};
     } else if (dwm_frame_color_) {
       inactive_frame_transform =
@@ -136,45 +138,70 @@ void FrameColorHelper::AddNativeChromeColors(
                                       ? kSystemMicaDarkFrameColor
                                       : kSystemMicaLightFrameColor};
     }
-  }
 
-  // If setting custom window frame colors ensure we also update the
-  // corresponding sys header colors. Although this diverges from chrome's
-  // material spec these overrides are necessary to ensure UI assigned to these
-  // color roles can continue to work as expected while respecting platform
-  // frame overrides.
-  if (active_frame_transform) {
-    mixer[ui::kColorFrameActive] = active_frame_transform.value();
-    mixer[ui::kColorSysHeader] = active_frame_transform.value();
-    mixer[ui::kColorSysOnHeaderDivider] =
-        GetColorWithMaxContrast(ui::kColorSysHeader);
-    mixer[ui::kColorSysOnHeaderPrimary] =
-        GetColorWithMaxContrast(ui::kColorSysHeader);
-    mixer[ui::kColorSysStateHeaderHover] =
-        ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeader,
-                       /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
-    mixer[ui::kColorSysHeaderContainer] = {ui::kColorSysBase};
-  }
-  if (inactive_frame_transform) {
-    mixer[ui::kColorFrameInactive] = inactive_frame_transform.value();
-    mixer[ui::kColorSysHeaderInactive] = inactive_frame_transform.value();
-    mixer[ui::kColorSysOnHeaderDividerInactive] =
-        GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
-    mixer[ui::kColorSysOnHeaderPrimaryInactive] =
-        GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
-    mixer[ui::kColorSysStateHeaderHoverInactive] =
-        ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeaderInactive,
-                       /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
-    mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
-  }
+    // If setting custom window frame colors ensure we also update the
+    // corresponding sys header colors. Although this diverges from chrome's
+    // material spec these overrides are necessary to ensure UI assigned to
+    // these color roles can continue to work as expected while respecting
+    // platform frame overrides.
+    if (active_frame_transform) {
+      mixer[ui::kColorFrameActive] = active_frame_transform.value();
+      mixer[ui::kColorSysHeader] = active_frame_transform.value();
+      mixer[ui::kColorSysOnHeaderDivider] =
+          GetColorWithMaxContrast(ui::kColorSysHeader);
+      mixer[ui::kColorSysOnHeaderPrimary] =
+          GetColorWithMaxContrast(ui::kColorSysHeader);
+      mixer[ui::kColorSysStateHeaderHover] =
+          ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeader,
+                         /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
+      mixer[ui::kColorSysHeaderContainer] = {ui::kColorSysBase};
+    }
+    if (inactive_frame_transform) {
+      mixer[ui::kColorFrameInactive] = inactive_frame_transform.value();
+      mixer[ui::kColorSysHeaderInactive] = inactive_frame_transform.value();
+      mixer[ui::kColorSysOnHeaderDividerInactive] =
+          GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
+      mixer[ui::kColorSysOnHeaderPrimaryInactive] =
+          GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
+      mixer[ui::kColorSysStateHeaderHoverInactive] =
+          ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeaderInactive,
+                         /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
+      mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
+    }
+
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      mixer[ui::kColorFrameInactive] = {color.value()};
+    } else if (dwm_inactive_frame_color_) {
+      mixer[ui::kColorFrameInactive] = {dwm_inactive_frame_color_.value()};
+    } else if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemMicaDarkFrameColor
+                                            : kSystemMicaLightFrameColor};
+    } else if (!ShouldCustomDrawSystemTitlebar()) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemSolidDarkInactiveFrameColor
+                                            : kSystemSolidLightFrameColor};
+    } else if (dwm_frame_color_) {
+      mixer[ui::kColorFrameInactive] =
+          ui::HSLShift({dwm_frame_color_.value()},
+                       GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+    }
 
-  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
-    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonInkDropFrameActive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
-    mixer[kColorNewTabButtonInkDropFrameInactive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
+    if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonInkDropFrameInactive] =
+          ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
+      mixer[kColorNewTabButtonInkDropFrameActive] =
+          ui::GetColorWithMaxContrast(ui::kColorFrameActive);
+    }
+  } else {
+    if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE)) {
+      mixer[ui::kColorFrameActive] = {color.value()};
+    }
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      mixer[ui::kColorFrameInactive] = {color.value()};
+    }
   }
 }
 
@@ -197,6 +224,17 @@ FrameColorHelper* FrameColorHelper::Get() {
   return g_frame_color_helper.get();
 }
 
+bool FrameColorHelper::HasCustomImage(int id,
+                                      const ui::ColorProviderKey& key) const {
+  return BrowserThemePack::IsPersistentImageID(id) && key.custom_theme &&
+         key.custom_theme->HasCustomImage(id);
+}
+
+bool FrameColorHelper::DwmColorsAllowed(const ui::ColorProviderKey& key) const {
+  return (!ShouldCustomDrawSystemTitlebar() ||
+          !HasCustomImage(IDR_THEME_FRAME, key));
+}
+
 color_utils::HSL FrameColorHelper::GetTint(
     int id,
     const ui::ColorProviderKey& key) const {
@@ -217,25 +255,11 @@ void FrameColorHelper::OnAccentColorUpdated() {
 }
 
 void FrameColorHelper::FetchAccentColors() {
-  // Update the NativeTheme's user_color to reflect the system accent color.
-  // TODO(crbug.com/1477908): Explore moving FrameColorHelper logic into
-  // NativeThemeWin.
   const auto* accent_color_observer = ui::AccentColorObserver::Get();
-  const auto accent_color = accent_color_observer->accent_color();
-  ui::NativeTheme::GetInstanceForNativeUi()->set_user_color(accent_color);
-  ui::NativeTheme::GetInstanceForDarkUI()->set_user_color(accent_color);
-
-  if (!accent_color_observer->use_dwm_frame_color()) {
-    dwm_accent_border_color_ = SK_ColorWHITE;
-    dwm_frame_color_.reset();
-    dwm_inactive_frame_color_.reset();
-    return;
-  }
-
   dwm_accent_border_color_ =
       accent_color_observer->accent_border_color().value_or(SK_ColorWHITE);
 
-  dwm_frame_color_ = accent_color;
+  dwm_frame_color_ = accent_color_observer->accent_color();
   dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
 }
 
diff --git a/chrome/browser/ui/startup/bad_flags_prompt.cc b/chrome/browser/ui/startup/bad_flags_prompt.cc
index f4b8bc02b8da0..2a14dfc62f263 100644
--- a/chrome/browser/ui/startup/bad_flags_prompt.cc
+++ b/chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -69,7 +69,6 @@ const char* const kBadFlags[] = {
     sandbox::policy::switches::kDisableGpuSandbox,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kDisableSetuidSandbox,
-    sandbox::policy::switches::kNoSandbox,
 #if BUILDFLAG(IS_WIN)
     sandbox::policy::switches::kAllowThirdPartyModules,
 #endif
diff --git a/chrome/browser/ui/test/test_browser_ui.cc b/chrome/browser/ui/test/test_browser_ui.cc
index 2f61aef15bbf8..9d33b659c032e 100644
--- a/chrome/browser/ui/test/test_browser_ui.cc
+++ b/chrome/browser/ui/test/test_browser_ui.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/ui/test/test_browser_ui.h"
 
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/test/gtest_util.h"
 #include "base/test/test_switches.h"
 #include "build/build_config.h"
@@ -159,19 +160,21 @@ void TestBrowserUi::ShowAndVerifyUi() {
   // Gold files for pixel tests are for light mode, so if dark mode is not
   // forced, and host is in dark mode, skip test.
   if (!IsInteractiveUi() &&
-      !base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode) &&
+      (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag) &&
       ui::NativeTheme::GetInstanceForNativeUi()->ShouldUseDarkColors()) {
     GTEST_SKIP() << "Host is in dark mode; skipping test";
   }
 #endif  // BUILDFLAG(IS_WIN)
   ShowUi(NameFromTestCase());
   ASSERT_TRUE(VerifyUi());
-  if (IsInteractiveUi())
+  if (IsInteractiveUi()){
     WaitForUserDismissal();
-  else
+}
+  else{
     DismissUi();
 }
+}
 
 bool TestBrowserUi::IsInteractiveUi() const {
   return base::CommandLine::ForCurrentProcess()->HasSwitch(
diff --git a/chrome/browser/ui/views/frame/browser_frame.cc b/chrome/browser/ui/views/frame/browser_frame.cc
index bb4b3821bcfda..019ca9eed1135 100644
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -490,7 +490,6 @@ ui::ColorProviderKey BrowserFrame::GetColorProviderKey() const {
 
   const auto* theme_service =
       ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile());
-  CHECK(theme_service);
 
   // color_mode.
   [this, &key, theme_service]() {
@@ -501,6 +500,7 @@ ui::ColorProviderKey BrowserFrame::GetColorProviderKey() const {
     }
 
     const auto browser_color_scheme = theme_service->GetBrowserColorScheme();
+
     if (browser_color_scheme != ThemeService::BrowserColorScheme::kSystem) {
       key.color_mode =
           browser_color_scheme == ThemeService::BrowserColorScheme::kLight
@@ -509,29 +509,43 @@ ui::ColorProviderKey BrowserFrame::GetColorProviderKey() const {
     }
   }();
 
+  // is_grayscale.
+  // Incognito mode browser should be forced to grayscale.
+  key.is_grayscale = IsIncognitoBrowser() ||
+                     (theme_service && !theme_service->UsingDeviceTheme() &&
+                      theme_service->GetIsGrayscale());
+
   // user_color.
-  // Device theme retains the user_color from `Widget`.
-  if (!theme_service->UsingDeviceTheme()) {
+  [&key, theme_service]() {
+    // The grayscale theme also assumes that the baseline palette is used.
+    if (key.is_grayscale) {
+      // Baseline palette is used when `ColorProviderKey::user_color` is empty.
+      key.user_color = absl::nullopt;
+      return;
+    }
+
+    if (!theme_service) {
+      return;
+    }
+
+    if (theme_service->UsingDeviceTheme()) {
+      // Device theme retains the user_color from `Widget`.
+      return;
+    }
+
     if (theme_service->UsingAutogeneratedTheme()) {
       key.user_color = theme_service->GetAutogeneratedThemeColor();
-    } else if (auto user_color = theme_service->GetUserColor()) {
-      key.user_color = user_color;
+      return;
     }
-  }
 
-  // user_color_source.
-  if (IsIncognitoBrowser()) {
-    key.user_color_source = ui::ColorProviderKey::UserColorSource::kGrayscale;
-  } else if (theme_service->UsingDeviceTheme()) {
-    key.user_color_source = ui::ColorProviderKey::UserColorSource::kAccent;
-  } else if (theme_service->GetIsGrayscale()) {
-    key.user_color_source = ui::ColorProviderKey::UserColorSource::kGrayscale;
-  } else if (theme_service->GetIsBaseline()) {
-    key.user_color_source = ui::ColorProviderKey::UserColorSource::kBaseline;
-  } else {
-    CHECK(key.user_color.has_value());
-    key.user_color_source = ui::ColorProviderKey::UserColorSource::kAccent;
-  }
+    if (theme_service->GetIsBaseline()) {
+      // Baseline theme has to explicitly clear user_color as it might have been
+      // set earlier.
+      key.user_color = absl::nullopt;
+    } else {
+      key.user_color = theme_service->GetUserColor();
+    }
+  }();
 
   // scheme_variant.
   ui::mojom::BrowserColorVariant color_variant =
@@ -544,11 +558,7 @@ ui::ColorProviderKey BrowserFrame::GetColorProviderKey() const {
   // frame_type.
   key.frame_type = UseCustomFrame() ? ui::ColorProviderKey::FrameType::kChromium
                                     : ui::ColorProviderKey::FrameType::kNative;
-#if BUILDFLAG(IS_WIN)
-  if (theme_service && theme_service->UsingDeviceTheme() && UseCustomFrame()) {
-    key.frame_style = ui::ColorProviderKey::FrameStyle::kSystem;
-  }
-#endif
+
 
   return key;
 }
@@ -633,4 +643,4 @@ bool BrowserFrame::RegenerateFrameOnThemeChange(
 
 bool BrowserFrame::IsIncognitoBrowser() const {
   return browser_view_->browser()->profile()->IsIncognitoProfile();
-}
+}
\ No newline at end of file
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.cc b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
index 769e7e8ac3b39..8579e6a095305 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
@@ -409,7 +409,7 @@ void BrowserFrameViewWin::ResetWindowControls() {
 void BrowserFrameViewWin::OnThemeChanged() {
   BrowserNonClientFrameView::OnThemeChanged();
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
@@ -649,24 +649,26 @@ bool BrowserFrameViewWin::ShouldShowWindowTitle(TitlebarType type) const {
 
 void BrowserFrameViewWin::TabletModeChanged() {
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
-void BrowserFrameViewWin::SetSystemMicaTitlebarAttributes() {
-  CHECK(SystemTitlebarCanUseMicaMaterial());
-
-  const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
-                        sizeof(dark_titlebar_enabled));
+void BrowserFrameViewWin::SetSystemTitlebarAttributes() {
+  if (SystemTitlebarSupportsDarkMode()) {
+    const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
+                          sizeof(dark_titlebar_enabled));
+  }
 
-  const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
-      browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
-                                           : DWMSBT_MAINWINDOW;
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
-                        sizeof(dwm_backdrop_type));
+  if (ShouldBrowserUseMicaTitlebar(browser_view())) {
+    const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
+        browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
+                                             : DWMSBT_MAINWINDOW;
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
+                          sizeof(dwm_backdrop_type));
+  }
 }
 
 SkColor BrowserFrameViewWin::GetTitlebarColor() const {
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.h b/chrome/browser/ui/views/frame/browser_frame_view_win.h
index 40c9246a8833f..bb24a265a06c7 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.h
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.h
@@ -146,8 +146,8 @@ class BrowserFrameViewWin : public BrowserNonClientFrameView,
   // Called when the device enters or exits tablet mode.
   void TabletModeChanged();
 
-  // Sets DWM attributes for rendering the system-drawn Mica titlebar.
-  void SetSystemMicaTitlebarAttributes();
+  // Sets DWM attributes for rendering the system-drawn titlebar.
+  void SetSystemTitlebarAttributes();
 
   // Paint various sub-components of this view.
   void PaintTitlebar(gfx::Canvas* canvas) const;
diff --git a/chrome/browser/webshare/win/fake_storage_file_statics.cc b/chrome/browser/webshare/win/fake_storage_file_statics.cc
index 6308ccec3a576..516e84ab3422f 100644
--- a/chrome/browser/webshare/win/fake_storage_file_statics.cc
+++ b/chrome/browser/webshare/win/fake_storage_file_statics.cc
@@ -9,7 +9,6 @@
 #include <wrl/module.h>
 
 #include <memory>
-#include <string>
 #include <tuple>
 
 #include "base/functional/bind.h"
@@ -279,6 +278,12 @@ IFACEMETHODIMP FakeStorageFileStatics::CreateStreamedFileAsync(
     IStreamedFileDataRequestedHandler* data_requested,
     IRandomAccessStreamReference* thumbnail,
     IAsyncOperation<StorageFile*>** operation) {
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    ADD_FAILURE() << "Attempted to use FakeStorageFileStatics in an "
+                     "environment that doesn't support ScopedHStrings.";
+    return E_UNEXPECTED;
+  }
+
   auto fake_iasync_operation =
       Make<base::win::FakeIAsyncOperation<StorageFile*>>();
   HRESULT hr = fake_iasync_operation->QueryInterface(IID_PPV_ARGS(operation));
diff --git a/chrome/browser/webshare/win/share_operation.cc b/chrome/browser/webshare/win/share_operation.cc
index ef09f08ba9cf4..8747e21cbe552 100644
--- a/chrome/browser/webshare/win/share_operation.cc
+++ b/chrome/browser/webshare/win/share_operation.cc
@@ -370,6 +370,13 @@ void ShareOperation::Run(blink::mojom::ShareService::ShareCallback callback) {
   DCHECK(!callback_);
   callback_ = std::move(callback);
 
+  // Ensure that the required WinRT functionality is available/loaded.
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    Complete(blink::mojom::ShareError::INTERNAL_ERROR);
+    return;
+  }
+
   // If the corresponding web_contents have already been cleaned up, cancel
   // the operation.
   if (!web_contents_) {
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
index 15f2def437648..91ba75dc1c86b 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
@@ -40,6 +40,11 @@ HRESULT GetDataTransferManagerHandles(
     HWND hwnd,
     IDataTransferManagerInterop** data_transfer_manager_interop,
     IDataTransferManager** data_transfer_manager) {
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return E_FAIL;
+  }
+
   // IDataTransferManagerInterop is semi-hidden behind a CloakedIid
   // structure on the DataTransferManager, excluding it from things
   // used by RoGetActivationFactory like GetIids(). Because of this,
diff --git a/chrome/browser/win/titlebar_config.cc b/chrome/browser/win/titlebar_config.cc
index f088a7071b1e0..cdfdf1d7ee102 100644
--- a/chrome/browser/win/titlebar_config.cc
+++ b/chrome/browser/win/titlebar_config.cc
@@ -4,23 +4,50 @@
 
 #include "chrome/browser/win/titlebar_config.h"
 
+#include <Windows.h>
+#include "base/command_line.h"
 #include "base/win/windows_version.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/common/chrome_switches.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/native_theme/native_theme.h"
 
-// Allows the titlebar to be drawn by the system using the Mica material
-// on Windows 11, version 22H2 and above.
-BASE_FEATURE(kWindows11MicaTitlebar,
-             "Windows11MicaTitlebar",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+bool ShouldCustomDrawSystemTitlebar() {
+  // Some extra code added here because those with pre-win8 and no DWM will have
+  // to fallback on the custom titlebar.
+  BOOL result = FALSE;
+
+  typedef HRESULT(WINAPI * DwmIsCompositionEnabledFunc)(BOOL * enabled);
+  DwmIsCompositionEnabledFunc func_ = nullptr;
+
+  HMODULE dwmapi_library_ = LoadLibraryW(L"dwmapi.dll");
+  if (dwmapi_library_) {
+    func_ = reinterpret_cast<DwmIsCompositionEnabledFunc>(
+        GetProcAddress(dwmapi_library_, "DwmIsCompositionEnabled"));
+  } else {
+    return true;
+  }
+
+  if (func_) {
+    func_(&result);
+  } else {
+    return true;
+  }
+  // Cache flag lookup.
+  static const bool custom_titlebar_disabled =
+      base::CommandLine::InitializedForCurrentProcess() &&
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableWindows10CustomTitlebar);
+
+  return (!custom_titlebar_disabled &&
+          base::win::GetVersion() >= base::win::Version::WIN10) ||
+         !result;
+}
 
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view) {
-  return !ShouldDefaultThemeUseMicaTitlebar() ||
-         !ThemeServiceFactory::GetForProfile(browser_view->GetProfile())
-              ->UsingSystemTheme() ||
+  return ShouldCustomDrawSystemTitlebar() ||
          (!browser_view->browser()->is_type_normal() &&
           !browser_view->browser()->is_type_popup() &&
           !browser_view->browser()->is_type_devtools());
@@ -28,12 +55,19 @@ bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view) {
 
 bool ShouldDefaultThemeUseMicaTitlebar() {
   return SystemTitlebarCanUseMicaMaterial() &&
-         !ui::AccentColorObserver::Get()->use_dwm_frame_color() &&
+         !ui::AccentColorObserver::Get()->accent_color().has_value() &&
          !ui::NativeTheme::GetInstanceForNativeUi()
               ->UserHasContrastPreference();
 }
 
 bool SystemTitlebarCanUseMicaMaterial() {
-  return base::win::GetVersion() >= base::win::Version::WIN11_22H2 &&
-         base::FeatureList::IsEnabled(kWindows11MicaTitlebar);
+  return false;
+}
+
+bool ShouldBrowserUseMicaTitlebar(class BrowserView*) {
+  return false;
+}
+
+bool SystemTitlebarSupportsDarkMode() {
+  return base::win::GetVersion() >= base::win::Version::WIN11;
 }
diff --git a/chrome/browser/win/titlebar_config.h b/chrome/browser/win/titlebar_config.h
index 48f413792d5aa..596d9ad041c21 100644
--- a/chrome/browser/win/titlebar_config.h
+++ b/chrome/browser/win/titlebar_config.h
@@ -10,10 +10,18 @@
 class BrowserView;
 
 BASE_DECLARE_FEATURE(kWindows11MicaTitlebar);
+BASE_DECLARE_FEATURE(kForceXpTheme);
 
 // Returns whether we should custom draw the titlebar for a browser window.
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view);
 
+// Returns whether we should always custom draw the system title bar.
+bool ShouldCustomDrawSystemTitlebar();
+
+// Returns whether we should use the Mica titlebar material for a browser
+// window.
+bool ShouldBrowserUseMicaTitlebar(BrowserView* browser_view);
+
 // Returns whether we should use the Mica titlebar in standard browser windows
 // using the default theme.
 bool ShouldDefaultThemeUseMicaTitlebar();
@@ -22,4 +30,7 @@ bool ShouldDefaultThemeUseMicaTitlebar();
 // material.
 bool SystemTitlebarCanUseMicaMaterial();
 
+// Returns whether the system-drawn titlebar can be drawn in dark mode.
+bool SystemTitlebarSupportsDarkMode();
+
 #endif  // CHROME_BROWSER_WIN_TITLEBAR_CONFIG_H_
diff --git a/chrome/chrome_elf/chrome_elf_security.cc b/chrome/chrome_elf/chrome_elf_security.cc
index ea44babfb52ea..045b3a6221712 100644
--- a/chrome/chrome_elf/chrome_elf_security.cc
+++ b/chrome/chrome_elf/chrome_elf_security.cc
@@ -82,6 +82,7 @@ class ExtensionPointDisableSet {
 }  // namespace
 
 void EarlyBrowserSecurity() {
+  typedef decltype(SetProcessMitigationPolicy)* SetProcessMitigationPolicyFunc;
   // This function is called from within DllMain.
   // Don't do anything naughty while we have the loader lock.
   NTSTATUS ret_val = STATUS_SUCCESS;
@@ -105,12 +106,20 @@ void EarlyBrowserSecurity() {
 
   nt::CloseRegKey(handle);
 
-  // Disable extension points (legacy hooking) in this process.
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  policy.DisableExtensionPoints = true;
-  SetProcessMitigationPolicy(ProcessExtensionPointDisablePolicy, &policy,
-                             sizeof(policy));
-  ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+  if (::IsWindows8OrGreater()) {
+    SetProcessMitigationPolicyFunc set_process_mitigation_policy =
+        reinterpret_cast<SetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "SetProcessMitigationPolicy"));
+    if (set_process_mitigation_policy) {
+      // Disable extension points in this process.
+      // (Legacy hooking.)
+      PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+      policy.DisableExtensionPoints = true;
+      set_process_mitigation_policy(ProcessExtensionPointDisablePolicy, &policy,
+                                    sizeof(policy));
+      ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+    }
+  }
 
   return;
 }
diff --git a/chrome/chrome_elf/hook_util/hook_util.cc b/chrome/chrome_elf/hook_util/hook_util.cc
index ce309c8b6888b..405014c15aad9 100644
--- a/chrome/chrome_elf/hook_util/hook_util.cc
+++ b/chrome/chrome_elf/hook_util/hook_util.cc
@@ -8,6 +8,9 @@
 #include <versionhelpers.h>  // windows.h must be before
 
 #include "base/win/pe_image.h"
+#include "chrome/chrome_elf/nt_registry/nt_registry.h"  // utils
+#include "sandbox/win/src/internal_types.h"
+#include "sandbox/win/src/service_resolver.h"
 
 namespace {
 
@@ -194,6 +197,46 @@ DWORD RemoveIATHook(void* intercept_function,
 
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed) {
+  // Create a thunk via the appropriate ServiceResolver instance.
+  sandbox::ServiceResolverThunk* thunk = nullptr;
+
+  // No hooking on unsupported OS versions.
+  if (!::IsWindows7OrGreater()) {
+    return thunk;
+  }
+
+  // Pseudo-handle, no need to close.
+  HANDLE current_process = ::GetCurrentProcess();
+
+#if defined(_WIN64)
+  // ServiceResolverThunk can handle all the formats in 64-bit (instead only
+  // handling one like it does in 32-bit versions).
+  thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+#else
+  BOOL is_wow64 = FALSE;
+  if (::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64) {
+    if (::IsWindows10OrGreater()) {
+      thunk = new sandbox::Wow64W10ResolverThunk(current_process, relaxed);
+    } else if (::IsWindows8OrGreater()) {
+      thunk = new sandbox::Wow64W8ResolverThunk(current_process, relaxed);
+    } else {
+      thunk = new sandbox::Wow64ResolverThunk(current_process, relaxed);
+    }
+  } else if (::IsWindows8OrGreater()) {
+    thunk = new sandbox::Win8ResolverThunk(current_process, relaxed);
+  } else {
+    thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+  }
+#endif
+
+  return thunk;
+}
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/hook_util/hook_util.h b/chrome/chrome_elf/hook_util/hook_util.h
index 9070b9d93a6f0..687042ec330c7 100644
--- a/chrome/chrome_elf/hook_util/hook_util.h
+++ b/chrome/chrome_elf/hook_util/hook_util.h
@@ -7,8 +7,20 @@
 
 #include <windows.h>
 
+namespace sandbox {
+class ServiceResolverThunk;
+}
+
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+// Creates a |ServiceResolverThunk| based on the OS version. Ownership of the
+// resulting thunk is passed to the caller.
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed);
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 8c62578d98c5f..3ad284e05463a 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -771,6 +771,10 @@ const char kMakeChromeDefault[] = "make-chrome-default";
 #endif  // BUILDFLAG(IS_MAC)
 
 #if BUILDFLAG(IS_WIN)
+// Disables custom-drawing the window titlebar on Windows 10.
+const char kDisableWindows10CustomTitlebar[] =
+    "disable-windows10-custom-titlebar";
+
 // Force-enables the profile shortcut manager. This is needed for tests since
 // they use a custom-user-data-dir which disables this.
 const char kEnableProfileShortcutManager[] = "enable-profile-shortcut-manager";
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index d06cebbece2da..a233435b771ac 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -244,6 +244,7 @@ extern const char kMakeChromeDefault[];
 #endif  // BUILDFLAG(IS_MAC)
 
 #if BUILDFLAG(IS_WIN)
+extern const char kDisableWindows10CustomTitlebar[];
 extern const char kEnableProfileShortcutManager[];
 extern const char kFromInstaller[];
 extern const char kHideIcons[];
diff --git a/chrome/installer/setup/install.cc b/chrome/installer/setup/install.cc
index 4ab0037456c8c..f459966796cf0 100644
--- a/chrome/installer/setup/install.cc
+++ b/chrome/installer/setup/install.cc
@@ -27,6 +27,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_params.h"
@@ -134,6 +135,7 @@ void ExecuteAndLogShortcutOperation(
   // For Start Menu shortcut creation on versions of Win10 that support
   // pinning, record whether or not the installer pinned Chrome.
   if (location == ShellUtil::SHORTCUT_LOCATION_START_MENU_ROOT &&
+      base::win::GetVersion() >= base::win::Version::WIN10 &&
       CanPinShortcutToTaskbar()) {
     SetInstallerPinnedChromeToTaskbar(properties.pin_to_taskbar && pinned);
   }
diff --git a/chrome/installer/util/install_util.cc b/chrome/installer/util/install_util.cc
index 5efc79e743383..1bf0bf47f68e4 100644
--- a/chrome/installer/util/install_util.cc
+++ b/chrome/installer/util/install_util.cc
@@ -242,10 +242,10 @@ base::Version InstallUtil::GetCriticalUpdateVersion() {
 }
 
 bool InstallUtil::IsOSSupported() {
-  // We do not support anything prior to Windows 10.
+  // We do not support anything prior to Windows Vista.
   VLOG(1) << base::SysInfo::OperatingSystemName() << ' '
           << base::SysInfo::OperatingSystemVersion();
-  return base::win::GetVersion() >= base::win::Version::WIN10;
+  return base::win::GetVersion() >= base::win::Version::VISTA;
 }
 
 void InstallUtil::AddInstallerResultItems(bool system_install,
diff --git a/chrome/installer/util/shell_util.cc b/chrome/installer/util/shell_util.cc
index 595d30a92a099..b38aea64292a3 100644
--- a/chrome/installer/util/shell_util.cc
+++ b/chrome/installer/util/shell_util.cc
@@ -304,39 +304,41 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
     entries->back()->set_removal_flag(RegistryEntry::RemovalFlag::VALUE);
   }
 
-  // The following entries are required but do not depend on the DelegateExecute
-  // verb handler being set.
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
-  }
+  // The following entries are required as of Windows 8, but do not
+  // depend on the DelegateExecute verb handler being set.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
 
-  // Add \Software\Classes\<prog_id>\Application entries
-  std::wstring application_path(prog_id_path + ShellUtil::kRegApplication);
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        application_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
-  }
-  if (!app_info.application_icon_path.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        application_path, ShellUtil::kRegApplicationIcon,
-        ShellUtil::FormatIconLocation(app_info.application_icon_path,
-                                      app_info.application_icon_index)));
-  }
-  if (!app_info.application_name.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        application_path, ShellUtil::kRegApplicationName,
-        app_info.application_name));
-  }
-  if (!app_info.application_description.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        application_path, ShellUtil::kRegApplicationDescription,
-        app_info.application_description));
-  }
-  if (!app_info.publisher_name.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        application_path, ShellUtil::kRegApplicationCompany,
-        app_info.publisher_name));
+    // Add \Software\Classes\<prog_id>\Application entries
+    std::wstring application_path(prog_id_path + ShellUtil::kRegApplication);
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          application_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
+    if (!app_info.application_icon_path.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          application_path, ShellUtil::kRegApplicationIcon,
+          ShellUtil::FormatIconLocation(app_info.application_icon_path,
+                                        app_info.application_icon_index)));
+    }
+    if (!app_info.application_name.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          application_path, ShellUtil::kRegApplicationName,
+          app_info.application_name));
+    }
+    if (!app_info.application_description.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          application_path, ShellUtil::kRegApplicationDescription,
+          app_info.application_description));
+    }
+    if (!app_info.publisher_name.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          application_path, ShellUtil::kRegApplicationCompany,
+          app_info.publisher_name));
+    }
   }
 }
 
@@ -751,11 +753,12 @@ bool QuickIsChromeRegisteredForMode(
   }
   reg_key += ShellUtil::kRegShellOpen;
 
-  // ProgId and shell integration registrations are allowed to reside in HKCU
-  // for user-level installs, and values there have priority over values in
-  // HKLM.
+  // ProgId registrations are allowed to reside in HKCU for user-level installs
+  // (and values there have priority over values in HKLM). The same is true for
+  // shell integration entries as of Windows 8.
   if (confirmation_level == CONFIRM_PROGID_REGISTRATION ||
-      confirmation_level == CONFIRM_SHELL_REGISTRATION) {
+      (confirmation_level == CONFIRM_SHELL_REGISTRATION &&
+       base::win::GetVersion() >= base::win::Version::WIN8)) {
     const RegKey key_hkcu(HKEY_CURRENT_USER, reg_key.c_str(), KEY_QUERY_VALUE);
     std::wstring hkcu_value;
     // If |reg_key| is present in HKCU, assert that it points to |chrome_exe|.
@@ -830,7 +833,9 @@ bool GetInstallationSpecificSuffix(const base::FilePath& chrome_exe,
 // be placed for this install. As of Windows 8 everything can go in HKCU for
 // per-user installs.
 HKEY DetermineRegistrationRoot(bool is_per_user) {
-  return is_per_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
+  return is_per_user && base::win::GetVersion() >= base::win::Version::WIN8
+             ? HKEY_CURRENT_USER
+             : HKEY_LOCAL_MACHINE;
 }
 
 // Associates Chrome with supported protocols and file associations. This should
@@ -1049,6 +1054,7 @@ ShellUtil::DefaultState ProbeProtocolHandlers(const base::FilePath& chrome_exe,
 // Returns true on success.
 bool GetAppShortcutsFolder(ShellUtil::ShellChange level, base::FilePath* path) {
   DCHECK(path);
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
 
   base::FilePath folder;
   if (!base::PathService::Get(base::DIR_APP_SHORTCUTS, &folder)) {
@@ -1429,6 +1435,7 @@ bool RegisterChromeBrowserImpl(const base::FilePath& chrome_exe,
 bool RegisterApplicationForProtocols(const std::vector<std::wstring>& protocols,
                                      const std::wstring& prog_id,
                                      const base::FilePath& chrome_exe) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
   std::vector<std::unique_ptr<RegistryEntry>> entries;
   ShellUtil::ApplicationInfo app_info =
       ShellUtil::GetApplicationInfoForProgId(prog_id);
@@ -1790,10 +1797,12 @@ bool ShellUtil::ShortcutLocationIsSupported(ShortcutLocation location) {
     case SHORTCUT_LOCATION_START_MENU_ROOT:                   // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_DIR_DEPRECATED:  // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR:        // Falls through.
-    case SHORTCUT_LOCATION_STARTUP:                           // Falls through.
-    case SHORTCUT_LOCATION_TASKBAR_PINS:                      // Falls through.
-    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+    case SHORTCUT_LOCATION_STARTUP:
       return true;
+    case SHORTCUT_LOCATION_TASKBAR_PINS:
+      return base::win::GetVersion() >= base::win::Version::WIN7;
+    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+      return base::win::GetVersion() >= base::win::Version::WIN8;
     default:
       NOTREACHED();
       return false;
@@ -2812,16 +2821,19 @@ bool ShellUtil::AddAppProtocolAssociations(
     if (!AddRegistryEntries(HKEY_CURRENT_USER, entries))
       success = false;
 
-    // Removing the existing user choice for a given protocol forces Windows to
-    // present a disambiguation dialog the next time this protocol is invoked
-    // from the OS.
-    std::unique_ptr<RegistryEntry> entry = GetProtocolUserChoiceEntry(protocol);
-    if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
-                                        WorkItem::kWow64Default, kRegProgId)) {
-      success = false;
+    // On Windows 10, removing the existing user choice for a given protocol
+    // forces Windows to present a disambiguation dialog the next time this
+    // protocol is invoked from the OS.
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      std::unique_ptr<RegistryEntry> entry =
+          GetProtocolUserChoiceEntry(protocol);
+      if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
+                                          WorkItem::kWow64Default,
+                                          kRegProgId)) {
+        success = false;
+      }
     }
   }
-
   return success;
 }
 
diff --git a/chrome/services/util_win/processor_metrics.cc b/chrome/services/util_win/processor_metrics.cc
index 29c5bb2dd47f4..84c5d865520b2 100644
--- a/chrome/services/util_win/processor_metrics.cc
+++ b/chrome/services/util_win/processor_metrics.cc
@@ -7,7 +7,6 @@
 #include <objbase.h>
 #include <sysinfoapi.h>
 #include <wbemidl.h>
-#include <winbase.h>
 #include <wrl/client.h>
 
 #include "base/metrics/histogram_functions.h"
@@ -110,63 +109,37 @@ void RecordCetAvailability() {
           ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"),
                            "IsUserCetAvailableInEnvironment"));
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
   if (is_user_cet_available_in_environment) {
     available = is_user_cet_available_in_environment(
         USER_CET_ENVIRONMENT_WIN32_PROCESS);
   }
   base::UmaHistogramBoolean("Windows.CetAvailable", available);
 
-  if (available) {
+  if (available && get_process_mitigation_policy) {
     PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {0};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                     ProcessUserShadowStackPolicy, &policy,
-                                     sizeof(policy))) {
+    if (get_process_mitigation_policy(GetCurrentProcess(),
+                                      ProcessUserShadowStackPolicy, &policy,
+                                      sizeof(policy))) {
       base::UmaHistogramBoolean("Windows.CetEnabled",
                                 policy.EnableUserShadowStack);
     }
   }
 }
 
-void RecordEnclaveAvailabilityInternal(base::StringPiece type,
-                                       DWORD enclave_type) {
-  // This API does not appear to be exported from kernel32.dll on
-  // Windows 10.0.10240.
-  static auto is_enclave_type_supported_func =
-      reinterpret_cast<decltype(&IsEnclaveTypeSupported)>(::GetProcAddress(
-          ::GetModuleHandleW(L"kernel32.dll"), "IsEnclaveTypeSupported"));
-
-  bool is_supported = false;
-
-  if (is_enclave_type_supported_func) {
-    is_supported = is_enclave_type_supported_func(enclave_type);
-  }
-
-  base::UmaHistogramBoolean(
-      base::StrCat({"Windows.Enclave.", type, ".Available"}), is_supported);
-}
-
-void RecordEnclaveAvailability() {
-  RecordEnclaveAvailabilityInternal("SGX", ENCLAVE_TYPE_SGX);
-  RecordEnclaveAvailabilityInternal("SGX2", ENCLAVE_TYPE_SGX2);
-  RecordEnclaveAvailabilityInternal("VBS", ENCLAVE_TYPE_VBS);
-  RecordEnclaveAvailabilityInternal("VBSBasic", ENCLAVE_TYPE_VBS_BASIC);
-}
-
 void RecordProcessorMetrics() {
-  // These metrics do not require a WMI connection.
-  RecordCetAvailability();
-  RecordEnclaveAvailability();
-
-  {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-    ComPtr<IWbemServices> wmi_services;
-    if (!base::win::CreateLocalWmiConnection(true, &wmi_services)) {
-      return;
-    }
-    RecordProcessorMetricsFromWMI(wmi_services);
-    RecordHypervStatusFromWMI(wmi_services);
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+  ComPtr<IWbemServices> wmi_services;
+  if (!base::win::CreateLocalWmiConnection(true, &wmi_services)) {
+    return;
   }
+  RecordProcessorMetricsFromWMI(wmi_services);
+  RecordHypervStatusFromWMI(wmi_services);
+  RecordCetAvailability();
 }
 
 }  // namespace
diff --git a/chrome/test/base/test_browser_window.cc b/chrome/test/base/test_browser_window.cc
index 25088d8a0343b..59513c58fa6bf 100644
--- a/chrome/test/base/test_browser_window.cc
+++ b/chrome/test/base/test_browser_window.cc
@@ -107,9 +107,7 @@ const ui::ColorProvider* TestBrowserWindow::GetColorProvider() const {
   return ui::ColorProviderManager::Get().GetColorProviderFor(
       {ui::ColorProviderKey::ColorMode::kLight,
        ui::ColorProviderKey::ContrastMode::kNormal, ui::SystemTheme::kDefault,
-       ui::ColorProviderKey::FrameType::kChromium,
-       ui::ColorProviderKey::FrameStyle::kDefault,
-       ui::ColorProviderKey::UserColorSource::kAccent});
+       ui::ColorProviderKey::FrameType::kChromium});
 }
 
 ui::ElementContext TestBrowserWindow::GetElementContext() {
@@ -415,4 +413,4 @@ TestBrowserWindowOwner::~TestBrowserWindowOwner() {
 void TestBrowserWindowOwner::OnBrowserRemoved(Browser* browser) {
   if (browser->window() == window_.get())
     delete this;
-}
+}
\ No newline at end of file
diff --git a/chrome/updater/net/network_fetcher_win.cc b/chrome/updater/net/network_fetcher_win.cc
index e28cbd8a7d622..d751a153cb3b8 100644
--- a/chrome/updater/net/network_fetcher_win.cc
+++ b/chrome/updater/net/network_fetcher_win.cc
@@ -19,8 +19,10 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/sequence_checker.h"
 #include "base/strings/sys_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "chrome/updater/policy/service.h"
 #include "chrome/updater/util/win_util.h"
+#include "chrome/updater/win/scoped_impersonation.h"
 #include "chrome/updater/win/user_info.h"
 #include "components/update_client/network.h"
 #include "components/winhttp/network_fetcher.h"
@@ -32,6 +34,57 @@
 namespace updater {
 namespace {
 
+std::wstring FromCharOrEmpty(const wchar_t* str) {
+  return str ? std::wstring(str) : std::wstring();
+}
+
+// Wrapper for WINHTTP_CURRENT_USER_IE_PROXY_CONFIG structure.
+// According to MSDN, callers must free strings with GlobalFree.
+class ScopedIeProxyConfig {
+ public:
+  ScopedIeProxyConfig();
+  ScopedIeProxyConfig(const ScopedIeProxyConfig&) = delete;
+  ScopedIeProxyConfig& operator=(const ScopedIeProxyConfig&) = delete;
+  ~ScopedIeProxyConfig();
+
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* receive() { return &ie_proxy_config_; }
+
+  bool auto_detect() const { return ie_proxy_config_.fAutoDetect; }
+  std::wstring auto_config_url() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszAutoConfigUrl);
+  }
+  std::wstring proxy() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxy);
+  }
+  std::wstring proxy_bypass() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxyBypass);
+  }
+
+ private:
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG ie_proxy_config_ = {};
+};
+
+ScopedIeProxyConfig::ScopedIeProxyConfig() {
+  ie_proxy_config_.fAutoDetect = false;
+  ie_proxy_config_.lpszAutoConfigUrl = nullptr;
+  ie_proxy_config_.lpszProxy = nullptr;
+  ie_proxy_config_.lpszProxyBypass = nullptr;
+}
+
+ScopedIeProxyConfig::~ScopedIeProxyConfig() {
+  if (ie_proxy_config_.lpszAutoConfigUrl) {
+    ::GlobalFree(ie_proxy_config_.lpszAutoConfigUrl);
+  }
+
+  if (ie_proxy_config_.lpszProxy) {
+    ::GlobalFree(ie_proxy_config_.lpszProxy);
+  }
+
+  if (ie_proxy_config_.lpszProxyBypass) {
+    ::GlobalFree(ie_proxy_config_.lpszProxyBypass);
+  }
+}
+
 // Factory method for the proxy configuration strategy.
 scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
     absl::optional<PolicyServiceProxyConfiguration>
@@ -48,7 +101,32 @@ scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
 
   VLOG(1) << "Using the system configuration for proxy.";
 
-  return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+  const base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  const bool supports_automatic_proxy =
+      os_info->version() >= base::win::Version::WIN8_1;
+  if (supports_automatic_proxy) {
+    return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+  }
+
+  ScopedImpersonation impersonate_user;
+  if (IsLocalSystemUser()) {
+    VLOG(2) << "Running as SYSTEM, impersonate the current user.";
+    base::win::ScopedHandle user_token = GetUserTokenFromCurrentSessionId();
+    if (user_token.IsValid()) {
+      impersonate_user.Impersonate(user_token.Get());
+    }
+  }
+
+  ScopedIeProxyConfig ie_proxy_config;
+  if (::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config.receive())) {
+    return base::MakeRefCounted<winhttp::ProxyConfiguration>(winhttp::ProxyInfo{
+        ie_proxy_config.auto_detect(), ie_proxy_config.auto_config_url(),
+        ie_proxy_config.proxy(), ie_proxy_config.proxy_bypass()});
+  } else {
+    PLOG(ERROR) << "Failed to get proxy for current user";
+  }
+
+  return base::MakeRefCounted<winhttp::ProxyConfiguration>();
 }
 
 class NetworkFetcher : public update_client::NetworkFetcher {
diff --git a/chrome/updater/win/installer/installer.cc b/chrome/updater/win/installer/installer.cc
index 070562390b2a1..a9772b5ef3903 100644
--- a/chrome/updater/win/installer/installer.cc
+++ b/chrome/updater/win/installer/installer.cc
@@ -343,7 +343,7 @@ ProcessExitResult InstallerMain(HMODULE module) {
   CHECK(EnableSecureDllLoading());
   EnableProcessHeapMetadataProtection();
 
-  if (base::win::GetVersion() < base::win::Version::WIN10) {
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
     return ProcessExitResult(UNSUPPORTED_WINDOWS_VERSION);
   }
 
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index c957a691efcac..9304bb2711923 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -88,13 +88,47 @@ int GetPreRS5UniversalApiContractVersion() {
     return 6;
   }
   // The list above should account for all Windows versions prior to
-  // RS5.
-  NOTREACHED();
+  // RS5. 0 represents all pre-Win10 releases.
+  return 0;
+}
+
+int GetLegacyWindowsVersion() {
+  // The User Agent Client Hints specification indicates that Windows 7
+  // through 8.x should be handled as having a major version of 0 while using
+  // the OS' minor version. (i.e. Windows 7 is 0.1). This does not account for
+  // how to handle Windows Vista and below. As a result, Vista will report as
+  // 0.60 and NT 5.x as 0.5x.
+  // TODO: introduce UA-CH spoofer to avoid any undesirable impacts of having
+  // the "wrong" values in future.
+  const base::win::Version version = base::win::OSInfo::Kernel32Version();
+  if (version == base::win::Version::WIN8_1) {
+    return 3;
+  }
+  if (version == base::win::Version::WIN8) {
+    return 2;
+  }
+  if (version == base::win::Version::WIN7) {
+    return 1;
+  }
+  if (version == base::win::Version::VISTA) {
+    return 60;
+  }
+  if (version == base::win::Version::SERVER_2003) {
+    return 52;
+  }
+  if (version == base::win::Version::XP) {
+    return 51;
+  }
+  if (version == base::win::Version::PRE_XP) {
+    return 50;
+  }
   return 0;
 }
 
 // Returns the UniversalApiContract version number, which is available for
-// Windows versions greater than RS5. Otherwise, returns 0.
+// Windows versions greater than RS5. Otherwise, returns a version value
+// representing the Windows version (non-zero major version for early Windows
+// 10, non-zero minor version for pre-Windows 10).
 const std::string& GetUniversalApiContractVersion() {
   // Do not use this for runtime environment detection logic. This method should
   // only be used to help populate the Sec-CH-UA-Platform client hint. If
@@ -108,6 +142,7 @@ const std::string& GetUniversalApiContractVersion() {
         if (base::win::OSInfo::Kernel32Version() <=
             base::win::Version::WIN10_RS4) {
           major_version = GetPreRS5UniversalApiContractVersion();
+          minor_version = GetLegacyWindowsVersion();
         } else {
           base::win::RegKey version_key(
               HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
diff --git a/components/metrics/motherboard.cc b/components/metrics/motherboard.cc
index 4b2270d10a86d..053529d4973f6 100644
--- a/components/metrics/motherboard.cc
+++ b/components/metrics/motherboard.cc
@@ -16,6 +16,7 @@
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
 
+#include "base/scoped_native_library.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/scoped_bstr.h"
@@ -142,7 +143,21 @@ void ReadWin32Bios(const ComPtr<IWbemServices>& services,
 
 void ReadFirmwareType(absl::optional<Motherboard::BiosType>* bios_type) {
   FIRMWARE_TYPE firmware_type = FirmwareTypeUnknown;
-  if (::GetFirmwareType(&firmware_type)) {
+  // NOTE: GetFirmwareType API only exists on >= Win8.  Dynamically
+  //       get function handle.
+  using GetFirmwareTypeFunction = decltype(&GetFirmwareType);
+  base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+  if (!dll.is_valid()) {
+    return;
+  }
+  GetFirmwareTypeFunction get_firmware_type_function =
+      reinterpret_cast<GetFirmwareTypeFunction>(
+          dll.GetFunctionPointer("GetFirmwareType"));
+  if (!get_firmware_type_function) {
+    return;
+  }
+
+  if (get_firmware_type_function(&firmware_type)) {
     if (firmware_type == FirmwareTypeBios) {
       *bios_type = Motherboard::BiosType::kLegacy;
     } else if (firmware_type == FirmwareTypeUefi) {
diff --git a/components/system_media_controls/win/system_media_controls_win.cc b/components/system_media_controls/win/system_media_controls_win.cc
index 8e6430f0832db..9291a58c2c003 100644
--- a/components/system_media_controls/win/system_media_controls_win.cc
+++ b/components/system_media_controls/win/system_media_controls_win.cc
@@ -9,11 +9,6 @@
 #include <wrl/client.h>
 #include <wrl/event.h>
 
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
 #include "base/strings/string_piece.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/core_winrt_util.h"
@@ -91,6 +86,11 @@ bool SystemMediaControlsWin::Initialize() {
 
   attempted_to_initialize_ = true;
 
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
   Microsoft::WRL::ComPtr<ISystemMediaTransportControlsInterop> interop;
   HRESULT hr = base::win::GetActivationFactory<
       ISystemMediaTransportControlsInterop,
diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index 6600e576a857f..6259f4a0754e9 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,6 +20,10 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,16 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
+#elif BUILDFLAG(IS_ANDROID)
+    // On Android we run a Finch experiment testing direct memory allocation.
+    config.force_direct_shared_memory_allocation = base::FeatureList::IsEnabled(
+        mojo::core::kMojoDirectSharedMemoryAndroid);
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 755bfcc4ed84f..62f903c01695c 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2831,6 +2831,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/legacy_render_widget_host_win.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index fa8f475c71a2d..ef8188f764e21 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -192,6 +192,7 @@
 #include <windows.h>
 
 #include "base/threading/platform_thread_win.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
@@ -997,6 +998,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/installedapp/installed_app_provider_impl_win.cc b/content/browser/installedapp/installed_app_provider_impl_win.cc
index e02f9dc5251cc..2957aa6b07971 100644
--- a/content/browser/installedapp/installed_app_provider_impl_win.cc
+++ b/content/browser/installedapp/installed_app_provider_impl_win.cc
@@ -112,6 +112,12 @@ void FilterInstalledAppsForWin(
     std::vector<blink::mojom::RelatedApplicationPtr> related_apps,
     blink::mojom::InstalledAppProvider::FilterInstalledAppsCallback callback,
     const GURL frame_url) {
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload() ||
+      !base::win::ResolveCoreWinRTDelayload()) {
+    std::move(callback).Run(std::vector<blink::mojom::RelatedApplicationPtr>());
+    return;
+  }
+
   ComPtr<ILauncherStatics4> launcher_statics;
   HRESULT hr = base::win::RoActivateInstance(
       base::win::ScopedHString::Create(RuntimeClass_Windows_System_Launcher)
diff --git a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
index b141cfe3cc2e6..056b5adb55b24 100644
--- a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
+++ b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
@@ -12,6 +12,7 @@
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox_policy.h"
@@ -34,9 +35,12 @@ bool PpapiPluginSandboxedProcessLauncherDelegate::InitializeConfig(
   // create the server side of Chrome pipes.
   sandbox::ResultCode result;
 #if !defined(NACL_WIN64)
-  result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
-  if (result != sandbox::SBOX_ALL_OK) {
-    return false;
+  // We don't support PPAPI win32k lockdown prior to Windows 10.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
+    if (result != sandbox::SBOX_ALL_OK) {
+      return false;
+    }
   }
 #endif  // !defined(NACL_WIN64)
 
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index b04194c32a4d1..ad51d5b66318a 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,11 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    return nullptr;
+  }
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +47,11 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    return nullptr;
+  }
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
@@ -173,9 +184,12 @@ void DirectManipulationHelper::OnPointerHitTest(WPARAM w_param) {
   // For WM_POINTER, the pointer type will show the event from mouse.
   // For WM_POINTERACTIVATE, the pointer id will be different with the following
   // message.
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(pointer_id, &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     viewport_->SetContact(pointer_id);
   }
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..9df2e08a91a7f
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,773 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  if (!collection_) {
+    return;
+  }
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (UNLIKELY(slow_down_mode_for_testing == SlowDownMode::kDelayEachTask)) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (UNLIKELY(slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask) &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..cee91dd4e059b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index 90ee5a4f433c8..633093dd54c3c 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -36,6 +36,9 @@
 #include "third_party/abseil-cpp/absl/utility/utility.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/ports/SkTypeface_win.h"
 #include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/text_analysis_source.h"
 
@@ -446,6 +449,40 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -542,7 +579,55 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {
+  InitializeDirectWrite();
+  callback = mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+      std::move(callback),
+      blink::mojom::FallbackFamilyAndStyle::New("",
+                                                /* weight */ 0,
+                                                /* width */ 0,
+                                                /* slant */ 0));
+
+  if (!codepoint || !collection_ || !factory_) {
+    return;
+  }
+
+  sk_sp<SkFontMgr> font_mgr(
+      SkFontMgr_New_DirectWrite(factory_.Get(), collection_.Get()));
+
+  if (!font_mgr) {
+    return;
+  }
+
+  const char* bcp47_locales[] = {locale_name.c_str()};
+  int num_locales = locale_name.empty() ? 0 : 1;
+  const char** locales = locale_name.empty() ? nullptr : bcp47_locales;
+
+  sk_sp<SkTypeface> typeface(font_mgr->matchFamilyStyleCharacter(
+      base_family_name.c_str(), SkFontStyle(), locales, num_locales,
+      codepoint));
+
+  if (!typeface) {
+    return;
+  }
+
+  SkString family_name;
+  typeface->getFamilyName(&family_name);
+
+  SkFontStyle font_style = typeface->fontStyle();
+
+  auto result_fallback_and_style = blink::mojom::FallbackFamilyAndStyle::New(
+      family_name.c_str(), font_style.weight(), font_style.width(),
+      font_style.slant());
+  std::move(callback).Run(std::move(result_fallback_and_style));
+}
+
 void DWriteFontProxyImpl::InitializeDirectWrite() {
+  HRESULT hr;
   if (direct_write_initialized_)
     return;
   direct_write_initialized_ = true;
@@ -556,20 +641,28 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
-  // Normally identical to factory_->GetSystemFontCollection() unless a
-  // sideloaded font has been added using SideLoadFontForTesting().
-  HRESULT hr = GetLocalFontCollection(factory3_, &collection_);
-  DCHECK(SUCCEEDED(hr));
+  // On Windows 10 and up (or Vista exkernel/Windows 8.x with modified
+  // dwrite.dll from 1809) you can take advantage of the extended DirectWrite
+  // APIs to sideload local fonts in addition to system fonts. But if
+  // IDWriteFactory3 is unavailable, fall back to GetSystemFontCollection.
+  // TODO: make DirectWrite optional for the benefit of the NT 5 users.
+
+  if (factory3_ == nullptr) {
+    hr = factory_->GetSystemFontCollection(&collection_);
+    DCHECK(SUCCEEDED(hr));
+  } else {
+    hr = GetLocalFontCollection(factory3_, &collection_);
+    DCHECK(SUCCEEDED(hr));
+  }
 
   if (!collection_) {
     return;
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index 421d471aaa6e1..3beaa0fb58fef 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_message_filter.h"
 #include "content/public/browser/browser_thread.h"
@@ -63,6 +64,20 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
   void InitializeDirectWrite();
 
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 522868ab9b0e6..36ce4866d9e7a 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3465,6 +3465,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kRendererWaitForJavaDebugger,
 #endif
 #if BUILDFLAG(IS_WIN)
+    switches::kDisableDirectWrite,
     switches::kDisableHighResTimer,
     switches::kTrySupportedChannelLayouts,
     switches::kRaiseTimerFrequency,
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
index a529ad9aac0b9..c5f4c167d7194 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
@@ -79,7 +79,8 @@ void InitializeDWriteFontProxy() {
 
   skia::OverrideDefaultSkFontMgr(std::move(skia_font_manager));
 
-  DCHECK(g_font_fallback);
+  blink::WebFontRendering::SetUseSkiaFontFallback(g_font_fallback ? true
+                                                                  : false);
 }
 
 void UninitializeDWriteFontProxy() {
diff --git a/content/common/sandbox_init_win.cc b/content/common/sandbox_init_win.cc
index 498f60227d13e..724ce1120b720 100644
--- a/content/common/sandbox_init_win.cc
+++ b/content/common/sandbox_init_win.cc
@@ -17,6 +17,7 @@
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace content {
 
diff --git a/content/ppapi_plugin/ppapi_plugin_main.cc b/content/ppapi_plugin/ppapi_plugin_main.cc
index 89e84b2c25c52..8af071d123a33 100644
--- a/content/ppapi_plugin/ppapi_plugin_main.cc
+++ b/content/ppapi_plugin/ppapi_plugin_main.cc
@@ -172,7 +172,12 @@ int PpapiPluginMain(MainFunctionParams parameters) {
 #if BUILDFLAG(IS_WIN)
   if (!base::win::IsUser32AndGdi32Available())
     gfx::win::InitializeDirectWrite();
-  InitializeDWriteFontProxy();
+  bool use_direct_write = gfx::win::IsDirectWriteEnabled();
+  if (use_direct_write) {
+    InitializeDWriteFontProxy();
+  }
+
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   int antialiasing_enabled = 1;
   base::StringToInt(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index a0d56a9a24f22..8b0f9ac748100 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -731,6 +731,10 @@ std::string ContentBrowserClient::GetDefaultDownloadName() {
   return std::string();
 }
 
+base::FilePath ContentBrowserClient::GetFontLookupTableCacheDir() {
+  return base::FilePath();
+}
+
 base::FilePath ContentBrowserClient::GetShaderDiskCacheDirectory() {
   return base::FilePath();
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index a6e922be7e686..869cc3bc8eb14 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1163,6 +1163,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // else we should do with the file.
   virtual std::string GetDefaultDownloadName();
 
+  // Returns the path to the font lookup table cache directory in which - on
+  // Windows 7 & 8 - we cache font name meta information to perform @font-face {
+  // src: local() } lookups.
+  virtual base::FilePath GetFontLookupTableCacheDir();
+
   // Returns the path to the browser shader disk cache root.
   virtual base::FilePath GetShaderDiskCacheDirectory();
 
diff --git a/content/renderer/renderer_main_platform_delegate_win.cc b/content/renderer/renderer_main_platform_delegate_win.cc
index 7a493adbd504c..2430e7048c6f6 100644
--- a/content/renderer/renderer_main_platform_delegate_win.cc
+++ b/content/renderer/renderer_main_platform_delegate_win.cc
@@ -27,6 +27,18 @@
 #include "ui/gfx/win/direct_write.h"
 
 namespace content {
+namespace {
+
+// Windows-only skia sandbox support
+// These are used for GDI-path rendering.
+void SkiaPreCacheFont(const LOGFONT& logfont) {
+  RenderThread* render_thread = RenderThread::Get();
+  if (render_thread) {
+    render_thread->PreCacheFont(logfont);
+  }
+}
+
+}  // namespace
 
 RendererMainPlatformDelegate::RendererMainPlatformDelegate(
     const MainFunctionParams& parameters)
@@ -43,6 +55,15 @@ void RendererMainPlatformDelegate::PlatformInitialize() {
   bool no_sandbox =
       command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
 
+  bool use_direct_write = gfx::win::ShouldUseDirectWrite();
+
+  if (use_direct_write) {
+    InitializeDWriteFontProxy();
+  } else {
+    SkTypeface_SetEnsureLOGFONTAccessibleProc(SkiaPreCacheFont);
+  }
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
+
   if (!no_sandbox) {
     // ICU DateFormat class (used in base/time_format.cc) needs to get the
     // Olson timezone ID by accessing the registry keys under
diff --git a/content/shell/browser/shell_content_browser_client.cc b/content/shell/browser/shell_content_browser_client.cc
index c1834434b9e7d..aaaf76948394e 100644
--- a/content/shell/browser/shell_content_browser_client.cc
+++ b/content/shell/browser/shell_content_browser_client.cc
@@ -17,6 +17,7 @@
 #include "base/containers/cxx20_erase.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
+#include "base/features.h"
 #include "base/files/file.h"
 #include "base/files/file_util.h"
 #include "base/functional/callback_helpers.h"
@@ -450,6 +451,11 @@ std::string ShellContentBrowserClient::GetDefaultDownloadName() {
   return "download";
 }
 
+base::FilePath ShellContentBrowserClient::GetFontLookupTableCacheDir() {
+  return browser_context()->GetPath().Append(
+      FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 std::unique_ptr<WebContentsViewDelegate>
 ShellContentBrowserClient::GetWebContentsViewDelegate(
     WebContents* web_contents) {
@@ -513,7 +519,8 @@ void ShellContentBrowserClient::OverrideWebkitPrefs(
     WebContents* web_contents,
     blink::web_pref::WebPreferences* prefs) {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode)) {
+          switches::kForceDarkMode) ||
+      base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag)) {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kDark;
   } else {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kLight;
diff --git a/content/shell/browser/shell_content_browser_client.h b/content/shell/browser/shell_content_browser_client.h
index 32966a5dcf3e6..0c610a076da5e 100644
--- a/content/shell/browser/shell_content_browser_client.h
+++ b/content/shell/browser/shell_content_browser_client.h
@@ -87,6 +87,7 @@ class ShellContentBrowserClient : public ContentBrowserClient {
       override;
   void OverrideWebkitPrefs(WebContents* web_contents,
                            blink::web_pref::WebPreferences* prefs) override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   std::unique_ptr<content::DevToolsManagerDelegate>
   CreateDevToolsManagerDelegate() override;
   void ExposeInterfacesToRenderer(
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index bed299f10f56f..831be9c7ef7df 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -146,6 +146,21 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {}
+
+void FakeFontCollection::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {}
+
+void FakeFontCollection::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {}
+
+void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {}
+
 FakeFontCollection::~FakeFontCollection() = default;
 
 }  // namespace content
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index e5c7230ffcaad..223e1546a197d 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,17 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
  private:
   std::vector<FakeFont> fonts_;
diff --git a/content/web_test/browser/web_test_control_host.cc b/content/web_test/browser/web_test_control_host.cc
index 60bc586693ed0..5f0fa24bd59b4 100644
--- a/content/web_test/browser/web_test_control_host.cc
+++ b/content/web_test/browser/web_test_control_host.cc
@@ -20,6 +20,7 @@
 #include "base/base64.h"
 #include "base/command_line.h"
 #include "base/containers/contains.h"
+#include "base/features.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
 #include "base/functional/callback_helpers.h"
@@ -772,7 +773,8 @@ void WebTestControlHost::OverrideWebkitPrefs(
     ApplyWebTestDefaultPreferences(prefs);
   }
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode)) {
+          switches::kForceDarkMode) ||
+      base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag)) {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kDark;
   } else {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kLight;
diff --git a/device/bluetooth/bluetooth_adapter_winrt.cc b/device/bluetooth/bluetooth_adapter_winrt.cc
index a2ba812053fa5..20b6c3735740a 100644
--- a/device/bluetooth/bluetooth_adapter_winrt.cc
+++ b/device/bluetooth/bluetooth_adapter_winrt.cc
@@ -105,6 +105,11 @@ using ABI::Windows::Storage::Streams::IDataReaderStatics;
 using Microsoft::WRL::Callback;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 // Query string for powered Bluetooth radios. GUID Reference:
 // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/guid-bthport-device-interface
 // TODO(https://crbug.com/821766): Consider adding WindowsCreateStringReference
@@ -666,6 +671,13 @@ void BluetoothAdapterWinrt::InitForTests(
     ComPtr<IBluetoothAdapterStatics> bluetooth_adapter_statics,
     ComPtr<IDeviceInformationStatics> device_information_statics,
     ComPtr<IRadioStatics> radio_statics) {
+  if (!ResolveCoreWinRT()) {
+    CompleteInit(std::move(init_callback), std::move(bluetooth_adapter_statics),
+                 std::move(device_information_statics),
+                 std::move(radio_statics));
+    return;
+  }
+
   auto statics = PerformSlowInitTasks();
 
   // This allows any passed in values (which would be fakes) to replace
@@ -689,6 +701,9 @@ void BluetoothAdapterWinrt::InitForTests(
 BluetoothAdapterWinrt::StaticsInterfaces
 BluetoothAdapterWinrt::PerformSlowInitTasks() {
   base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
+  if (!ResolveCoreWinRT()) {
+    return BluetoothAdapterWinrt::StaticsInterfaces();
+  }
   ComPtr<IBluetoothAdapterStatics> adapter_statics;
   HRESULT hr = base::win::GetActivationFactory<
       IBluetoothAdapterStatics,
diff --git a/device/gamepad/wgi_data_fetcher_win.cc b/device/gamepad/wgi_data_fetcher_win.cc
index a215ae7f06fc7..5c685f7deea47 100644
--- a/device/gamepad/wgi_data_fetcher_win.cc
+++ b/device/gamepad/wgi_data_fetcher_win.cc
@@ -210,6 +210,11 @@ GamepadSource WgiDataFetcherWin::source() {
 
 void WgiDataFetcherWin::OnAddedToProvider() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!base::win::HStringReference::ResolveCoreWinRTStringDelayload()) {
+    initialization_state_ =
+        InitializationState::kCoreWinrtStringDelayLoadFailed;
+    return;
+  }
   HRESULT hr = get_activation_factory_function_(
       base::win::HStringReference(RuntimeClass_Windows_Gaming_Input_Gamepad)
           .Get(),
diff --git a/device/gamepad/wgi_data_fetcher_win.h b/device/gamepad/wgi_data_fetcher_win.h
index a5a27848749a2..450ad10130f76 100644
--- a/device/gamepad/wgi_data_fetcher_win.h
+++ b/device/gamepad/wgi_data_fetcher_win.h
@@ -36,6 +36,7 @@ class DEVICE_GAMEPAD_EXPORT WgiDataFetcherWin final
     kAddGamepadAddedFailed,
     kAddGamepadRemovedFailed,
     kRoGetActivationFactoryFailed,
+    kCoreWinrtStringDelayLoadFailed,
   };
 
   using Factory =
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index cb3f192994152..ab1a511b5df45 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -236,6 +236,13 @@ bool InitializeUWPSupport() {
     // 10.0.10240.0.
     DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
 
+    if (!(base::win::ResolveCoreWinRTDelayload() &&
+          base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+      // Failed loading functions from combase.dll.
+      DLOG(WARNING) << "Failed to initialize WinRT/UWP";
+      return false;
+    }
+
     return true;
   }();
 
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/media/capture/video/win/video_capture_device_factory_win.cc
index f38fb0b766ab5..9ac7219a4367c 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/media/capture/video/win/video_capture_device_factory_win.cc
@@ -302,6 +302,16 @@ bool DevicesInfoContainsDeviceId(const DevicesInfo& devices_info,
                         });
 }
 
+bool IsEnclosureLocationSupported() {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
+  return true;
+}
+
 // Returns a non DirectShow descriptor DevicesInfo with the provided name and
 // model.
 DevicesInfo::const_iterator FindNonDirectShowDeviceInfoByNameAndModel(
@@ -629,17 +639,22 @@ void VideoCaptureDeviceFactoryWin::GetDevicesInfo(
     devices_info = GetDevicesInfoDirectShow(devices_info);
   }
 
-  com_thread_.init_com_with_mta(true);
-  com_thread_.Start();
-  com_thread_data_ =
-      base::MakeRefCounted<VideoCaptureDeviceFactoryWin::ComThreadData>(
-          weak_ptr_factory_.GetWeakPtr(), com_thread_.task_runner(),
-          base::SingleThreadTaskRunner::GetCurrentDefault());
-  com_thread_.task_runner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(
-          &VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP,
-          com_thread_data_, std::move(devices_info), std::move(callback)));
+  if (IsEnclosureLocationSupported()) {
+    com_thread_.init_com_with_mta(true);
+    com_thread_.Start();
+    com_thread_data_ =
+        base::MakeRefCounted<VideoCaptureDeviceFactoryWin::ComThreadData>(
+            weak_ptr_factory_.GetWeakPtr(), com_thread_.task_runner(),
+            base::SingleThreadTaskRunner::GetCurrentDefault());
+    com_thread_.task_runner()->PostTask(
+        FROM_HERE,
+        base::BindOnce(
+            &VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP,
+            com_thread_data_, std::move(devices_info), std::move(callback)));
+
+  } else {
+    DeviceInfoReady(std::move(devices_info), std::move(callback));
+  }
 }
 
 void VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP(
diff --git a/media/cdm/win/media_foundation_cdm_module.cc b/media/cdm/win/media_foundation_cdm_module.cc
index 28fbd5d233a83..55580eb8bc504 100644
--- a/media/cdm/win/media_foundation_cdm_module.cc
+++ b/media/cdm/win/media_foundation_cdm_module.cc
@@ -129,6 +129,11 @@ HRESULT MediaFoundationCdmModule::ActivateCdmFactory() {
     return kErrorLoadLibrary;
   }
 
+  // Initialization required to call base::win::ScopedHString::Create();
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return kErrorResolveCoreWinRTStringDelayload;
+  }
+
   // Get function pointer to the activation factory.
   using GetActivationFactoryFunc =
       HRESULT(WINAPI*)(_In_ HSTRING activatible_class_id,
diff --git a/media/midi/midi_manager_winrt.cc b/media/midi/midi_manager_winrt.cc
index d5ce6175bffbf..5ee947135e9ee 100644
--- a/media/midi/midi_manager_winrt.cc
+++ b/media/midi/midi_manager_winrt.cc
@@ -822,6 +822,17 @@ void MidiManagerWinrt::InitializeOnComRunner() {
 
   DCHECK(service()->task_service()->IsOnTaskRunner(kComTaskRunner));
 
+  bool preload_success = base::win::ResolveCoreWinRTDelayload() &&
+                         ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!preload_success) {
+    service()->task_service()->PostBoundTask(
+        kDefaultTaskRunner,
+        base::BindOnce(&MidiManagerWinrt::CompleteInitialization,
+                       base::Unretained(this), Result::INITIALIZATION_ERROR));
+    return;
+  }
+
   port_manager_in_ = std::make_unique<MidiInPortManager>(this);
   port_manager_out_ = std::make_unique<MidiOutPortManager>(this);
 
diff --git a/media/renderers/win/media_foundation_protection_manager.cc b/media/renderers/win/media_foundation_protection_manager.cc
index cd4b85d979afa..563e778291764 100644
--- a/media/renderers/win/media_foundation_protection_manager.cc
+++ b/media/renderers/win/media_foundation_protection_manager.cc
@@ -37,6 +37,10 @@ HRESULT MediaFoundationProtectionManager::RuntimeClassInitialize(
   task_runner_ = std::move(task_runner);
   waiting_cb_ = std::move(waiting_cb);
 
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return kErrorResolveCoreWinRTStringDelayload;
+  }
+
   // Init an empty |property_set_| as MFMediaEngine could access it via
   // |get_Properties| before we populate it within SetPMPServer.
   base::win::ScopedHString property_set_id = base::win::ScopedHString::Create(
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
index da19df4f20b5d..2f1b5576a1f5a 100644
--- a/mojo/core/embedder/embedder.cc
+++ b/mojo/core/embedder/embedder.cc
@@ -28,6 +28,10 @@
 #include "mojo/core/node_controller.h"
 #include "mojo/public/c/system/thunks.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif  // BUILDFLAG(IS_WIN)
+
 #if !BUILDFLAG(IS_NACL)
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
 #include "mojo/core/channel_linux.h"
@@ -86,7 +90,21 @@ void InitFeatures() {
 }
 
 void EnableMojoIpcz() {
-  g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+#if BUILDFLAG(IS_WIN)
+  // TODO(https://crbug.com/1299283): Sandboxed processes on Windows versions
+  // older than 8.1 require some extra (not yet implemented... err... never
+  // implemented) setup for ipcz to work properly. This is omitted for early
+  // experimentation.
+  const bool kIsIpczSupported =
+      base::win::GetVersion() >= base::win::Version::WIN8_1;
+#else
+  const bool kIsIpczSupported = true;
+#endif
+  if (kIsIpczSupported) {
+    g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+  } else {
+    g_mojo_ipcz_enabled.store(false, std::memory_order_release);
+  }
 }
 
 void Init(const Configuration& configuration) {
diff --git a/net/proxy_resolution/win/winhttp_status.h b/net/proxy_resolution/win/winhttp_status.h
index ae5f9ee08ba6a..975d714dab343 100644
--- a/net/proxy_resolution/win/winhttp_status.h
+++ b/net/proxy_resolution/win/winhttp_status.h
@@ -19,6 +19,9 @@ enum class WinHttpStatus {
   // Aborted by caller.
   kAborted,
 
+  // WinHttp binary failed to load.
+  kFunctionsNotLoaded,
+
   // WinHttpOpen() API failed.
   kWinHttpOpenFailed,
 
diff --git a/sandbox/policy/win/sandbox_warmup.cc b/sandbox/policy/win/sandbox_warmup.cc
index 1c5142a49ceb7..fa36708b609a6 100644
--- a/sandbox/policy/win/sandbox_warmup.cc
+++ b/sandbox/policy/win/sandbox_warmup.cc
@@ -18,48 +18,16 @@
 #include <NTSecAPI.h>
 #undef SystemFunction036
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace sandbox::policy {
 
-namespace {
-
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
-}  // namespace
-
 void WarmupRandomnessInfrastructure() {
   BYTE data[1];
-
-  if (base::FeatureList::IsEnabled(
-          sandbox::policy::features::kWinSboxWarmupProcessPrng)) {
-    // TODO(crbug.com/74242) Call a warmup function exposed by boringssl.
-    static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-    BOOL success = process_prng_fn(data, sizeof(data));
-    // ProcessPrng is documented to always return TRUE.
-    CHECK(success);
-  } else {
     // This loads advapi!SystemFunction036 which is forwarded to
     // cryptbase!SystemFunction036. This allows boringsll and Chrome to call
     // RtlGenRandom from within the sandbox. This has the unfortunate side
     // effect of opening a handle to \\Device\KsecDD which we will later close
     // in processes that do not need this.
     RtlGenRandom(data, sizeof(data));
-  }
 }
 
 }  // namespace sandbox::policy
diff --git a/sandbox/policy/win/sandbox_win.cc b/sandbox/policy/win/sandbox_win.cc
index 3add6ba6997a3..da1f1f1771633 100644
--- a/sandbox/policy/win/sandbox_win.cc
+++ b/sandbox/policy/win/sandbox_win.cc
@@ -64,6 +64,7 @@
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace sandbox {
 namespace policy {
@@ -177,18 +178,21 @@ bool AddWindowsFontsDir(TargetConfig* config) {
     return false;
   }
 
-  ResultCode result =
-      config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
-                      directory.value().c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
-  std::wstring directory_str = directory.value() + L"\\*";
-  result = config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
-                           directory_str.c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
+  if (gfx::win::ShouldUseDirectWrite()) {
+    ResultCode result =
+        config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
+                        directory.value().c_str());
+    if (result != SBOX_ALL_OK) {
+      return false;
+    }
 
+    std::wstring directory_str = directory.value() + L"\\*";
+    result = config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
+                             directory_str.c_str());
+    if (result != SBOX_ALL_OK) {
+      return false;
+    }
+  }
   return true;
 }
 #endif  // !defined(NACL_WIN64)
@@ -324,7 +328,10 @@ ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
 
   config->SetLockdownDefaultDacl();
 
-  result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  // Win8+ adds a device DeviceApi that we don't need.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  }
   if (result != SBOX_ALL_OK)
     return result;
 
@@ -576,6 +583,13 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
       MITIGATION_IMAGE_LOAD_NO_REMOTE | MITIGATION_IMAGE_LOAD_NO_LOW_LABEL |
       MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION | MITIGATION_KTM_COMPONENT;
 
+#if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite()) {
+    mitigations ^= sandbox::MITIGATION_NONSYSTEM_FONT_DISABLE;
+  }
+#endif
+
   // CET is enabled with the CETCOMPAT bit on chrome.exe so must be
   // disabled for processes we know are not compatible.
   if (!delegate->CetCompatible())
@@ -722,12 +736,18 @@ ResultCode LaunchWithoutSandbox(
   // on process shutdown, in which case TerminateProcess can fail. See
   // https://crbug.com/820996.
   if (delegate->ShouldUnsandboxedRunInJob()) {
-    static base::NoDestructor<base::win::ScopedHandle> job_object(
-        CreateUnsandboxedJob());
-    if (!job_object->is_valid()) {
-      return SBOX_ERROR_CANNOT_INIT_JOB;
+    BOOL in_job = true;
+    // Prior to Windows 8 nested jobs aren't possible.
+    if (base::win::GetVersion() >= base::win::Version::WIN8 ||
+        (::IsProcessInJob(::GetCurrentProcess(), nullptr, &in_job) &&
+         !in_job)) {
+      static base::NoDestructor<base::win::ScopedHandle> job_object(
+          CreateUnsandboxedJob());
+      if (!job_object->is_valid()) {
+        return SBOX_ERROR_CANNOT_INIT_JOB;
+      }
+      options.job_handle = job_object->get();
     }
-    options.job_handle = job_object->get();
   }
 
   // Chromium binaries are marked as CET Compatible but some processes
@@ -818,6 +838,11 @@ ResultCode SandboxWin::AddAppContainerPolicy(TargetConfig* config,
 ResultCode SandboxWin::AddWin32kLockdownPolicy(TargetConfig* config) {
   DCHECK(!config->IsConfigured());
 #if !defined(NACL_WIN64)
+  // Win32k Lockdown is supported on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8) {
+    return SBOX_ALL_OK;
+  }
+
   MitigationFlags flags = config->GetProcessMitigations();
   // Check not enabling twice. Should not happen.
   DCHECK_EQ(0U, flags & MITIGATION_WIN32K_DISABLE);
diff --git a/sandbox/win/src/app_container_base.cc b/sandbox/win/src/app_container_base.cc
index 37cc8fa8f8996..d947e68e5907e 100644
--- a/sandbox/win/src/app_container_base.cc
+++ b/sandbox/win/src/app_container_base.cc
@@ -20,6 +20,18 @@ namespace sandbox {
 
 namespace {
 
+typedef decltype(::CreateAppContainerProfile) CreateAppContainerProfileFunc;
+
+typedef decltype(::DeriveAppContainerSidFromAppContainerName)
+    DeriveAppContainerSidFromAppContainerNameFunc;
+
+typedef decltype(::DeleteAppContainerProfile) DeleteAppContainerProfileFunc;
+
+typedef decltype(::GetAppContainerFolderPath) GetAppContainerFolderPathFunc;
+
+typedef decltype(::GetAppContainerRegistryLocation)
+    GetAppContainerRegistryLocationFunc;
+
 struct FreeSidDeleter {
   inline void operator()(void* ptr) const { ::FreeSid(ptr); }
 };
@@ -30,8 +42,15 @@ struct FreeSidDeleter {
 AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
                                                   const wchar_t* display_name,
                                                   const wchar_t* description) {
+  static auto create_app_container_profile =
+      reinterpret_cast<CreateAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "CreateAppContainerProfile"));
+  if (!create_app_container_profile) {
+    return nullptr;
+  }
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::CreateAppContainerProfile(
+  HRESULT hr = create_app_container_profile(
       package_name, display_name, description, nullptr, 0, &package_sid_ptr);
   if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
     return Open(package_name);
@@ -47,9 +66,16 @@ AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
 
 // static
 AppContainerBase* AppContainerBase::Open(const wchar_t* package_name) {
+  static auto derive_app_container_sid =
+      reinterpret_cast<DeriveAppContainerSidFromAppContainerNameFunc*>(
+          GetProcAddress(GetModuleHandle(L"userenv"),
+                         "DeriveAppContainerSidFromAppContainerName"));
+  if (!derive_app_container_sid) {
+    return nullptr;
+  }
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::DeriveAppContainerSidFromAppContainerName(package_name,
-                                                           &package_sid_ptr);
+  HRESULT hr = derive_app_container_sid(package_name, &package_sid_ptr);
   if (FAILED(hr))
     return nullptr;
 
@@ -71,7 +97,14 @@ AppContainerBase* AppContainerBase::CreateLowbox(const wchar_t* sid) {
 
 // static
 bool AppContainerBase::Delete(const wchar_t* package_name) {
-  return SUCCEEDED(::DeleteAppContainerProfile(package_name));
+  static auto delete_app_container_profile =
+      reinterpret_cast<DeleteAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "DeleteAppContainerProfile"));
+  if (!delete_app_container_profile) {
+    return false;
+  }
+
+  return SUCCEEDED(delete_app_container_profile(package_name));
 }
 
 AppContainerBase::AppContainerBase(base::win::Sid& package_sid,
diff --git a/sandbox/win/src/broker_services.cc b/sandbox/win/src/broker_services.cc
index 9dfe4b3d8ba21..62ca137396f14 100644
--- a/sandbox/win/src/broker_services.cc
+++ b/sandbox/win/src/broker_services.cc
@@ -451,7 +451,11 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   if (container)
     startup_info->SetAppContainer(container);
 
-  startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  // On Win10, jobs are associated via startup_info.
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      policy_base->HasJob()) {
+    startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  }
 
   if (!startup_info->BuildStartupInformation())
     return SBOX_ERROR_PROC_THREAD_ATTRIBUTES;
diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index 11f19502adc0f..0c922b0599314 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
@@ -149,8 +150,11 @@ bool HandleCloserAgent::CloseHandles() {
     return true;
 
   absl::optional<ProcessHandleMap> handle_map = GetCurrentProcessHandles();
-  if (!handle_map)
-    return false;
+  // Fallback for pre-Windows 8.1.
+  if (!handle_map) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN8_1);
+    handle_map = GetCurrentProcessHandlesWin7();
+  }
 
   for (const HandleMap::value_type& handle_to_close : handles_to_close_) {
     ProcessHandleMap::iterator result = handle_map->find(handle_to_close.first);
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index f9f4f061aeec0..cfc656dce7bf1 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -19,6 +19,7 @@
 #include "base/rand_util.h"
 #include "base/scoped_native_library.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
@@ -427,7 +428,26 @@ ResultCode InterceptionManager::PatchClientFunctions(
   if (!ntdll_base)
     return SBOX_ERROR_NO_HANDLE;
 
-  ServiceResolverThunk thunk(child_->Process(), /*relaxed=*/true);
+  std::unique_ptr<ServiceResolverThunk> thunk;
+#if defined(_WIN64)
+  thunk = std::make_unique<ServiceResolverThunk>(child_->Process(), true);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  base::win::Version real_os_version = os_info->Kernel32Version();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (real_os_version >= base::win::Version::WIN10) {
+      thunk.reset(new Wow64W10ResolverThunk(child_->Process(), true));
+    } else if (real_os_version >= base::win::Version::WIN8) {
+      thunk.reset(new Wow64W8ResolverThunk(child_->Process(), true));
+    } else {
+      thunk.reset(new Wow64ResolverThunk(child_->Process(), true));
+    }
+  } else if (real_os_version >= base::win::Version::WIN8) {
+    thunk.reset(new Win8ResolverThunk(child_->Process(), true));
+  } else {
+    thunk.reset(new ServiceResolverThunk(child_->Process(), true));
+  }
+#endif
 
   for (auto interception : interceptions_) {
     const std::wstring ntdll(kNtdllName);
@@ -437,7 +457,7 @@ ResultCode InterceptionManager::PatchClientFunctions(
     if (INTERCEPTION_SERVICE_CALL != interception.type)
       return SBOX_ERROR_BAD_PARAMS;
 
-    NTSTATUS ret = thunk.Setup(
+    NTSTATUS ret = thunk->Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
         &thunks->thunks[dll_data->num_thunks],
diff --git a/sandbox/win/src/job.cc b/sandbox/win/src/job.cc
index 2dc76c19df5ba..16cb1f9ccf4df 100644
--- a/sandbox/win/src/job.cc
+++ b/sandbox/win/src/job.cc
@@ -9,22 +9,27 @@
 #include <stddef.h>
 #include <utility>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/restricted_token.h"
 
 namespace sandbox {
 
-Job::Job() = default;
-Job::~Job() = default;
+Job::Job() : job_handle_(nullptr) {}
+
+Job::~Job() {}
 
 DWORD Job::Init(JobLevel security_level,
                 DWORD ui_exceptions,
                 size_t memory_limit) {
-  if (job_handle_.is_valid())
+  if (job_handle_.IsValid()) {
     return ERROR_ALREADY_INITIALIZED;
+  }
 
-  job_handle_.Set(::CreateJobObject(nullptr, nullptr));
-  if (!job_handle_.is_valid())
+  job_handle_.Set(::CreateJobObject(nullptr,  // No security attribute
+                                    nullptr));
+  if (!job_handle_.IsValid()) {
     return ::GetLastError();
+  }
 
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
   JOBOBJECT_BASIC_UI_RESTRICTIONS jbur = {};
@@ -64,6 +69,9 @@ DWORD Job::Init(JobLevel security_level,
           JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
       break;
     }
+    case JobLevel::kNone: {
+      return ERROR_BAD_ARGUMENTS;
+    }
   }
 
   if (!::SetInformationJobObject(job_handle_.Get(),
@@ -83,20 +91,46 @@ DWORD Job::Init(JobLevel security_level,
 }
 
 bool Job::IsValid() {
-  return job_handle_.is_valid();
+  return job_handle_.IsValid();
 }
 
 HANDLE Job::GetHandle() {
-  return job_handle_.get();
+  return job_handle_.Get();
+}
+
+DWORD Job::UserHandleGrantAccess(HANDLE handle) {
+  if (!job_handle_.IsValid()) {
+    return ERROR_NO_DATA;
+  }
+
+  if (!::UserHandleGrantAccess(handle, job_handle_.Get(),
+                               true)) {  // Access allowed.
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+DWORD Job::AssignProcessToJob(HANDLE process_handle) {
+  if (!job_handle_.IsValid()) {
+    return ERROR_NO_DATA;
+  }
+
+  if (!::AssignProcessToJobObject(job_handle_.Get(), process_handle)) {
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
 }
 
 DWORD Job::SetActiveProcessLimit(DWORD processes) {
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
 
-  if (!job_handle_.is_valid())
+  if (!job_handle_.IsValid()) {
     return ERROR_NO_DATA;
+  }
 
-  if (!::QueryInformationJobObject(job_handle_.get(),
+  if (!::QueryInformationJobObject(job_handle_.Get(),
                                    JobObjectExtendedLimitInformation, &jeli,
                                    sizeof(jeli), nullptr)) {
     return ::GetLastError();
@@ -104,7 +138,7 @@ DWORD Job::SetActiveProcessLimit(DWORD processes) {
   jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   jeli.BasicLimitInformation.ActiveProcessLimit = processes;
 
-  if (!::SetInformationJobObject(job_handle_.get(),
+  if (!::SetInformationJobObject(job_handle_.Get(),
                                  JobObjectExtendedLimitInformation, &jeli,
                                  sizeof(jeli))) {
     return ::GetLastError();
diff --git a/sandbox/win/src/job.h b/sandbox/win/src/job.h
index 31037e1b7aff7..a148179e108a5 100644
--- a/sandbox/win/src/job.h
+++ b/sandbox/win/src/job.h
@@ -15,7 +15,8 @@ enum class JobLevel;
 // Handles the creation of job objects based on a security profile.
 // Sample usage:
 //   Job job;
-//   job.Init(JobLevel::kLockdown, 0, 0);
+//   job.Init(JobLevel::kLockdown, nullptr);  //no job name
+//   job.AssignProcessToJob(process_handle);
 class Job {
  public:
   Job();
@@ -27,6 +28,7 @@ class Job {
 
   // Initializes and creates the job object. The security of the job is based
   // on the security_level parameter.
+  // job_name can be nullptr if the job is unnamed.
   // If the chosen profile has too many ui restrictions, you can disable some
   // by specifying them in the ui_exceptions parameters.
   // If the function succeeds, the return value is ERROR_SUCCESS. If the
@@ -34,6 +36,19 @@ class Job {
   // the error.
   DWORD Init(JobLevel security_level, DWORD ui_exceptions, size_t memory_limit);
 
+  // Assigns the process referenced by process_handle to the job.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD AssignProcessToJob(HANDLE process_handle);
+
+  // Grants access to "handle" to the job. All processes in the job can
+  // subsequently recognize and use the handle.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD UserHandleGrantAccess(HANDLE handle);
+
   // True if the job has been initialized and has a valid handle.
   bool IsValid();
 
diff --git a/sandbox/win/src/nt_internals.h b/sandbox/win/src/nt_internals.h
index 72d96b96f4fd4..c3dedf262abcf 100644
--- a/sandbox/win/src/nt_internals.h
+++ b/sandbox/win/src/nt_internals.h
@@ -162,7 +162,13 @@ typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN PVOID ThreadInformation,
     IN ULONG ThreadInformationLength);
 
+typedef struct _PROCESS_ACCESS_TOKEN {
+  HANDLE token;
+  HANDLE thread;
+} PROCESS_ACCESS_TOKEN;
+
 // Partial definition only for values not in PROCESS_INFO_CLASS.
+constexpr auto ProcessInformationAccessToken = static_cast<PROCESSINFOCLASS>(9);
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
 constexpr auto ProcessHandleTable = static_cast<PROCESSINFOCLASS>(58);
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 6afd1d3ec80be..68a46e726b4e8 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -24,6 +24,7 @@
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/win_utils.h"
+#include "ui/gfx/win/direct_write.h"
 
 // These are missing in 10.0.19551.0 but are in 10.0.19041.0 and 10.0.20226.0.
 #ifndef PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_STRICT_MODE
@@ -37,22 +38,39 @@ namespace sandbox {
 
 namespace {
 
+// API defined in libloaderapi.h >= Win8. Also available in Vista/7 starting
+// with KB2533623. Known to be buggy on Vista, but not known to affect Chromium.
+using SetDefaultDllDirectoriesFunction = decltype(&SetDefaultDllDirectories);
+
+// APIs defined in processthreadsapi.h >= Win8.
+using SetProcessMitigationPolicyFunction =
+    decltype(&SetProcessMitigationPolicy);
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+using SetThreadInformationFunction = decltype(&SetThreadInformation);
+
 // Returns a two-element array of mitigation flags supported on this machine.
 const ULONG64* GetSupportedMitigations() {
   static ULONG64 mitigations[2] = {};
 
   // This static variable will only be initialized once.
   if (!mitigations[0] && !mitigations[1]) {
-    // NOTE: the two-element-sized input array is only supported on >= Win10
-    // RS2. If an earlier version, the second element will be left 0.
-    size_t mits_size =
-        (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
-            ? (sizeof(mitigations[0]) * 2)
-            : sizeof(mitigations[0]);
-    if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                      ProcessMitigationOptionsMask,
-                                      &mitigations, mits_size)) {
-      NOTREACHED();
+    GetProcessMitigationPolicyFunction get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+            ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (get_process_mitigation_policy) {
+      // NOTE: the two-element-sized input array is only supported on >= Win10
+      // RS2.
+      //       If an earlier version, the second element will be left 0.
+      size_t mits_size =
+          (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
+              ? (sizeof(mitigations[0]) * 2)
+              : sizeof(mitigations[0]);
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessMitigationOptionsMask,
+                                         &mitigations, mits_size)) {
+        NOTREACHED();
+      }
     }
   }
 
@@ -76,7 +94,15 @@ bool IsRunning32bitEmulatedOnArm64() {
 bool SetProcessMitigationPolicyInternal(PROCESS_MITIGATION_POLICY policy,
                                         PVOID lpBuffer,
                                         SIZE_T dwLength) {
-  PCHECK(::SetProcessMitigationPolicy(policy, lpBuffer, dwLength))
+  HMODULE module = ::GetModuleHandleA("kernel32.dll");
+  SetProcessMitigationPolicyFunction set_process_mitigation_policy_function =
+      reinterpret_cast<SetProcessMitigationPolicyFunction>(
+          ::GetProcAddress(module, "SetProcessMitigationPolicy"));
+  if (!set_process_mitigation_policy_function) {
+    return false;
+  }
+
+  PCHECK(set_process_mitigation_policy_function(policy, lpBuffer, dwLength))
       << "SetProcessMitigationPolicy failed with Policy: " << policy;
 
   return true;
@@ -92,21 +118,36 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
 
   base::win::Version version = base::win::GetVersion();
 
+#if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite()) {
+    flags ^= sandbox::MITIGATION_NONSYSTEM_FONT_DISABLE;
+  }
+#endif
+
   if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+    HMODULE module = ::GetModuleHandleA("kernel32.dll");
+    SetDefaultDllDirectoriesFunction set_default_dll_directories =
+        reinterpret_cast<SetDefaultDllDirectoriesFunction>(
+            ::GetProcAddress(module, "SetDefaultDllDirectories"));
+
+    // Check for SetDefaultDllDirectories since it requires KB2533623.
+    if (set_default_dll_directories) {
 #if defined(COMPONENT_BUILD)
-    const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
+      const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
 #else
-    // In a non-component build, all DLLs will be loaded manually, or via
-    // manifest definition, so these flags can be stronger. This prevents DLL
-    // planting in the application directory.
-    const DWORD directory_flags =
-        LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
+      // In a non-component build, all DLLs will be loaded manually, or via
+      // manifest definition, so these flags can be stronger. This prevents DLL
+      // planting in the application directory.
+      const DWORD directory_flags =
+          LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
 #endif
-    if (!::SetDefaultDllDirectories(directory_flags)) {
-      return false;
-    }
+      if (!set_default_dll_directories(directory_flags)) {
+        return false;
+      }
 
-    applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+      applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+    }
   }
 
   // Set the heap to terminate on corruption
@@ -149,6 +190,11 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   }
 #endif
 
+  // This is all we can do in Win7 and below.
+  if (version < base::win::Version::WIN8) {
+    return true;
+  }
+
   // Enable ASLR policies.
   if (flags & MITIGATION_RELOCATE_IMAGE) {
     PROCESS_MITIGATION_ASLR_POLICY policy = {};
@@ -212,6 +258,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_EXTENSION_POINT_DISABLE;
   }
 
+  if (version < base::win::Version::WIN8_1) {
+    return true;
+  }
+
   // Enable dynamic code policies.
   if (!IsRunning32bitEmulatedOnArm64() &&
       (flags & MITIGATION_DYNAMIC_CODE_DISABLE)) {
@@ -228,6 +278,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
   }
 
+  if (version < base::win::Version::WIN10) {
+    return true;
+  }
+
   // Enable font policies.
   if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
     PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
@@ -349,9 +403,22 @@ bool ApplyMitigationsToCurrentThread(MitigationFlags flags) {
   if (flags & MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD) {
     DWORD thread_policy = THREAD_DYNAMIC_CODE_ALLOW;
 
+    // NOTE: SetThreadInformation API only exists on >= Win8.  Dynamically
+    //       get function handle.
+    base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+    if (!dll.is_valid()) {
+      return false;
+    }
+    SetThreadInformationFunction set_thread_info_function =
+        reinterpret_cast<SetThreadInformationFunction>(
+            dll.GetFunctionPointer("SetThreadInformation"));
+    if (!set_thread_info_function) {
+      return false;
+    }
+
     // NOTE: Must use the pseudo-handle here, a thread HANDLE won't work.
-    if (!::SetThreadInformation(::GetCurrentThread(), ThreadDynamicCodePolicy,
-                                &thread_policy, sizeof(thread_policy))) {
+    if (!set_thread_info_function(::GetCurrentThread(), ThreadDynamicCodePolicy,
+                                  &thread_policy, sizeof(thread_policy))) {
       return false;
     }
   }
@@ -372,8 +439,15 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
   *policy_value_1 = 0;
   *policy_value_2 = 0;
 
-#if defined(_WIN64) || defined(_M_IX86)
+#if defined(_WIN64)
   *size = sizeof(*policy_flags);
+#elif defined(_M_IX86)
+  // A 64-bit flags attribute is illegal on 32-bit Win 7.
+  if (version < base::win::Version::WIN8) {
+    *size = sizeof(DWORD);
+  } else {
+    *size = sizeof(*policy_flags);
+  }
 #else
 #error This platform is not supported.
 #endif
@@ -391,53 +465,81 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
     *policy_value_1 |= PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE;
 #endif
 
-  if (flags & MITIGATION_RELOCATE_IMAGE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
-    if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
-      *policy_value_1 |=
-          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
-    }
+  // Win 7
+  if (version < base::win::Version::WIN8) {
+    return;
   }
 
-  if (flags & MITIGATION_HEAP_TERMINATE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+#if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite()) {
+    *policy_value_1 ^= sandbox::MITIGATION_NONSYSTEM_FONT_DISABLE;
   }
+#endif
 
-  if (flags & MITIGATION_BOTTOM_UP_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
-  }
+  // Everything >= Win8, do not return before the end of the function where
+  // the final policy bitmap is sanity checked against what is supported on this
+  // machine.  The API required to do so is only available since Win8.
 
-  if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
-  }
+  // Mitigations >= Win8:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8) {
+    if (flags & MITIGATION_RELOCATE_IMAGE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
+      if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+        *policy_value_1 |=
+            PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+      }
+    }
 
-  if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HEAP_TERMINATE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_WIN32K_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_BOTTOM_UP_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
+    }
+
+    if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
+    }
+
+    if (flags & MITIGATION_WIN32K_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
+    }
+
+    if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+  // Mitigations >= Win8.1:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8_1) {
+    if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+  // Mitigations >= Win10:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN10) {
+    if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+    }
   }
 
   // Mitigations >= Win10 TH2:
@@ -539,6 +641,15 @@ void ConvertProcessMitigationsToComponentFilter(MitigationFlags flags,
 }
 
 MitigationFlags FilterPostStartupProcessMitigations(MitigationFlags flags) {
+  base::win::Version version = base::win::GetVersion();
+
+  // Windows 7.
+  if (version < base::win::Version::WIN8) {
+    return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER |
+                    MITIGATION_HEAP_TERMINATE);
+  }
+
+  // Windows 8 and above.
   return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER);
 }
 
diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
index 050d9d585a622..aa7ab4f0dda32 100644
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -10,8 +10,10 @@
 #include "base/check.h"
 #include "base/notreached.h"
 #include "base/win/access_token.h"
+#include "base/win/scoped_handle.h"
 #include "base/win/security_descriptor.h"
 #include "sandbox/win/src/acl.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/security_level.h"
diff --git a/sandbox/win/src/sandbox_policy_diagnostic.cc b/sandbox/win/src/sandbox_policy_diagnostic.cc
index 34bf5f551d783..6139c2e6d6793 100644
--- a/sandbox/win/src/sandbox_policy_diagnostic.cc
+++ b/sandbox/win/src/sandbox_policy_diagnostic.cc
@@ -83,6 +83,8 @@ std::string GetJobLevelInEnglish(JobLevel job) {
       return "Interactive";
     case JobLevel::kUnprotected:
       return "Unprotected";
+    case JobLevel::kNone:
+      return "None";
   }
 }
 
diff --git a/sandbox/win/src/security_level.h b/sandbox/win/src/security_level.h
index 60e42e97d6f48..a028062b178ec 100644
--- a/sandbox/win/src/security_level.h
+++ b/sandbox/win/src/security_level.h
@@ -95,6 +95,9 @@ enum TokenLevel {
 //  JobLevel        |General                            |Quota               |
 //                  |restrictions                       |restrictions        |
 // -----------------|---------------------------------- |--------------------|
+// kNone            | No job is assigned to the         | None               |
+//                  | sandboxed process.                |                    |
+// -----------------|---------------------------------- |--------------------|
 // kUnprotected     | None                              | *Kill on Job close.|
 // -----------------|---------------------------------- |--------------------|
 // kInteractive     | *Forbid system-wide changes using |                    |
@@ -120,7 +123,13 @@ enum TokenLevel {
 // In the context of the above table, 'user handles' refers to the handles of
 // windows, bitmaps, menus, etc. Files, treads and registry handles are kernel
 // handles and are not affected by the job level settings.
-enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected };
+enum class JobLevel {
+  kLockdown = 0,
+  kLimitedUser,
+  kInteractive,
+  kUnprotected,
+  kNone
+};
 
 // These flags correspond to various process-level mitigations (eg. ASLR and
 // DEP). Most are implemented via UpdateProcThreadAttribute() plus flags for
diff --git a/sandbox/win/src/service_resolver.h b/sandbox/win/src/service_resolver.h
index dc74bd6e52539..97f828e3feeb0 100644
--- a/sandbox/win/src/service_resolver.h
+++ b/sandbox/win/src/service_resolver.h
@@ -53,23 +53,18 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   size_t GetThunkSize() const override;
 
   // Call this to set up ntdll_base_ which will allow for local patches.
-  void AllowLocalPatches();
+  virtual void AllowLocalPatches();
 
   // Verifies that the function specified by |target_name| in |target_module| is
   // a service and copies the data from that function into |thunk_storage|. If
   // |storage_bytes| is too small, then the method fails.
-  NTSTATUS CopyThunk(const void* target_module,
-                     const char* target_name,
-                     BYTE* thunk_storage,
-                     size_t storage_bytes,
-                     size_t* storage_used);
+  virtual NTSTATUS CopyThunk(const void* target_module,
+                             const char* target_name,
+                             BYTE* thunk_storage,
+                             size_t storage_bytes,
+                             size_t* storage_used);
 
-  // Checks if a target was patched correctly for a jump. This is only for use
-  // in testing in 32-bit builds. Will always return true on 64-bit builds. Set
-  // |thunk_storage| to the same pointer passed to Setup().
-  bool VerifyJumpTargetForTesting(void* thunk_storage) const;
-
- private:
+ protected:
   // The unit test will use this member to allow local patch on a buffer.
   HMODULE ntdll_base_;
 
@@ -87,15 +82,15 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   // Returns true if the code pointer by target_ corresponds to the expected
   // type of function. Saves that code on the first part of the thunk pointed
   // by local_thunk (should be directly accessible from the parent).
-  bool IsFunctionAService(void* local_thunk) const;
+  virtual bool IsFunctionAService(void* local_thunk) const;
 
   // Performs the actual patch of target_.
   // local_thunk must be already fully initialized, and the first part must
   // contain the original code. The real type of this buffer is ServiceFullThunk
   // (yes, private). remote_thunk (real type ServiceFullThunk), must be
   // allocated on the child, and will contain the thunk data, after this call.
-  // Returns the appropriate status code.
-  NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
+  // Returns the apropriate status code.
+  virtual NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
 
   // Provides basically the same functionality as IsFunctionAService but it
   // continues even if it does not recognize the function code. remote_thunk
@@ -107,6 +102,74 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   ULONG relative_jump_;
 };
 
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).
+class Wow64ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64ResolverThunk(const Wow64ResolverThunk&) = delete;
+  Wow64ResolverThunk& operator=(const Wow64ResolverThunk&) = delete;
+
+  ~Wow64ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 8.
+class Wow64W8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W8ResolverThunk(const Wow64W8ResolverThunk&) = delete;
+  Wow64W8ResolverThunk& operator=(const Wow64W8ResolverThunk&) = delete;
+
+  ~Wow64W8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on Windows 8.
+class Win8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Win8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Win8ResolverThunk(const Win8ResolverThunk&) = delete;
+  Win8ResolverThunk& operator=(const Win8ResolverThunk&) = delete;
+
+  ~Win8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 10.
+class Wow64W10ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W10ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W10ResolverThunk(const Wow64W10ResolverThunk&) = delete;
+  Wow64W10ResolverThunk& operator=(const Wow64W10ResolverThunk&) = delete;
+
+  ~Wow64W10ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_SERVICE_RESOLVER_H_
diff --git a/sandbox/win/src/service_resolver_32.cc b/sandbox/win/src/service_resolver_32.cc
index cb43a3d053a74..b0f018e84e42f 100644
--- a/sandbox/win/src/service_resolver_32.cc
+++ b/sandbox/win/src/service_resolver_32.cc
@@ -20,16 +20,43 @@ namespace {
 const BYTE kMovEax = 0xB8;
 const BYTE kMovEdx = 0xBA;
 const USHORT kMovEdxEsp = 0xD48B;
+const USHORT kCallPtrEdx = 0x12FF;
 const USHORT kCallEdx = 0xD2FF;
 const BYTE kCallEip = 0xE8;
 const BYTE kRet = 0xC2;
 const BYTE kRet2 = 0xC3;
 const USHORT kJmpEdx = 0xE2FF;
+const USHORT kXorEcx = 0xC933;
+const ULONG kLeaEdx = 0x0424548D;
+const ULONG kCallFs1 = 0xC015FF64;
+const USHORT kCallFs2 = 0;
+const BYTE kCallFs3 = 0;
+const BYTE kAddEsp1 = 0x83;
+const USHORT kAddEsp2 = 0x4C4;
 const BYTE kJmp32 = 0xE9;
 const USHORT kSysenter = 0x340F;
 
-// Service code for 32 bit Windows. Introduced in Windows 8.
-struct ServiceEntry32 {
+// Service code for 32 bit systems.
+// NOTE: on win2003 "call dword ptr [edx]" is "call edx".
+struct ServiceEntry {
+  // This struct contains roughly the following code:
+  // 00 mov     eax,25h
+  // 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
+  // 0a call    dword ptr [edx]
+  // 0c ret     2Ch
+  // 0f nop
+  BYTE mov_eax;  // = B8
+  ULONG service_id;
+  BYTE mov_edx;  // = BA
+  ULONG stub;
+  USHORT call_ptr_edx;  // = FF 12
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for 32 bit Windows 8.
+struct ServiceEntryW8 {
   // This struct contains the following code:
   // 00 b825000000      mov     eax,25h
   // 05 e803000000      call    eip+3
@@ -50,13 +77,60 @@ struct ServiceEntry32 {
   USHORT nop;
 };
 
-// Service code for a 32 bit process under Wow64. Introduced in Windows 10.
-// Also used for the patching process.
-struct ServiceEntryWow64 {
+// Service code for a 32 bit process running on a 64 bit os.
+struct Wow64Entry {
+  // This struct may contain one of two versions of code:
+  // 1. For XP, Vista and 2K3:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 c22c00          ret     2Ch
+  //
+  // 2. For Windows 7:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 83c404          add     esp, 4
+  // 15 c22c00          ret     2Ch
+  //
+  // So we base the structure on the bigger one:
+  BYTE mov_eax;  // = B8
+  ULONG service_id;
+  USHORT xor_ecx;   // = 33 C9
+  ULONG lea_edx;    // = 8D 54 24 04
+  ULONG call_fs1;   // = 64 FF 15 C0
+  USHORT call_fs2;  // = 00 00
+  BYTE call_fs3;    // = 00
+  BYTE add_esp1;    // = 83             or ret
+  USHORT add_esp2;  // = C4 04          or num_params
+  BYTE ret;         // = C2
+  USHORT num_params;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 8.
+struct Wow64EntryW8 {
+  // 00 b825000000      mov     eax, 25h
+  // 05 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 0b c22c00          ret     2Ch
+  // 0f 90              nop
+  BYTE mov_eax;  // = B8
+  ULONG service_id;
+  ULONG call_fs1;   // = 64 FF 15 C0
+  USHORT call_fs2;  // = 00 00
+  BYTE call_fs3;    // = 00
+  BYTE ret;         // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 10.
+struct Wow64EntryW10 {
   // 00 b828000000      mov     eax, 28h
   // 05 bab0d54877      mov     edx, 7748D5B0h
   // 09 ffd2            call    edx
-  // 0c c22800          ret     28h
+  // 0b c22800          ret     28h
   BYTE mov_eax;         // = B8
   ULONG service_id;
   BYTE mov_edx;         // = BA
@@ -64,86 +138,27 @@ struct ServiceEntryWow64 {
   USHORT call_edx;      // = FF D2
   BYTE ret;             // = C2
   USHORT num_params;
-  BYTE nop;
 };
 
 // Make sure that relaxed patching works as expected.
-const size_t kMinServiceSize = offsetof(ServiceEntryWow64, ret);
-// Maximum size of the entry, was the size of the Windows Vista WoW64 entry.
-// Keep this fixed for compatibility reasons.
-const size_t kMaxServiceSize = 24;
-static_assert(sizeof(ServiceEntry32) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntry32) < kMaxServiceSize,
-              "wrong maximum service length");
-static_assert(sizeof(ServiceEntryWow64) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntryWow64) < kMaxServiceSize,
-              "wrong maximum service length");
+const size_t kMinServiceSize = offsetof(ServiceEntry, ret);
+static_assert(sizeof(ServiceEntryW8) >= kMinServiceSize,
+              "wrong service length");
+static_assert(sizeof(Wow64Entry) >= kMinServiceSize, "wrong service length");
+static_assert(sizeof(Wow64EntryW8) >= kMinServiceSize, "wrong service length");
 
 struct ServiceFullThunk {
   union {
-    ServiceEntryWow64 original;
-    // Pad the entry to the maximum size.
-    char dummy[kMaxServiceSize];
+    ServiceEntry original;
+    ServiceEntryW8 original_w8;
+    Wow64Entry wow_64;
+    Wow64EntryW8 wow_64_w8;
   };
   int internal_thunk;  // Dummy member to the beginning of the internal thunk.
 };
 
 #pragma pack(pop)
 
-bool IsWow64Process() {
-  // We don't need to use IsWow64Process2 as this returns the expected result
-  // when running in the ARM64 x86 emulator.
-  BOOL is_wow64 = FALSE;
-  return ::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64;
-}
-
-bool IsFunctionAService32(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntry32 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
-      function_code.call_offset != 3 || kRet != function_code.ret_p ||
-      kMovEdxEsp != function_code.mov_edx_esp ||
-      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-
-  return true;
-}
-
-bool IsFunctionAServiceWow64(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntryWow64 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
-      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-  return true;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -212,14 +227,73 @@ NTSTATUS ServiceResolverThunk::CopyThunk(const void* target_module,
 }
 
 bool ServiceResolverThunk::IsFunctionAService(void* local_thunk) const {
-  static bool is_wow64 = IsWow64Process();
-  return is_wow64 ? IsFunctionAServiceWow64(process_, target_, local_thunk)
-                  : IsFunctionAService32(process_, target_, local_thunk);
+  ServiceEntry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read) {
+    return false;
+  }
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      (kCallPtrEdx != function_code.call_ptr_edx &&
+       kCallEdx != function_code.call_ptr_edx) ||
+      kRet != function_code.ret) {
+    return false;
+  }
+
+  // Find the system call pointer if we don't already have it.
+  if (kCallEdx != function_code.call_ptr_edx) {
+    DWORD ki_system_call;
+    if (!::ReadProcessMemory(process_,
+                             base::bit_cast<const void*>(function_code.stub),
+                             &ki_system_call, sizeof(ki_system_call), &read)) {
+      return false;
+    }
+
+    if (sizeof(ki_system_call) != read) {
+      return false;
+    }
+
+    HMODULE module_1, module_2;
+    // last check, call_stub should point to a KiXXSystemCall function on ntdll
+    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                           base::bit_cast<const wchar_t*>(ki_system_call),
+                           &module_1)) {
+      return false;
+    }
+
+    if (ntdll_base_) {
+      // This path is only taken when running the unit tests. We want to be
+      // able to patch a buffer in memory, so target_ is not inside ntdll.
+      module_2 = ntdll_base_;
+    } else {
+      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                             reinterpret_cast<const wchar_t*>(target_),
+                             &module_2)) {
+        return false;
+      }
+    }
+
+    if (module_1 != module_2) {
+      return false;
+    }
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
 }
 
 NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
                                             void* remote_thunk) {
-  ServiceEntryWow64 intercepted_code;
+  ServiceEntry intercepted_code;
   size_t bytes_to_write = sizeof(intercepted_code);
   ServiceFullThunk* full_local_thunk =
       reinterpret_cast<ServiceFullThunk*>(local_thunk);
@@ -232,15 +306,15 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   intercepted_code.mov_eax = kMovEax;
   intercepted_code.service_id = full_local_thunk->original.service_id;
   intercepted_code.mov_edx = kMovEdx;
-  intercepted_code.mov_edx_param =
+  intercepted_code.stub =
       base::bit_cast<ULONG>(&full_remote_thunk->internal_thunk);
-  intercepted_code.call_edx = kJmpEdx;
+  intercepted_code.call_ptr_edx = kJmpEdx;
   bytes_to_write = kMinServiceSize;
 
   if (relative_jump_) {
     intercepted_code.mov_eax = kJmp32;
     intercepted_code.service_id = relative_jump_;
-    bytes_to_write = offsetof(ServiceEntryWow64, mov_edx);
+    bytes_to_write = offsetof(ServiceEntry, mov_edx);
   }
 
   // setup the thunk
@@ -276,7 +350,7 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
 
 bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
                                                 void* remote_thunk) {
-  ServiceEntryWow64 function_code;
+  ServiceEntry function_code;
   SIZE_T read;
   if (!::ReadProcessMemory(process_, target_, &function_code,
                            sizeof(function_code), &read)) {
@@ -312,18 +386,104 @@ bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
   return true;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(
-    void* thunk_storage) const {
-  const size_t kJmp32Size = 5;
-  ServiceEntryWow64* patched = static_cast<ServiceEntryWow64*>(target_);
-  if (kJmp32 != patched->mov_eax) {
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64Entry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read) {
+    return false;
+  }
+
+  if (kMovEax != function_code.mov_eax || kXorEcx != function_code.xor_ecx ||
+      kLeaEdx != function_code.lea_edx || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3) {
+    return false;
+  }
+
+  if ((kAddEsp1 == function_code.add_esp1 &&
+       kAddEsp2 == function_code.add_esp2 && kRet == function_code.ret) ||
+      kRet == function_code.add_esp1) {
+    // Save the verified code
+    memcpy(local_thunk, &function_code, sizeof(function_code));
+    return true;
+  }
+
+  return false;
+}
+
+bool Wow64W8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read) {
+    return false;
+  }
+
+  if (kMovEax != function_code.mov_eax || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3 || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
+}
+
+bool Win8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  ServiceEntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read) {
+    return false;
+  }
+
+  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
+      function_code.call_offset != 3 || kRet != function_code.ret_p ||
+      kMovEdxEsp != function_code.mov_edx_esp ||
+      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
+}
+
+bool Wow64W10ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW10 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read) {
     return false;
   }
 
-  ULONG source_addr = base::bit_cast<ULONG>(target_);
-  ULONG target_addr = base::bit_cast<ULONG>(thunk_storage);
-  return target_addr + kMaxServiceSize - kJmp32Size - source_addr ==
-         patched->service_id;
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_64.cc b/sandbox/win/src/service_resolver_64.cc
index 33b91d04ad114..38e451da143a3 100644
--- a/sandbox/win/src/service_resolver_64.cc
+++ b/sandbox/win/src/service_resolver_64.cc
@@ -282,8 +282,4 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   return STATUS_SUCCESS;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(void*) const {
-  return true;
-}
-
 }  // namespace sandbox
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index afdddac091985..c18e7b14fddc3 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -570,6 +570,37 @@ absl::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return handle_map;
 }
 
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count)) {
+    return absl::nullopt;
+  }
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 }  // namespace sandbox
 
 void ResolveNTFunctionPtr(const char* name, void* ptr) {
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index e416d6cda9979..03a7fd806246d 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -115,6 +115,11 @@ void* GetProcessBaseAddress(HANDLE process);
 // use them.
 absl::optional<ProcessHandleMap> GetCurrentProcessHandles();
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
 }  // namespace sandbox
 
 // Resolves a function name in NTDLL to a function pointer. The second parameter
diff --git a/services/device/geolocation/win/location_provider_winrt.cc b/services/device/geolocation/win/location_provider_winrt.cc
index 2c2b868a5294a..7a78235589925 100644
--- a/services/device/geolocation/win/location_provider_winrt.cc
+++ b/services/device/geolocation/win/location_provider_winrt.cc
@@ -70,6 +70,11 @@ void RecordUmaEvent(WindowsRTLocationRequestEvent event) {
   base::UmaHistogramEnumeration("Windows.RT.LocationRequest.Event", event);
 }
 
+bool IsWinRTSupported() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 template <typename F>
 absl::optional<DOUBLE> GetOptionalDouble(F&& getter) {
   DOUBLE value = 0;
@@ -506,7 +511,7 @@ std::unique_ptr<LocationProvider> NewSystemLocationProvider(
     GeolocationManager* geolocation_manager) {
   if (!base::FeatureList::IsEnabled(
           features::kWinrtGeolocationImplementation) ||
-      !IsSystemLocationSettingEnabled()) {
+      !IsWinRTSupported() || !IsSystemLocationSettingEnabled()) {
     return nullptr;
   }
 
diff --git a/services/proxy_resolver_win/BUILD.gn b/services/proxy_resolver_win/BUILD.gn
index ed4b004f06350..c3fa7ec452180 100644
--- a/services/proxy_resolver_win/BUILD.gn
+++ b/services/proxy_resolver_win/BUILD.gn
@@ -11,6 +11,8 @@ component("proxy_resolver_win") {
     "winhttp_api_wrapper.h",
     "winhttp_api_wrapper_impl.cc",
     "winhttp_api_wrapper_impl.h",
+    "winhttp_proxy_resolver_functions.cc",
+    "winhttp_proxy_resolver_functions.h",
   ]
 
   libs = [ "winhttp.lib" ]
diff --git a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
index 68801e4636cab..3089fca76f4bf 100644
--- a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
+++ b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
@@ -15,6 +15,8 @@ EnumTraits<proxy_resolver_win::mojom::WinHttpStatus,
       return proxy_resolver_win::mojom::WinHttpStatus::kOk;
     case net::WinHttpStatus::kAborted:
       return proxy_resolver_win::mojom::WinHttpStatus::kAborted;
+    case net::WinHttpStatus::kFunctionsNotLoaded:
+      return proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded;
     case net::WinHttpStatus::kWinHttpOpenFailed:
       return proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed;
     case net::WinHttpStatus::kWinHttpSetTimeoutsFailed:
@@ -55,6 +57,9 @@ bool EnumTraits<proxy_resolver_win::mojom::WinHttpStatus, net::WinHttpStatus>::
     case proxy_resolver_win::mojom::WinHttpStatus::kAborted:
       *output = net::WinHttpStatus::kAborted;
       return true;
+    case proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded:
+      *output = net::WinHttpStatus::kFunctionsNotLoaded;
+      return true;
     case proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed:
       *output = net::WinHttpStatus::kWinHttpOpenFailed;
       return true;
diff --git a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
index c05d1f63d7d9b..ff3447e285e46 100644
--- a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
+++ b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
@@ -12,6 +12,7 @@ import "url/mojom/url.mojom";
 enum WinHttpStatus {
   kOk,
   kAborted,
+  kFunctionsNotLoaded,
   kWinHttpOpenFailed,
   kWinHttpSetTimeoutsFailed,
   kWinHttpSetStatusCallbackFailed,
diff --git a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
index 54baece710f7a..78e4538bd2ded 100644
--- a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
+++ b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
@@ -9,6 +9,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
 
 namespace proxy_resolver_win {
 
@@ -34,9 +35,9 @@ WinHttpAPIWrapperImpl::~WinHttpAPIWrapperImpl() {
 
 bool WinHttpAPIWrapperImpl::CallWinHttpOpen() {
   DCHECK_EQ(nullptr, session_handle_);
-  session_handle_ = ::WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY,
-                                  WINHTTP_NO_PROXY_NAME,
-                                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
+  session_handle_ =
+      WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME,
+                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
   return (session_handle_ != nullptr);
 }
 
@@ -45,16 +46,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetTimeouts(int resolve_timeout,
                                                    int send_timeout,
                                                    int receive_timeout) {
   DCHECK_NE(nullptr, session_handle_);
-  return (!!::WinHttpSetTimeouts(session_handle_, resolve_timeout,
-                                 connect_timeout, send_timeout,
-                                 receive_timeout));
+  return (!!WinHttpSetTimeouts(session_handle_, resolve_timeout,
+                               connect_timeout, send_timeout, receive_timeout));
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
     WINHTTP_STATUS_CALLBACK internet_callback) {
   DCHECK_NE(nullptr, session_handle_);
   const WINHTTP_STATUS_CALLBACK winhttp_status_callback =
-      ::WinHttpSetStatusCallback(
+      WinHttpSetStatusCallback(
           session_handle_, internet_callback,
           WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
               WINHTTP_CALLBACK_FLAG_GETPROXYFORURL_COMPLETE,
@@ -64,14 +64,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetIEProxyConfigForCurrentUser(
     WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* ie_proxy_config) {
-  return !!::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
+  return !!WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpCreateProxyResolver(
     HINTERNET* out_resolver_handle) {
   DCHECK_NE(nullptr, session_handle_);
   const DWORD result =
-      ::WinHttpCreateProxyResolver(session_handle_, out_resolver_handle);
+      WinHttpProxyResolverFunctions::GetInstance().create_proxy_resolver(
+          session_handle_, out_resolver_handle);
   return (result == ERROR_SUCCESS);
 }
 
@@ -83,25 +84,28 @@ bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyForUrlEx(
   const std::wstring wide_url(url.begin(), url.end());
   // TODO(https://crbug.com/1032820): Upgrade to WinHttpGetProxyForUrlEx2()
   // if there is a clear reason to do so.
-  const DWORD result = ::WinHttpGetProxyForUrlEx(
-      resolver_handle, wide_url.data(), autoproxy_options, context);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_for_url_ex(
+          resolver_handle, wide_url.data(), autoproxy_options, context);
   return (result == ERROR_IO_PENDING);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyResult(
     HINTERNET resolver_handle,
     WINHTTP_PROXY_RESULT* proxy_result) {
-  const DWORD result = ::WinHttpGetProxyResult(resolver_handle, proxy_result);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_result(
+          resolver_handle, proxy_result);
   return (result == ERROR_SUCCESS);
 }
 
 VOID WinHttpAPIWrapperImpl::CallWinHttpFreeProxyResult(
     WINHTTP_PROXY_RESULT* proxy_result) {
-  WinHttpFreeProxyResult(proxy_result);
+  WinHttpProxyResolverFunctions::GetInstance().free_proxy_result(proxy_result);
 }
 
 void WinHttpAPIWrapperImpl::CallWinHttpCloseHandle(HINTERNET internet_handle) {
-  ::WinHttpCloseHandle(internet_handle);
+  WinHttpCloseHandle(internet_handle);
 }
 
 void WinHttpAPIWrapperImpl::CloseSessionHandle() {
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
new file mode 100644
index 0000000000000..b00c5670bb517
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
@@ -0,0 +1,43 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+WinHttpProxyResolverFunctions::WinHttpProxyResolverFunctions() {
+  HMODULE winhttp_module =
+      LoadLibraryEx(L"winhttp.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  if (winhttp_module) {
+    create_proxy_resolver = reinterpret_cast<WinHttpCreateProxyResolverFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpCreateProxyResolver"));
+    get_proxy_for_url_ex = reinterpret_cast<WinHttpGetProxyForUrlExFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyForUrlEx"));
+    get_proxy_result = reinterpret_cast<WinHttpGetProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyResult"));
+    free_proxy_result = reinterpret_cast<WinHttpFreeProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpFreeProxyResult"));
+  }
+}
+
+// Never called due to base::NoDestructor.
+WinHttpProxyResolverFunctions::~WinHttpProxyResolverFunctions() = default;
+
+bool WinHttpProxyResolverFunctions::are_all_functions_loaded() const {
+  return create_proxy_resolver && get_proxy_for_url_ex && get_proxy_result &&
+         free_proxy_result;
+}
+
+// static
+const WinHttpProxyResolverFunctions&
+WinHttpProxyResolverFunctions::GetInstance() {
+  // This is a singleton for performance reasons. This avoids having to load
+  // proxy resolver functions multiple times.
+  static base::NoDestructor<WinHttpProxyResolverFunctions> instance;
+  return *instance;
+}
+
+}  // namespace proxy_resolver_win
\ No newline at end of file
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
new file mode 100644
index 0000000000000..768269019cd0e
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
@@ -0,0 +1,47 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+#define SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+
+#include <windows.h>
+#include <winhttp.h>
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+// Not all WinHttp APIs we'll be using exist in all versions of Windows.
+// Several only exist in Windows 8+. Thus, each function entry point must be
+// loaded dynamically.
+struct WinHttpProxyResolverFunctions {
+ public:
+  WinHttpProxyResolverFunctions(const WinHttpProxyResolverFunctions&) = delete;
+  WinHttpProxyResolverFunctions& operator=(
+      const WinHttpProxyResolverFunctions&) = delete;
+
+  bool are_all_functions_loaded() const;
+
+  static const WinHttpProxyResolverFunctions& GetInstance();
+
+  using WinHttpCreateProxyResolverFunc = decltype(WinHttpCreateProxyResolver)*;
+  using WinHttpGetProxyForUrlExFunc = decltype(WinHttpGetProxyForUrlEx)*;
+  using WinHttpGetProxyResultFunc = decltype(WinHttpGetProxyResult)*;
+  using WinHttpFreeProxyResultFunc = decltype(WinHttpFreeProxyResult)*;
+
+  WinHttpCreateProxyResolverFunc create_proxy_resolver = nullptr;
+  WinHttpGetProxyForUrlExFunc get_proxy_for_url_ex = nullptr;
+  WinHttpGetProxyResultFunc get_proxy_result = nullptr;
+  WinHttpFreeProxyResultFunc free_proxy_result = nullptr;
+
+ private:
+  friend class base::NoDestructor<WinHttpProxyResolverFunctions>;
+
+  WinHttpProxyResolverFunctions();
+  ~WinHttpProxyResolverFunctions();
+};
+
+}  // namespace proxy_resolver_win
+
+#endif  // SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
\ No newline at end of file
diff --git a/services/shape_detection/face_detection_provider_win.cc b/services/shape_detection/face_detection_provider_win.cc
index 59e9eb36d95a5..dbe49923cf948 100644
--- a/services/shape_detection/face_detection_provider_win.cc
+++ b/services/shape_detection/face_detection_provider_win.cc
@@ -49,6 +49,11 @@ BitmapPixelFormat GetPreferredPixelFormat(IFaceDetectorStatics* factory) {
 void FaceDetectionProviderWin::CreateFaceDetection(
     mojo::PendingReceiver<shape_detection::mojom::FaceDetection> receiver,
     shape_detection::mojom::FaceDetectorOptionsPtr options) {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
   ComPtr<IFaceDetectorStatics> factory;
   HRESULT hr = GetActivationFactory<
       IFaceDetectorStatics,
diff --git a/services/shape_detection/text_detection_impl_win.cc b/services/shape_detection/text_detection_impl_win.cc
index a442dced19ad6..5000cf94dfb06 100644
--- a/services/shape_detection/text_detection_impl_win.cc
+++ b/services/shape_detection/text_detection_impl_win.cc
@@ -42,6 +42,12 @@ using Microsoft::WRL::ComPtr;
 // static
 void TextDetectionImpl::Create(
     mojo::PendingReceiver<mojom::TextDetection> receiver) {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
+
   // Text Detection specification only supports Latin-1 text as documented in
   // https://wicg.github.io/shape-detection-api/text.html#text-detection-api.
   // TODO(junwei.fu): https://crbug.com/794097 consider supporting other Latin
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index bedc83f29fadb..2d45db23680f7 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -460,6 +460,7 @@ component("skia") {
   if (is_win) {
     # See SK_TYPEFACE_FACTORY_DIRECTWRITE
     sources += [
+      "//third_party/skia/src/ports/SkFontHost_win.cpp",
       "//third_party/skia/src/ports/SkFontMgr_win_dw.cpp",
       "//third_party/skia/src/ports/SkOSFile_win.cpp",
       "//third_party/skia/src/ports/SkRemotableFontMgr_win_dw.cpp",
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index a66ddcf4d9031..c6ddb5b7e6061 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -20,6 +20,13 @@ struct DWriteFontStyle {
   uint8 font_stretch;
 };
 
+struct FallbackFamilyAndStyle {
+  string fallback_family_name;
+  uint16 weight;
+  uint8 width;
+  uint8 slant;
+};
+
 struct MapCharactersResult {
   uint32 family_index;
   mojo_base.mojom.String16 family_name;
@@ -28,6 +35,11 @@ struct MapCharactersResult {
   DWriteFontStyle font_style;
 };
 
+enum UniqueFontLookupMode {
+    kRetrieveTable,
+    kSingleLookups
+};
+
 interface DWriteFontProxy {
   // Locates the index of the specified font family within the system
   // collection.
@@ -51,14 +63,47 @@ interface DWriteFontProxy {
   GetFontFileHandles(uint32 family_index)
      => (array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
@@ -73,4 +118,18 @@ interface DWriteFontProxy {
                 uint32 reading_direction,
                 mojo_base.mojom.String16 base_family_name)
       => (MapCharactersResult out);
+
+  // For a given base family name, bcp47 language tag, and codepoint to look up,
+  // return a font family name that is available on the system to display the
+  // given codepoint. This internally calls Skia's
+  // SkFontMgr_DirectWrite::matchFamilyStyleCharacter which executes
+  // IDWriteTextLayout based fallback code, which cannot be run in the renderer
+  // due triggering loading the DWrite system font collection.
+  // Use only on Windows 8.0 and earlier - otherwise better fallback API is
+  // available through using a proxies IDWriteFontFallback.
+  [Sync]
+  FallbackFamilyAndStyleForCodepoint(string base_family_name,
+                                     string bcp47_language_tag,
+                                     uint32 codepoint)
+      => (FallbackFamilyAndStyle fallback_result);
 };
diff --git a/third_party/blink/public/web/win/web_font_rendering.h b/third_party/blink/public/web/win/web_font_rendering.h
index 851b6c95d0c69..1c3135b59201f 100644
--- a/third_party/blink/public/web/win/web_font_rendering.h
+++ b/third_party/blink/public/web/win/web_font_rendering.h
@@ -18,6 +18,7 @@ class WebFontRenderingClient;
 
 class BLINK_EXPORT WebFontRendering {
  public:
+  static void setUseDirectWrite(bool);
   static void SetSkiaFontManager(sk_sp<SkFontMgr>);
   // Set an instance of |WebFontPrewarmer|. The instance must be kept alive
   // until the process exits.
@@ -34,6 +35,7 @@ class BLINK_EXPORT WebFontRendering {
                                    int32_t font_height);
   static void SetAntialiasedTextEnabled(bool);
   static void SetLCDTextEnabled(bool);
+  static void SetUseSkiaFontFallback(bool);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
index 178b04c75c258..1d4988bb76765 100644
--- a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
+++ b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
@@ -9,6 +9,11 @@
 
 namespace blink {
 
+// static
+void WebFontRendering::setUseDirectWrite(bool useDirectWrite) {
+  FontCache::setUseDirectWrite(useDirectWrite);
+}
+
 // static
 void WebFontRendering::SetSkiaFontManager(sk_sp<SkFontMgr> font_mgr) {
   FontCache::SetFontManager(std::move(font_mgr));
@@ -59,4 +64,9 @@ void WebFontRendering::SetLCDTextEnabled(bool enabled) {
   FontCache::SetLCDTextEnabled(enabled);
 }
 
+// static
+void WebFontRendering::SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+  FontCache::SetUseSkiaFontFallback(use_skia_font_fallback);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 5ecdd70e2152a..62eaaf3d5b701 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1632,6 +1632,8 @@ component("platform") {
     sources += [
       "fonts/win/dwrite_font_format_support.cc",
       "fonts/win/dwrite_font_format_support.h",
+      "fonts/win/fallback_family_style_cache_win.cc",
+      "fonts/win/fallback_family_style_cache_win.h",
       "fonts/win/font_cache_skia_win.cc",
       "fonts/win/font_fallback_win.cc",
       "fonts/win/font_fallback_win.h",
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index 2d160f4de81ce..eaa0462c680fb 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -59,6 +59,7 @@
 #include "ui/gfx/font_list.h"
 
 #if BUILDFLAG(IS_WIN)
+#include <Windows.h>
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -77,8 +78,10 @@ float FontCache::device_scale_factor_ = 1.0;
 #endif
 
 #if BUILDFLAG(IS_WIN)
+bool FontCache::s_useDirectWrite = false;
 bool FontCache::antialiased_text_enabled_ = false;
 bool FontCache::lcd_text_enabled_ = false;
+bool FontCache::use_skia_font_fallback_ = false;
 static bool should_use_test_font_mgr = false;
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -95,7 +98,11 @@ FontCache::FontCache()
     // This code path is only for unit tests. This SkFontMgr does not work in
     // sandboxed environments, but injecting this initialization code to all
     // unit tests isn't easy.
-    font_manager_ = SkFontMgr_New_DirectWrite();
+    if (s_useDirectWrite) {
+      font_manager_ = SkFontMgr_New_DirectWrite();
+    } else {
+      font_manager_ = SkFontMgr_New_GDI();
+    }
     // Set |is_test_font_mgr_| to capture if this is not happening in the
     // production code. crbug.com/561873
     is_test_font_mgr_ = true;
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index ae5cee24b4c49..991cdb480930f 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -38,6 +38,7 @@
 #include "base/gtest_prod_util.h"
 #include "base/memory/scoped_refptr.h"
 #include "build/build_config.h"
+#include "mojo/public/cpp/bindings/remote.h"
 #include "third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_client.h"
 #include "third_party/blink/renderer/platform/fonts/font_data_cache.h"
@@ -60,6 +61,11 @@
 #include "ui/gfx/font_fallback_linux.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+#endif
+
 class SkString;
 class SkTypeface;
 
@@ -197,8 +203,12 @@ class PLATFORM_EXPORT FontCache final {
 #if BUILDFLAG(IS_WIN)
   // TODO(https://crbug.com/808221) System font style configuration is not
   // related to FontCache. Move it somewhere else, e.g. to WebThemeEngine.
+  static bool useDirectWrite() { return s_useDirectWrite; }
   static bool AntialiasedTextEnabled() { return antialiased_text_enabled_; }
   static bool LcdTextEnabled() { return lcd_text_enabled_; }
+  static void setUseDirectWrite(bool useDirectWrite) {
+    s_useDirectWrite = useDirectWrite;
+  }
   static void SetAntialiasedTextEnabled(bool enabled) {
     antialiased_text_enabled_ = enabled;
   }
@@ -222,6 +232,13 @@ class PLATFORM_EXPORT FontCache final {
   static const AtomicString& StatusFontFamily() {
     return *status_font_family_name_;
   }
+  static void SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+    use_skia_font_fallback_ = use_skia_font_fallback;
+  }
+
+  // On Windows pre 8.1 establish a connection to the DWriteFontProxy service in
+  // order to retrieve family names for fallback lookup.
+  void EnsureServiceConnected();
 
   scoped_refptr<SimpleFontData> GetFallbackFamilyNameFromHardcodedChoices(
       const FontDescription&,
@@ -352,6 +369,7 @@ class PLATFORM_EXPORT FontCache final {
   static SkFontMgr* static_font_manager_;
 
 #if BUILDFLAG(IS_WIN)
+  static bool s_useDirectWrite;
   static WebFontPrewarmer* prewarmer_;
   static bool antialiased_text_enabled_;
   static bool lcd_text_enabled_;
@@ -362,10 +380,13 @@ class PLATFORM_EXPORT FontCache final {
   static int32_t small_caption_font_height_;
   static AtomicString* status_font_family_name_;
   static int32_t status_font_height_;
+  static bool use_skia_font_fallback_;
 
   // Windows creates an SkFontMgr for unit testing automatically. This flag is
   // to ensure it's not happening in the production from the crash log.
   bool is_test_font_mgr_ = false;
+  mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
index da25d2d225f2a..7c2487a4aa3b3 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
@@ -128,6 +128,36 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
   // now, going with a reasonable upper limit. Deduplication is
   // handled by Skia with priority given to the last occuring
   // assignment.
+#if BUILDFLAG(IS_WIN)
+  if (!FontCache::useDirectWrite()) {
+    // FIXME: Skia currently renders synthetic bold and italics with
+    // hinting and without linear metrics on the windows GDI backend
+    // while the DirectWrite backend does the right thing. Using
+    // legacyCreateTypeface and specifying the bold/italics style allows
+    // for proper rendering of synthetic style. Once Skia has been
+    // updated this workaround will no longer be needed.
+    // http://crbug.com/332958
+    bool syntheticBold = bold && !return_typeface->isBold();
+    bool syntheticItalic = italic && !return_typeface->isItalic();
+    if (syntheticBold || syntheticItalic) {
+      SkString name;
+      sk_sp<SkFontMgr> font_mgr(SkFontMgr::RefDefault());
+      return_typeface->getFamilyName(&name);
+
+      SkFontStyle realStyle = return_typeface->fontStyle();
+      SkFontStyle syntheticStyle = SkFontStyle(
+          realStyle.weight() + (syntheticBold ? 200 : 0), realStyle.width(),
+          syntheticItalic ? SkFontStyle::kItalic_Slant : realStyle.slant());
+      sk_sp<SkTypeface> typeface =
+          font_mgr->legacyMakeTypeface(name.c_str(), syntheticStyle);
+      syntheticBold = false;
+      syntheticItalic = false;
+      return FontPlatformData(typeface, "", size, syntheticBold,
+                              syntheticItalic, text_rendering,
+                              resolved_font_features, orientation);
+    }
+  }
+#endif
   FontFormatCheck::VariableFontSubType font_sub_type =
       FontFormatCheck::ProbeVariableFont(base_typeface_);
   bool synthetic_bold = bold;
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
index bb6625fe0df54..15ab82a954148 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
@@ -83,8 +83,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
 
   // Save first candidate to be returned if all other fonts fail, and we need
   // it to render the .notdef glyph.
-  if (!first_candidate_)
+  if (!first_candidate_) {
     first_candidate_ = candidate;
+  }
   return candidate;
 }
 
@@ -153,8 +154,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
   if (fallback_stage_ == kFirstCandidateForNotdefGlyph) {
     fallback_stage_ = kOutOfLuck;
-    if (!first_candidate_)
+    if (!first_candidate_) {
       FontCache::CrashWithFontInfo(&font_description_);
+    }
     return first_candidate_;
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index ae4a61fa41713..78934a94c2263 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -193,7 +193,6 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
                             AlternateFontName::kLastResort);
   }
 #endif
-
   DCHECK(font_platform_data);
   return FontDataFromFontPlatformData(font_platform_data, should_retain);
 }
@@ -233,6 +232,13 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   // TODO(https://crbug.com/1425390: Assign FontCache::font_manager_ in the
   // ctor.
   auto font_manager = font_manager_ ? font_manager_ : SkFontMgr::RefDefault();
+#if BUILDFLAG(IS_WIN)
+  if (!useDirectWrite()) {
+    return sk_sp<SkTypeface>(
+        font_manager->legacyMakeTypeface(name.empty() ? nullptr : name.c_str(),
+                                         font_description.SkiaFontStyle()));
+  }
+#endif
   return sk_sp<SkTypeface>(font_manager->matchFamilyStyle(
       name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
 }
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
new file mode 100644
index 0000000000000..2e8c855270541
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
@@ -0,0 +1,90 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+
+namespace blink {
+
+namespace {
+
+const wtf_size_t kMaxCacheSlots = 16;
+
+String makeCacheKey(FontDescription::GenericFamilyType generic_family,
+                    String bcp47_language_tag,
+                    FontFallbackPriority fallback_priority) {
+  StringBuilder cache_key;
+  cache_key.Append(bcp47_language_tag);
+  cache_key.AppendNumber(
+      static_cast<
+          std::underlying_type<FontDescription::GenericFamilyType>::type>(
+          generic_family));
+  cache_key.AppendNumber(
+      static_cast<std::underlying_type<FontFallbackPriority>::type>(
+          fallback_priority));
+  return cache_key.ToString();
+}
+
+void getFallbackFamilyAndStyle(SkTypeface* typeface,
+                               String* fallback_family,
+                               SkFontStyle* fallback_style) {
+  SkString family;
+  typeface->getFamilyName(&family);
+  *fallback_family = family.c_str();
+
+  *fallback_style = typeface->fontStyle();
+}
+}  // namespace
+
+FallbackFamilyStyleCache::FallbackFamilyStyleCache()
+    : recent_fallback_fonts_(kMaxCacheSlots) {}
+
+void FallbackFamilyStyleCache::Put(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    SkTypeface* typeface) {
+  String cache_key =
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority);
+
+  auto it = recent_fallback_fonts_.Get(cache_key);
+  if (it != recent_fallback_fonts_.end()) {
+    it->second.insert(0, sk_ref_sp(typeface));
+  } else {
+    TypefaceVector typefaces;
+    typefaces.push_back(sk_ref_sp(typeface));
+    recent_fallback_fonts_.Put(std::move(cache_key), std::move(typefaces));
+  }
+}
+
+void FallbackFamilyStyleCache::Get(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    UChar32 character,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  auto it = recent_fallback_fonts_.Get(
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority));
+  if (it == recent_fallback_fonts_.end())
+    return;
+  TypefaceVector& typefaces = it->second;
+  for (wtf_size_t i = 0; i < typefaces.size(); ++i) {
+    sk_sp<SkTypeface>& typeface = typefaces.at(i);
+    if (typeface->unicharToGlyph(character)) {
+      getFallbackFamilyAndStyle(typeface.get(), fallback_family,
+                                fallback_style);
+      sk_sp<SkTypeface> tmp_typeface(typeface);
+      // For the vector of typefaces for this specific language tag, since this
+      // SkTypeface had a glyph, move it to the beginning to accelerate
+      // subsequent lookups.
+      typefaces.EraseAt(i);
+      typefaces.insert(0, std::move(tmp_typeface));
+      return;
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
new file mode 100644
index 0000000000000..72e27fa69b27f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
@@ -0,0 +1,59 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+
+#include "base/containers/lru_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+using TypefaceVector = Vector<sk_sp<SkTypeface>>;
+using FallbackLruCache = base::HashingLRUCache<String, TypefaceVector>;
+
+class FallbackFamilyStyleCache {
+  USING_FAST_MALLOC(FallbackFamilyStyleCache);
+
+ public:
+  FallbackFamilyStyleCache();
+  FallbackFamilyStyleCache(const FallbackFamilyStyleCache&) = delete;
+  FallbackFamilyStyleCache& operator=(const FallbackFamilyStyleCache&) = delete;
+
+  // Places a SkTypeface object in the cache for specified language tag and
+  // fallback priority, taking a reference on SkTypeface. Adds the |SkTypeface|
+  // to the beginning of a list of typefaces if previous |SkTypefaces| objects
+  // where added for this set of parameters. Note, the internal list of
+  // typefaces for a language tag and fallback priority is not checked for
+  // duplicates when adding a |typeface| object.
+  void Put(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           SkTypeface* typeface);
+
+  // Fetches a |fallback_family| and |fallback_style| for a given language tag,
+  // fallback priority and codepoint. Checks the internal cache for whether a
+  // fallback font with glyph coverage for |character| is available for the
+  // given parameters, then returns its family name and style.
+  void Get(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           UChar32 character,
+           String* fallback_family,
+           SkFontStyle* fallback_style);
+
+  // Empties the internal cache, deleting keys and unrefing the typefaces that
+  // were placed in the cache.
+  void Clear();
+
+ private:
+  FallbackLruCache recent_fallback_fonts_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index 83efc5cc57615..023150c0dfd47 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -42,6 +42,8 @@
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/trace_event/trace_event.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/web_font_prewarmer.h"
 #include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -163,6 +165,14 @@ void FontCache::SetStatusFontMetrics(const AtomicString& family_name,
   status_font_height_ = EnsureMinimumFontHeightIfNeeded(font_height);
 }
 
+void FontCache::EnsureServiceConnected() {
+  if (service_) {
+    return;
+  }
+  Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+      service_.BindNewPipeAndPassReceiver());
+}
+
 // TODO(https://crbug.com/976737): This function is deprecated and only intended
 // to run in parallel with the API based OOP font fallback calls to compare the
 // results and track them in UMA for a while until we decide to remove this
@@ -247,30 +257,95 @@ scoped_refptr<SimpleFontData> FontCache::GetDWriteFallbackFamily(
       font_description, fallback_priority, codepoint);
   DCHECK(fallback_locale);
 
-  const std::string family_name = font_description.Family().FamilyName().Utf8();
+  // On Pre Windows 8.1 (where use_skia_font_fallback_ is false) we cannot call
+  // the Skia version, as there is no IDWriteFontFallback (which is
+  // proxyable). If no IDWriteFontFallback API exists in the DWrite Skia
+  // SkTypeface implemnetation it will proceed to call the layoutFallback method
+  // of SkTypeface DWrite implementation. This method we must not call in the
+  // renderer as it causes stability issues due to reaching a path that will try
+  // to load the system font collection in-process and thus load DLLs that are
+  // blocked in the renderer, see comment in dwrite_font_proxy_init_impl_win.cc
+  // InitializeDWriteFontProxy(). Hence, for Windows pre 8.1 we add a
+  // DWriteFontProxy code path to retrieve a family name as string for a
+  // character + language tag and call matchFamilyStyleCharacter on the browser
+  // side, where we can do that.
+  if (!use_skia_font_fallback_) {
+    String fallback_family;
+    SkFontStyle fallback_style;
+
+    if (UNLIKELY(!fallback_params_cache_)) {
+      fallback_params_cache_ = std::make_unique<FallbackFamilyStyleCache>();
+    }
 
-  Bcp47Vector locales;
-  locales.push_back(fallback_locale->LocaleForSkFontMgr());
-  sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
-      family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
-      locales.size(), codepoint));
+    fallback_params_cache_->Get(
+        font_description.GenericFamily(), fallback_locale->LocaleForSkFontMgr(),
+        fallback_priority, codepoint, &fallback_family, &fallback_style);
+    bool result_from_cache = !fallback_family.IsNull();
 
-  if (!typeface) {
-    return nullptr;
-  }
+    if (!result_from_cache) {
+      EnsureServiceConnected();
+
+      // After Mojo IPC, on the browser side, this ultimately reaches
+      // Skia's matchFamilyStyleCharacter for Windows, which does not implement
+      // traversing the language tag stack but only processes the most important
+      // one, so we use FallbackLocaleForCharacter() to determine what locale to
+      // choose to achieve the best possible result.
+
+      if (!GetOutOfProcessFallbackFamily(
+              codepoint, font_description.GenericFamily(),
+              fallback_locale->LocaleForSkFontMgr(), fallback_priority,
+              service_, &fallback_family, &fallback_style)) {
+        return nullptr;
+      }
+
+      if (fallback_family.empty()) {
+        return nullptr;
+      }
+    }
 
-  SkString skia_family;
-  typeface->getFamilyName(&skia_family);
-  FontDescription fallback_updated_font_description(font_description);
-  fallback_updated_font_description.UpdateFromSkiaFontStyle(
-      typeface->fontStyle());
-  const FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
-  FontPlatformData* data =
-      GetFontPlatformData(fallback_updated_font_description, create_by_family);
-  if (!data || !data->FontContainsCharacter(codepoint)) {
-    return nullptr;
+    FontFaceCreationParams create_by_family((AtomicString(fallback_family)));
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(fallback_style);
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint)) {
+      return nullptr;
+    }
+
+    if (!result_from_cache) {
+      fallback_params_cache_->Put(font_description.GenericFamily(),
+                                  fallback_locale->LocaleForSkFontMgr(),
+                                  fallback_priority, data->Typeface());
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  } else {
+    std::string family_name = font_description.Family().FamilyName().Utf8();
+
+    Bcp47Vector locales;
+    locales.push_back(fallback_locale->LocaleForSkFontMgr());
+    sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
+        family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+        locales.size(), codepoint));
+
+    if (!typeface) {
+      return nullptr;
+    }
+
+    SkString skia_family;
+    typeface->getFamilyName(&skia_family);
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(
+        typeface->fontStyle());
+    FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint)) {
+      return nullptr;
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
   }
-  return FontDataFromFontPlatformData(data, kDoNotRetain);
+  NOTREACHED();
+  return nullptr;
 }
 
 // Given the desired base font, this will create a SimpleFontData for a specific
@@ -296,9 +371,10 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       GetFallbackFamilyNameFromHardcodedChoices(font_description, character,
                                                 fallback_priority);
 
-  // Fall through to running the API-based fallback.
+  // Fall through to running the API based fallback on Windows 8.1 and above
+  // where API fallback was previously available.
   if (RuntimeEnabledFeatures::LegacyWindowsDWriteFontFallbackEnabled() ||
-      !hardcoded_list_fallback_font) {
+      (!hardcoded_list_fallback_font && use_skia_font_fallback_)) {
     return GetDWriteFallbackFamily(font_description, character,
                                    fallback_priority);
   }
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
index fe7c9a5c819bd..edd8710b1e28a 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
@@ -48,11 +48,19 @@ namespace blink {
 
 namespace {
 
+const char kArial[] = "Arial";
+const char kCourierNew[] = "Courier New";
+const char kTimesNewRoman[] = "Times New Roman";
+
 static inline bool IsFontPresent(const UChar* font_name,
                                  SkFontMgr* font_manager) {
   String family = font_name;
-  sk_sp<SkTypeface> tf(
-      font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle()));
+  sk_sp<SkTypeface> tf;
+  if (FontCache::useDirectWrite()) {
+    tf = font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle());
+  } else {
+    tf = font_manager->legacyMakeTypeface(family.Utf8().data(), SkFontStyle());
+  }
   if (!tf)
     return false;
 
@@ -538,4 +546,38 @@ const UChar* GetFallbackFamily(UChar32 character,
   return family;
 }
 
+bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& service,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  String base_family_name_approximation;
+  switch (generic_family) {
+    case FontDescription::kMonospaceFamily:
+      base_family_name_approximation = kCourierNew;
+      break;
+    case FontDescription::kSansSerifFamily:
+      base_family_name_approximation = kArial;
+      break;
+    default:
+      base_family_name_approximation = kTimesNewRoman;
+  }
+
+  mojom::blink::FallbackFamilyAndStylePtr fallback_family_and_style;
+  bool mojo_result = service->FallbackFamilyAndStyleForCodepoint(
+      base_family_name_approximation, bcp47_language_tag, character,
+      &fallback_family_and_style);
+
+  SECURITY_DCHECK(fallback_family);
+  SECURITY_DCHECK(fallback_style);
+  *fallback_family = fallback_family_and_style->fallback_family_name;
+  *fallback_style = SkFontStyle(
+      fallback_family_and_style->weight, fallback_family_and_style->width,
+      static_cast<SkFontStyle::Slant>(fallback_family_and_style->slant));
+  return mojo_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
index 6a51e150dc5b9..254eba78a3639 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
@@ -34,10 +34,13 @@
 #include <unicode/locid.h>
 #include <unicode/uscript.h>
 
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 class SkFontMgr;
 
@@ -55,6 +58,19 @@ PLATFORM_EXPORT const UChar* GetFallbackFamily(
     FontFallbackPriority,
     SkFontMgr* font_manager);
 
+// Return a font family that can render |character| based on what script
+// that characters belong to by performing an out of process lookup and using
+// system fallback API based on IDWriteTextLayout. This method is only to be
+// used on pre Windows 8.1, as otherwise IDWriteFontFallback API is available.
+PLATFORM_EXPORT bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& font_proxy,
+    String* fallback_family,
+    SkFontStyle* fallback_style);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_FALLBACK_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index 3b1c3db022fd0..06e4f8edc0b57 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
@@ -26,11 +27,15 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  }
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -43,6 +48,33 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup()) {
+    return nullptr;
+  }
+
+  absl::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result) {
+    return nullptr;
+  }
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  return SkTypeface::MakeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -60,11 +92,55 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
-    EnsureServiceConnected();
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
+    return true;
+  }
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
+  }
+
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get()) {
+    return true;
   }
 
-  return true;
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value()) {
+    return sync_available_.value();
+  }
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -74,11 +150,67 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1) {
+    return;
+  }
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index 7b31b5af1cabc..fc34bd99c18d1 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows Vista, 7 & 8, a shared memory region is
+// retrieved asynchronously, then lookups are performed against that table. When
+// the asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,17 +32,32 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  absl::optional<bool> sync_available_;
+  absl::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
diff --git a/tools/metrics/histograms/metadata/windows/histograms.xml b/tools/metrics/histograms/metadata/windows/histograms.xml
index aee2749f193b7..247779fee1b3c 100644
--- a/tools/metrics/histograms/metadata/windows/histograms.xml
+++ b/tools/metrics/histograms/metadata/windows/histograms.xml
@@ -76,30 +76,6 @@ chromium-metrics-reviews@google.com.
   </summary>
 </histogram>
 
-<histogram name="Windows.Enclave.{Type}.Available" enum="BooleanAvailable"
-    expires_after="2023-12-01">
-  <owner>ajgo@chromium.org</owner>
-  <owner>wfh@chromium.org</owner>
-  <summary>
-    Whether or not support for {Type} is/are available for use on the system, by
-    calling IsEnclaveTypeSupported. Reported once per browser session, on
-    startup.
-  </summary>
-  <token key="Type">
-    <variant name="SGX"
-        summary="an enclave for the Intel Software Guard Extensions (SGX)
-                 architecture extension"/>
-    <variant name="SGX2"
-        summary="SGX2 and SGX1 enclaves (the platform and OS support SGX2
-                 instructions with EDMM on this platform - in addition to
-                 other SGX2 constructs)"/>
-    <variant name="VBS"
-        summary="a virtualization-based security (VBS) enclave"/>
-    <variant name="VBSBasic"
-        summary="a virtualization-based security (VBS) basic enclave"/>
-  </token>
-</histogram>
-
 <histogram name="Windows.HasHighResolutionTimeTicks" enum="Boolean"
     expires_after="2024-02-20">
   <owner>brucedawson@chromium.org</owner>
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
index e079f9ccd09d2..ed9cb666ff09b 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
@@ -91,6 +91,11 @@ class OnScreenKeyboardDisplayManagerInputPane::VirtualKeyboardInputPane
     if (input_pane2_)
       return true;
 
+    if (!base::win::ResolveCoreWinRTDelayload() ||
+        !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+      return false;
+    }
+
     base::win::AssertComApartmentType(base::win::ComApartmentType::STA);
 
     base::win::ScopedHString input_pane_guid = base::win::ScopedHString::Create(
diff --git a/ui/color/color_provider_key.cc b/ui/color/color_provider_key.cc
index d8733b9f44ad2..5cb51f2d8ec58 100644
--- a/ui/color/color_provider_key.cc
+++ b/ui/color/color_provider_key.cc
@@ -21,10 +21,9 @@ ColorProviderKey::ColorProviderKey()
                        ContrastMode::kNormal,
                        SystemTheme::kDefault,
                        FrameType::kChromium,
-                       FrameStyle::kDefault,
-                       UserColorSource::kAccent,
                        absl::nullopt,
                        absl::nullopt,
+                       false,
                        nullptr) {}
 
 ColorProviderKey::ColorProviderKey(
@@ -32,20 +31,18 @@ ColorProviderKey::ColorProviderKey(
     ContrastMode contrast_mode,
     SystemTheme system_theme,
     FrameType frame_type,
-    FrameStyle frame_style,
-    UserColorSource user_color_source,
     absl::optional<SkColor> user_color,
     absl::optional<SchemeVariant> scheme_variant,
+    bool is_grayscale,
     scoped_refptr<ThemeInitializerSupplier> custom_theme)
     : color_mode(color_mode),
       contrast_mode(contrast_mode),
       elevation_mode(ElevationMode::kLow),
       system_theme(system_theme),
       frame_type(frame_type),
-      frame_style(frame_style),
-      user_color_source(user_color_source),
       user_color(user_color),
       scheme_variant(scheme_variant),
+      is_grayscale(is_grayscale),
       custom_theme(std::move(custom_theme)) {}
 
 ColorProviderKey::ColorProviderKey(const ColorProviderKey&) = default;
@@ -55,4 +52,4 @@ ColorProviderKey& ColorProviderKey::operator=(const ColorProviderKey&) =
 
 ColorProviderKey::~ColorProviderKey() = default;
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/color/color_provider_key.h b/ui/color/color_provider_key.h
index 53e99a5a90ac8..644ff021ea6a6 100644
--- a/ui/color/color_provider_key.h
+++ b/ui/color/color_provider_key.h
@@ -42,14 +42,6 @@ struct COMPONENT_EXPORT(COLOR_PROVIDER_KEY) ColorProviderKey {
     // Native system renders the browser frame. Currently GTK only.
     kNative,
   };
-  // The style in which Chrome-rendered frames are painted. This only applies
-  // for the kChromium frame type.
-  enum class FrameStyle {
-    // Paints the default Chrome frame.
-    kDefault,
-    // Paints an emulated system style frame.
-    kSystem,
-  };
   // The type of color palette that is generated.
   enum class SchemeVariant {
     kTonalSpot,
@@ -57,12 +49,6 @@ struct COMPONENT_EXPORT(COLOR_PROVIDER_KEY) ColorProviderKey {
     kVibrant,
     kExpressive,
   };
-  // The source of the color used to generate the material color palette.
-  enum class UserColorSource {
-    kBaseline,
-    kGrayscale,
-    kAccent,
-  };
 
   class COMPONENT_EXPORT(COLOR_PROVIDER_KEY) InitializerSupplier {
    public:
@@ -108,17 +94,14 @@ struct COMPONENT_EXPORT(COLOR_PROVIDER_KEY) ColorProviderKey {
 
   ColorProviderKey();  // For test convenience.
 
-  // TODO(tluk): Switch to using named initializers so clients can set only the
-  // necessary parameters on the key.
   ColorProviderKey(
       ColorMode color_mode,
       ContrastMode contrast_mode,
       SystemTheme system_theme,
       FrameType frame_type,
-      FrameStyle = FrameStyle::kDefault,
-      UserColorSource user_color_source = UserColorSource::kAccent,
       absl::optional<SkColor> user_color = absl::nullopt,
       absl::optional<SchemeVariant> scheme_variant = absl::nullopt,
+      bool is_grayscale = false,
       scoped_refptr<ThemeInitializerSupplier> custom_theme = nullptr);
 
   ColorProviderKey(const ColorProviderKey&);
@@ -131,10 +114,9 @@ struct COMPONENT_EXPORT(COLOR_PROVIDER_KEY) ColorProviderKey {
   ElevationMode elevation_mode;
   SystemTheme system_theme;
   FrameType frame_type;
-  FrameStyle frame_style;
-  UserColorSource user_color_source;
   absl::optional<SkColor> user_color;
   absl::optional<SchemeVariant> scheme_variant;
+  bool is_grayscale;
   scoped_refptr<ThemeInitializerSupplier> custom_theme;
   // Only dereferenced when populating the ColorMixer. After that, used to
   // compare addresses during lookup.
@@ -145,16 +127,15 @@ struct COMPONENT_EXPORT(COLOR_PROVIDER_KEY) ColorProviderKey {
     auto* lhs_app_controller = app_controller.get();
     auto* rhs_app_controller = other.app_controller.get();
     return std::tie(color_mode, contrast_mode, elevation_mode, system_theme,
-                    frame_type, frame_style, user_color_source, user_color,
-                    scheme_variant, custom_theme, lhs_app_controller) <
+                    frame_type, user_color, scheme_variant, is_grayscale,
+                    custom_theme, lhs_app_controller) <
            std::tie(other.color_mode, other.contrast_mode, other.elevation_mode,
-                    other.system_theme, other.frame_type, other.frame_style,
-                    other.user_color_source, other.user_color,
-                    other.scheme_variant, other.custom_theme,
-                    rhs_app_controller);
+                    other.system_theme, other.frame_type, other.user_color,
+                    other.scheme_variant, other.is_grayscale,
+                    other.custom_theme, rhs_app_controller);
   }
 };
 
 }  // namespace ui
 
-#endif  // UI_COLOR_COLOR_PROVIDER_KEY_H_
+#endif  // UI_COLOR_COLOR_PROVIDER_KEY_H_
\ No newline at end of file
diff --git a/ui/color/ref_color_mixer.cc b/ui/color/ref_color_mixer.cc
index 5a824db06c75a..f13293145e30a 100644
--- a/ui/color/ref_color_mixer.cc
+++ b/ui/color/ref_color_mixer.cc
@@ -244,14 +244,7 @@ void AddGeneratedPalette(ColorProvider* provider,
 }
 
 void AddRefColorMixer(ColorProvider* provider, const ColorProviderKey& key) {
-  // Typically user_color should always be set when the source has been set to
-  // kAccent, however there may still be cases when this can occur (e.g. failing
-  // to retrieve the system accent color on Windows).
-  // TODO(tluk): Investigate guaranteeing the user_color is defined when kAccent
-  // is set.
-  if (!key.user_color.has_value() ||
-      key.user_color_source == ColorProviderKey::UserColorSource::kBaseline ||
-      key.user_color_source == ColorProviderKey::UserColorSource::kGrayscale) {
+  if (!key.user_color.has_value()) {
     AddBaselinePalette(provider);
   } else {
     // The default value for schemes is Tonal Spot.
@@ -272,4 +265,4 @@ void AddRefColorMixer(ColorProvider* provider, const ColorProviderKey& key) {
   }
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/color/sys_color_mixer.cc b/ui/color/sys_color_mixer.cc
index 9d2c92c453099..e154a0557588b 100644
--- a/ui/color/sys_color_mixer.cc
+++ b/ui/color/sys_color_mixer.cc
@@ -353,13 +353,14 @@ void AddSysColorMixer(ColorProvider* provider, const ColorProviderKey& key) {
 
   // If grayscale is specified the design intention is to apply the grayscale
   // overrides over the baseline palette.
-  if (key.user_color_source == ColorProviderKey::UserColorSource::kGrayscale) {
+  if (key.is_grayscale) {
     AddGrayscaleSysColorOverrides(mixer, key);
-  } else if (key.user_color_source ==
-                 ColorProviderKey::UserColorSource::kAccent &&
-             key.user_color.has_value()) {
+    return;
+  }
+
+  if (key.user_color.has_value()) {
     AddThemedSysColorOverrides(mixer, key);
   }
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/color/win/accent_color_observer.cc b/ui/color/win/accent_color_observer.cc
index 5c8625f621bd6..5a59987ba7e4e 100644
--- a/ui/color/win/accent_color_observer.cc
+++ b/ui/color/win/accent_color_observer.cc
@@ -36,18 +36,6 @@ base::CallbackListSubscription AccentColorObserver::Subscribe(
   return callbacks_.Add(std::move(callback));
 }
 
-void AccentColorObserver::SetAccentColorForTesting(
-    absl::optional<SkColor> accent_color) {
-  accent_color_ = accent_color;
-  callbacks_.Notify();
-}
-
-void AccentColorObserver::SetUseDwmFrameColorForTesting(
-    bool use_dwm_frame_color) {
-  use_dwm_frame_color_ = use_dwm_frame_color;
-  callbacks_.Notify();
-}
-
 void AccentColorObserver::OnDwmKeyUpdated() {
   accent_border_color_ = absl::nullopt;
   DWORD colorization_color, colorization_color_balance;
@@ -78,23 +66,21 @@ void AccentColorObserver::OnDwmKeyUpdated() {
 
   accent_color_ = absl::nullopt;
   accent_color_inactive_ = absl::nullopt;
-  DWORD accent_color = 0;
-  if (dwm_key_->ReadValueDW(L"AccentColor", &accent_color) == ERROR_SUCCESS) {
+  DWORD accent_color, color_prevalence;
+  bool use_dwm_frame_color =
+      dwm_key_->ReadValueDW(L"AccentColor", &accent_color) == ERROR_SUCCESS &&
+      dwm_key_->ReadValueDW(L"ColorPrevalence", &color_prevalence) ==
+          ERROR_SUCCESS &&
+      color_prevalence == 1;
+  if (use_dwm_frame_color) {
     accent_color_ = skia::COLORREFToSkColor(accent_color);
-    DWORD accent_color_inactive = 0;
+    DWORD accent_color_inactive;
     if (dwm_key_->ReadValueDW(L"AccentColorInactive", &accent_color_inactive) ==
         ERROR_SUCCESS) {
       accent_color_inactive_ = skia::COLORREFToSkColor(accent_color_inactive);
     }
   }
 
-  DWORD color_prevalence;
-  use_dwm_frame_color_ =
-      accent_color_.has_value() &&
-      (dwm_key_->ReadValueDW(L"ColorPrevalence", &color_prevalence) ==
-       ERROR_SUCCESS) &&
-      color_prevalence == 1;
-
   callbacks_.Notify();
 
   // Watch for future changes. If there is no task runner, this is a test or
@@ -106,4 +92,4 @@ void AccentColorObserver::OnDwmKeyUpdated() {
   }
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/color/win/accent_color_observer.h b/ui/color/win/accent_color_observer.h
index f992280e10002..96eebd87244a0 100644
--- a/ui/color/win/accent_color_observer.h
+++ b/ui/color/win/accent_color_observer.h
@@ -37,10 +37,6 @@ class COMPONENT_EXPORT(COLOR) AccentColorObserver {
   absl::optional<SkColor> accent_border_color() const {
     return accent_border_color_;
   }
-  bool use_dwm_frame_color() const { return use_dwm_frame_color_; }
-
-  void SetAccentColorForTesting(absl::optional<SkColor> accent_color);
-  void SetUseDwmFrameColorForTesting(bool use_dwm_frame_color);
 
  private:
   void OnDwmKeyUpdated();
@@ -52,9 +48,8 @@ class COMPONENT_EXPORT(COLOR) AccentColorObserver {
   absl::optional<SkColor> accent_color_;
   absl::optional<SkColor> accent_color_inactive_;
   absl::optional<SkColor> accent_border_color_;
-  bool use_dwm_frame_color_ = false;
 };
 
 }  // namespace ui
 
-#endif  // UI_COLOR_WIN_ACCENT_COLOR_OBSERVER_H_
+#endif  // UI_COLOR_WIN_ACCENT_COLOR_OBSERVER_H_
\ No newline at end of file
diff --git a/ui/color/win/native_color_mixers_win.cc b/ui/color/win/native_color_mixers_win.cc
index a0eb66d2a28b1..022af8fee2ce5 100644
--- a/ui/color/win/native_color_mixers_win.cc
+++ b/ui/color/win/native_color_mixers_win.cc
@@ -148,12 +148,9 @@ void AddNativeCoreColorMixer(ColorProvider* provider,
   mixer[kColorNativeWindowText] = {
       color_utils::GetSysSkColor(COLOR_WINDOWTEXT)};
 
-  // Use the system accent color as the Chrome accent color, if present and only
-  // if dwm colors are enabled.
-  const auto* accent_color_observer = AccentColorObserver::Get();
-  const auto& accent_color = accent_color_observer->accent_color();
-  if (accent_color.has_value() &&
-      accent_color_observer->use_dwm_frame_color()) {
+  // Use the system accent color as the Chrome accent color, if present.
+  if (const auto accent_color = AccentColorObserver::Get()->accent_color();
+      accent_color.has_value()) {
     mixer[kColorAccent] = PickGoogleColor(accent_color.value());
   }
 
@@ -308,4 +305,4 @@ void AddNativeUiColorMixer(ColorProvider* provider,
   mixer[kColorForcedScrollbar] = {kColorNativeScrollbar};
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/display/win/screen_win.cc b/ui/display/win/screen_win.cc
index f02d58195a931..02f660f8347bb 100644
--- a/ui/display/win/screen_win.cc
+++ b/ui/display/win/screen_win.cc
@@ -46,11 +46,48 @@ namespace {
 // resolved with Desktop Aura and WindowTreeHost.
 ScreenWin* g_instance = nullptr;
 
+bool IsProcessPerMonitorDpiAware() {
+  enum class PerMonitorDpiAware {
+    UNKNOWN = 0,
+    PER_MONITOR_DPI_UNAWARE,
+    PER_MONITOR_DPI_AWARE,
+  };
+  static PerMonitorDpiAware per_monitor_dpi_aware = PerMonitorDpiAware::UNKNOWN;
+  if (per_monitor_dpi_aware == PerMonitorDpiAware::UNKNOWN) {
+    per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_UNAWARE;
+    HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    if (shcore_dll) {
+      auto get_process_dpi_awareness_func =
+          reinterpret_cast<decltype(::GetProcessDpiAwareness)*>(
+              ::GetProcAddress(shcore_dll, "GetProcessDpiAwareness"));
+      if (get_process_dpi_awareness_func) {
+        PROCESS_DPI_AWARENESS awareness;
+        if (SUCCEEDED(get_process_dpi_awareness_func(nullptr, &awareness)) &&
+            awareness == PROCESS_PER_MONITOR_DPI_AWARE) {
+          per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+        }
+      }
+    }
+  }
+  return per_monitor_dpi_aware == PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+}
+
 // Gets the DPI for a particular monitor.
 absl::optional<int> GetPerMonitorDPI(HMONITOR monitor) {
+  if (!IsProcessPerMonitorDpiAware()) {
+    return absl::nullopt;
+  }
+
+  static auto get_dpi_for_monitor_func = []() {
+    const HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    return reinterpret_cast<decltype(&::GetDpiForMonitor)>(
+        shcore_dll ? ::GetProcAddress(shcore_dll, "GetDpiForMonitor")
+                   : nullptr);
+  }();
   UINT dpi_x, dpi_y;
-  if (!SUCCEEDED(
-          ::GetDpiForMonitor(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y))) {
+  if (!get_dpi_for_monitor_func ||
+      !SUCCEEDED(get_dpi_for_monitor_func(monitor, MDT_EFFECTIVE_DPI, &dpi_x,
+                                          &dpi_y))) {
     return absl::nullopt;
   }
 
diff --git a/ui/display/win/uwp_text_scale_factor.cc b/ui/display/win/uwp_text_scale_factor.cc
index f6867edea301e..2d2d18c212bca 100644
--- a/ui/display/win/uwp_text_scale_factor.cc
+++ b/ui/display/win/uwp_text_scale_factor.cc
@@ -52,6 +52,13 @@ bool g_default_instance_cleaned_up = false;
 bool CreateUiSettingsComObject(ComPtr<IUISettings2>& ptr) {
   DCHECK(!ptr);
 
+  // This is required setup before using ScopedHString.
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
   // Create the COM object.
   auto hstring = base::win::ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UISettings);
diff --git a/ui/gfx/font_render_params_win.cc b/ui/gfx/font_render_params_win.cc
index 4769c5853ee61..569418e1e758e 100644
--- a/ui/gfx/font_render_params_win.cc
+++ b/ui/gfx/font_render_params_win.cc
@@ -11,6 +11,7 @@
 #include "base/functional/callback_helpers.h"
 #include "base/memory/singleton.h"
 #include "base/win/registry.h"
+#include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/singleton_hwnd_observer.h"
 
 namespace gfx {
@@ -83,7 +84,8 @@ class CachedFontRenderParams {
     BOOL enabled = false;
     if (SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &enabled, 0) && enabled) {
       params_->antialiasing = true;
-      params_->subpixel_positioning = true;
+      // GDI does not support subpixel positioning.
+      params_->subpixel_positioning = win::IsDirectWriteEnabled();
 
       UINT type = 0;
       if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index 794b77e9eca3e..f298b366c0169 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -42,6 +42,10 @@
 #include "ui/gfx/text_utils.h"
 #include "ui/gfx/utf16_indexing.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -253,23 +257,25 @@ UChar32 ReplaceControlCharacter(UChar32 codepoint) {
     // Support Microsoft defined PUA on Windows.
     // see:
     // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
-    switch (codepoint) {
-      case 0xF093:  // ButtonA
-      case 0xF094:  // ButtonB
-      case 0xF095:  // ButtonY
-      case 0xF096:  // ButtonX
-      case 0xF108:  // LeftStick
-      case 0xF109:  // RightStick
-      case 0xF10A:  // TriggerLeft
-      case 0xF10B:  // TriggerRight
-      case 0xF10C:  // BumperLeft
-      case 0xF10D:  // BumperRight
-      case 0xF10E:  // Dpad
-      case 0xEECA:  // ButtonView2
-      case 0xEDE3:  // ButtonMenu
-        return codepoint;
-      default:
-        break;
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      switch (codepoint) {
+        case 0xF093:  // ButtonA
+        case 0xF094:  // ButtonB
+        case 0xF095:  // ButtonY
+        case 0xF096:  // ButtonX
+        case 0xF108:  // LeftStick
+        case 0xF109:  // RightStick
+        case 0xF10A:  // TriggerLeft
+        case 0xF10B:  // TriggerRight
+        case 0xF10C:  // BumperLeft
+        case 0xF10D:  // BumperRight
+        case 0xF10E:  // Dpad
+        case 0xEECA:  // ButtonView2
+        case 0xEDE3:  // ButtonMenu
+          return codepoint;
+        default:
+          break;
+      }
     }
 #endif
     const int8_t codepoint_category = u_charType(codepoint);
diff --git a/ui/gfx/switches.cc b/ui/gfx/switches.cc
index 9576188a9872f..08cbed51a27e8 100644
--- a/ui/gfx/switches.cc
+++ b/ui/gfx/switches.cc
@@ -9,6 +9,11 @@
 
 namespace switches {
 
+#if BUILDFLAG(IS_WIN)
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+#endif
+
 // Scale factor to apply to every animation duration. Must be >= 0.0. This will
 // only apply to LinearAnimation and its subclasses.
 const char kAnimationDurationScale[] = "animation-duration-scale";
diff --git a/ui/gfx/switches.h b/ui/gfx/switches.h
index 37011f67b3d33..a838d42264fc1 100644
--- a/ui/gfx/switches.h
+++ b/ui/gfx/switches.h
@@ -18,6 +18,10 @@ GFX_SWITCHES_EXPORT extern const char kEnableNativeGpuMemoryBuffers[];
 GFX_SWITCHES_EXPORT extern const char kForcePrefersReducedMotion[];
 GFX_SWITCHES_EXPORT extern const char kHeadless[];
 
+#if BUILDFLAG(IS_WIN)
+GFX_SWITCHES_EXPORT extern const char kDisableDirectWrite[];
+#endif
+
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 GFX_SWITCHES_EXPORT extern const char kX11Display[];
 GFX_SWITCHES_EXPORT extern const char kNoXshm[];
diff --git a/ui/gfx/win/direct_write.cc b/ui/gfx/win/direct_write.cc
index 6e091a20069c0..d05df1de8fa80 100644
--- a/ui/gfx/win/direct_write.cc
+++ b/ui/gfx/win/direct_write.cc
@@ -8,10 +8,13 @@
 
 #include <string>
 
+#include "base/command_line.h"
 #include "base/debug/alias.h"
+#include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/fontmgr_default.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
@@ -19,8 +22,23 @@
 namespace gfx {
 namespace win {
 
+GFX_EXPORT bool ShouldUseDirectWrite() {
+  // If the flag is currently on, and we're on WinVista or above, we enable
+  // DirectWrite. There is no reason to not install Platform Update or
+  // even use the Windows 7 Platform Update dwrite.dll with the extended kernel.
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-direct-write");
+}
+
 namespace {
 
+static bool dwrite_enabled = false;
+
 // Pointer to the global IDWriteFactory interface.
 IDWriteFactory* g_direct_write_factory = nullptr;
 
@@ -35,10 +53,27 @@ void SetDirectWriteFactory(IDWriteFactory* factory) {
 }  // anonymous namespace
 
 void CreateDWriteFactory(IDWriteFactory** factory) {
+  if (!gfx::win::ShouldUseDirectWrite()) {
+    return;
+  }
+
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll) {
+    return;
+  }
+
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc) {
+    return;
+  }
+
   Microsoft::WRL::ComPtr<IUnknown> factory_unknown;
-  HRESULT hr =
-      DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
-                          &factory_unknown);
+
+  HRESULT hr = dwrite_create_factory_proc(
+      DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &factory_unknown);
   if (FAILED(hr)) {
     base::debug::Alias(&hr);
     CHECK(false);
@@ -57,12 +92,48 @@ void InitializeDirectWrite() {
 
   Microsoft::WRL::ComPtr<IDWriteFactory> factory;
   CreateDWriteFactory(&factory);
-  CHECK(!!factory);
+  if (factory == nullptr) {
+    sk_sp<SkFontMgr> direct_write_font_mgr = SkFontMgr_New_GDI();
+    skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
+    return;
+  }
   SetDirectWriteFactory(factory.Get());
 
+  // The skia call to create a new DirectWrite font manager instance can fail
+  // if we are unable to get the system font collection from the DirectWrite
+  // factory. The GetSystemFontCollection method in the IDWriteFactory
+  // interface fails with E_INVALIDARG on certain Windows 7 gold versions
+  // (6.1.7600.*).
   sk_sp<SkFontMgr> direct_write_font_mgr =
       SkFontMgr_New_DirectWrite(factory.Get());
-  CHECK(!!direct_write_font_mgr);
+
+  int iteration = 0;
+  if (!direct_write_font_mgr &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    // Windows (win7_rtm) may fail to map the service sections
+    // (crbug.com/956064).
+    constexpr int kMaxRetries = 5;
+    constexpr base::TimeDelta kRetrySleepTime = base::Microseconds(500);
+    while (iteration < kMaxRetries) {
+      base::PlatformThread::Sleep(kRetrySleepTime);
+      direct_write_font_mgr = SkFontMgr_New_DirectWrite(factory.Get());
+      if (direct_write_font_mgr) {
+        break;
+      }
+      ++iteration;
+    }
+  }
+  if (!direct_write_font_mgr) {
+    iteration = -1;
+  }
+  base::UmaHistogramSparse("DirectWrite.Fonts.Gfx.InitializeLoopCount",
+                           iteration);
+  DCHECK(!!direct_write_font_mgr);
+  if (!direct_write_font_mgr) {
+    direct_write_font_mgr = SkFontMgr_New_GDI();
+  } else {
+    dwrite_enabled = true;
+  }
 
   // Override the default skia font manager. This must be called before any
   // use of the skia font manager is done (e.g. before any call to
@@ -70,6 +141,10 @@ void InitializeDirectWrite() {
   skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
 }
 
+bool IsDirectWriteEnabled() {
+  return dwrite_enabled;
+}
+
 IDWriteFactory* GetDirectWriteFactory() {
   // Some unittests may access this accessor without any previous call to
   // |InitializeDirectWrite|. A call to |InitializeDirectWrite| after this
diff --git a/ui/gfx/win/direct_write.h b/ui/gfx/win/direct_write.h
index 72022056d29c4..88839b7621ce2 100644
--- a/ui/gfx/win/direct_write.h
+++ b/ui/gfx/win/direct_write.h
@@ -14,9 +14,15 @@
 namespace gfx {
 namespace win {
 
+// Returns whether DirectWrite font rendering should be used.
+GFX_EXPORT bool ShouldUseDirectWrite();
+
 GFX_EXPORT void InitializeDirectWrite();
 
-// Creates a DirectWrite factory.
+// Returns true if we are using DirectWrite for font metrics and rendering.
+GFX_EXPORT bool IsDirectWriteEnabled();
+
+// Creates a DirectWrite factory, if using DirectWrite.
 GFX_EXPORT void CreateDWriteFactory(IDWriteFactory** factory);
 
 // Returns the global DirectWrite factory.
diff --git a/ui/native_theme/caption_style_win.cc b/ui/native_theme/caption_style_win.cc
index 2c27d56f29eaa..22f41c928d0d4 100644
--- a/ui/native_theme/caption_style_win.cc
+++ b/ui/native_theme/caption_style_win.cc
@@ -14,6 +14,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/color_utils.h"
@@ -172,8 +173,18 @@ std::string GetCssColorWithAlpha(CC::ClosedCaptionColor caption_color,
 
 absl::optional<CaptionStyle> InitializeFromSystemSettings() {
   TRACE_EVENT0("ui", "InitializeFromSystemSettings");
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
   DCHECK(base::FeatureList::IsEnabled(features::kSystemCaptionStyle));
 
+  // Need to do this check before using ScopedHString.
+  bool can_use_scoped_hstring =
+      base::win::ResolveCoreWinRTDelayload() &&
+      base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!can_use_scoped_hstring) {
+    return absl::nullopt;
+  }
+
   base::win::ScopedHString closed_caption_properties_string =
       base::win::ScopedHString::Create(
           RuntimeClass_Windows_Media_ClosedCaptioning_ClosedCaptionProperties);
@@ -270,10 +281,12 @@ absl::optional<CaptionStyle> InitializeFromSystemSettings() {
 }  // namespace
 
 absl::optional<CaptionStyle> CaptionStyle::FromSystemSettings() {
-  if (base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
     return InitializeFromSystemSettings();
   }
-  // Return default CaptionStyle if kSystemCaptionStyle is not enabled.
+  // Return default CaptionStyle for pre Win10 versions since system settings
+  // don't allow caption styling.
   return absl::nullopt;
 }
 
diff --git a/ui/native_theme/native_theme.cc b/ui/native_theme/native_theme.cc
index af49c133fb2b1..6621aec81df39 100644
--- a/ui/native_theme/native_theme.cc
+++ b/ui/native_theme/native_theme.cc
@@ -8,6 +8,7 @@
 
 #include "base/command_line.h"
 #include "base/containers/fixed_flat_map.h"
+#include "base/features.h"
 #include "base/functional/bind.h"
 #include "base/logging.h"
 #include "base/observer_list.h"
@@ -58,11 +59,8 @@ ColorProviderKey NativeTheme::GetColorProviderKey(
       system_theme_,
       use_custom_frame ? ui::ColorProviderKey::FrameType::kChromium
                        : ui::ColorProviderKey::FrameType::kNative,
-      ui::ColorProviderKey::FrameStyle::kDefault,
-      should_use_system_accent_color_
-          ? ui::ColorProviderKey::UserColorSource::kAccent
-          : ui::ColorProviderKey::UserColorSource::kBaseline,
-      user_color_, scheme_variant_, std::move(custom_theme));
+      user_color_, scheme_variant_, /*is_grayscale=*/false,
+      std::move(custom_theme));
 }
 
 SkColor NativeTheme::GetSystemButtonPressedColor(SkColor base_color) const {
@@ -208,7 +206,8 @@ void NativeTheme::SetPreferredContrast(
 bool NativeTheme::IsForcedDarkMode() {
   static bool kIsForcedDarkMode =
       base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode);
+          switches::kForceDarkMode) ||
+      base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag);
   return kIsForcedDarkMode;
 }
 
@@ -343,4 +342,4 @@ NativeTheme::ColorScheme NativeTheme::GetDefaultSystemColorScheme() const {
   return ShouldUseDarkColors() ? ColorScheme::kDark : ColorScheme::kLight;
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/native_theme/native_theme.h b/ui/native_theme/native_theme.h
index 341248a6b15b2..27ff8a6f7ecb5 100644
--- a/ui/native_theme/native_theme.h
+++ b/ui/native_theme/native_theme.h
@@ -544,13 +544,6 @@ class NATIVE_THEME_EXPORT NativeTheme {
     return scheme_variant_;
   }
 
-  void set_should_use_system_accent_color(bool should_use_system_accent_color) {
-    should_use_system_accent_color_ = should_use_system_accent_color;
-  }
-  bool should_use_system_accent_color() const {
-    return should_use_system_accent_color_;
-  }
-
   // Updates the state of dark mode, forced colors mode, and the map of system
   // colors. Returns true if NativeTheme was updated as a result, or false if
   // the state of NativeTheme was untouched.
@@ -642,10 +635,6 @@ class NATIVE_THEME_EXPORT NativeTheme {
   // transforms of `user_color_` which generate colors.
   absl::optional<ui::ColorProviderKey::SchemeVariant> scheme_variant_;
 
-  // Determines whether generated colors should express the system's accent
-  // color if present.
-  bool should_use_system_accent_color_ = true;
-
   bool should_use_dark_colors_ = false;
   const ui::SystemTheme system_theme_;
   bool forced_colors_ = false;
@@ -660,4 +649,4 @@ class NATIVE_THEME_EXPORT NativeTheme {
 
 }  // namespace ui
 
-#endif  // UI_NATIVE_THEME_NATIVE_THEME_H_
+#endif  // UI_NATIVE_THEME_NATIVE_THEME_H_
\ No newline at end of file
diff --git a/ui/native_theme/native_theme_win.cc b/ui/native_theme/native_theme_win.cc
index 595b718583212..0503f28e2bd9c 100644
--- a/ui/native_theme/native_theme_win.cc
+++ b/ui/native_theme/native_theme_win.cc
@@ -293,9 +293,6 @@ NativeThemeWin::NativeThemeWin(bool configure_web_instance,
     : NativeTheme(should_only_use_dark_colors),
       supports_windows_dark_mode_(base::win::IsDarkModeAvailable()),
       color_change_listener_(this) {
-  // By default UI should not use the system accent color.
-  set_should_use_system_accent_color(false);
-
   // If there's no sequenced task runner handle, we can't be called back for
   // dark mode changes. This generally happens in tests. As a result, ignore
   // dark mode in this case.
@@ -358,8 +355,6 @@ void NativeThemeWin::ConfigureWebInstance() {
   web_instance->set_prefers_reduced_transparency(
       GetPrefersReducedTransparency());
   web_instance->set_system_colors(GetSystemColors());
-  web_instance->set_should_use_system_accent_color(
-      should_use_system_accent_color());
 }
 
 NativeThemeWin::~NativeThemeWin() {
@@ -1705,4 +1700,4 @@ void NativeThemeWin::UpdateInvertedColors() {
   NotifyOnNativeThemeUpdated();
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/snapshot/snapshot_win.cc b/ui/snapshot/snapshot_win.cc
index 74d600db1ea5e..f36b2c48a219d 100644
--- a/ui/snapshot/snapshot_win.cc
+++ b/ui/snapshot/snapshot_win.cc
@@ -5,7 +5,6 @@
 #include "ui/snapshot/snapshot_win.h"
 
 #include <memory>
-#include <utility>
 
 #include "base/functional/callback.h"
 #include "base/win/windows_version.h"
@@ -21,6 +20,17 @@
 #include "ui/snapshot/snapshot.h"
 #include "ui/snapshot/snapshot_aura.h"
 
+namespace {
+
+// Windows 8.1 is the first version that supports PW_RENDERFULLCONTENT.
+// Without that flag PrintWindow may not correctly capture what's actually
+// onscreen.
+bool UseAuraSnapshot() {
+  return (base::win::GetVersion() < base::win::Version::WIN8_1);
+}
+
+}  // namespace
+
 namespace ui {
 
 namespace internal {
@@ -29,6 +39,7 @@ bool GrabHwndSnapshot(HWND window_handle,
                       const gfx::Rect& snapshot_bounds_in_pixels,
                       const gfx::Rect& clip_rect_in_pixels,
                       gfx::Image* image) {
+  BOOL result = false;
   gfx::Rect snapshot_bounds_in_window =
       snapshot_bounds_in_pixels + clip_rect_in_pixels.OffsetFromOrigin();
   gfx::Size bitmap_size(snapshot_bounds_in_window.right(),
@@ -44,7 +55,32 @@ bool GrabHwndSnapshot(HWND window_handle,
   // the window that are drawn using DirectComposition.
   UINT flags = PW_CLIENTONLY | PW_RENDERFULLCONTENT;
 
-  BOOL result = PrintWindow(window_handle, mem_hdc, flags);
+  if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+    result = PrintWindow(window_handle, mem_hdc, flags);
+  } else {
+    // PrintWindow does not work for pre-Windows 8.1. So we'll use BitBlt.
+    // Copying from the window's actual HDC doesn't work so let's just use the
+    // full screen HDC. When a snapshot is captured the focus should be on the
+    // browser window anyway.
+    HDC window_hdc = GetDC(NULL);
+
+    RECT window_rect;
+
+    memset(&window_rect, 0, sizeof(RECT));
+
+    result = GetWindowRect(window_handle, &window_rect);
+
+    if (!result) {
+      PLOG(ERROR) << "Failed to get valid rect for snapshot area.";
+      return false;
+    }
+    // The left of the snapshot "window" rect is offset by 8 pixels to remove a
+    // bit of the dark grey showing through.
+    result = BitBlt(mem_hdc, 0, 0, bitmap_size.width(), bitmap_size.height(),
+                    window_hdc, window_rect.left + 8, window_rect.top, SRCCOPY);
+
+    DeleteDC(window_hdc);
+  }
   if (!result) {
     PLOG(ERROR) << "Failed to print window";
     return false;
@@ -85,6 +121,11 @@ bool GrabViewSnapshot(gfx::NativeView view_handle,
 bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
                         const gfx::Rect& snapshot_bounds,
                         gfx::Image* image) {
+  if (UseAuraSnapshot()) {
+    // Not supported in Aura.  Callers should fall back to the async version.
+    return false;
+  }
+
   DCHECK(window_handle);
   gfx::Rect window_bounds = window_handle->GetBoundsInRootWindow();
   aura::WindowTreeHost* host = window_handle->GetHost();
@@ -109,6 +150,10 @@ bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
 void GrabWindowSnapshotAsync(gfx::NativeWindow window,
                              const gfx::Rect& source_rect,
                              GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(window, source_rect, std::move(callback));
+    return;
+  }
   gfx::Image image;
   GrabWindowSnapshot(window, source_rect, &image);
   std::move(callback).Run(image);
@@ -117,6 +162,10 @@ void GrabWindowSnapshotAsync(gfx::NativeWindow window,
 void GrabViewSnapshotAsync(gfx::NativeView view,
                            const gfx::Rect& source_rect,
                            GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(view, source_rect, std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
@@ -125,6 +174,11 @@ void GrabWindowSnapshotAndScaleAsync(gfx::NativeWindow window,
                                      const gfx::Rect& source_rect,
                                      const gfx::Size& target_size,
                                      GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAndScaleAsyncAura(window, source_rect, target_size,
+                                        std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
diff --git a/ui/views/controls/scrollbar/scroll_bar.cc b/ui/views/controls/scrollbar/scroll_bar.cc
index da848fcdc1784..d89c4c60077a9 100644
--- a/ui/views/controls/scrollbar/scroll_bar.cc
+++ b/ui/views/controls/scrollbar/scroll_bar.cc
@@ -438,6 +438,11 @@ void ScrollBar::TrackClicked() {
 
 void ScrollBar::ScrollContentsToOffset() {
   ScrollToPosition(contents_scroll_offset_);
+  // Safeguard against a divide-by-zero bug that happens when separating
+  // multiple tabs into separate windows.
+  contents_size_ = std::max(1, contents_size_);
+  viewport_size_ = std::max(1, viewport_size_);
+
   thumb_->SetPosition(CalculateThumbPosition(contents_scroll_offset_));
 }
 
@@ -459,6 +464,7 @@ int ScrollBar::CalculateThumbPosition(int contents_scroll_offset) const {
   if (viewport_size_ == contents_size_) {
     return 0;
   }
+
   return (contents_scroll_offset * thumb_max) /
          (contents_size_ - viewport_size_);
 }
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index a386fb0594530..a3faf75050d92 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -2229,8 +2229,12 @@ LRESULT HWNDMessageHandler::OnMouseRange(UINT message,
 LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
                                               WPARAM w_param,
                                               LPARAM l_param) {
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     return PA_NOACTIVATE;
   }
@@ -2241,11 +2245,15 @@ LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
 LRESULT HWNDMessageHandler::OnPointerEvent(UINT message,
                                            WPARAM w_param,
                                            LPARAM l_param) {
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   POINTER_INPUT_TYPE pointer_type;
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
   // If the WM_POINTER messages are not sent from a stylus device, then we do
   // not handle them to make sure we do not change the current behavior of
   // touch and mouse inputs.
-  if (!::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type)) {
+  if (!get_pointer_type || !get_pointer_type(pointer_id, &pointer_type)) {
     SetMsgHandled(FALSE);
     return -1;
   }
@@ -3577,8 +3585,13 @@ LRESULT HWNDMessageHandler::HandlePointerEventTypePenClient(UINT message,
                                                             WPARAM w_param,
                                                             LPARAM l_param) {
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerPenInfoFn = BOOL(WINAPI*)(UINT32, POINTER_PEN_INFO*);
   POINTER_PEN_INFO pointer_pen_info;
-  if (!GetPointerPenInfo(pointer_id, &pointer_pen_info)) {
+  static const auto get_pointer_pen_info =
+      reinterpret_cast<GetPointerPenInfoFn>(
+          base::win::GetUser32FunctionPointer("GetPointerPenInfo"));
+  if (!get_pointer_pen_info ||
+      !get_pointer_pen_info(pointer_id, &pointer_pen_info)) {
     SetMsgHandled(FALSE);
     return -1;
   }
@@ -3608,7 +3621,6 @@ bool HWNDMessageHandler::IsSynthesizedMouseMessage(unsigned int message,
 }
 
 void HWNDMessageHandler::PerformDwmTransition() {
-  CHECK(IsFrameSystemDrawn());
 
   dwm_transition_desired_ = false;
   delegate_->HandleFrameChanged();
diff --git a/ui/views/win/pen_id_handler.cc b/ui/views/win/pen_id_handler.cc
index 96826a9c5b271..c872ee20b4f37 100644
--- a/ui/views/win/pen_id_handler.cc
+++ b/ui/views/win/pen_id_handler.cc
@@ -38,7 +38,15 @@ class PenIdStatics {
     if (skip_initialization_) {
       return;
     }
+
     SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+    if (!base::win::ResolveCoreWinRTDelayload()) {
+      pen_device_statics_ = nullptr;
+      pointer_point_statics_ = nullptr;
+      return;
+    }
+
     base::win::AssertComInitialized();
     base::win::RoGetActivationFactory(
         base::win::HStringReference(
